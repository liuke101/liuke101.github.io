<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++精粹 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="零、预处理器确保头文件多次包含仍能安全工作的常用技术是预处理器，预处理器是在编译之前执行的一段程序，任何以 # 开头的东西，都被称为预处理器命令或者预处理器指令。如 #include ，当预处理器看到 #include 标记时就会用指定的头文件内容代替 #include 。 头文件保护符下面来说 # pargma once pragma 本质上是一个被发送到编译器或预处理器的预处理指令。pragm">
<meta property="og:type" content="article">
<meta property="og:title" content="C++精粹">
<meta property="og:url" content="http://liuke101.github.io/post/60549.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="零、预处理器确保头文件多次包含仍能安全工作的常用技术是预处理器，预处理器是在编译之前执行的一段程序，任何以 # 开头的东西，都被称为预处理器命令或者预处理器指令。如 #include ，当预处理器看到 #include 标记时就会用指定的头文件内容代替 #include 。 头文件保护符下面来说 # pargma once pragma 本质上是一个被发送到编译器或预处理器的预处理指令。pragm">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png">
<meta property="article:published_time" content="2023-08-17T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-06T15:43:32.070Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/60549.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++精粹',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 23:43:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++精粹</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-17T16:00:00.000Z" title="发表于 2023-08-18 00:00:00">2023-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T15:43:32.070Z" title="更新于 2024-08-06 23:43:32">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">68.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>242分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++精粹"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/60549.html#post-comment"><span class="waline-comment-count" data-path="/post/60549.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零、预处理器"><a href="#零、预处理器" class="headerlink" title="零、预处理器"></a>零、预处理器</h1><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>，预处理器是在编译之前执行的一段程序，任何以 # 开头的东西，都被称为预处理器命令或者预处理器指令。如 <code>#include</code> ，当预处理器看到 <code>#include</code> 标记时就会用指定的头文件内容代替 <code>#include</code> 。</p>
<h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><p>下面来说 <code># pargma once</code></p>
<p>pragma 本质上是一个被发送到编译器或预处理器的预处理指令。<br><strong>pragma once 阻止我们单个头文件多次被 include 在同一个 cpp 文件里。</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新方法</span></span><br><span class="line"><span class="meta">#pargma once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//旧方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  _PROJECT_A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _PROJECT_A</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>include 用于告诉编译器，包含文件的路径是什么，有两种写法：</p>
<ul>
<li><code>#include&lt; &gt;</code>: 在所有 include 路径中搜索文件</li>
<li><code>#include&quot; &quot;</code> ：引用相对路径，现在也有 <code>#include&lt; &gt;</code> 的功能，作用范围更大</li>
</ul>
<h2 id="宏-macro"><a href="#宏-macro" class="headerlink" title="宏 macro"></a>宏 macro</h2><p>#define #宏 #macro</p>
<ol>
<li><p><strong>预处理阶段</strong> ：当编译 C++ 代码时，首先<strong>预处理器</strong>会检查一遍 C++ 所有的<strong>以 # 符号开头（这是预编译指令符号）的语句，当预编译器将这些代码评估完后给到编译器去进行实际的编译</strong>。</p>
</li>
<li><p><strong>宏和模板的区别</strong>：<strong>发生时间</strong>不同，宏是在<strong>预处理阶段</strong>就被评估了，而模板会被评估的更晚一点。</p>
</li>
<li><p><strong>用宏的目的：</strong>写一些宏将代码中的文本<strong>替换</strong>为其他东西（纯文本替换）**（不一定是简单的替换，是可以自定义调用宏的方式的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defind WAIT std::cin.get()</span></span><br><span class="line"><span class="comment">//这里可以不用放分号，如果放分号就会加入宏里面了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WAIT;</span><br><span class="line">    <span class="comment">//等效于std::cin.get()，属于纯文本替换</span></span><br><span class="line">    <span class="comment">//但单纯做这种操作是很愚蠢的，除了自己以外别人读代码会特别痛苦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏的用法之一：<strong>宏是可以发送参数的</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">//这样子会输出“hello”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>宏可以辅助调试</li>
</ol>
<p>在 Debug 模式下会有很多日志的输出，但是在 Release 模式下就不需要日志的输出了。正常的方法可能会删掉好多的输出日志的语句或者函数，<strong>但是用宏可以直接取消掉这些语句</strong></p>
<p>利用宏中的 <code>#if，#else</code>，<code>endif</code> 来实现。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#defind PR_DEBUG 1 <span class="comment">//可以在这里切换成0，作为一个开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1   <span class="comment">//如果PR_DEBUG为1</span></span></span><br><span class="line"><span class="meta">#defind LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl  <span class="comment">//则执行这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">//反之</span></span></span><br><span class="line"><span class="meta">#defind LOG(x)   <span class="comment">//这个宏什么也不定义，即是无意义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    <span class="comment">//结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 Debug (PR_DEBUG &#x3D;&#x3D; 1) 模式下，则会打印日志，如果在 Release (PR_DEBUG &#x3D;&#x3D; 0) 模式，则在<strong>预处理阶段就会把日志语句给删除掉</strong>。</p>
<p>利用 <code>#if 0</code> 和 <code>#endif</code> 删除一段宏.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0   <span class="comment">//从这里到最后的endif的宏都被无视掉了，某种意义上的删除</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#defind PR_DEBUG 1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1 </span></span><br><span class="line"><span class="meta">#defind LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#defind LOG(x) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="续行符"><a href="#续行符" class="headerlink" title="续行符 \"></a>续行符 <code>\</code></h3><p>普通代码行后面编译器自动判断续行的，宏定义则不行。</p>
<p><strong>宏定义规定必须用一行完成:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SomeFun(x, a, b) <span class="keyword">if</span>(x)x=a+b;<span class="keyword">else</span> x=a-b;</span></span><br></pre></td></tr></table></figure>

<p>这一行定义是没有问题的，但是这样代码很不容易被理解，如果写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SomeFun(x, a, b)</span></span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">        x = a + b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = a - b;</span><br><span class="line"><span class="comment">//这样理解是好理解了,但是编译器会出错,因为它会认为#define SomeFun(x, a, b)是完整的一行,if (x)以及后面的语句与#define SomeFun(x, a, b)没有关系.这时候我们就必须使用这样的写法:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SomeFun(x, a, b)\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (x)\</span></span><br><span class="line"><span class="meta">        x = a + b;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>\</span></span><br><span class="line"><span class="meta">        x = a - b; <span class="comment">//最后一行不加续行符</span></span></span><br></pre></td></tr></table></figure>

<h3 id="和"><a href="#和" class="headerlink" title="# 和 ##"></a><code>#</code> 和 <code>##</code></h3><p><strong>单个 <code>#</code>：</strong><br>在 C 语言的宏中，<code>#</code> 的功能是将其后面的宏参数进行字符串化操作，简单说就是对他所引用的宏变量通过替换后再其左右各加上一个双引用。  </p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> WARNIF(EXP) \</span></span><br><span class="line"><span class="meta">do&#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (EXP) \</span></span><br><span class="line"><span class="meta">    &#123;    \ </span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> #EXP <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">    &#125;   \  </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)    </span><br><span class="line"><span class="comment">// 在实际使用中会出现下面所示的替换过程：</span></span><br><span class="line"><span class="comment">// WARN_IF(div == 0);被替换成以下代码</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (div == <span class="number">0</span>) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> <span class="string">&quot;div == 0&quot;</span> <span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>两个 <code>##</code>:</strong><br><code>##</code> 被称为连接符，用来将两个 Token 链接成一个 Token. 注意这里的连接的对象是 Token 就行，而不一定是宏的变量。比如你要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数和菜单项命令名直接有直观的名字上的关系，那么下面的代码就非常实用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name；</span><br><span class="line">    <span class="built_in">void</span> (*function)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND(NAME)&#123;NAME, NAME##_command&#125;</span></span><br><span class="line"><span class="comment">//然后就用一些预定义好的命令来方便的初始化一个command结构的数据了：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">command</span> commands[] = &#123;</span><br><span class="line">    <span class="built_in">COMMAND</span>(quit),</span><br><span class="line">    <span class="built_in">COMMAND</span>(help),</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//COMMAND宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码的密度， 间接的也可以减少粗心所造成的错误。</span></span><br><span class="line"><span class="comment">//我们还可以n个##符号链接n+1个Token，这个特性也是#符号所不具备的。</span></span><br><span class="line"><span class="comment">//例如： </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINK_MULTIPLE(a, b, c, d) a##_##b##_##c##_###d</span></span><br><span class="line"><span class="keyword">typedef</span> struct_record_type <span class="built_in">LINK_MULTIPLE</span>(name, company, position, salary);</span><br><span class="line"><span class="comment">//展开内容为 ： </span></span><br><span class="line"><span class="keyword">typedef</span> struct_record_type name_company_position_salary;</span><br></pre></td></tr></table></figure>


<h3 id="变参宏"><a href="#变参宏" class="headerlink" title="... 变参宏"></a><code>...</code> 变参宏</h3><p><code>...</code> 在 C 语言中被称为<strong>变参宏</strong>   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> myprintf (templt, ...)  fprintf (stderr, templt, ##__VA_ARGS__)  </span></span><br></pre></td></tr></table></figure>

<p>这里 <code>##</code> 这个连接符充当的作用就是当 <code>__VA_ARGS__</code> 为空的时候，消除前面的那个逗号。</p>
<h1 id="一、变量和基本类型"><a href="#一、变量和基本类型" class="headerlink" title="一、变量和基本类型"></a>一、变量和基本类型</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><p>对象：具有某种数据类型的内存空间</p>
<ul>
<li>基本上，当我们编写了一个类并且到了我们实际开始使用该类的时候，就需要实例化它 (除非它是完全静态的类)</li>
<li>实例化类有两种选择，这两种选择的区别是内存来自哪里，我们的对象实际上会创建在哪里。</li>
<li>应用程序会把内存分为两个主要部分：堆和栈。还有其他部分，比如源代码部分，此时它是机器码。</li>
</ul>
<h3 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈中创建</span></span><br><span class="line">Entity entity;</span><br><span class="line"><span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;lk&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>什么时候栈分配？几乎任何时候，因为在 C++ 中这是初始化对象最快的方式和最受管控的方式。</li>
<li>什么时候不栈分配？ 如果创建的<strong>对象太大</strong>，或是需要显示地控制对象的<strong>生存期</strong>，那就需要堆上创建 。</li>
</ul>
<h3 id="堆分配"><a href="#堆分配" class="headerlink" title="堆分配"></a>堆分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆中创建</span></span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;lk&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> entity； <span class="comment">//清除</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当我们调用 new Entity 时，实际发生的就是我们在堆上分配了内存，我们调用了构造函数，然后这个 <strong>new Entity 实际上会返回一个 Entity 指针，它返回了这个 entity 在堆上被分配的内存地址</strong>，这就是为什么我们要声明成 Entity * 类型。</li>
<li>如果你使用了 new 关键字，那你就要用 delete 来进行清理。</li>
</ul>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><ul>
<li>new 的主要目的是分配内存，具体来说就是在堆上分配内存。</li>
<li>如果你用 new 和 **<code>[]</code> 来分配数组，那么也用  <code>delete[]</code> 。</li>
<li>new 主要就是找到一个满足我们需求的足够大的内存块，然后<strong>返回一个指向那个内存地址的指针</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//这就是一个在堆上分配的4字节的整数,这个a存储的就是他的内存地址.</span></span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];<span class="comment">//在堆上需要200字节的内存。</span></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配Entity类</span></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Entity* e = <span class="keyword">new</span> Entity;<span class="comment">//或者这我们不需要使用括号，因为他有默认构造函数。</span></span><br><span class="line">Entity* e0 = <span class="keyword">new</span> Entity[<span class="number">50</span>]; <span class="comment">//如果我们想要一个Entity数组，我们可以这样加上方括号,在这个数组里，你会在内存中得到50个连续的Entity</span></span><br><span class="line"><span class="keyword">delete</span> e;</span><br><span class="line"><span class="keyword">delete</span>[] e0;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 new 类时，该关键字做了两件事</li>
</ul>
<ul>
<li>分配内存 </li>
<li>调用构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//1.分配内存 2.调用构造函数</span></span><br><span class="line">Entity* e = (Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity);<span class="comment">//仅仅只是分配内存**然后给我们一个指向那个内存的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两行代码之间仅有的区别就是第一行代码new调用了Entity的构造函数</span></span><br><span class="line"><span class="keyword">delete</span> e;<span class="comment">//new了，必须要手动清除</span></span><br></pre></td></tr></table></figure>

<ul>
<li>new 是一个<strong>操作符</strong>，就像加、减、等于一样。它是一个操作符，这意味着你可以重载这个操作符，并改变它的行为。</li>
<li>通常调用 new 会调用隐藏在里面的 C 函数 malloc，但是 <strong>malloc 仅仅只是分配内存</strong>然后给我们一个指向那个内存的指针，而 <strong>new 不但分配内存，还会调用构造函数</strong>。同样，<strong>delete 则会调用 destructor 析构函数。</strong></li>
<li>new 支持一种叫 <strong>placement new</strong> 的用法，这决定了他的内存来自哪里, 所以你并没有真正的分配内存。在这种情况下，你只需要调用构造函数，并在一个特定的内存地址中初始化你的 Entity，可以通过 new() 然后指定内存地址，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>]; </span><br><span class="line">Entity* entity = <span class="built_in">new</span>(b) <span class="built_in">Entity</span>(); </span><br></pre></td></tr></table></figure>

<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p><strong>区分初始化和赋值：</strong></p>
<ul>
<li>初始化不是赋值，初始化的含义是<strong>创建变量</strong>时赋予其一个初始值，而赋值的含义是把<strong>已创建对象</strong>的当前值擦除，而以一个新值来替代。</li>
<li><strong>只有对象被创建才会出现初始化</strong>，而赋值操作并不应用于对象的创建过程中。</li>
<li>构造函数体中进行的是<strong>赋值</strong>（下图首先执行默认构造函数为变量设置初始值，然后在对他们赋予新值。） <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019170.png" alt="Pasted image 20231012153325"></li>
<li>C++规定对象的成员函数的<strong>初始化动作发生在进入构造函数本体之前</strong>。一个比较好的写法是在构造函数<strong>成员初始化列表</strong>中列出所有成员变量。<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019171.png" alt="Pasted image 20231012153355"><blockquote>
<p>只需要调用一次 copy 构造，通常效率更高（对于内置类型，初始化和赋值成本相同）</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>区分初始化类型</strong></p>
<ul>
<li><strong>拷贝初始化：</strong> 使用等号 <code>=</code> （赋值运算符）初始化变量</li>
<li><strong>直接初始化：</strong> 不使用等号，使用 <code>（）</code></li>
<li>列表初始化：使用<code>&#123;&#125;</code></li>
</ul>
</li>
<li><p><strong>区分拷贝构造函数和拷贝赋值运算符运算符</strong>：[[#拷贝构造和拷贝赋值的区别]]</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TestClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;.&#x27;</span>)</span> <span class="comment">//直接初始化, 调用构造函数</span></span></span><br><span class="line"><span class="function">TestClass <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">//直接初始化，因为obj1已经存在，所以调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">TestClass obj3 = obj1; <span class="comment">//拷贝初始化，因为obj1已经存在，所以调用拷贝构造函数</span></span><br><span class="line">obj3 = obj2; <span class="comment">//不是初始化而是赋值，因为没有产生新对象。调用拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">TestClass obj4 = <span class="string">&quot;abcdefg&quot;</span>; <span class="comment">//拷贝初始化，先调用构造函数创建临时对象，再调用拷贝构造函数</span></span><br><span class="line">TestClass obj5 = <span class="built_in">string</span>(<span class="number">100</span>,<span class="number">9</span>); <span class="comment">//拷贝初始化，先调用构造函数创建临时对象，再调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>注：<code>obj2</code> 与 <code>obj3</code> 的创建所调用的函数是一样的，调用复制函数的原因却有所不同。因为直接初始化是根据参数来调用构造函数的，<code>obj2</code> 是根据括号中的参数（一个本类的对象），来直接确定为调用拷贝构造函数，这跟函数重载时，会根据函数调用时的参数来调用相应的函数是一个道理；<br>而对于 <code>obj3</code> 则不同，它的调用并不是像 <code>obj2</code> 时那样是根据参数来确定要调用拷贝构造函数的，它只是因为初始化必然要调用复制构造函数而已。它理应要创建一个临时对象，但只是这个对象却已经存在，所以就省去了这一步，然后直接调用拷贝构造函数，因为拷贝初始化必然要调用拷贝构造函数，所以 <code>obj3</code> 的创建仍是拷贝初始化。</p>
<h4 id="初始化方式的选择"><a href="#初始化方式的选择" class="headerlink" title="初始化方式的选择"></a>初始化方式的选择</h4><ol>
<li><p>初始值只有一个时，使用直接初始化 或拷贝初始化都行。如果初始化多个值，一般只使用直接初始化。如果非要用拷贝初始化的方式，就要显式创建一个临时对象用于拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果提供的是一个【C++11】<strong>类内初始值</strong>，则只能使用拷贝初始化或使用花括号的形式初始化，不能使用圆括号。</p>
</li>
<li><p>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1&#123;“a”, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;; <span class="comment">//正确的列表初始化</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v1</span><span class="params">(“a”, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>)</span></span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>【C++11】<strong>使用花括号进行列表初始化</strong><br>当用于内置类型的变量时，<strong>花括号初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;  <span class="comment">//报错，因为存在丢失信息的风险（long double-&gt;int）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(ld)</span>,b</span>=ld;  <span class="comment">//正确，可以进行转换，但确实丢失了部分值</span></span><br></pre></td></tr></table></figure>

<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><ul>
<li><strong>内置变量（包括内置变量的数组类型）默认初始化值由定义的位置决定</strong>：定义于函数体外的变量被初始化为 0，定义在函数体内部的内置变量将不被初始化，其值是未定义的（如果试图拷贝或访问会引发错误）。</li>
<li>const 变量规定初始化必须有初始值，否则编译器错误</li>
<li>static 变量（包括 static 数组）默认初始化为 0。</li>
<li>类、结构体的默认初始化由其构造函数决定</li>
</ul>
<h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>C++支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++将声明和定义区分开来，声明使得名字未程序所知，一个文件如果想用别处定义的名字就必须包含对这个名字的声明，而定义负责创建与名字关联的实体。</p>
<p><strong>变量、函数能且只能被定义一次，但是可以多次被声明。</strong></p>
<p>- 函数声明：这个符号、这个函数是存在的。  <br>- 函数定义：这个函数到底是什么。</p>
<p>- 变量声明：告诉编译器变量的名称和类型，不分配内存，不赋初始值<br>- 变量定义：为变量分配内存，为变量赋初值</p>
<p><strong>如果想声明一个变量而非定义它，就在变量名前加关键字 <code>extern</code>，且不要显式初始化变量：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a； <span class="comment">//只声明不定义</span></span><br><span class="line"><span class="type">int</span> b; <span class="comment">//声明并定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//如果包含了显示初始化，那么声明就会变成定义，在函数体内部会报错</span></span><br></pre></td></tr></table></figure>

<p>函数声明（又称函数原型）建议放在头文件中</p>
<h4 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h4><p>#extern</p>
<p><strong>extern 可以置于变量声明或者函数声明前，以标示变量或者函数的定义在别的文件中，编译器遇到此变量和函数时会在其他文件中寻找其定义</strong>。<br>通过为变量和函数添加 extern 声明，可以让编译器把“寻找定义”这件事情推迟到<strong>链接阶段</strong>，而不会在编译阶段报“没有定义”的错误。</p>
<ol>
<li>声明函数或<strong>全局变量</strong>的作用范围，其声明的函数和变量可以在本文件或其他文件中使用。</li>
<li>extern “C”：兼容 C 语言，详情 [[#extern “C”]]</li>
<li><strong>C++ 中的函数声明默认被隐式的 <code>extern</code> 关键字修饰</strong></li>
</ol>
<h5 id="使用在其它文件中定义的全局变量-函数"><a href="#使用在其它文件中定义的全局变量-函数" class="headerlink" title="使用在其它文件中定义的全局变量&#x2F;函数"></a>使用在其它文件中定义的全局变量&#x2F;函数</h5><p>“用到未被定义的变量&#x2F;函数”这种情况一般出现在<strong>使用在其它文件中定义的变量&#x2F;函数</strong>时。</p>
<p><strong>使用场景：需要在 <code>a.cpp</code> 文件中使用在 <code>b.cpp</code> 中定义的全局变量&#x2F;函数:</strong></p>
<p>一般而言，C++全局变量的作用范围仅限于当前的文件，但同时 C++也支持分离式编译，允许将程序分割为若干个文件被独立编译。<strong>在一个文件中定义了变量和函数，在其他文件中要使用它们，可以有两种方式：</strong></p>
<ol>
<li>使用头文件，然后声明它们，然后其他文件去包含头文件</li>
<li>使用 extern，引用不在同一个文件中的变量或者函数。</li>
</ol>
<figure class="highlight c++"><figcaption><span>title:A.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//不需要include &quot;B.cpp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用extern声明变量和函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//函数声明默认被extern修饰，所以此处的extern可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl; <span class="comment">//输出10</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:B.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++中我们通常在头文件中声明变量和函数，我们可以将上述 A.cpp 文件中的声明移动到A.h 头文件中，并在 A.cpp 中 include 该头文件。</p>
<figure class="highlight c++"><figcaption><span>title:A.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:A.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意此时变量 i 和函数 func 已经在 B.cpp 中定义。其他任何地方不能重复定义。</p>
<h5 id="const-变量多文件编程"><a href="#const-变量多文件编程" class="headerlink" title="const 变量多文件编程"></a>const 变量多文件编程</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zjuhaohaoxuexi/p/16470605.html">C++ const常量在多文件编程中的3种用法 - 朴素贝叶斯 - 博客园 (cnblogs.com)</a></p>
<p>已知：<br>![[#const 变量]]</p>
<p>那么如何让 const 变量在其他文件使用？<br>由于 const 变量无法分离声明和定义，最简单的方法是将 const 定义在头文件中，其他 cpp 文件包含即可，但这违反了多文件编程的规定：在头文件中声明，在 cpp 文件中定义。<br>**有些情况下我们想要只在一个文件中定义 const，而在其他多个文件中声明并使用它，要使 const 变量能够在其他的文件中访问，必须地指定它为 <code>extern</code>。（将 const 改为外部链接）</p>
<figure class="highlight c++"><figcaption><span>title:D.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> j; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:D.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;D.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">123</span>; <span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h5><p><strong>告诉编译器按着 C 的函数命名规则去翻译指定的C++函数，以此兼容 C 语言。</strong><br><strong>如果不用 extern C，由于 C++ 和 C 语言在编译和链接时使用的命名规则不同，这会导致 C++ 代码无法调用 C 语言编写的函数或变量（链接时找不到符号）。</strong></p>
<p><strong>简单解释一下什么是函数的命名规则</strong>：对于 C++ 语言，由于需要支持重载，所以一个函数的链接名（Linkage Name）是由函数的名称、参数类型和返回值类型等信息组成的，用于在编译和链接时唯一标识该函数。</p>
<p>函数的链接名的生成规则在不同的编译器和操作系统上可能有所不同，一般是由编译器自动处理，不需要手动指定。</p>
<p><strong>而 C 语言的链接函数名规则又和上面三个 C++ 不一样，通过在 C++ 代码中使用 extern “C” 关键字，可以将 C++ 编译器的命名规则转换为 C 语言的命名规则，从而使得 C++ 代码可以调用 C 语言的函数或变量。</strong></p>
<p>extern “C” 的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言代码:test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 代码:test.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明 C 语言函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 C 语言函数</span></span><br><span class="line">    <span class="built_in">print_message</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意 extern “C” 关键字只对函数的名称和调用约定起作用，对于函数的参数类型和返回值类型没有影响。</p>
<p>所以，在使用 extern “C” 声明函数时，需要保证函数的参数类型和返回值类型与 C 语言的定义相同，否则可能会导致编译错误或运行时错误。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><code>extern</code> 关键字在 C++ 中有几个优点，尤其在多文件项目中使用时：</p>
<ol>
<li><strong>避免重复定义：</strong> 当在多个源文件中需要共享全局变量或函数时，<code>extern</code> 关键字帮助避免了重复定义的问题。通过在头文件中声明并在一个源文件中定义，其他源文件可以通过 <code>extern</code> 关键字访问而不会导致重复定义错误。</li>
<li><strong>提高可维护性：</strong> 使用 <code>extern</code> 显式声明全局变量或函数，可以提高代码的可维护性。通过头文件的声明，程序员可以清晰地了解哪些变量和函数是在其他文件中定义的，这有助于代码的理解和维护。</li>
<li><strong>分离接口和实现：</strong> <code>extern</code> 关键字有助于分离接口和实现。头文件中包含的声明提供了对外部功能的接口，而实际定义则可以隐藏在实现文件中，这符合良好的软件设计原则。</li>
<li><strong>支持模块化设计：</strong> 在大型项目中，使用 <code>extern</code> 可以支持模块化设计。模块化设计将代码分割成小的、独立的模块，每个模块可以在单独的源文件中进行定义，而 <code>extern</code> 允许这些模块之间共享数据和功能。</li>
</ol>
<p>总体来说，<code>extern</code> 关键字有助于管理和组织多文件项目，提高代码的可读性和可维护性。</p>
<h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3 类型"></a>3 类型</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>对计算机来说内存就是一切。x86 即 32 位地址为 32 位（8 位 16 进制数，4 * 8 &#x3D; 32），那么对应指针就是 4 字节；x64 则为 64 位地址（16 位 16 进制数），则对应指针 8 字节。</p>
<ul>
<li><strong>指针是一个存储变量内存首地址的整数</strong>，指针自身也是一个变量也有自己的内存地址，所以可以使用诸如 <code>**</code>、<code>***</code> 等多级指针。</li>
<li><strong>解引用时，编译器怎么知道该从首地址开始取多少个字节呢？</strong><ul>
<li>编译器会根据指针的所指元素的类型去判断应该取多少个字节。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line">	<span class="comment">//指针就是一个整数，值为内存地址</span></span><br><span class="line">	<span class="type">int</span>* ptr = &amp;var;	<span class="comment">//&amp;取地址：返回变量var的内存地址</span></span><br><span class="line">	std::cout &lt;&lt; *ptr;	<span class="comment">//*解引用：返回指针ptr指向内存所存储的值，即8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针的类型要和他所指向的对象严格匹配，有两种例外：</strong></p>
<ol>
<li>允许令一个指向常量的指针指向一个非常量对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">//dval不是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *ctpr = &amp;dval; <span class="comment">//正确，但是不能通过cptr改变dval的值</span></span><br></pre></td></tr></table></figure></li>
<li>存在继承关系的类。我们可以将基类的指针或引用绑定到派生类对象上（动态多态）</li>
</ol>
<blockquote>
<p>[!command] 建议：初始化所有指针<br>使用未经初始化的指针是引发运行时错误的一大原因。</p>
<p>和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p>
<p>在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。<strong>访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</strong></p>
<p>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。</p>
</blockquote>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>根本上，引用通常只是指针一种形式，只是在指针上的语法糖（Syntactic sugar）。<br>也可以理解成变量的别名<br>当我们使用术语“引用”时，通常指的是“左值引用”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ref = var;  <span class="comment">//ref是var的别名</span></span><br><span class="line">	std::cout &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用必须被初始化，一旦定义了引用，就无法将其绑定到其他对象</li>
<li><strong>引用本身不是对象，引用本身不占有内存空间（自身没有地址）</strong>，所以不能定义引用的引用，也不能定义指向引用的指针（指针自身占有内存空间，所以存在对指针的引用）</li>
<li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li>
<li><strong>引用的类型要与之绑定的对象严格匹配，有两种例外情况：</strong><ol>
<li>在<strong>初始化常量引用时</strong>允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可(编译器内部进行自动转换)。允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;r4 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>编译器内部转换的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>；</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部转换：使用一个临时对象temp进行转换</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval; <span class="comment">//由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp; <span class="comment">// 让ri绑定这个临时量</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>存在继承关系的类。我们可以将基类的指针或引用绑定到派生类对象上（动态多态）</li>
</ol>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>#const</p>
<blockquote>
<p>[!NOTE] 重点 </p>
<ol>
<li><strong>const 变量</strong>只能由常量引用或常量指针绑定，<strong>非 const 变量</strong>既可以由普通引用&#x2F;指针绑定，也可以由常量引用&#x2F;指针绑定。</li>
<li>顶层 const: 对象本身是 const 。底层 const：指针所指的对象或引用绑定的对象是一个常量</li>
<li>[[#拷贝操作的区别]]</li>
<li>非 const 指针可以转换为 const 指针，反之不行</li>
<li>当用实参初始化形参时会忽略掉顶层 const。即当形参为 <code>const int x</code> 时，传给它常量或非常量对象都是可以的。</li>
<li>非 const 对象(成员函数)即可以调用 const 对象(成员函数)，也可以调用非 const 对象(成员函数)  </li>
<li>const对象(成员函数)只能调用const对象(成员函数)，想调用非const对象(成员函数)就需要强转<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019172.png" alt="Pasted image 20240311234309"></li>
</ol>
</blockquote>
<h4 id="const-变量"><a href="#const-变量" class="headerlink" title="const 变量"></a>const 变量</h4><ul>
<li><strong><code>const</code> 变量必须在声明时进行初始化</strong>。一旦被初始化，其值就不能再被修改。</li>
<li>默认情况下，<code>const</code> 变量被设定为仅在文件内有效，多个文件中出现了同名的 <code>const</code> 变量时，等同于在不同文件中分别定义了独立的变量（ const 默认为内部链接）。可以使用 <code>extern</code> 关键字修改为外部链接。</li>
</ul>
<h4 id="const-变量与常量的关系"><a href="#const-变量与常量的关系" class="headerlink" title="const 变量与常量的关系"></a>const 变量与常量的关系</h4><p>首先我们要明确什么是常量：</p>
<ul>
<li>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面值常量</strong>。</li>
<li>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</li>
<li>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。<br>也就是诸如 <code>123, 3.141596, true/false/, &#39;A&#39;</code> 这些都是常量。常量是本来就存在的，我们也不能将通过修改将 1 作为 2 使用。</li>
</ul>
<p><strong>在 C++ 中，有四种简单的定义常量的方式：</strong></p>
<ul>
<li>使用 <code>#define</code> 预处理器。</li>
<li>使用枚举</li>
<li>使用 <code>const</code> 关键字。</li>
<li>使用 <code>constexpr</code> 关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10 <span class="comment">//宏定义不会进行类型检查，不建议使用这种方法定义</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123;length = <span class="number">10</span>&#125;; <span class="comment">//无名的枚举类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意，我们不能把这里的 lenth 叫做常量，它只是一个只读变量！</strong> </p>
<p><strong>使用 const 关键字只在编译期间保证该变量被使用时的不变性，无法保证运行期间的行为。</strong> 程序员直接修改 const 变量会得到一个编译错误，但是使用间接指针修改内存，只要符合语法则不会得到任何错误和警告。因为编译器无法得知你是有意还是无意的修改，但是既然定义成 const，那么程序员就不应当修改它，不然直接使用变量定义好了。</p>
<h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p><strong>指向常量的引用</strong>：常量对象只能用常量引用绑定！<br>const int &amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci; <span class="comment">//正确,初始化常量引用时允许用任意表达式作为初始值</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">//错误，r1是常量的引用，不允许为ci赋值，也就不能通过引用改变ci</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci; <span class="comment">//错误，非常量引用不能绑定常量对象。</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>[!comment] 建议<br>如果函数无须改变引用形参的值，最好将其声明为常量引用</p>
</blockquote>
<h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p><strong>指向常量的指针</strong>：类似于常量引用，存放常量对象的地址必须使用常量指针。<br>const int<em>（同 int const</em>）<br>对于常量指针，const写在类型之前和类型之后是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Wiget <span class="type">const</span>* pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>可以改变指针指向的地址, 不能再去修改指针指向的内容</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*a = <span class="number">2</span>; <span class="comment">//error! 不能再去修改指针指向的内容了。</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;Age  <span class="comment">//可以改变指针指向的地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常量指针也没有规定所指的对象必须是一个常量</strong>，所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，没有规定那个对象的值能不能通过其他途径改变。</li>
</ul>
<h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><p><strong>指针本身是常量</strong><br>int* const  </p>
<p><strong>可以改变指针指向的内容, 不能再去修改指针指向的地址</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*a = <span class="number">2</span>; <span class="comment">//ok</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;Age  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h4 id="const-int-const"><a href="#const-int-const" class="headerlink" title="const int* const"></a>const int* const</h4><p><strong>指针和被指对象都是常量</strong></p>
<p>既不可以改变指针指向的内容, 也不能再去修改指针指向的地址</p>
<h4 id="顶层const、底层const"><a href="#顶层const、底层const" class="headerlink" title="顶层const、底层const"></a>顶层const、底层const</h4><ul>
<li>顶层 const：对象本身是个常量</li>
<li>底层 const：指针所指的对象或引用绑定的对象是一个常量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;  <span class="comment">//顶层const， 对象ci本身是个常量</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;  <span class="comment">//顶层const：p1是指针常量，不可改变指向的地址，即对象p1本身是一个常量。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">//底层const:p2是常量指针，可以改变指向的地址，所以p2不是常量。不可以改变指向的内容，即指向的ci是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;  <span class="comment">//用于声明引用的const都是底层const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">//左边的const是底层const，右边的是顶层const</span></span><br></pre></td></tr></table></figure>
<h5 id="拷贝操作的区别"><a href="#拷贝操作的区别" class="headerlink" title="拷贝操作的区别"></a>拷贝操作的区别</h5><p>顶层const和底层const在执行对象的拷贝操作时区别明显</p>
<ol>
<li><p>顶层 const 不受影响：拷入或拷出的对象是否是常量没什么影响</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;  <span class="comment">//正确：拷贝ci的值，ci是一个顶层const</span></span><br><span class="line">p2 = p3; <span class="comment">//正确：p2 p3指向的类型相同，p3顶层const的部分不影响。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>底层 const 有限制：执行对象的的拷贝操作时，**拷入和拷出的对象必须具有相同的底层 const 资格，或两个对象的数据类型必须能够转换（非 const 指针可以转换为 const 指针 ，反之不行）：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = p3;  <span class="comment">//错误：p3包含底层const的定义，而p没有</span></span><br><span class="line">p2 = p3;  <span class="comment">//正确：p2和p3都是都是底层const</span></span><br><span class="line">p2 = &amp;i;  <span class="comment">//正确：非const变量可以由const引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;i = ci;  <span class="comment">//错误，const变量不能由非const引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//正确：非const变量可以由const引用绑定</span></span><br></pre></td></tr></table></figure>

<h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h4><p>和其他初始化过程一样，<strong>当用实参初始化形参时会忽略掉顶层const</strong>。即当形参有const时，传给它常量或非常量对象都是可以的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123; &#125;;  <span class="comment">//因为忽略了const，所以这句等价于fcn(int i)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; &#125;;  <span class="comment">//等价上句，相当于重新定义了 fcn(int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果调用该函数将会报错</span></span><br><span class="line"><span class="built_in">fcn</span>(<span class="number">1</span>); <span class="comment">//error: redefinition of ‘void fcn(int)’</span></span><br></pre></td></tr></table></figure>

<h4 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h4><p><strong>常量表达式（const expression）是指<code>值不会改变</code>并且在<code>编译期</code>就能得到计算结果的表达式。</strong></p>
<p><strong>哪些是常量表达式？</strong> #常量表达式</p>
<ol>
<li><strong>字面值常量</strong><ul>
<li>整型和浮点型字面值：12、3.14等</li>
<li>字符和字符串字面值：’a’、”hello world!”等</li>
<li>转义序列：转义序列均以反斜线作为开始，如换行符\n等</li>
<li>指定字面值的类型：1E、3.15L等</li>
<li>布尔字面值：true、bool</li>
<li>指针字面值：nullptr</li>
</ul>
</li>
<li><strong>用常量表达式初始化的 const 对象</strong></li>
</ol>
<p><strong>一个对象是不是常量表达式由他的数据类型和初始值共同决定</strong></p>
<ol>
<li>数据类型必须为 const</li>
<li>初始值可以在编译期获取<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>; <span class="comment">//a是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a + <span class="number">1</span>； <span class="comment">//b是</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">27</span>; <span class="comment">//c不是，因为不是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="built_in">get_size</span>(); <span class="comment">//d不是，因为初始值get_size()必须在运行时才能获取，不符合在编译过程中获取。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="【C-11】constexpr-变量"><a href="#【C-11】constexpr-变量" class="headerlink" title="【C++11】constexpr 变量"></a>【C++11】constexpr 变量</h5><p>#constexpr<br>将变量声明为 <code>constexpr</code> 类型，由编译器来验证变量的值是否是一个常量表达式。<strong>声明为 <code>constexpr</code> 的变量一定是一个常量，而且必须用常量表达式初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="built_in">test</span>(); <span class="comment">//该函数必须为constexpr函数</span></span><br></pre></td></tr></table></figure>

<p><strong>声明constexpr的数据类型必须是“字面值类型”</strong></p>
<h5 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h5><ul>
<li>算术类型（包含字符、整形数、布尔值、浮点数）</li>
<li>引用和指针（初始值必须是nullptr或0或存储与某个固定地址中的对象）</li>
<li>[[#字面值常量类]]</li>
<li>枚举类型</li>
</ul>
<h5 id="【C-11】constexpr函数"><a href="#【C-11】constexpr函数" class="headerlink" title="【C++11】constexpr函数"></a>【C++11】constexpr函数</h5><p>不能使用普通函数作为<code>constexpr</code>变量的初始值，允许定义一种特殊的<code>constexpr</code>函数，<strong>这种函数可以在编译时计算器结果</strong>。</p>
<blockquote>
<p>[!info] 定义遵循的约定</p>
<ul>
<li>函数的返回类型及所有形参的类型都得是字面值类型</li>
<li>函数体中必须有且只有一条return语句</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> c = <span class="built_in">new_func</span>(); <span class="comment">//正确，c是常量表达式</span></span><br></pre></td></tr></table></figure>

<p>执行初始化任务时，编译器把对 <code>constexpr</code> 函数的调用替换成结果值，<strong>并且<code>constexpr</code> 函数被隐式指定为内联函数，得以在编译过程中展开。</strong></p>
<ul>
<li><code>constexpr</code>函数体内可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如空语句、类型别名以及using声明。</li>
<li>允许<code>constexpr</code>函数返回值并非一个常量</li>
</ul>
<blockquote>
<p>[!bug] 把内联函数和constexpr函数放在头文件内<br>和其他函数不一样，内联函数和 constexpr 函数可以在程序中多次定义，不过对于某个给定的内联函数或者 constexpr 函数来说，它的多个定义必须完全一致，因此通常定义在头文件中。</p>
</blockquote>
<h5 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a>constexpr指针</h5><p>限定符<code>constexpr</code>只对指针有效，与指针所指的对象无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *a = <span class="literal">nullptr</span>;  <span class="comment">//指向整型常量的指针，底层const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *b = <span class="literal">nullptr</span>; <span class="comment">//指针本身是constexpr，顶层const</span></span><br></pre></td></tr></table></figure>

<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>#const成员函数<br><strong><code>const</code> 的第三种用法</strong>，他和变量没有关系，而是用在方法名的后面 ( <strong>只有类才有这样的写法</strong> )<br>本质上是将<code>this</code>指针类型改变为常量指针，因此<strong>不能修改类的成员变量</strong>。<br>![[#4 this指针]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_x,m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Getx</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//const的第三种用法，他和变量没有关系，而是用在方法名的后面 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_x; <span class="comment">//不能修改类的成员变量</span></span><br><span class="line">        m_x = <span class="number">2</span>; <span class="comment">//ERROR!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Getx</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        m_x = a; <span class="comment">//ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span>  <span class="comment">//const Entity调用const函数 &#123;</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; e.<span class="title">Getx</span><span class="params">()</span> &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后有时我们就会写两个<code> Getx</code> 版本，一个有 <code>const</code> 一个没有，然后上面面这个传 <code>const Enity &amp;</code> 的方法就会调用 <code>const</code> 的 <code>GetX</code> 版本。</p>
<p>所以，我们把成员方法标记为 const 是因为<strong>如果我们真的有一些 const Entity 对象，我们可以调用 const 方法</strong>。如果没有 const 方法，那 const Entity &amp; 对象就掉用不了该方法。</p>
<blockquote>
<p>[!NOTE]<br>如果实际上没有修改类或者它们不应该修改类，<strong>总是</strong>标记你的方法为 const，否则在有常量引用或类似的情况下就用不了你的方法。</p>
</blockquote>
<p>注意： const 对象只能调用 const 成员函数</p>
<h4 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a>mutable关键字</h4><p>#mutable</p>
<p><code>mutable</code> 意为“可变的”，与 constant（即 C++中的 <code>const</code>） 是相反词。</p>
<p>被 const 修饰的函数无法改变类成员变量，把类成员标记为 <code>mutable</code>（可变数据成员），意味着类中的 const 方法可以修改这个成员。<strong>即一个 const 成员函数可以改变一个可变数据成员的值。</strong></p>
<p>需要注意的是：mutable 不能修饰 const 和 static 类型的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">      x = <span class="number">2</span>; <span class="comment">//ERROR!表达式必须是可修改的左值</span></span><br><span class="line">      y = <span class="number">2</span>; <span class="comment">//可以修改！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><p>#inline<br>在 C++ 中，可以在<mark style="background: #FF5582A6;">定义</mark>函数时，在返回值类型前面加上 inline 关键字。增加了 inline 关键字的函数称为“<strong>内联函数</strong>”。</p>
<p><strong>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。</strong>  </p>
<p><strong>有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销</strong>。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。  </p>
<ul>
<li>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。  <ul>
<li>**另外，需要注意的是，调用内联函数的语句前必须已经出现内联函数的<mark style="background: #FF5582A6;">定义</mark>（即整个函数体），而不能只出现内联函数的声明。</li>
</ul>
</li>
<li>有时函数看上去很简单，例如只有一个包含一两条语句的循环，但该循环的执行次数可能很多，要消耗大量时间，那么这种情况也不适合将其实现为内联函数。</li>
</ul>
<blockquote>
<p>[!warning]<br>注意将函数定义为 inline 对编译器来说只是一个建议，编译器可以选择忽略该建议。例如递归函数的内联通常会被编译器忽略，因为编译器无法预知递归深度，且会造成代码膨胀。</p>
</blockquote>
<p>⭐<strong>定义在类内部的成员函数是默认 <code>inline</code> 的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  &#125; <span class="comment">// 自动地成为内联函数</span></span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//inline void Foo(int x, int y) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。</p>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>; <span class="comment">//声明</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;&#125; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>


<p><strong>总结</strong>：加上 inline 的函数在调用时和普通函数不同，相当于把这段函数展开后复制到执行语句前，减少了时间上的开销，增大了空间开销。C++ 用 inline 关键字较好地解决了函数调用开销的问题。</p>
<h3 id="【C-11】using类型别名"><a href="#【C-11】using类型别名" class="headerlink" title="【C++11】using类型别名"></a>【C++11】using类型别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> zhengxing; <span class="comment">//zhengxing是int的类型别名</span></span><br><span class="line"><span class="keyword">using</span> zhengxing = <span class="type">int</span>; <span class="comment">//等价</span></span><br></pre></td></tr></table></figure>

<h3 id="【C-11】auto类型说明符"><a href="#【C-11】auto类型说明符" class="headerlink" title="【C++11】auto类型说明符"></a>【C++11】auto类型说明符</h3><p><strong>让编译器通过初始值推算变量类型，所以auto定义的变量必须有初始值</strong></p>
<p>在函数返回值 &#x2F; 范围 for 循环 等情况中使用 auto 时，有 5 种用法</p>
<ul>
<li><code>auto</code> ：拷贝</li>
<li><code>auto&amp;</code> ：左值引用，只能接左值（和常量右值）</li>
<li><code>auto&amp;&amp;</code> ：万能引用，能接左值和右值</li>
<li><code>const auto&amp;</code> ：const 万能引用，能接左值和右值</li>
<li><code>const auto&amp;&amp;</code> ：常量右值引用，只能接右值</li>
</ul>
<p>很多人直接就写 <code>auto&amp;&amp;</code>，但尽量分场景使用</p>
<ul>
<li><code>auto</code>：用于你想修改右值的情形</li>
<li><code>auto&amp;</code>：用于你想修改左值的情形</li>
<li><code>auto&amp;&amp;</code>：用于泛型编程中的转发</li>
<li><code>const auto&amp;</code>：用于只读</li>
<li><code>const auto&amp;&amp;</code>：基本没用，基本可被 <code>const auto&amp;</code> 替代（比 <code>const auto&amp;</code> 多一个语义：一定得是右值。然而这没什么用，因为你都不对其进行修改，是左还是右没什么影响）</li>
</ul>
<p>看下边的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ElementType&gt; arr;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ele : arr) &#123;</span><br><span class="line">  <span class="comment">// auto, 意味着下边的代码需要修改并使用 ele，但并不影响 arr</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ele : arr) &#123;</span><br><span class="line">  <span class="comment">// auto&amp;，意味着下边的代码需要修改 arr 中的 ele</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ele : arr) &#123;</span><br><span class="line">  <span class="comment">// const auto&amp;，意味着下边的代码无需改动 ele</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; result = <span class="built_in">foo</span>(); <span class="comment">// auto&amp;&amp; 意味着后边要转发</span></span><br><span class="line"><span class="built_in">bar</span>(std::forward&lt;<span class="keyword">decltype</span>(result)&gt;(result));</span><br></pre></td></tr></table></figure>
<p>也就是说，4 种情形后边代表的语义是不一样的</p>
<p>比如明明不需要修改值的场合却用了 <code>auto&amp;&amp;</code>赋予了修改权限</p>
<p>所以一般情况下，我默认选择的是 <code>const auto&amp;</code>，如果发现需要修改，再选择 <code>auto&amp;</code>或<code>auto</code>（函数返回值如果是右值，是不用标记为 &amp;&amp; 的，并且赋值处也不需要写上 &amp;&amp;，编译器会把这个部分优化掉）</p>
<p>在泛型编程的转发情况中，选择 <code>auto&amp;&amp;</code>（非转发情况就跟上边的一样）</p>
<p><code>auto&amp;&amp;</code> 还有一种特殊情况，就是需要区分是左值引用还是右值引用的情形（这属于超级高级的优化了）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; result = <span class="built_in">foo</span>();</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_lvalue_reference_v&lt;<span class="keyword">decltype</span>(result)&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 左值引用情形</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="comment">// std::is_rvalue_reference_v&lt;decltype(result)&gt;</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 右值引用情形</span></span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>除auto之外类型名过长的时候也可以使用 <code>using</code> 或 <code>typedef</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;;</span><br><span class="line"><span class="keyword">typedef</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; DeviceMap;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> DeviceMap&amp; devices = dm.<span class="built_in">GetDevices</span>();</span><br></pre></td></tr></table></figure>

<h3 id="【C-11】decltype类型指示符"><a href="#【C-11】decltype类型指示符" class="headerlink" title="【C++11】decltype类型指示符"></a>【C++11】decltype类型指示符</h3><p>#decltype<br>decl&#x2F;type：declare type（声明类型）<br>作用：并返回操作数的数据类型<br><strong>从表达式的类型推断出要定义的变量的类型，但是不用该表达式的值初始化变量。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = x; <span class="comment">//sum的类型就是函数func()的返回类型</span></span><br></pre></td></tr></table></figure>

<p>如果decltype使用的表达式是一个变量，则返回该变量的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>, &amp;b = a; </span><br><span class="line"><span class="keyword">decltype</span>(a) x = <span class="number">0</span>;  <span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(b) y = x;  <span class="comment">//y的类型是const int&amp;,y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(b) z;  <span class="comment">//错误，z是引用，必须初始化</span></span><br><span class="line"><span class="comment">//引用从来都作为其所指对象的同义词出现，只有在用在decltype处是一个例外。</span></span><br></pre></td></tr></table></figure>

<p>如果decltype使用的表达式是不是一个变量，则返回表达式结果对应的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的结果可以是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//加法结果是int，所以b是一个（未初始化）的int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype的表达式如果加上了括号，编译器会把它当成一个表达式，得到引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误，d是int &amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;  <span class="comment">//正确，e是一个（未初始化的）int</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!bug] 多层括号<br><code>decltype((i))</code>（注意是双层括号）的返回结果永远是引用，而<code>decltype(i)</code>的返回结果只有当<code>i</code>本身是引用时才是引用</p>
</blockquote>
<h3 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h3><p>#enum #枚举</p>
<ul>
<li>枚举类型(enumeration ）将<strong>一组整型常数</strong>组织在一起。</li>
<li>默认情况下，编译器设置第一个 枚举变量值为 0，下一个为 1，以此类推（也可以手动给每个枚举量赋值），且 <strong>未被初始化的枚举值的值默认将比其前面的枚举值大 1。</strong> ）</li>
</ul>
<p>分类：</p>
<ul>
<li><p><strong>【C++11】限定作用域的枚举类型，默认成员类型位int</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定作用域的枚举类型</span></span><br><span class="line"><span class="comment">//关键字enum class + 枚举类型名 + &#123;枚举成员&#125;;</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">color</span>&#123;red, yellow, green&#125;;</span><br><span class="line"><span class="keyword">enum struct</span> <span class="title class_">color</span>&#123;red, yellow, green&#125;; <span class="comment">//等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不限定作用域的枚举类型，无默认类型，分配一个足够容纳枚举值的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不限定作用域的枚举类型，省略关键字class或struct</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span>&#123;red, yellow, green&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//未命名的、不限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> &#123;red = <span class="number">1</span>, yellow = <span class="number">2</span>, green = <span class="number">3</span>&#125;;  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。<br>与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;red, yellow, green&#125;;  <span class="comment">//不限定作用域的枚举类型</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">stoplight</span> <span class="params">(red, yellow, green&#125;;  <span class="comment">//错误：重复定义了枚举成员</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">enum</span> <span class="keyword">class</span> peppers &#123;red, yellow, green&#125;;<span class="comment">//正确：枚举成员被隐藏了</span></span></span></span><br><span class="line"><span class="params"><span class="function">color eyes = green;  <span class="comment">//正确：不限定作用域的枚举类型的枚举成员位于有效的作用域中</span></span></span></span><br><span class="line"><span class="params"><span class="function">peppers p = green;   <span class="comment">//错误：peppers的枚举成员不在有效的作用域中</span></span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="comment">//color::green在有效的作用域中，但是类型错误</span></span></span></span><br><span class="line"><span class="params"><span class="function">color hair = color::red;  <span class="comment">//正确：允许显式地访问枚举成员</span></span></span></span><br><span class="line"><span class="params"><span class="function">peppers p2 = peppers::red;  <span class="comment">//正确：使用pappers的red</span></span></span></span><br></pre></td></tr></table></figure>

<h4 id="【C-11】指定enum的大小"><a href="#【C-11】指定enum的大小" class="headerlink" title="【C++11】指定enum的大小"></a>【C++11】指定enum的大小</h4><p>只能指定不同大小的整型！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">example</span> : <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">//将类型指定成unsigned char，枚举变量变成了8位整型，减少内存使用。  char型是大小为1字节（8位）的整型</span></span><br><span class="line">&#123;</span><br><span class="line"> Aa, Bb = <span class="number">10</span>, Cc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">intValues</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="comment">//将类型指定成unsigned longlong</span></span><br><span class="line">&#123;</span><br><span class="line">		charTyp = <span class="number">255</span>,shortTyp = <span class="number">65535</span>,intTyp = <span class="number">65535</span>,</span><br><span class="line">		longTyp = <span class="number">4294967295UL</span>,</span><br><span class="line">		<span class="number">1</span>ong_ongTyp = <span class="number">18446744073709551615ULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> example : <span class="type">float</span>  <span class="comment">//错误！枚举量必须是一个整数，float不是整数（double也不行）。</span></span><br><span class="line">&#123;</span><br><span class="line"> Aa, Bb = <span class="number">10</span>, Cc</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="【C-11】枚举类型的前置声明"><a href="#【C-11】枚举类型的前置声明" class="headerlink" title="【C++11】枚举类型的前置声明"></a>【C++11】枚举类型的前置声明</h4><p>提前声明 enum，前置声明必须指定其成员的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不限定作用域的枚举类型intValues的前置声明</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">intvalues</span> : <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;<span class="comment">//不限定作用域的，必须指定成员类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">open</span> modes;  <span class="comment">//限定作用域的枚举类型可以使用默认成员类型int</span></span><br></pre></td></tr></table></figure>

<h4 id="枚举的定义和初始化"><a href="#枚举的定义和初始化" class="headerlink" title="枚举的定义和初始化"></a>枚举的定义和初始化</h4><p>可利用新的枚举类型 <strong>example</strong> 声明这种类型的变量 example Dd，可以在定义枚举类型时定义枚举变量：</p>
<figure class="highlight c++"><figcaption><span>title:三种等价实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通定义+初始化</span></span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">example</span> </span><br><span class="line">&#123;</span><br><span class="line">     Aa, Bb, Cc</span><br><span class="line">&#125;</span><br><span class="line">example Dd = Aa;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明枚举的时候直接定义了枚举变量Dd,并初始化为Aa </span></span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">example</span> </span><br><span class="line">&#123;</span><br><span class="line">     Aa, Bb, Cc</span><br><span class="line">&#125;Dd = Aa; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只定义Dd而不初始化</span></span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">example</span> </span><br><span class="line">&#123;</span><br><span class="line">     Aa, Bb, Cc</span><br><span class="line">&#125;Dd</span><br><span class="line">Dd=Aa</span><br></pre></td></tr></table></figure>

<p>与基本变量类型不同的地方是，<strong>在不进行强制转换的前提下</strong>，只能将定义的<strong>枚举量</strong>赋值给该种枚举的变量 (非绝对的，可用强制类型转换将其他类型值赋给<strong>枚举变量</strong>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dd = Bb; <span class="comment">//ok</span></span><br><span class="line">Dd = Cc; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">Dd = <span class="number">5</span>; <span class="comment">//Error!因为5不是枚举量</span></span><br></pre></td></tr></table></figure>

<p>枚举量可赋给非枚举变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = Aa; <span class="comment">//ok.枚举量是符号常量，赋值时编译器会自动把枚举量转换为int类型。</span></span><br></pre></td></tr></table></figure>

<p>对于枚举，<strong>只定义了赋值运算符，没有为枚举定义算术运算</strong> ，但<strong>能参与其他类型变量的运算</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Aa++;          <span class="comment">//非法！</span></span><br><span class="line">Dd = Aa + Cc   <span class="comment">//非法！</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span> + Aa <span class="comment">//Ok,编译器会自动把枚举量转换为int类型。</span></span><br></pre></td></tr></table></figure>

<p>可以通过<strong>强制转换</strong>将其他类型值赋给枚举变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dd = <span class="built_in">example</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Dd = Cc</span><br><span class="line"><span class="comment">//若试图将一个超出枚举取值范围的值通过强制转换赋给枚举变量</span></span><br><span class="line">Dd = <span class="built_in">example</span>(<span class="number">10</span>); <span class="comment">//结果将是不确定的，这么做不会出错，但得不到想要的结果</span></span><br></pre></td></tr></table></figure>

<h4 id="枚举应用"><a href="#枚举应用" class="headerlink" title="枚举应用"></a>枚举应用</h4><p><strong>枚举</strong>和 <strong>switch</strong> 是最好的搭档：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">enumType</span>&#123;</span><br><span class="line">    Step0, Step1, Step2</span><br><span class="line">&#125;Step=Step0;      <span class="comment">//注意这里在声明枚举的时候直接定义了枚举变量Step,并初始化为Step0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (Step)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Step0:&#123;…;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Step1:&#123;…;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Step2:&#123;…;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>类可以将其（非static）成员定义为位域（bit-field）, 位域的类型必须是整型或枚举类型（通常声明为<code>unsigned int</code>）。<br>位域的声明形式是在<strong>成员名字之后紧跟一个冒号以及一个常量表达式</strong>，该表达式用于<strong>指定成员所占的二进制位数</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &lt;位域结构名&gt;</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   &lt;类型说明符&gt; &lt;位域名&gt; : &lt;位域长度&gt; <span class="comment">// 位域列表</span></span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a : <span class="number">8</span>;</span><br><span class="line"> <span class="type">int</span> b : <span class="number">2</span>;</span><br><span class="line"> <span class="type">int</span> c : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位域，就是把一个字节中的二进制位划分为不同的区域，并说明每个区域的位数。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>有些信息在存储时，并不需要占用一个完整的字节，而只需要占一个或几个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，只需要用一位二进制位即可。这样可以节省<strong>内存</strong></p>
<p>ue 中通常用位域表示 bool，字段后面都加了 <code>：1</code>，连续八个这种类型的变量才占一个字节，而一个 bool 就要占一字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint32 bPending: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<p>注意事项：</p>
<ol>
<li><p>一个位域必须存储在同一个字节中，不能跨字节存储。如一个字节所剩空间不能存储下一个位域的时候，应从下一个字节开始存储。也可以有意使某个位域从下一单元开始，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a : <span class="number">4</span>;</span><br><span class="line"> <span class="type">int</span>   : <span class="number">0</span>;<span class="comment">//空域</span></span><br><span class="line"> <span class="type">int</span> b : <span class="number">6</span>;<span class="comment">//从第二个字节开始存放</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在这个位域定义中，a占第一个字节的4bit，这个字节的另4bit填0表示不使用，b从第二个字节开始，占4bit。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说位域的不能超过8bit；</p>
</li>
<li><p>位域可以无位域名，这时它只用作填充或调整位置。无名的位域是不能使用的。例如：</p>
</li>
</ol>
<h1 id="二、字符串和数组"><a href="#二、字符串和数组" class="headerlink" title="二、字符串和数组"></a>二、字符串和数组</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>C++ 数组就是表示一堆的变量组成的集合，一般是一行相同类型的变量。</li>
</ul>
<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125; <span class="comment">//多的元素初始化为默认值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!bug] 不允许拷贝和赋值<br>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = a; <span class="comment">//错误</span></span><br><span class="line">b = a; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的特殊性"><a href="#数组的特殊性" class="headerlink" title="数组的特殊性"></a>数组的特殊性</h3><p>字符数组：用字符串字面值对数组初始化，使用这种方式时注意字符串字面值的结尾处还有一个’\0’空字符，这个空字符也被拷贝到字符数组中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> a[<span class="number">6</span>] = “abcdef”; <span class="comment">//错误，没有空间存放空字符，数组大小至少为7</span></span><br></pre></td></tr></table></figure>

<p>直接使用数组名字时，编译器自动将其转换为指向数组首元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>.<span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">string *p2 = nums; <span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<p>当使用decltype关键字时，转换不会发生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的仍是数组类型</span></span><br><span class="line"><span class="keyword">decltype</span>（nums） num =  &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>.<span class="string">&quot;three&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组的下标是 <code>size_t</code> 无符号类型，定义在 cstddef 头文件中，内置的下标运算符所用的索引值是有符号类型，可以处理负数下标，只是我们用负数作为下标的情况比较少。<br>而标准库类型限定使用下标必须是无符号类型</p>
<h3 id="【C-11】标准库函数begin和end"><a href="#【C-11】标准库函数begin和end" class="headerlink" title="【C++11】标准库函数begin和end"></a>【C++11】标准库函数begin和end</h3><p>数组的指针也是迭代器。数组的begin和end函数与容器中的begin和end成员函数类似，但数组不是类，所以这里的begin和end不是成员函数，直接调用即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia); <span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia); <span class="comment">//指向ia尾元素的下一位置的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *beg &lt;&lt; endl; <span class="comment">//返回1</span></span><br></pre></td></tr></table></figure>

<p>两个指针相减的结果是一种名为<code>ptrdiff_t</code>的带符号类型。</p>
<h3 id="栈数组和堆数组"><a href="#栈数组和堆数组" class="headerlink" title="栈数组和堆数组"></a>栈数组和堆数组</h3><ul>
<li>不能把栈上分配的数组（字符串）作为返回值，<strong>除非</strong>你传入的参数是一个内存地址。</li>
<li>如果你想返回的是在函数内新创建的数组，那你就要用 new 关键字来创建。</li>
<li>栈数组<code>int example[5];</code> 堆数组<code>int* another = new int[5];</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> example[<span class="number">5</span>]; <span class="comment">//这个是创建在栈上的，它会在跳出这个作用域时被销毁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>;i++) <span class="comment">//5个元素全部设置为2</span></span><br><span class="line">    example[i] = <span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span>* another = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];<span class="comment">//这行代码和之前的是同一个意思，但是它们的生存期是不同的.因为这个是创建在堆上的,实际上它会一直存活到直到我们把它销毁或者程序结束。所以你需要用delete关键字来删除它。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>;i++) <span class="comment">//5个元素全部设置为2</span></span><br><span class="line">    another[i] = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">delete</span>[] another;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的两个数组在内存上看都是一样的，元素都是 5 个 2；<br>那为什么要使用 new 关键字来动态分配，而不是在栈上创建它们呢？<strong>最大的原因是因为生存期</strong>, 因为 new 分配的内存，会一直存在，直到你手动删除它。<br>如果你有个函数要<strong>返回新创建的数组</strong>，那么你<strong>必须要使用 new 来分配</strong>，<strong>除非</strong>你传入的参数是一个内存地址。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>#char </p>
<ul>
<li>字符型变量用于显示<strong>单个字符</strong></li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;     <span class="comment">//输出的是97对应的字符a</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++中的string是字符串类，const char * 是字符串常量指针。</p>
<h3 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h3><p>虽然 C++ 提供了 string 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，string 类为我们提供了一个转换函数 <code>c_str()</code>，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）。请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串。</span></span><br><span class="line">string path = <span class="string">&quot;D:\\demo.txt&quot;</span>;</span><br><span class="line">FILE *fp = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;rt&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="C-字符串字面量"><a href="#C-字符串字面量" class="headerlink" title="C++ 字符串字面量"></a>C++ 字符串字面量</h3><ul>
<li>字符串字面量就是双引号中的内容。  </li>
<li>字符串字面量是存储在<strong>内存</strong>的<strong>只读部分</strong>的，不可对只读内存进行写操作。  </li>
<li>C++11 以后，默认为<code>const char*</code>, 否则会报错。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* name = <span class="string">&quot;cherno&quot;</span>;<span class="comment">//Error!</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="comment">//ERROR! 未定义行为；是因为你实际上是在用一个指针指向那个字符串字面量的内存位置，</span></span><br><span class="line"><span class="comment">//但字符串字面量是存储在内存的只读部分的，而你正在试图对只读内存进行写操作</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;cherno&quot;</span>; <span class="comment">//Ok!</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//ERROR!const不可修改</span></span><br><span class="line"><span class="comment">//如果你真的想要修改这个字符串，你只需要把类型定义为一个数组而不是指针</span></span><br><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;cherno&quot;</span>; <span class="comment">//Ok!</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从 C++11 开始，有些编译器比如 Clang，实际上只允许你编译<code>const char*</code>, 如果你想从一个字符串字面量编译 char, 你必须手动将他转换成<code>char*</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* name = (<span class="type">char</span>*)<span class="string">&quot;cherno&quot;</span>; <span class="comment">//Ok!</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<ul>
<li>别的一些字符串</li>
</ul>
<p>基本上，<code>char</code> 是一个字节的字符，<code>char16_t</code> 是两个字节的 16 个比特的字符（utf16），<code>char32_t</code> 是 32 比特 4 字节的字符（utf32），<code>const char</code> 就是 utf8. 那么 <code>wchar_t</code> 也是两个字节，和 <code>char16_t</code> 的区别是什么呢？事实上宽字符的大小，实际上是由编译器决定的，可能是一个字节也可能是两个字节也可能是 4 个字节，实际应用中通常不是 2 个就是 4 个（Windows 是 2 个字节，Linux 是 4 个字节），所以这是一个变动的值。如果要两个字节就用 char16_t，它总是 16 个比特的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;lk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;lk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;lk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;lk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name5 = <span class="string">u8&quot;lk&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>string_literals</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"></span><br><span class="line">    std::string name0 = <span class="string">&quot;hbh&quot;</span>s + <span class="string">&quot; hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string_literals 中定义了很多方便的东西，这里字符串字面量末尾加 s，可以看到实际上是一个操作符函数，它返回标准字符串对象（std::string）</p>
<p>然后我们就还能方便地这样写等等：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::wstring name0 = <span class="string">L&quot;hbh&quot;</span>s + <span class="string">L&quot; hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>string_literals 也可以忽略转义字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* example =<span class="string">R&quot;(line1</span></span><br><span class="line"><span class="string">    line2</span></span><br><span class="line"><span class="string">    line3</span></span><br><span class="line"><span class="string">    line4)&quot;</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>用于格式化输出字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The number is: %d&quot;</span>, num);</span><br></pre></td></tr></table></figure>
<p><strong>常用</strong><br><code>%c</code> char 字符<br><code>%d</code> 有符号十进制整数（<code>d</code> 代表了”decimal”十进制）<br><code>%f </code> 浮点数、十进制记数法（默认输出六位小数，使用 <code>%.2f</code> 指定为指定为两位小数）<br><code>%s</code> 字符串</p>
<p>其他：<br><code>%a</code> 浮点数、十六进制 bai 数字和 p-记法（C99）<br><code>%e</code> 浮点数、e-记数法<br><code>%g</code> 根据数值不同自动选择％f 或％e．<br><code>%i</code> 有符号十进制数（与％d 相同）<br><code>%o</code> 无符号八进制整数<br><code>%p</code> 指针<br><code>%u</code> 无符号十进制整数<br><code>%x</code> 使用十六进制数字 0f 的无符号十六进制整数<br><code>%%</code> 打印一个百分号<br>等等</p>
<p>使用案例：</p>
<p>输出整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">-12</span>)<span class="comment">//有符号</span></span><br><span class="line"><span class="comment">//-12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,<span class="number">-12</span>)<span class="comment">//无符号</span></span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>输出小数（默认输出六位小数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,<span class="number">12.3</span>)</span><br><span class="line"><span class="comment">//12.300000</span></span><br></pre></td></tr></table></figure>

<p>输出字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;ww&quot;</span>)</span><br><span class="line"><span class="comment">//ww</span></span><br></pre></td></tr></table></figure>

<p>按照指定位数输出整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d\n&quot;</span>,<span class="number">1234</span>);<span class="comment">//指定位数小于实际位数，按照实际位数输出</span></span><br><span class="line"><span class="comment">//12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,<span class="number">1234</span>);<span class="comment">//大于，默认右对齐，缺的用空格补齐</span></span><br><span class="line"><span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<p>按照指定位数输出小数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%1.3f\n&quot;</span>,<span class="number">123.456</span>);<span class="comment">//整数部分指定位数小于实际位数，按照实际位数输出</span></span><br><span class="line"><span class="comment">//123.456</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%9.3f\n&quot;</span>,<span class="number">123.456</span>);<span class="comment">//整数部分指定位数大于实际位数，默认右对齐，缺的空格补齐,小数点也算一位</span></span><br><span class="line"><span class="comment">//  123.456</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3.2f\n&quot;</span>,<span class="number">123.456</span>);<span class="comment">//小数部分指定位数小于实际位数，默认四舍五入</span></span><br><span class="line"><span class="comment">//123.46</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3.5f&quot;</span>,<span class="number">123.456</span>);<span class="comment">//小数部分指定位数大于实际位数，缺的0补齐</span></span><br><span class="line"><span class="comment">//123.45600</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">123.456</span>);<span class="comment">//保留两位小数，默认四舍五入</span></span><br><span class="line"><span class="comment">//123.46</span></span><br></pre></td></tr></table></figure>

<p>添加填充</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08d&quot;</span>,<span class="number">123</span>);<span class="comment">//默认以0填充</span></span><br><span class="line"><span class="comment">//00000123</span></span><br></pre></td></tr></table></figure>
<h1 id="三、表达式"><a href="#三、表达式" class="headerlink" title="三、表达式"></a>三、表达式</h1><h2 id="1-左值与右值-lvalue-and-rvalue"><a href="#1-左值与右值-lvalue-and-rvalue" class="headerlink" title="1 左值与右值 (lvalue and rvalue)"></a>1 左值与右值 (lvalue and rvalue)</h2><blockquote>
<p>[!NOTE] 简单总结</p>
<ul>
<li><p>当一个对象被用作左值的时候，用的是对象的地址（在内存中的位置）</p>
</li>
<li><p>当一个对象被用作右值的时候，用的是对象的值（内容）</p>
</li>
<li><p><strong>左值有地址和值</strong>，可以出现在赋值运算符左边或者右边。</p>
</li>
<li><p>右值只有临时值，无地址，只能在右边</p>
</li>
</ul>
</blockquote>
<ol>
<li><p>左值：<br>有地址 数值 有存储空间的值，往往长期存在； 左值是<strong>由某种存储支持的变量</strong>；<strong>左值有地址和值</strong>，可以出现在赋值运算符左边或者右边。</p>
</li>
<li><p>左值引用:</p>
</li>
</ol>
<ul>
<li><strong>非 const 的左值引用</strong>只接受左值</li>
<li><strong>const 左值引用</strong>。兼容右值和左值。<br>为什么？</li>
</ul>
<ol start="3">
<li><p>右值：<br>是<strong>临时量</strong>，无地址（或者说有地址但访问不到，它只是一个临时量） 没有存储空间的短暂存在的值 。</p>
</li>
<li><p>右值引用：<br>右值引用只能引用右值，不能绑定到左值，可以通过 const 引用或者右值引用延长右值的生命周期 </p>
</li>
<li><p>在给函数形参列表传参时，有四种情况：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(std::string name)</span> <span class="comment">// 可接受左值和右值 &#123;</span></span></span><br><span class="line"><span class="function">    std::cout&lt;&lt;name&lt;&lt;std::endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(std::string&amp; name)</span> <span class="comment">// 只接受左值引用，不接受右值 &#123;</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; name &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="comment">// 接受左值和右值，把右值当作 const lvalue&amp; </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(std::string&amp;&amp; name)</span> <span class="comment">// 接受右值引用 &#123;</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; name &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string firstName = <span class="string">&quot;yang&quot;</span>;</span><br><span class="line">    std::string lastName = <span class="string">&quot;dingchao&quot;</span>;</span><br><span class="line">    std::string fullName = firstName + lastName; <span class="comment">//右边的表达式是个右值。</span></span><br><span class="line">    <span class="built_in">PrintName</span>(fullName);</span><br><span class="line">    <span class="built_in">PrintName</span>(firstName+lastName);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>常规引用称为”左值引用“</p>
<p>”右值引用“就是必须绑定到右值的引用，通过&amp;&amp;获得。<br>”右值引用“只能绑定到右值（右值是临时的，没有地址），因此可以自由的将右值引用的资源“移动” 到另一个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;  <span class="comment">//正确：r引用i</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;  <span class="comment">//错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;  <span class="comment">//错误：i * 42是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 =i * <span class="number">42</span>;  <span class="comment">//正确：我们可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;  <span class="comment">//正确：将rr2绑定到右值上</span></span><br></pre></td></tr></table></figure>

<p>右值引用的优势：</p>
<p>如果我们知道传入的是一个临时对象的话，那么我们就不需要担心它们是否活着，是否完整，是否拷贝。我们可以简单地偷它的资源，给到特定的对象，或者其他地方使用它们。因为我们知道它是暂时的，它不会存在很长时间。而如果如上使用 <code>const string&amp; str</code>，虽然可以兼容右值，但是却不能从这个字符串中窃取任何东西！因为这个 str 可能会在很多函数中使用，不可乱修改！（所以才加了 const）</p>
<h2 id="2-递增递减运算符"><a href="#2-递增递减运算符" class="headerlink" title="2 递增递减运算符"></a>2 递增递减运算符</h2><blockquote>
<p>[!comment] 建议：除非必须，否则不用递增递减运算符的后置版本<br>前置版本避免了不必要的工作，它把值加1后直接返回了改变了的运算对象。</p>
<p>后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</p>
<p><strong>现代编译器中它门的性能差距非常小，可以忽略不计。</strong></p>
</blockquote>
<p>在 C++ 中，前置递增运算符（++i）和后置递增运算符（i++）是用于增加变量值的运算符。它们的区别在于它们返回的值和执行的顺序。</p>
<p><strong>前置递增运算符（++i）：</strong></p>
<ul>
<li>先将变量递增，然后返回递增后的值。</li>
<li>例如，<code>int i = 5; int a = ++i;</code>，<code>a</code> 的值为 6，<code>i</code> 的值也为 6。</li>
</ul>
<p><strong>后置递增运算符（i++）：</strong></p>
<ul>
<li>先返回变量原始值，然后再将变量递增。</li>
<li>例如，<code>int i = 5; int a = i++;</code>，<code>a</code> 的值为 5，而 <code>i</code> 的值会在语句结束之后变为 6。</li>
</ul>
<p>需要注意的是，在表达式中使用这两种递增运算符时可以产生不同的结果。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 5;</span><br><span class="line">cout &lt;&lt; ++i &lt;&lt; endl; // 输出：6</span><br><span class="line">int i = 5;</span><br><span class="line">cout &lt;&lt; i++ &lt;&lt; endl; // 输出：5</span><br></pre></td></tr></table></figure>

<h2 id="3-箭头操作符"><a href="#3-箭头操作符" class="headerlink" title="3 箭头操作符-&gt;"></a>3 箭头操作符-&gt;</h2><p><strong>1. 特点：</strong></p>
<ul>
<li>箭头运算符必须是类的成员。</li>
<li>一般将箭头运算符定义成了 const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变类对象的状态。</li>
</ul>
<p><strong>2. 对箭头运算符返回值的限定</strong></p>
<p>箭头运算符的重载<strong>永远不能丢掉成员访问</strong>这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。<br><strong>对于形如 point-&gt;mem 的表达式来说，point 必须是指向类对象的指针或者是一个重载了 operator-&gt; 的类的对象。</strong> 根据 point 类型的不同，point-&gt;mem 分别等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">point-&gt;mem;</span><br><span class="line"></span><br><span class="line">(*point).mem; <span class="comment">//point 是一个内置的指针类型, 点运算符获取类对象的一个成员</span></span><br><span class="line">point.<span class="built_in">operator</span>()-&gt;mem; <span class="comment">//point是类的一个对象</span></span><br></pre></td></tr></table></figure>

<p>重载的箭头运算符<strong>必须返回类的指针或者自定义了箭头运算符的某个类的对象。</strong></p>
<p><strong>3. 三种应用场景</strong></p>
<ol>
<li><p>可用于指针调用成员：p-&gt;x 等价于 (* p).x (最常见的情况)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	Entity* ptr = &amp;e;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//两种方式等价</span></span><br><span class="line">	(*ptr).x=<span class="number">2</span>;</span><br><span class="line">	ptr-&gt;x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr): <span class="built_in">m_Ptr</span>(ptr) &#123; &#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    Entity* <span class="keyword">operator</span>-&gt;()  <span class="comment">//重载操作符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ScopedPtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>进一步, 可以写为 const 版本的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//添加const &#123;</span></span></span><br><span class="line"><span class="function">        std::cout &lt;&lt; &quot;hello!&quot; &lt;&lt; std::endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">        : <span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    Entity* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="comment">//添加const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> ScopedPtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">//如果是const，则上面代码要改为const版本的。</span></span><br><span class="line">        entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可用于计算成员变量的 offset：</li>
</ol>
<p>引自 B 站评论：<br>因为 “指针 -&gt; 属性” 访问属性的方法实际上是通过把指针的值和属性的偏移量相加，得到属性的内存地址进而实现访问。 而把指针设为 nullptr(0)，然后 -&gt; 属性就等于 0 + 属性偏移量。编译器能知道你指定属性的偏移量是因为你把 nullptr 转换为类指针，而这个类的结构你已经写出来了 (float x,y,z)，float4 字节，所以它在编译的时候就知道偏移量 (0,4,8)，所以无关对象是否创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vec2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">float</span> pos,v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="type">int</span> offset = (<span class="type">int</span>)&amp;((vec2*)<span class="literal">nullptr</span>)-&gt;x; <span class="comment">// x,y,pos,v的offset分别为0,4,8,12</span></span><br><span class="line">    std::cout&lt;&lt;offset&lt;&lt;std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-sizeof-运算符"><a href="#4-sizeof-运算符" class="headerlink" title="4 sizeof 运算符"></a>4 sizeof 运算符</h2><p>返回一条表达式或一个类型所占的字节数，结果是 <code>size_t</code> 类型的常量表达式。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种形式：</span></span><br><span class="line"><span class="built_in">sizeof</span>(type);</span><br><span class="line"><span class="keyword">sizeof</span> expr; <span class="comment">//返回表达式结果类型的大小</span></span><br></pre></td></tr></table></figure>

<h2 id="5-强制类型转换"><a href="#5-强制类型转换" class="headerlink" title="5 强制类型转换"></a>5 强制类型转换</h2><h3 id="c-风格强制类型转换"><a href="#c-风格强制类型转换" class="headerlink" title="c 风格强制类型转换"></a>c 风格强制类型转换</h3><p>直接用括号进行转换，可以实现 cast 相同功能，缺点是表现形式不清晰，不容易 debug。</p>
<ul>
<li>形式一：C 语言风格的转型语法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(T)expression     <span class="comment">//将expression转换为T类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>形式二: 函数风格的转型：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>(expression)     <span class="comment">////将expression转换为T类型</span></span><br></pre></td></tr></table></figure>

<p>上面两种形式并无差别，只是小括号摆放位置不同。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p><code>static_cast</code> 用于进行比较 “自然” 和低风险的转换</p>
<ol>
<li>基本类型如整型和浮点型、字符型之间的互相转换。</li>
<li>指针&#x2F;引用类型之间的转换，<strong>不执行运行时类型检查，可能不安全</strong>。</li>
</ol>
<p>任何具有明确定义的类型转换，<strong>只要不包含底层 const，都可以使用 static_cast</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dPi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dPi);  <span class="comment">//num的值为3</span></span><br></pre></td></tr></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret：重新解释</p>
<p><code>reinterpret_cast</code> 用于进行各种<strong>不同类型的指针</strong>之间强制转换。</p>
<p>通常为运算对象的位模式提供较低层次上的重新解释。危险，不推荐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(ip);</span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><code>const_cast&lt;T&gt;</code> 中的类型必须是指针、引用，用于去除指针或引用的 const 或 volatile 属性。</p>
<p>使用场景：const 对象（或 const 成员函数）调用非 const 成员函数，必须将 const 去掉才能调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">//非 const 成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MyClass obj;</span><br><span class="line">MyClass* obj_ptr = <span class="built_in">const_cast</span>&lt;MyClass*&gt;(&amp;obj); <span class="comment">// 删除const属性，使得可以调用非const成员函数</span></span><br><span class="line">obj_ptr-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用非const成员函数</span></span><br></pre></td></tr></table></figure>

<p>使用 const_cast 可能导致未定义的行为，因此应谨慎使用。</p>
<h3 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h3><p>RTTI 即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</p>
<p><strong>C++ 是一种静态类型语言</strong>。在静态类型语言中，变量的类型在编译时确定，，不能在运行时更改。然而由于面向对象程序设计中<strong>多态性</strong>的要求，<strong>C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致</strong>。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。</p>
<p><strong>运行时类型识别（run-time type identification,RTTI）</strong>由两个运算符实现：</p>
<ul>
<li>typeid运算符，用于返回表达式的类型</li>
<li>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><blockquote>
<p>[!NOTE] 总结</p>
<ul>
<li>子类向父类转换（向上转换）可以使用 <code>static_cast</code> 或 <code>dynamic_cast</code> 。向上转换始终是安全的，没必要使用 <code>dynamic_cast</code>，它会增加运行时的开销。我们通常使用隐式转换即可。</li>
<li>父类向子类转换（向下转换）<strong>必须</strong>使用 <code>dynamic_cast</code> ，且要保证父类有虚函数。</li>
</ul>
</blockquote>
<ol>
<li><code>dynamic_cast</code> 运算符，用于<strong>将基类的指针或引用安全地转换成派生类的指针或引用，</strong> 如果转换失败会返回空指针（对于指针）或 <code>std::bad_cast</code> 异常（对于引用）。</li>
<li>使用时需要保证是多态，<strong>即只能用于基类含有虚函数的类</strong>。</li>
<li>支持运行时类型识别。</li>
</ol>
<p>适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。</p>
<p><strong>使用形式：</strong><br>其中，<strong>type 必须是一个类类型</strong>，并且通常情况下该<strong>类型含有虚函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic <span class="built_in">cast</span>&lt;type*&gt; (e) <span class="comment">//e必须是一个有效的指针</span></span><br><span class="line">dynamic <span class="built_in">cast</span>&lt;type&amp;&gt; (e) <span class="comment">//e必须是一个左值</span></span><br><span class="line">dynamic <span class="built_in">cast</span>&lt;type&amp;&amp;&gt; (e) <span class="comment">//e不能是左值</span></span><br></pre></td></tr></table></figure>

<p>在上面的所有形式中，e 的类型必须符合以下三个条件中的任意一个：</p>
<ul>
<li>e 的类型是目标 type 的<strong>公有派生类</strong></li>
<li>e 的类型是目标 type 的<strong>公有基类</strong></li>
<li>e 的类型就是<strong>目标 type 的类型</strong>。<br>如果符合，则类型转换可以成功。否则，转换失败。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> z = <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建父类指针指向子类对象，这里进行了隐式【向上转换】</span></span><br><span class="line">    Parent *parent = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想访问子类创建的成员，需要进行【向下转换】</span></span><br><span class="line">    <span class="keyword">if</span>(Son* son = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(parent))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 访问子类的成员变量</span></span><br><span class="line">        cout &lt;&lt; son-&gt;z &lt;&lt; endl; <span class="comment">// 输出123</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;转换失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>可以对一个空指针执行 dynamic_cast，结果是所需类型的空指针</p>
</blockquote>
<h4 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h4><p>typeid运算符允许向程序表达式提问：你的对象是什么类型？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(e)  <span class="comment">//e可以是任意表达式或类型的名字</span></span><br><span class="line"><span class="comment">//返回一个常量对象的引用，该对象的类型时标准库类型type_info或type_info的公有派生类型（type_info类在不同编译器上有所区别）。</span></span><br></pre></td></tr></table></figure>
<p>typeid运算符可以作用于任意类型的表达式。和往常一样，顶层const被忽略，如果表达式是一个引用，则typeid返回该引用所引对象的类型。不过当typeid作用于数组或函数时，并不会执行向指针的标准类型转换。也就是说，如果我们对数组a执行typeid(a),则所得的结果是数组类型而非指针类型。</p>
<ul>
<li>当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid 运算符指示的是运算对象的静态类型。</li>
<li><strong>而当运算对象是定义了至少一个虚函数的类的左值时，typeid 的结果直到<mark style="background: #FF5582A6;">运行时</mark>才会求得。</strong></li>
</ul>
<p>通常我们使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;</span><br><span class="line"><span class="comment">//两个指针都指向Derived对象</span></span><br><span class="line"><span class="comment">//在运行时比较两个对象的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp)==<span class="built_in">typeid</span>(*dp))&#123;</span><br><span class="line"><span class="comment">//bp和dp指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查运行时类型是否是某种指定的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp)==<span class="built_in">typeid</span>(Derived))&#123;</span><br><span class="line"><span class="comment">//bp实际指向Derived对象</span></span><br></pre></td></tr></table></figure>
<h4 id="type-info-类"><a href="#type-info-类" class="headerlink" title="type_info 类"></a>type_info 类</h4><p><code>type_info</code> 类的精确定义随着编译器的不同而略有差异。不过，C++标准规定 <code>type_info</code> 类必须定义在 typeinfo 头文件中，并且至少提供表 19.1 所列的操作。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019173.png" alt="Pasted image 20240217212011"><br>除此之外，因为 <code>type_info</code> 类一般是作为一个基类出现，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时, 通常在 <code>type_info</code> 的派生类中完成。<br><code>type_info</code> 类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义成删除的。因此，我们无法定义或拷贝 <code>type_info</code> 类型的对象，也不能为 <code>type_info</code> 类型的对象赋值。<strong>创建 <code>type_info</code> 对象的唯一途径是使用 <code>typeid</code> 运算符。</strong><br><code>type_info</code> 类的 <code>name</code> 成员函数返回一个 C 风格字符串，表示对象的类型名字。对于某种给定的类型来说，name 的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于 name 返回值的唯一要求是，类型不同则返回的字符串必须有所区别。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr [<span class="number">10</span>];</span><br><span class="line">Derived d;</span><br><span class="line">Base *p = &amp;d;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span> (<span class="number">42</span>).<span class="built_in">name</span> ( ) &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">     &lt;&lt;<span class="built_in">typeid</span>(arr) .<span class="built_in">name</span> () &lt;&lt;<span class="string">&quot;,&quot;</span></span><br><span class="line">     &lt;&lt;<span class="built_in">typeid</span> (Sales_data) .<span class="built_in">name</span> () &lt;&lt; <span class="string">&quot;,“</span></span><br><span class="line"><span class="string">     &lt;&lt;typeid(std: :string) .name ()&lt;&lt; &quot;</span>,”</span><br><span class="line">     &lt;&lt;<span class="built_in">typeid</span>(p).<span class="built_in">name</span> ( ) &lt;&lt; <span class="string">&quot;，&quot;</span></span><br><span class="line">     &lt;&lt;<span class="built_in">typeid</span>(*p) .<span class="built_in">name</span> () &lt;&lt;endl;</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"> <span class="comment">//i， A10_i, 10sales_data, Ss,P4Base, 7Derived</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type_info 对象是在编译的时候决定其内容的，作为静态数据存在于最终生成的目标代码里。编译器会在静态存储空间里为这些 type_info 对象分配空间，并生成代码来初始化它们的内容。 </p>
<h3 id="类型转换函数（类型转换运算符）"><a href="#类型转换函数（类型转换运算符）" class="headerlink" title="类型转换函数（类型转换运算符）"></a>类型转换函数（类型转换运算符）</h3><p>又称类型转换运算符，<strong>使用类型转换函数可以将该类类型转换为其他类型。</strong><br>用法：P514 </p>
<p>一个类型转换函数必须是类的成员函数，他不能声明返回类型，形参列表也必须为空。类型转换函数通常是 const 函数。<br><code>operator type () const</code></p>
<h2 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6 运算符优先级"></a>6 运算符优先级</h2><p><strong>从上到下优先级递减</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019174.png" alt="Pasted image 20230317224005"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019175.png" alt="Pasted image 20230317224036"></p>
<h1 id="四、控制流"><a href="#四、控制流" class="headerlink" title="四、控制流"></a>四、控制流</h1><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>执行多条件分支语句</p>
<blockquote>
<p><strong>注意1：switch语句中表达式类型只能是整型或者字符型</strong><br><strong>注意2：case里如果没有break，那么程序会一直向下执行</strong></p>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，<strong>缺点是switch不可以判断区间</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>:</span><br><span class="line">		执行语句;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span></span><br><span class="line">		执行语句;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		执行语句;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法形式</span></span><br><span class="line"><span class="keyword">for</span>(init-statement;condition;expression)</span><br><span class="line">&#123;</span><br><span class="line">		statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语句头多重定义"><a href="#语句头多重定义" class="headerlink" title="语句头多重定义"></a>语句头多重定义</h3><p>init-statement可以定义多个对象，但是只能由一条声明语句，因此，所有变量的基础类型必须相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//init-statement定义了两个对象：i和sz</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(v.<span class="built_in">size</span>()) i = <span class="number">0</span>, sz = v.<span class="built_in">size</span>(); i!=sz; ++i)</span><br><span class="line">&#123;</span><br><span class="line">		v.<span class="built_in">pushback</span>(v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="省略语句头的某些部分"><a href="#省略语句头的某些部分" class="headerlink" title="省略语句头的某些部分"></a>省略语句头的某些部分</h3><p>for语句头能省略掉init-statement、condition、expression中的任何一个（或全部）。</p>
<p>省略condition：等价于在条件部分写了一个true，所以循环体内必须有语句负责退出循环，否则将会无限循环。</p>
<p>省略expression：要求condition部分或者循环体必须有改变迭代变量的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i; cin&gt;&gt;i; <span class="comment">/*expression为空*/</span>)  <span class="comment">//condition能改变i的值</span></span><br><span class="line">&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【C-11】范围for"><a href="#【C-11】范围for" class="headerlink" title="【C++11】范围for"></a>【C++11】范围for</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//range for语法</span></span><br><span class="line"><span class="keyword">for</span>(declaration : expression)</span><br><span class="line">		statement</span><br><span class="line"><span class="comment">//expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、vector、string，这些类型的共同特点是拥有能返回迭代器的begin和end成员。</span></span><br><span class="line"><span class="comment">//declaration定义一个变量，该变量用于访问序列中的基础元素，每次迭代，该部分的变量都会初始化为expression部分的下一个元素值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历string对象中的每个字符</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : str)</span><br><span class="line">&#123;</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对string元素执行写操作，必须把循环变量定义为引用类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : str)</span><br><span class="line">&#123;</span><br><span class="line">		i = <span class="number">1</span>;  <span class="comment">//将string全部改为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = v.begin, end = v.<span class="built_in">end</span>(); beg!=end; ++beg)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">auto</span> &amp;i = *beg;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><p>与while的区别在于do…while会先执行一次循环语句，再判断循环条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">		statement;</span><br><span class="line"><span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure>

<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><strong>终止离他最近的</strong>while、do while、for或swtich语句，并从这些语句之后的第一条语句开始执行。</p>
<p>break使用的时机：</p>
<ul>
<li>出现在<strong>switch条件语句中，作用是 终止case 并跳出switch</strong></li>
<li>出现在<strong>循环语句中，作用是跳出 当前 的循环语句</strong></li>
<li>出现在<strong>嵌套循环中，跳出 最近的 内层循环语句</strong></li>
</ul>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>终止最近的循环中的当前迭代，并立即开始下一次迭代。</p>
<h1 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h1><p>函数就是我们写的代码块，被设计为用来执行特定的任务。<strong>在 class 中这些代码块则被称为方法 method。</strong></p>
<p><strong>这里所说函数单独指类外的。</strong></p>
<p>每次调用函数，编译器生成一个 call 指令（类外的，因此没有什么动态绑定，也暂时不考虑内联）。这基本上意义着，在一个运行的程序中，为了调用一个函数，我们需要创建一个堆栈结构，这意味着我们必须把像参数这样的东西推进堆栈。我们还需要一个叫做返回地址的东西压入堆栈。然后我们要做的是跳到二进制执行文件的不同部分，以便开始执行我们的函数指令。<br>为了将 push 进去的结果返回，然后我们得回去到最初调用函数之前。跳跃和执行这些都需要时间，所以它会减慢我们的程序。</p>
<p>而对于 main 函数，返回值是 int，并且只有 main 函数可以不 return——它会自动假设返回 0.（这是现代 C 和 C++ 的一个特性）</p>
<h2 id="1-空形参列表"><a href="#1-空形参列表" class="headerlink" title="1 空形参列表"></a>1 空形参列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参列表可以为空，下列两种方式等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;&#125;;  <span class="comment">//兼容c</span></span><br></pre></td></tr></table></figure>

<h2 id="2-main-处理命令行选项"><a href="#2-main-处理命令行选项" class="headerlink" title="2 main 处理命令行选项"></a>2 main 处理命令行选项</h2><p>有时我们需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。<br>例如，假定main函数位于可执行文件prog内，我们可以向程序传递下面的选项：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile date0</span><br></pre></td></tr></table></figure>
<p>这些命令通过两个（可选的）形参传递给main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;......&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;......&#125; <span class="comment">//等价表示，其中argv指向char*</span></span><br><span class="line"><span class="comment">//argc表示数组中字符串的数量</span></span><br><span class="line"><span class="comment">//argv是一个数组，他的元素是指向C风格字符串的指针</span></span><br></pre></td></tr></table></figure>
<p>当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下里的元素依次传递命令行提供的是实参，最后一个指针之后的元素值保证为0</p>
<p>例子中，argc的值等于5，argv应该包含如下的C风格字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;prog&quot;</span>; <span class="comment">//指向程序的名字或者一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-o&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;date0&quot;</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="string">&quot;0&quot;</span>;  <span class="comment">//最后一个指针之后的元素值保证为0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>当使用 argv 中的实参时，一定要记得可选的实参从 argv[1]开始；argv[0]保证是程序的名字，而非用户输入</p>
</blockquote>
<h3 id="深入理解argc和argv"><a href="#深入理解argc和argv" class="headerlink" title="深入理解argc和argv"></a>深入理解argc和argv</h3><p> argc 是 argument count的缩写，表示传入main函数的参数个数；<br> <br> argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且<strong>第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径</strong>，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</p>
<p>简单用法示例，新建工程键代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;argument[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;] is: &quot;</span>&lt;&lt;argv[i]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>argv是指向指针的指针，main函数的第二个参数替换为 char** argv，两者是等价的。</p>
<p>在编译环境下按F5运行，输出如下：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019176.png" alt="Pasted image 20230105102141"><br>可见，在没有参数传入的情况下，保存程序名称的第一个变量argv[0]依然存在。</p>
<p>传参数给main函数有两种方法，第一种方式是在编译环境中设置，以vs2012为例，右击项目—&gt;属性—&gt;配置属性—&gt;调试—&gt;命令参数，在命令参数中输入，每个参数之间用空格隔开。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019177.png" alt="Pasted image 20230105102227"><br>之后点击确定并应用，运行之后显示如下：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019178.jpg" alt="Pasted image 20230105102233"><br>第二种方式也是经常会用到的方式是通过命令提示符传入。首先需要打开命令提示符窗口，点击开始菜单在“搜索程序和文件”里输入命令“cmd”或者直接按<strong>快捷键 Windows+R</strong>，在弹出的对话框里输入“cmd”即可打开命令提示符窗口：</p>
<p>打开命令提示符窗口后需要输入生成的exe文件所在的完整路径，一个简便的方法是把exe文件直接拖入提示符窗口即可，之后输入传入参数，以空格分隔，之后回车，显示如下：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019179.jpg" alt="Pasted image 20230105102321"><br>如果你坚持要手工输入完整路径的话，你会发现等你“Ctrl+C”路径后，在提示符窗口中按“Ctrl+V”却不能粘贴，这时候可以在窗口中右键单击一下试试，你会发现右键菜单里的粘贴功能还是有效的。</p>
<p>下一个例子演示使用opencv显示一幅图片：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Mat image=<span class="built_in">imread</span>(argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Lena&quot;</span>,image);</span><br><span class="line">		<span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意读入的参数是argv[1]，在命令提示符窗口运行：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019180.jpg" alt="Pasted image 20230105102410"><br>最后说明一下：<strong>一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名作为入参</strong>，效果是一样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> value,<span class="type">char</span> **point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;argument[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;] is: &quot;</span>&lt;&lt;point[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-【C-11】-含有可变形参的函数"><a href="#3-【C-11】-含有可变形参的函数" class="headerlink" title="3 【C++11】 含有可变形参的函数"></a>3 【C++11】 含有可变形参的函数</h2><p>编写处理不同数量形参的函数，C++11有两种方法：</p>
<ol>
<li>如果所有实参类型相同，可以使用 <code>initialize_list</code> 的标准库类型 </li>
<li>如果实参类型不同，可以编写可变参数模板P618</li>
</ol>
<p>还有一种特殊的形参类型（省略符 <code>.....</code>），可以用它传递可变数量的形参，这种功能一般只用于与 C 函数交互得接口程序。</p>
<h3 id="initialize-list-初始化列表"><a href="#initialize-list-初始化列表" class="headerlink" title="initialize_list 初始化列表"></a>initialize_list 初始化列表</h3><p><strong>如果函数的实参数量未知但是全部实参的类型相同，可以使用 <code>initialize_list</code> 类型的形参</strong>。<code>initialize_list</code> 是一种标准库类型，用于表示某种特定类型的值的数组。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019181.png" alt="Pasted image 20230823162816"></p>
<p><code>initialize_list</code> 对象中的元素永远是常量值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：输出错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span> <span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>() ; beg != il.<span class="built_in">end</span> ( ) ; ++beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    cout cc endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以同时拥有其他形参</span></span><br><span class="line"><span class="comment">//void error msg(ErrCode e, initializer_list&lt;string&gt; il)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果想向 <code>initializer_list</code> 形参中传递一个值的序列, 则必<strong>须把序列放在一对花括号内</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span> (expected != actual)</span><br><span class="line">    <span class="built_in">error__msg</span>( &#123; <span class="string">&quot; functionx&quot;</span> , expected, actual &#125;) ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span> (&#123;<span class="string">&quot;functionx&quot;</span> ,<span class="string">&quot;okay&quot;</span> &#125; ) ;</span><br></pre></td></tr></table></figure>

<h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>省略符形参是为了便于 C++程序访问某些特殊的 C 代码而设置的, 这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。</p>
<blockquote>
<p>[!bug] Title<br>省略符形参应该仅仅用于 C 和 C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
</blockquote>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一种形式指定了 foo 函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。</p>
<h2 id="4-【C-11】尾置返回类型"><a href="#4-【C-11】尾置返回类型" class="headerlink" title="4 【C++11】尾置返回类型"></a>4 【C++11】尾置返回类型</h2><p>任何函数的定义都能使用尾置返回，但是<strong>这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用</strong>。</p>
<p>下面的例子是返回一个指向维度为10的数组指针的函数定义方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>下面逐层理解上述例子的含义：</p>
<ul>
<li><code>func(int i)</code>表示调用函数时，需要一个int类型的参数；</li>
<li><code>* func(int i)</code>表示对调用func的结果执行解引用的操作；</li>
<li><code>(* func(int i))[10]</code>表示解引用之后得到一个维度为10的数组；</li>
<li><code>int (* func(int i))[10]</code>表示数组的数据类型为int；</li>
</ul>
<p>若使用尾置返回类型，上述函数的定义可以写成：</p>
<p>尾置返回类型跟在形参列表后面并以一个 -&gt; 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 <code>auto</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受了一个int类型的实参，返回了一个指针，该指针指向一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们把函数的返回类型放在了形参列表之后，所以我们可以很清晰地看到func函数返回的是一个指针，并且该指针指向了一个含有10个整数的数组。</p>
<p><strong>尾置返回类型的另一个好处是我们可以在函数返回类型中使用函数形参相关的信息：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//可以工作，但是需要改良</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>-&gt;<span class="title">decltype</span><span class="params">(c[i])</span> <span class="comment">//尾置返回类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(c[i])</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> <span class="comment">//error</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>authAndAccess</code> 函数中，我们使用 <code>c</code> 和 <code>i</code> 指定返回类型。如果我们按照传统语法把函数返回类型放在函数名称之前，<code>c</code> 和 <code>i</code> 就未被声明所以不能使用。</p>
<h2 id="5-默认实参"><a href="#5-默认实参" class="headerlink" title="5 默认实参"></a>5 默认实参</h2><ul>
<li>局部变量不能作为默认实参</li>
<li>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参</li>
<li>设计时尽量让不怎么使用默认值的参数出现在前面<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数具有默认实参</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> height = <span class="number">24</span>, <span class="type">int</span> width = <span class="number">80</span>, <span class="type">char</span> background = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用时实参按位置解析，默认实参负责填补函数调用缺少的尾部实参</span></span><br><span class="line">	string window;</span><br><span class="line">	window = <span class="built_in">screen</span>(); <span class="comment">// 等价于screen(24, 80, &#x27; &#x27;)</span></span><br><span class="line">	window = <span class="built_in">screen</span>(<span class="number">66</span>); <span class="comment">// 等价于screen(66, 80, &#x27; &#x27;)</span></span><br><span class="line">	window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>); <span class="comment">// 等价于screen(66, 256, &#x27; &#x27;)</span></span><br><span class="line">	window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>,<span class="string">&#x27;#&#x27;</span>); <span class="comment">// 等价于screen(66, 256, &#x27;#&#x27;)</span></span><br><span class="line">	window = <span class="built_in">screen</span>( , , <span class="string">&quot;S&quot;</span>) <span class="comment">// 错误，只能从尾部填充</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-函数指针"><a href="#6-函数指针" class="headerlink" title="6 函数指针"></a>6 函数指针</h2><p>#函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向该函数的指针，只需要用指针替换掉函数即可</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] Title<br>（*pf）两端的括号必不可少，如果不写括号，则pf是一个返回值为bool指针类型的函数</p>
<p>bool *pf(const string &amp;, const stirng &amp;);</p>
</blockquote>
<h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><p>当把函数名作为一个值使用时，该函数自动转换成指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">//pf指向lengthCompare函数</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">//等价，&amp;取地址符是可选的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用auto简写</span></span><br><span class="line"><span class="keyword">auto</span> pf = lengthCompare;</span><br></pre></td></tr></table></figure>

<p>可以直接使用函数指针调用该函数，无须提前解引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b = (*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>); <span class="comment">//等价，*解引用符是可选的</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>); <span class="comment">//等价，常规调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用auto简写</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h3><p>函数指针可以作为一个参数传递给另一个函数。这时函数指针的使用就像普通的常量和变量一样。<br>当函数指针作为参数传递的时候，这时接收参数传递的函数通常需要根据这个指针调用这个函数。作为参数传递的函数指针通常表示 <strong>回调函数（Callback Functions）</strong>。</p>
<blockquote>
<p>[!NOTE] 回调函数<br>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FuncPtr)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> FuncPtr = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, FuncPtr operation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> result;</span><br><span class="line">     result = <span class="built_in">operation</span>(a, b); <span class="comment">// 运算</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样写：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> (*operation)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = <span class="built_in">operation</span>(a, b); <span class="comment">// 运算</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么要首先使用函数指针"><a href="#为什么要首先使用函数指针" class="headerlink" title="为什么要首先使用函数指针"></a>为什么要首先使用函数指针</h3><p>和数组类似，不能定义函数类型的形参，但是形参可以是指向函数的指针，这样就能<strong>将一个函数作为另一个函数的形参</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面就将一个函数作为形参传入另一个函数里了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*function)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> temp : values) &#123;</span><br><span class="line">        <span class="built_in">function</span>(temp); <span class="comment">//就可以在当前函数里用其他函数了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; valus = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, Print); <span class="comment">//这里就是传入了一个函数指针进去！！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：lambda</strong><br><strong>lambda 本质上是一个普通的函数</strong>，只是它不像普通函数这样声明，它是我们的代码<strong>在过程中生成的，用完即弃的函数</strong>，不算一个真正的函数，是<strong>匿名函数</strong> 。<br>格式：<code>[] (&#123;形参表&#125;) &#123;函数内容&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*function)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> temp : values) &#123;</span><br><span class="line">        <span class="built_in">function</span>(temp);     <span class="comment">//正常调用lambda函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; valus = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, [](<span class="type">int</span> val)&#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;);     <span class="comment">//如此简单的事就交给lambda来解决就好了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7【C-11】lambda-表达式"><a href="#7【C-11】lambda-表达式" class="headerlink" title="7【C++11】lambda 表达式"></a>7【C++11】lambda 表达式</h2><p>#lambda<br>lambada 即 λ 的读音</p>
<p>可以理解为一个临时函数，适用于那种只在一两处使用的简单操作。<br>如果一个需要多次使用的功能，最好还是用函数。</p>
<p>普通函数的不同：</p>
<ol>
<li>lambda可以定义在函数内部</li>
<li>可以忽略参数列表和返回类型，但必须包含捕获列表和函数体</li>
<li>当我们需要为一个lamba定义返回类型时，必须使用尾置返回类型。</li>
<li>不能有默认参数</li>
</ol>
<p><code>[捕获列表](参数列表)-&gt;返回类型 &#123;函数体&#125;</code><br><code>[capture list](parameter list)-&gt;return type &#123; function body &#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以忽略参数列表和返回类型，但必须包含捕获列表和函数体</span></span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;  <span class="comment">//auto为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式和普通函数相同，注意要使用调用运算符()</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl; <span class="comment">//输出42</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p><strong>捕获列表</strong> 是一个 lambda 所在函数中定义的局部变量的列表（通常为空）<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019182.png" alt="Pasted image 20230212201442"><br>显式捕获：<code>[name]</code>显示列出所在函数的变量<br>隐式捕获：让编译器根据lambda体中的代码推断我们要使用哪些变量<br>注意 <code>identifier_list</code> 是个列表：可以指定多个显示捕获变量 </p>
<blockquote>
<p>[!NOTE] 捕获外部变量<br>lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p>
<p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [&amp;]&#123;&#125;;          <span class="comment">// OK: 隐式引用捕获列表</span></span><br><span class="line">    [&amp;, i]&#123;&#125;;       <span class="comment">// OK: i使用值捕获，其他局部变量都是引用捕获</span></span><br><span class="line">    [&amp;, &amp;i] &#123;&#125;;     <span class="comment">// Error，i只能值捕获</span></span><br><span class="line">   </span><br><span class="line">	[=]&#123;&#125;;          <span class="comment">// OK: 隐式值捕获列表</span></span><br><span class="line">    [=, &amp;i]&#123;&#125;;      <span class="comment">// OK: i使用引用捕获，其他局部变量都是值捕获</span></span><br><span class="line">    [=, =i]&#123;&#125;;      <span class="comment">// Eroor: i只能使用引用捕获获</span></span><br><span class="line">    [=, &amp;i,<span class="keyword">this</span>]&#123;&#125;; <span class="comment">// Error：C++11暂不支持this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*function)(<span class="type">int</span>))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> temp : values) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">function</span>(temp);     <span class="comment">//正常调用lambda函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数指针的地方都可以用auto来简化操作，lambda亦是</span></span><br><span class="line">    <span class="comment">//这样子来定义lambda表达式会更加清晰明了</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="type">int</span> val)&#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, lambda);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合 <code>std:: function</code> 捕获局部变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda可以使用外部（相对）的变量，而[]就是表示打算如何传递变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">//要用捕获就必须要用C++新的函数指针！</span></span></span><br><span class="line"><span class="comment">//新的函数指针的签名有所不同！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> temp : values)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">func</span>(temp);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; valus = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//注意这里的捕获必须要和C++新带的函数指针关联起来！！！</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">//如果lambda需要外部的a向量</span></span><br><span class="line">    <span class="comment">//则在捕获中写入a就好了</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [a](<span class="type">int</span> val)&#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, lambda);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>默认情况下，对一个通过<strong>值捕获</strong>的变量，lambda 表达式中认为该变量是只读的，无法改变其值（引用捕获则可以改变）。<strong>如果我们希望能改变被值捕获的变量的值，就必须在函数体前加上关键字 mutable。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [a]() <span class="keyword">mutable</span>  &#123;++a;&#125;;</span><br><span class="line">	<span class="built_in">lambda</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h3><blockquote>
<p>[!NOTE] lambda返回类型<br>如果lambda的函数体只有一个return语句，则返回类型从返回的表达式的类型推断。</p>
<p>如果lambda的函数体有多个return语句，则要求所有return的表达式类型相同。</p>
<p>如果lambda的函数体没有return语句，则返回类型为void。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将序列中的负数都改为正数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-5</span>&#125;;</span><br><span class="line">		<span class="comment">//正确：无需指定返回类型，编译器推断返回int</span></span><br><span class="line">		<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(),</span><br><span class="line">			[](<span class="type">int</span> i) &#123;<span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> value : v)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; value &lt;&lt; endl; <span class="comment">//输出1 2 3 4 5</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用if改写，看起来等价</span></span><br><span class="line"><span class="comment">//正确：return的表达式类型都是int</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span> (),</span><br><span class="line">		  [](<span class="type">int</span> i) &#123;<span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾置返回类型，指定lambda返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span> (),</span><br><span class="line">		  [](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;<span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无return，返回类型为void</span></span><br><span class="line"><span class="comment">//错误，lambda返回了void，而vector元素是int类型，无法完成转换</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(),</span><br><span class="line">		[](<span class="type">int</span> i) &#123;<span class="keyword">if</span> (i &lt; <span class="number">0</span>)  i*=<span class="number">-1</span>; &#125;);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>当我们定义一个 lambda 表达式后，编译器会自动生成一个类，在该类中对 <code>()</code> 运算符进行重载，实际 lambda 函数体的实现就是这个函数对象（仿函数）的 <code>operator()</code>的实现。<br>在调用 lambda 表达式时，参数列表和捕获列表的参数，最终都传递给了仿函数的 <code>operator()</code>。</p>
<h2 id="8【C-11】-bind-参数绑定"><a href="#8【C-11】-bind-参数绑定" class="headerlink" title="8【C++11】 bind 参数绑定"></a>8【C++11】 bind 参数绑定</h2><p>#bind</p>
<p>如果 lambda 的捕获列表为空，通常可以用函数来代替它。但是，对于<strong>捕获局部变量的 lambda</strong>，用函数来替换它就不是那么容易了。</p>
<p>例如，我们用在 <code>find_if</code> 调用中的 lambda 比较一个 string 和一个给定大小。我们可以很容易地编写一个完成同样工作的函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span> <span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span> ()&gt;=sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们不能用这个函数作为 <code>find_if</code> 的一个参数。<code>find_if</code> 接受一个一元谓词，因此传递给 <code>find_if</code> 的可调用对象必须接受单一参数。假设传递给 find_if 的 lambda 使用捕获列表来保存 sz。<strong>为了用 check_size 来代替此 lambda，必须解决如何向 sz 形参传递一个参数的问题。</strong><br>我们可以解决向 check_size 传递一个长度参数的问题，方法是使用一个新的名为 bind 的标准库函数，它定义在头文件 functional 中。</p>
<h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h4><p>可以将 bind 函数看作一个通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用bind的一般形式：</span></span><br><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span> (callable, arg_list);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>newCallable</code> 本身是一个可调用对象</li>
<li><code>arg_list</code> 是一个逗号分隔的参数列表，对应给定的 <code>callable</code> 的参数。</li>
<li><strong>即当我们调用 <code>newCallable</code> 时，<code>newCallable</code> 会调用 <code>callable</code>, 并传递给它 <code>arg_list</code> 中的参数。</strong></li>
</ul>
<p><code>arg_list</code> 中的参数可能包含形如 <code>_n</code> 的名字，其中 n 是一个整数。这些参数是“<strong>占位符</strong>”, 表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的“位置”。</p>
<ul>
<li>数值 <code>n</code> 表示生成的可调用对象中参数的位置：<code>_1</code> 为 newCallable 的第一个参数，<code>_2</code> 为第二个参数，依此类推。</li>
<li><code>arg_list</code> 中使用占位符的位置需要我们传入参数，若使用给定值，则不用传参。</li>
<li><code>_n</code> 都定义在 <code>std::placeholders</code> 命名空间： <code>std::placeholders::_n</code></li>
</ul>
<h3 id="函数参数绑定"><a href="#函数参数绑定" class="headerlink" title="函数参数绑定"></a>函数参数绑定</h3><p>作为一个简单的例子，我们将使用 bind 生成一个调用 check_size 的对象，如下所示，它用一个定值作为其大小参数来调用 check_size: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check6是一个可调用对象，接受一个string类型的参数</span></span><br><span class="line"><span class="comment">// 并用此string和值6来调用check_size</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>此bind 调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list 的第一个位置，表示 check6的此参数对应 check_size 的第一个参数。此参数是一个const string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s); <span class="comment">// check6(s)会调用 check_size(s,6)</span></span><br></pre></td></tr></table></figure>

<p>使用 bind，我们可以将原来基于 lambda 的 <code>find_if</code> 调用: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc= <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span> (),[sz] (<span class="type">const</span> string &amp;a)</span><br></pre></td></tr></table></figure>
<p>替换为如下使用 <code>check_size</code> 的版本: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>( ),<span class="built_in">bind</span>(check_size,_1, sz));</span><br></pre></td></tr></table></figure>
<p>此 bind 调用生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值。当 <code>find_if</code> 对 words 中的 string 调用这个对象时，这些对象会调用 <code>check_size</code>，将给定的 string 和 sz 传递给它。因此，find_if 可以有效地对输入序列中每个 string 调用 check_size，实现 string 的大小与 sz 的比较。 </p>
<h4 id="与-function-类型联用"><a href="#与-function-类型联用" class="headerlink" title="与 function 类型联用"></a>与 function 类型联用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base)</span></span>; <span class="comment">// 按 base 进制来输出 n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//function 与 bind 结合使用​</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; print10 = <span class="built_in">bind</span>(print, _1, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">print10</span>(<span class="number">23</span>); <span class="comment">//相当于 print(23, 10)</span></span><br></pre></td></tr></table></figure>

<h3 id="修正参数的值"><a href="#修正参数的值" class="headerlink" title="修正参数的值"></a>修正参数的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> std::string &amp;s, std::string::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check6是一个可调用对象，接受一个string类型的参数</span></span><br><span class="line"><span class="comment">//并用此string和值6来调用check_size</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&amp;</span></span><br><span class="line"><span class="comment">//因此调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size</span></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s); <span class="comment">//check6(s)会调用check size(s,6)</span></span><br></pre></td></tr></table></figure>

<h3 id="重排参数顺序"><a href="#重排参数顺序" class="headerlink" title="重排参数顺序"></a>重排参数顺序</h3><p>例如，假定 f 是一个可调用对象，它有 5 个参数，则下面对 bind 的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//g是一个有两个参数的可调用对象</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f,a,b,_2,c,_1);</span><br></pre></td></tr></table></figure>

<p>生成一个新的可调用对象，它有两个参数，分别用占位符 <code>_2</code> 和 <code>_1</code> 表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给 f。f 的第一个、第二个和第四个参数分别被绑定到给定的值 a、b 和 c 上。<br>传递给 g 的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用 g 时，其第一个参数将被传递给 f 作为最后一个参数，第二个参数将被传递给 f 作为第三个参数。实际上，这个 bind 调用会将 <code>g(_1,_2)</code> 映射为 <code>f(a,b,_2,c,1)</code> 即，对 g 的调用会调用 f, 用 g 的参数代替占位符，再加上绑定的参数 a、b 和 c。例如，调用 <code>g(X,Y)</code> 会调用 <code>f(a,b,Y,c,X)</code></p>
<p>下面是用 bind 重排参数顺序的一个具体例子，我们可以用 bind 颠倒 isShroter<br>的含义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按单词长度由短至长排序</span></span><br><span class="line"><span class="built_in">sort</span> (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="comment">//按单词长度由长至短排序</span></span><br><span class="line"><span class="built_in">sort</span> (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter,<span class="number">2</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>在第一个调用中，当 sort 需要比较两个元素 A 和 B 时，它会调用 isShorter (A, B)。<br>在第二个对 sort 的调用中，传递给 isShorter 的参数被交换过来了。因此，当 sort 比较两个元素时，就好像调用 isShorter (B, A)一样。</p>
<h3 id="ref-函数：绑定引用参数"><a href="#ref-函数：绑定引用参数" class="headerlink" title="ref 函数：绑定引用参数"></a>ref 函数：绑定引用参数</h3><p>#ref<br>默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，<strong>有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。</strong><br>例如，为了替换一个引用方式捕获 ostream 的 lambda:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os是一个局部变量，引用一个输出流</span></span><br><span class="line"><span class="comment">//c是一个局部变量，类型为char</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;os,c](<span class="type">const</span> string &amp;s)&#123;os &lt;&lt; s &lt;&lt;c;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以很容易地编写一个函数，完成相同的工作：</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;s, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，不能直接用bind来代替对os的捕获：</span></span><br><span class="line"><span class="comment">//错误：不能拷贝os</span></span><br><span class="line">for_each (words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, os, _1,<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>原因在于 bind 拷贝其参数，而我们不能拷贝一个 ostream。如果我们希望传递给 bind 一个对象而又不拷贝它，就必须使用标准库 <code>ref</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each (words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print,<span class="built_in">ref</span>(os),<span class="number">1</span>,<span class="string">&#x27;&#x27;));</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>ref</code> 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 <code>cref</code> 函数，生成一个保存 const 引用的类。与 bind 一样，函数 ref 和 cref 也定义在头文件 functional 中。</p>
<h3 id="bind1st-和-bind2nd"><a href="#bind1st-和-bind2nd" class="headerlink" title="bind1st () 和 bind2nd ()"></a>bind1st () 和 bind2nd ()</h3><p><code>bind1st()</code> 和 <code>bind2nd()</code>，只能绑定第一个或第二个参数，局限性太强，在 C++11 里已经<strong>弃用</strong>了，建议使用新标准的 <code>bind()</code>，用法更灵活更方便。<br>下面先说明 <code>bind1st()</code> 和 <code>bind2nd()</code> 的用法</p>
<p><code>bind1st()</code> 和 <code>bind2nd()</code> 都是把二元函数转化为一元函数，方法是绑定其中一个参数。<br><code>bind1st()</code> 是绑定第一个参数。<br><code>bind2nd()</code> 是绑定第二个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[] = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> cx;</span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are not less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="number">4</span> elements that are less than <span class="number">40.</span></span><br><span class="line">There are <span class="number">1</span> elements that are <span class="keyword">not</span> less than <span class="number">40.</span></span><br></pre></td></tr></table></figure>

<p><code>less()</code> 是一个二元函数，<code>less(a, b)</code> 表示判断 <code>a&lt;b</code> 是否成立。<br>所以 <code>bind2nd(less&lt;int&gt;(), 40)</code> 相当于 <code>x&lt;40</code> 是否成立, 用于判定那些小于 40 的元素。<br><code>bind1st(less&lt;int&gt;(), 40)</code> 相当于 <code>40&lt;x</code> 是否成立, 用于判定那些大于 40 的元素。</p>
<p>上面的例子使用 <code>bind()</code> 可以写成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[] = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> cx;</span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">40</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cx = <span class="built_in">count_if</span>(numbers, numbers + <span class="number">6</span>, <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>, std::placeholders::_1));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cx &lt;&lt; <span class="string">&quot; elements that are not less than 40.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There are 4 elements that are less than 40.</span><br><span class="line">There are 1 elements that are not less than 40.</span><br></pre></td></tr></table></figure>

<h1 id="六、面向对象-OOP"><a href="#六、面向对象-OOP" class="headerlink" title="六、面向对象 OOP"></a>六、面向对象 OOP</h1><blockquote>
<p>[!NOTE] 面向对象程序设计（object-oriented programming）核心思想</p>
<ul>
<li>数据抽象：将类的接口与实现分离</li>
<li>继承：定义相似的类型并对相似关系建模</li>
<li>动态绑定(又称运行时绑定)：在运行时选择函数的版本，使用相同的代码处理不同类型的对象。<blockquote>
<p>[!NOTE]<br>当我们使用基类的引用或（指针）调用一个虚函数时，将发生动态绑定。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="0-类"><a href="#0-类" class="headerlink" title="0 类"></a>0 类</h2><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p><strong>定义在类内部的成员函数是默认<code>inline</code> 的</strong></p>
<h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><p>成员指针是指<strong>可以指向类的非静态成员</strong>的指针。<br>成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象：直到使用成员指针时，才提供成员所属的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类作为示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> _age, <span class="type">float</span> _height)</span><br><span class="line">    : <span class="built_in">age</span>(_age)</span><br><span class="line">    , <span class="built_in">height</span>(_height)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> height;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="type">float</span> height = <span class="number">185</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//age必须为public成员变量才可以访问</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Person::* p = &amp;Person::age;</span><br><span class="line">    <span class="comment">//auto p = &amp;Person::age; //用auto更方便</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用成员指针访问运算符.*，解引用指针p获取成员变量 (类似成员访问运算符.)</span></span><br><span class="line">    Person person1;</span><br><span class="line">    cout&lt;&lt; person1.*p &lt;&lt;endl;  <span class="comment">//输出18</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用成员指针访问运算符-&gt;* (类似成员访问运算符-&gt;)</span></span><br><span class="line">    Person* person2 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">15</span>,<span class="number">200</span>);</span><br><span class="line">    cout&lt;&lt; person2-&gt;*p &lt;&lt;endl; <span class="comment">//输出15</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h5><p>成员指针包含成员所属的类。再 <code>*</code> 之前添加<code>classname::</code>表示指针可以指向<code>classname</code>的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p可以指向一个常量（非常量）Person对象的age成员</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Person::* p = &amp;Person::age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用auto或decltype更方便</span></span><br><span class="line"><span class="keyword">auto</span> p = &amp;Person::age; </span><br></pre></td></tr></table></figure>

<p>与成员访问运算符<code>.</code>和<code>-&gt;</code>类似，也有两种成员指针访问运算符：<code>·*</code> 和<code>-&gt;*</code> ，这两个运算符使得我们可以解引用指针并获得该对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//使用成员指针访问运算符.*，解引用指针 p 获取成员变量 (类似成员访问运算符.)</span></span><br><span class="line">Person person1;</span><br><span class="line">cout&lt;&lt; person1.*p &lt;&lt;endl;  <span class="comment">//输出18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用成员指针访问运算符-&gt;* (类似成员访问运算符-&gt;)</span></span><br><span class="line">Person* person2 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">15</span>,<span class="number">200</span>);</span><br><span class="line">cout&lt;&lt; person2-&gt;*p &lt;&lt;endl; <span class="comment">//输出15</span></span><br></pre></td></tr></table></figure>


<h5 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h5><p>指向类的成员函数,语法和数据成员指针一样</p>
<p>举例：<br>由于访问控制规则，数据成员一般为私有的，我们通常无法直接访问 age，如果想访问，可以定义一个函数，令其返回值是指向该成员的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//GetAgePtr是一个静态成员，返回一个成员指针</span></span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Person::* <span class="built_in">GetAgePtr</span>() &#123; <span class="keyword">return</span> &amp;Person::age; &#125;</span><br><span class="line">		<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Person::* p = Person::<span class="built_in">GetAgePtr</span>();</span><br><span class="line">    </span><br><span class="line">Person person1;</span><br><span class="line">cout&lt;&lt; person1.*p &lt;&lt;endl;  <span class="comment">//输出18</span></span><br></pre></td></tr></table></figure>

<h5 id="成员指针函数表"><a href="#成员指针函数表" class="headerlink" title="成员指针函数表"></a>成员指针函数表</h5><p>具有相同参数和返回类型的函数成员可以存入一个[[#函数表]]中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个函数负责将光标向指定方向移动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//其他接口和实现成员与之前一致</span></span><br><span class="line">		<span class="function">Screen&amp; <span class="title">home</span> <span class="params">()</span>  <span class="comment">//光标移动函数</span></span></span><br><span class="line"><span class="function">		Screen&amp; <span class="title">forward</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">Screen&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">Screen&amp; <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">Screen&amp; <span class="title">down</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">			</span></span><br><span class="line"><span class="function">		<span class="comment">//Action是一个指针，可以用任意一个光标移动函数对其赋值</span></span></span><br><span class="line"><span class="function">		<span class="keyword">using</span> Action </span>= Screen&amp;(Screen::*)()</span><br><span class="line">		<span class="comment">//指定具体要移动的方向</span></span><br><span class="line">		<span class="keyword">enum</span> <span class="title class_">Directions</span> &#123; HOME,FORWARD,BACK,UP,DOWN )</span><br><span class="line">		<span class="comment">//定义一个move函数，使其可以调用上述任意光标函数</span></span><br><span class="line">		<span class="function">Screen&amp; <span class="title">move</span><span class="params">(Directions)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="type">static</span> Action Menu[];  <span class="comment">//函数表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen&amp; <span class="title">Screen::move</span> <span class="params">(Directions cm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//运行 this 对象中索引值为 cm 的元素</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">this</span>-&gt;*Menu[cm])();<span class="comment">//Menu[cm]指向一个成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表定义：</span></span><br><span class="line">Screen::Action Screen::Menu[] = </span><br><span class="line">&#123;</span><br><span class="line">		&amp;Screen:home,</span><br><span class="line">		&amp;Screen::forward,</span><br><span class="line">		&amp;Screen:back,</span><br><span class="line">		&amp;Screen:up,</span><br><span class="line">		&amp;Screen:down,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们调用move函数时，给它传入一个表示光标移动方向的枚举成员：</span></span><br><span class="line">Screen myScreen;</span><br><span class="line">myScreen.<span class="built_in">move</span>(Screen::HOME); <span class="comment">//调用myScreen.home</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(Screen::DOWN); <span class="comment">//调用myScreen.down</span></span><br></pre></td></tr></table></figure>
<h5 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h5><p>和普通的函数指针不同，成员指针不是一个可调用对象，不支持函数调用运算符()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fp = &amp;string::empty; <span class="comment">//fp指向string的empty函数</span></span><br><span class="line"><span class="comment">//错误，必须使用.*或-&gt;*调用成员指针</span></span><br><span class="line"><span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), fp); </span><br></pre></td></tr></table></figure>

<p><strong>从指向成员函数的指针获取可调用对象</strong><br><strong>方法一：</strong> 是使用标准模板库[[#【C++11】function类型]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt; pvec;</span><br><span class="line">function&lt;<span class="type">bool</span> (<span class="type">const</span> string*)&gt; fp = &amp;string::empty;</span><br><span class="line"><span class="comment">//fp接受一个指向string的指针，然后使用-&gt;*调用empty</span></span><br><span class="line"><span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), fp);</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 使用【C++11】<strong>mem_fn</strong>生成一个可调用对象<br>标准库功能men_fn让编译器负责推断成员的类型，可以从成员指针生成一个可调用对象。和function不同的是，men_fn可以根据成员指针的类型推断可调用对象的类型，而无须用户显式指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_if</span> (svec.<span class="built_in">begin</span>(),svec.<span class="built_in">end</span>(),<span class="built_in">mem_fn</span>(&amp;string:empty));</span><br><span class="line"></span><br><span class="line"><span class="comment">//mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用：</span></span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">mem_fn</span>(&amp;string::empty);  <span class="comment">//f接受一个string或者一个string*</span></span><br><span class="line"><span class="built_in">f</span> (*svec.<span class="built_in">begin</span> ()); <span class="comment">//正确：传入一个string对象，f使用.*调用empty</span></span><br><span class="line"><span class="built_in">f</span>(&amp;svec[<span class="number">0</span>]);  <span class="comment">//正确：传入一个string的指针，f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong> 使用 [[2 STL标准库#【C++11】参数绑定 bind 函数]] 从成员函数生成一个可调用对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择范围中的每个string,并将其bind到empty的第一个隐式实参上</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(),svec.<span class="built_in">end</span>(),<span class="built_in">bind</span>(&amp;string:empty,_1));</span><br></pre></td></tr></table></figure>

<p>和function类似的地方是，当我们使用bind时，必须将函数中用于表示执行对象的隐式形参转换成显式的。和mem_fn类似的地方是，bind生成的可调用对象的第一个实参既可以是string的指针，也可以是string的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="built_in">bind</span>(&amp;string:empty,_1);</span><br><span class="line"><span class="built_in">f</span>(*svec.<span class="built_in">begin</span>());  <span class="comment">//正确：实参是一个string,f使用.*调用empty</span></span><br><span class="line"><span class="built_in">f</span>(&amp;svec[<span class="number">0</span>]);  <span class="comment">//正确：实参是一个string的指针，f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>P746<br>嵌套类（嵌套类型）:<strong>定义在类的内部的类</strong></p>
<p><strong>常用于定义作为实现部分的类。</strong></p>
<p>嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。</p>
<h3 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h3><p><strong>定义在函数内部的类</strong><br>局部类定义的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。</p>
<blockquote>
<p>[!NOTE]<br>局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。</p>
</blockquote>
<p>在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。<br>类似的，<strong>在局部类中也不允许声明静态数据成员</strong>，因为我们没法定义这样的成员。</p>
<p><strong>局部类不能使用函数作用域中的变量：</strong><br>局部类只能访问外层作用域定义的类型名、静态变量、枚举成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, val;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> si;</span><br><span class="line">		<span class="keyword">enum</span> <span class="title class_">Loc</span> &#123; a = <span class="number">1024</span>,b &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Bar是foo的局部类</span></span><br><span class="line">		<span class="keyword">struct</span> Bar</span><br><span class="line">		&#123;</span><br><span class="line">			Loc locVal;  <span class="comment">//正确：使用一个局部类型名</span></span><br><span class="line">			<span class="type">int</span> barVal;</span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(Loc::a)</span>  <span class="comment">//正确：默认实参是Loc::a</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				barVal val;  <span class="comment">//错误：val是foo的局部变量</span></span><br><span class="line">				barVal = val;  <span class="comment">//正确：使用一个全局对象</span></span><br><span class="line">				barVal si;  <span class="comment">//正确：使用一个静态局部对象</span></span><br><span class="line">				locVal b;  <span class="comment">//正确：使用一个枚举成员</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的局部类"><a href="#嵌套的局部类" class="headerlink" title="嵌套的局部类"></a>嵌套的局部类</h4><p>可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Nested</span>;<span class="comment">//声明Nested类</span></span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义Nested类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Bar</span>::Nested</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="union联合类"><a href="#union联合类" class="headerlink" title="union联合类"></a>union联合类</h3><p><strong>联合(union)是一种特殊的类。</strong><br><strong>一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。</strong> 当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。</p>
<p>union不能含有引用类型的成员。</p>
<p>在C++11新标准中，含有构造函数或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、protected和private等保护标记。<strong>默认情况下，union的成员都是公有的</strong>，这一点与struct相同。<br>union可以定义包括构造函数和析构函数在内的成员函数。但是**由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下成员是公有的</span></span><br><span class="line">    <span class="type">char</span> cval;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式初始化</span></span><br><span class="line">Token first_token = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;  <span class="comment">//初始化cva1成员</span></span><br><span class="line">Token last_token;  <span class="comment">//未初始化的Token对象</span></span><br><span class="line">Token *pt = <span class="keyword">new</span> Token;  <span class="comment">//指向一个未初始化的Token对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通用的成员访问运算符访问一个union对象的成员：</span></span><br><span class="line">last_token.cval =<span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h4 id="匿名union"><a href="#匿名union" class="headerlink" title="匿名union"></a>匿名union</h4><blockquote>
<p>[!NOTE] Title<br>匿名union不能包含protected成员或private成员，也不能定义成员函数。</p>
</blockquote>
<p>匿名union是一个<strong>未命名的union，并且在右花括号和分号之间没有任何声明</strong>。一旦我们定义了一个匿名union,<strong>编译器就自动地为该union创建一个未命名的对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名union: 自动创建一个未命名的对象，我们可以直接访问它的成员</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">char</span> cval;</span><br><span class="line">		<span class="type">int</span> ival;</span><br><span class="line">		<span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。</span></span><br><span class="line">cval =<span class="string">&#x27;c&#x27;</span>;  <span class="comment">//为刚刚定义的未命名的匿名union对象赋一个新值</span></span><br><span class="line">iva1=<span class="number">42</span>:  <span class="comment">//该对象当前保存的值是42</span></span><br></pre></td></tr></table></figure>

<h4 id="使用类管理union成员"><a href="#使用类管理union成员" class="headerlink" title="使用类管理union成员"></a>使用类管理union成员</h4><p>对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与union的类类型成员有关的状态转换。<br>举个例子，我们为union添加一个string成员，并将我们的union定义成匿名union,最后将它作为Token类的一个成员。此时，Token类将可以管理union的成员。<br>为了<strong>追踪union中到底存储了什么类型的值</strong>，我们通常会定义一个独立的对象，该对象称为union的**判别式(discriminant)**。我们可以使用判别式辨认union存储的值。<br>为了保持union与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义个枚举类型的成员来追踪其union成员的状态。<br>在我们的类中定义的函数包括默认构造函数、拷贝控制成员以及一组赋值运算符，这些赋值运算符可以将union的某种类型的值赋给union成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//因为union含有一个string成员，所以Token必须定义拷贝控制成员</span></span><br><span class="line">		<span class="comment">//定义移动构造函数和移动赋值运算符的任务留待本节练习完成</span></span><br><span class="line">		<span class="built_in">Token</span> ()<span class="built_in">tok</span>(INT),<span class="built_in">ival</span>(<span class="number">0</span>&#125;</span><br><span class="line">		<span class="built_in">Token</span> (<span class="type">const</span> Token &amp;t):<span class="built_in">tok</span>(t.tok)&#123;<span class="built_in">copyUnion</span>(t);&#125;</span><br><span class="line">		Token &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Token&amp;);</span><br><span class="line">		<span class="comment">//如果union含有一个string成员，则我们必须销毁它，参见19.1.2节（第729页)</span></span><br><span class="line">		~<span class="built_in">Token</span>()&#123;<span class="keyword">if</span> (tok =STR)sval.~<span class="built_in">string</span>();</span><br><span class="line">		<span class="comment">//下面的赋值运算符负责设置union的不同成员</span></span><br><span class="line">		Token &amp;<span class="keyword">operator</span>=(<span class="type">const</span> std:string&amp;);</span><br><span class="line">		Token &amp;<span class="keyword">operator</span>=(<span class="type">char</span>);</span><br><span class="line">		Token &amp;<span class="keyword">operator</span>=(<span class="type">int</span>);</span><br><span class="line">		Token &amp;<span class="keyword">operator</span>=(<span class="type">double</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">enum</span> </span><br><span class="line">		&#123;</span><br><span class="line">			INT,CHAR,DBL,STR</span><br><span class="line">		&#125; tok;  <span class="comment">//tok为判别式，当union存储int值时，tok的值为INT，以此类推。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">union</span>  <span class="comment">//匿名union</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> cval;</span><br><span class="line">			<span class="type">int</span> ival;</span><br><span class="line">			<span class="type">double</span> dval;</span><br><span class="line">			std::string sval;</span><br><span class="line">		&#125;;  <span class="comment">//每个Token对象含有一个该未命名union类型的未命名成员</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查判别式，然后酌情拷贝union成员</span></span><br><span class="line">		<span class="type">void</span> <span class="built_in">copyUnion</span>(<span class="type">const</span> Token&amp;);</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure>

<p>更多细节P751</p>
<h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1 封装"></a>1 封装</h2><ul>
<li>封装是将属性和方法组合在一个类（Class）中的过程。</li>
<li>封装的主要目的是隐藏类的内部实现细节，仅暴露必要的接口给外部。</li>
<li>通过封装，我们可以控制类成员的访问级别（例如：public、protected 和 private），限制对类内部数据的直接访问，确保数据的完整性和安全性。</li>
</ul>
<h3 id="成员访问控制"><a href="#成员访问控制" class="headerlink" title="成员访问控制"></a>成员访问控制</h3><p>三种访问说明符，控制外部访问成员的权限</p>
<table>
<thead>
<tr>
<th>说明符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>类成员只能由类的成员函数和友元（类或函数）使用。</td>
</tr>
<tr>
<td>protected</td>
<td>类成员可由类的成员函数和友元（类或函数）、派生类使用。</td>
</tr>
<tr>
<td>public</td>
<td>类成员可由任意函数使用。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>[!NOTE] 建议：基类的成员访问控制：<br>public：基类的接口成员<br>protected：供派生类访问的成员函数<br>private：供基类及基类的友元访问的成员函数</p>
</blockquote>
<h3 id="class与struct"><a href="#class与struct" class="headerlink" title="class与struct"></a>class与struct</h3><p>引入 struct 是为了让 C++ 向后兼容 C</p>
<ul>
<li>在 C 语言中，struct 只能包含成员变量，不能包含成员函数。</li>
<li>而在 C++ 中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。</li>
</ul>
<p><strong>class与struct的区别</strong></p>
<ul>
<li>class 的类成员默认 private，struct 默认 public。  </li>
<li>class 继承继承默认是 private 继承，struct 默认 public 继承</li>
<li>class 可以用于定义模板参数，比如<code>template&lt;class T&gt;</code>，struct 不能</li>
</ul>
<p>推荐选用：<br>若只包含一些变量结构或 POD(plain old data) 时，选用 struct。例如数学中的向量类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span></span><br><span class="line">&#123;</span><br><span class="line">		 <span class="type">float</span> x, y;</span><br><span class="line">		 <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span></span><br><span class="line"><span class="function">		 </span>&#123;</span><br><span class="line">		     x += other.x;</span><br><span class="line">		     y += other.y;</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若要实现很多功能的类（非 POD），则选用 class</p>
<blockquote>
<p>[!NOTE] POD<br>“POD” 表示 “Plain Old Data”，翻译为中文是”普通老数据”。这是一个在C++中用来描述一些简单、平凡的数据结构的术语。POD类型在C++标准中有严格的定义，包括以下几个条件：</p>
<ol>
<li><strong>只包含数据成员</strong>：POD类型不能包含任何用户自定义的构造函数、析构函数、拷贝构造函数、拷贝赋值运算符或者虚函数。</li>
<li><strong>成员是标量类型</strong>：即成员不能是类类型或者其他的复杂类型，而只能是整数、浮点数、指针等简单的数据类型。</li>
<li><strong>是平凡的标准布局类型</strong>：这意味着 POD 类型的布局要符合一定的规范，可以通过 C++标准库的 <code>std::is_pod</code> 或 <code>std::is_trivial</code> 这样的类型特性来检查。</li>
</ol>
<p>POD类型通常可以通过C的<code>memcpy</code>等底层操作进行内存拷贝，因为其数据布局是简单的、平凡的。这种特性使得POD类型在一些场景中很有用，比如在底层通信、数据序列化和内存映射等方面。然而，随着C++标准的发展，一些更加灵活和安全的替代方法，比如<code>std::memcpy</code>和<code>std::byte</code>等，逐渐成为更好的选择。</p>
</blockquote>
<h3 id="友元friend"><a href="#友元friend" class="headerlink" title="友元friend"></a>友元friend</h3><p>类允许其他类或者函数访问它的<strong>非public成员</strong>，方法是令其他类或者函数称为它的友元。</p>
<p>成员函数和友元函数区别：</p>
<ul>
<li>成员函数有this指针，友元函数没有</li>
<li>友元不具备传递性，a的友元是b，b的友元是c，但是c不能访问a的非public成员。</li>
<li>友元不能继承</li>
</ul>
<h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制到public上面，加上 friend</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Building b;</span><br><span class="line">		<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">goodGay</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			building = <span class="keyword">new</span> <span class="built_in">Building</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Building</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		goodGay gg;</span><br><span class="line">		gg.<span class="built_in">visit</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> <span class="built_in">Building</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		goodGay  gg;</span><br><span class="line">		gg.<span class="built_in">visit</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h2><ul>
<li>继承是派生类从基类那里获得其属性和方法的过程。</li>
<li>继承允许我们创建具有共享代码的类层次结构，减少重复代码，提高代码复用性和可维护性。</li>
<li>访问修饰符（如 public、protected、private）控制了派生类对基类成员的访问权限。</li>
</ul>
<hr>
<ul>
<li>派生类拥有基类的全部成员函数和成员变量，不论是 private、protected、public。<strong>需要注意的是：在派生类的各个成员函数中，不能访问基类的 private 成员。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名：<span class="keyword">public</span> 基类名</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例子如下，分析：</p>
<ul>
<li>这个 Player 类不再仅仅只是 Player 类型，它也是 Entity 类型，就是说它<strong>同时是这两种类型</strong>。意思是我们可以在<strong>任何想要用 Entity 的地方使用 Player</strong></li>
<li>Player 总是 Entity 的一个超集，它拥有 Entity 的所有内容。</li>
<li>因为对于 Player 来说，在 Entity 中任何<strong>不是私有</strong>的（private）成员，Player 都可以<strong>访问</strong>到</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类，一个类被用作基类，那么它必须已定义而非仅仅声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">     x += xa;</span><br><span class="line">     y += ya;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line"><span class="comment">//  float x,y;    //因为是派生类，所以这些是重复代码，只保留新代码即可</span></span><br><span class="line"><span class="comment">//  void() move(float xa, float ya)</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      x += xa;</span></span><br><span class="line"><span class="comment">//     y += ya;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">		 <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span>   <span class="comment">//在派生类中，可以扩充新的成员变量和成员函数 </span></span></span><br><span class="line"><span class="function">		 </span>&#123;</span><br><span class="line">		     std::cout &lt;&lt; Name &lt;&lt; std::endl;</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是声明派生类，则不需要添加派生列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式主要作用是影响子类的成员访问控制</p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承（public）</li>
<li>保护继承（protected）</li>
<li>私有继承（private）<br>在 C++中，默认的继承方式是 <code>private</code>。当你声明一个类而没有指定继承方式时，C++默认使用 <code>private</code> 继承。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019183.png" alt="Pasted image 20230222223037"></p>
<ol>
<li>父类私有的变量子类皆不可访问</li>
<li>公有继承，子类中对应的public protected变量不变</li>
<li>保护继承，子类中对应的public protected变量都为protected</li>
<li>私有继承，子类对应的变量全为私有</li>
</ol>
<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p><strong>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。</strong></p>
<p>假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(<span class="type">const</span> Derived &amp;derived obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::<span class="built_in">statmem</span>();  <span class="comment">//正确：Base定义了statmem</span></span><br><span class="line">    Derived::<span class="built_in">statmem</span>();  <span class="comment">//正确：Derived继承了statmem </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正确: 派生类的对象能访问基类的静态成员</span></span><br><span class="line">    derived_obj.<span class="built_in">statmem</span>();  <span class="comment">//通过Derived对象访问</span></span><br><span class="line">    <span class="built_in">statmem</span>();  <span class="comment">//通过this对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【C-11】防止继承-final"><a href="#【C-11】防止继承-final" class="headerlink" title="【C++11】防止继承 final"></a>【C++11】防止继承 final</h3><p>#final<br>对于一个类，我们不想其他类继承它，或者不想考虑他是否适合作为一个基类，可以在类名后跟一个关键字<code>final</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span>&#123;<span class="comment">/* */</span>&#125;  <span class="comment">//NoDerived不能作为基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base &#123;<span class="comment">/*/&#125; //Last是final的；我们不能继承Last</span></span><br></pre></td></tr></table></figure>

<h3 id="using改变访问权限"><a href="#using改变访问权限" class="headerlink" title="using改变访问权限"></a>using改变访问权限</h3><p><strong>使用 <code>using</code> 关键字可以改变基类成员在派生类中的访问权限</strong>，例如将 public 改为 private、将 protected 改为 public。</p>
<p>注意：using 只能改变基类中 public 和 protected 成员的访问权限，<strong>不能改变 private 成员的访问权限</strong>。因为基类中 private 成员在派生类中是不可见的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">		std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base  <span class="comment">//注意：private继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">using</span> Base::size;    <span class="comment">//将public改为protected</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">using</span> Base::n;  <span class="comment">//将protected改为private</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p>派生类的作用域嵌套在基类的作用域之内。</p>
<h4 id="名字冲突"><a href="#名字冲突" class="headerlink" title="名字冲突"></a>名字冲突</h4><blockquote>
<p>[!NOTE] </p>
<ul>
<li>派生类的成员将隐藏同名的基类成员，即使派生类成员和基类成员的参数列表不一致，基类成员仍会被隐藏掉。</li>
<li>除了重写虚函数，派生类最好不要重用其他定义在基类中的名字。</li>
</ul>
</blockquote>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Base</span>() : <span class="built_in">mem</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">		<span class="type">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Derived</span>(<span class="type">int</span> i) : <span class="built_in">mem</span>(i) &#123; &#125;  <span class="comment">//用i初始化Derived::mem</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//隐藏基类的memfcn()							</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125;  <span class="comment">//返回Derived::mem</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">		<span class="type">int</span> mem;  <span class="comment">//隐藏基类中的mem</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>get_mem中mem引用的解析结果是定义在Derived中的名字，下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; d.<span class="built_in">get_mem</span>() &lt;&lt; endl;  <span class="comment">//打印42</span></span><br></pre></td></tr></table></figure>
<p>的输出结果将是42。</p>
<h4 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base</span><br><span class="line">&#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125; <span class="comment">//输出0</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用的解析过程"><a href="#函数调用的解析过程" class="headerlink" title="函数调用的解析过程"></a>函数调用的解析过程</h3><blockquote>
<p>[!Tip] 函数调用的解析过程<br>理解函数调用的解析过程对于理解C++的继承至关重要。<br>假定我们调用p-&gt;mem()(或者obj.mem()),则依次执行以下4个步骤：</p>
<ol>
<li>首先确定p(或obj)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。</li>
<li>在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。</li>
<li>一旦找到了mem,就进行常规的类型检查（参见6.1节，第183页）以确认对于当前找到的mem,本次调用是否合法。</li>
<li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：</li>
</ol>
<ul>
<li>如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。</li>
</ul>
</blockquote>
<h3 id="派生类的拷贝控制"><a href="#派生类的拷贝控制" class="headerlink" title="派生类的拷贝控制"></a>派生类的拷贝控制</h3><blockquote>
<p>[!warning]<br>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>
</blockquote>
<ul>
<li>派生类构造函数在初始化阶段不但要初始化派生类自己的成员，还负责初始化<strong>派生类对象的基类部分</strong>。</li>
<li>派生类的的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。</li>
<li>派生类赋值运算符也必须为基类部分的成员赋值</li>
<li>析构函数只负责销毁派生类自己分配的资源，派生类对象的基类部分是自动销毁的。</li>
</ul>
<h4 id="派生类的拷贝或移动构造函数"><a href="#派生类的拷贝或移动构造函数" class="headerlink" title="派生类的拷贝或移动构造函数"></a>派生类的拷贝或移动构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">    <span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D&amp; d) : <span class="built_in">Base</span>(d) &#123;<span class="comment">/*...*/</span>&#125;  <span class="comment">//拷贝基类成员</span></span><br><span class="line">                    </span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(d)) &#123;<span class="comment">/*...*/</span>&#125;  <span class="comment">//移动基类成员</span></span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</p>
</blockquote>
<h4 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h4><p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Base::operator=(const Base&amp;)  不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="type">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);<span class="comment">//为基类部分赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">    <span class="comment">//酌情处理自赋值及释放已有资源等情况</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h4><p>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。<br>因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> Base</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Base::~Base被自动调用执行</span></span><br><span class="line">    ~<span class="built_in">D</span>() &#123;<span class="comment">/*该处由用户定义清除派生类成员的操作*/</span>&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p><strong>对象销毁的顺序正好与其创建的顺序相反：</strong> 派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>【C++11】派生类能够重用其直接基类定义的构造函数。</p>
<p>派生类只继承其直接基类的构造函数，不能继承默认、拷贝、移动构造函数，如果派生类没有定义这些构造函数，编译器将自动合成。</p>
<p><strong>派生类继承基类构造函数的方式</strong>是提供一条注明了（直接)基类名的using声明语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk</span> quote : <span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;  <span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。</p>
<h3 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h3><p>当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。<br>由此，我们想在容器中存放具有继承关系的对象时，不应该在容器中直接存储对象，而应该存储（智能）指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quote是基类，Bulk_quote是派生类，派生类指针可以转换为基类指针</span></span><br><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.<span class="built_in">push_back</span> (<span class="built_in">make_shared</span>&lt;Quote&gt;(<span class="string">&quot;0-201-82470-1&quot;</span>,<span class="number">50</span>));</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Bulk_quote&gt;(<span class="string">&quot;0-201-54848-8&quot;</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">.25</span>)）: </span><br><span class="line"><span class="comment">//make_shared&lt;Bulk_quote&gt;返回一个shared_ptr&lt;Bulk_quote&gt;对象，当我们调用push_back时，转换成shared_ptr&lt;Quote&gt;</span></span><br><span class="line">				 </span><br><span class="line"><span class="comment">//调用Quote定义的版本；打印562.5，即在15*&amp;50中扣除掉折扣金额</span></span><br><span class="line">cout &lt;&lt; basket.<span class="built_in">back</span>()-&gt;<span class="built_in">net_price</span>(<span class="number">15</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>继承多个基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//派生类的派生类列表中可以包含多个基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endagered &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019184.png" alt="Pasted image 20230228233714|350"></p>
<p>派生类构造函数初始化所有基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式地初始化所有基类</span></span><br><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">		: <span class="built_in">Bear</span> (name,onExhibit,<span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">		  <span class="built_in">Endangered</span>(Endangered::critical) &#123; &#125;</span><br><span class="line">		  </span><br><span class="line"><span class="comment">//隐式地使用Bear的默认构造函数初始化Bear子对象</span></span><br><span class="line">Panda::<span class="built_in">Panda</span>() : <span class="built_in">Endangered</span> (Endangered::critical)&#123;</span><br></pre></td></tr></table></figure>
<p>初始化顺序：</p>
<ol>
<li>ZooAnima是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。</li>
<li>接下来初始化Panda的第一个直接基类Bear。</li>
<li>然后初始化Panda的第二个直接基类Endangered。</li>
<li>最后初始化Panda。</li>
</ol>
<p>【C++11】在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">Base1</span>()=<span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Base1</span>(<span class="type">const</span> std::string&amp;);</span><br><span class="line">		<span class="built_in">Base1</span>(std:shared ptr&lt;<span class="type">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">Base2</span>()=<span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Base2</span>(<span class="type">const</span> std::string&amp;);</span><br><span class="line">		<span class="built_in">Base2</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">using</span> Base1::Base1;  <span class="comment">//从Base1继承构造函数</span></span><br><span class="line">		<span class="keyword">using</span> Base2::Base2;  <span class="comment">//从Base2继承构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确：如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">using</span> Base1::Basel;  <span class="comment">//从Base1继承构造函数</span></span><br><span class="line">		<span class="keyword">using</span> Base2::Base2;  <span class="comment">//从Base2继承构造函数</span></span><br><span class="line">		<span class="comment">//D2必须自定义一个接受string的构造函数</span></span><br><span class="line">		<span class="built_in">D2</span>(<span class="type">const</span> string &amp;s) : <span class="built_in">Base1</span>(s),<span class="built_in">Base2</span>(s)  &#123;&#125;</span><br><span class="line">		<span class="built_in">D2</span>() = <span class="keyword">default</span>;  <span class="comment">//一旦D2定义了它自己的构造函数，则必须出现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>派生类可以通过多个直接基类多次继承同一个间接基类。比如 ZooAnimal 的子类有 Bear、Raccoon，Panda 继承于 Bear、Raccoon，这时 Panda 继承了两次 ZooAnimal。<br>有时候我们不想让 ZooAnimal 被重复继承，通过虚继承来实现。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019185.png" alt="Pasted image 20230302232604"><br><strong>虚继承的目的是令某个类做出声明，承诺愿意共享它的基类</strong>。其中，共享的基类子对象称为<strong>虚基类(virtual base class)<strong>。在这种机制下，</strong>不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</strong></p>
<blockquote>
<p>[!NOTE]<br>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定虚基类的方式是在派生列表中添加virtual关键字</span></span><br><span class="line"><span class="comment">//关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;<span class="comment">/*...*/</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal &#123;<span class="comment">/*...*/</span>&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear,<span class="keyword">public</span> Raccoon,<span class="keyword">public</span> Endangered</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>虚继承的对象的构造方式</strong><br><strong>含有虚基类的对象的构造顺序与一般的顺序稍有区别</strong>：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。<br>例如，当我们创建一个Panda对象时：</p>
<ul>
<li>首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</li>
<li>接下来构造Bear部分。</li>
<li>然后构造Raccoon部分。</li>
<li>然后构造第三个直接基类Endangered。</li>
<li>最后构造Panda部分。<br>如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnima1没有默认构造函数，则代码将发生错误。</li>
</ul>
<p>析构函数的次序与构造顺序相反</p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3 多态"></a>3 多态</h2><p>多态通俗来说就是<strong>多种形态</strong><br>- 即同一个接口可以有不同的实现。<br>- 通过多态，我们可以编写更加通用、可扩展的代码，提高代码的灵活性。</p>
<h3 id="静态多态与动态多态"><a href="#静态多态与动态多态" class="headerlink" title="静态多态与动态多态"></a>静态多态与动态多态</h3><p>多态分为两类：</p>
<ul>
<li><p><strong>静态多态</strong>: 编译阶段确定函数地址，<strong>函数重载</strong> 、 <strong>运算符重载</strong>和<strong>函数模板</strong>属于静态多态</p>
</li>
<li><p><strong>动态多态（动态绑定）</strong>: 运行时确定函数地址，<strong>虚函数、纯虚函数</strong>实现运行时多态</p>
</li>
<li><p><strong>基类的指针或引用可以绑定到派生类的对象，反之不可以。</strong></p>
</li>
<li><p>对象切割问题：当我们用一个派生类对象初始化或赋值一个基类对象时（注意不是指针），只有该派生类对象中继承的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
</li>
</ul>
<h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p><strong>静态类型</strong>：编译时的类型，运行前就确定了，是<strong>变量声明时的类型</strong>或<strong>表达式生成的类型</strong><br><strong>动态类型</strong>：运行时才确定的类型，是<strong>变量或表达式表示的内存中的对象的类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Actor* p = new Pawn();  <span class="comment">// Actor 是基类，Pawn是子类</span></span><br></pre></td></tr></table></figure>
<p>指针 p 的静态类型是 Actor，在编译时已经确定了，但它的动态类型是 Pawn，运行时才知道。</p>
<p>举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Actor MyActor;</span><br><span class="line">Pawn* MyPawn = &amp;MyActor;  <span class="comment">//MyPawn静态类型为Pawn，动态类型为Actor</span></span><br><span class="line">Pawn&amp; MyPawn = MyActor;   <span class="comment">//MyPawn静态类型为Pawn，动态类型为Actor</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>基类的指针或引用的静态类型可能与动态类型不一致</p>
</blockquote>
<h3 id="虚函数virtual"><a href="#虚函数virtual" class="headerlink" title="虚函数virtual"></a>虚函数virtual</h3><ul>
<li>虚函数可以让我们在子类中<strong>重写（又称覆盖，override)</strong> 父类的函数，要求形参严格匹配。</li>
<li>任何构造函数之外的非静态函数都可以是虚函数</li>
<li>关键字virtual只能出现在类内部的声明语句之前，而不能用于类外部的函数定义。</li>
<li>如果基类把一个函数声明成虚函数，则该函数在派生类中为隐式的虚函数，即在所有派生类中都是虚函数</li>
<li><strong>多态基类</strong>必须将析构函数<strong>声明</strong>为 <code>virtual</code>，即虚析构函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">claee 父类名&#123;</span><br><span class="line">   <span class="comment">//virtual + 函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">       .....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125; <span class="comment">//注意这里没有用virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">		 std::string m_Name; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">		 <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span> (name) &#123;&#125;  <span class="comment">//构造函数</span></span><br><span class="line">		 <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity* entity)</span></span>&#123;</span><br><span class="line"> std::cout &lt;&lt; entity -&gt; <span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"> <span class="built_in">printName</span>(e); <span class="comment">//我们这儿做的就是调用entity的GetName函数，我们希望这个GetName作用于Entity</span></span><br><span class="line"> Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;cherno&quot;</span>); </span><br><span class="line"> <span class="built_in">printName</span>(p); <span class="comment">//printName(Entity* entity)，没有报错是因为Player也是 Entity类型。同样我们希望这个GetName作用于Player</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Entity</span><br><span class="line">Entity <span class="comment">//不是我们想要的输出cherno，为什么会这样？</span></span><br></pre></td></tr></table></figure>

<p>两次输出都是 Entity，<strong>原因在于如果我们在类中正常声明函数或方法，当调用这个方法的时候，它总是会去调用属于这个类型的方法</strong>，而<code>void printName(Entity* entity);</code>参数类型是<code>Entity*</code>, 意味着它会调用 Entity 内部的 GetName 函数，<strong>它只会在 Entity 的内部寻找和调用 GetName</strong>.</p>
<p>但是我们希望 C++ 能意识到, 在这里我们传入的其实是一个 Player，所以请调用 Player 的 GetName。<strong>此时就需要使用虚函数了。</strong></p>
<p>虚函数的例子，通常有三步。</p>
<ul>
<li>第一步，定义基类，声明基类函数为 <code>virtual</code> 的。  </li>
<li>第二步，定义派生类 (继承基类)，派生类实现了定义在基类的 <code>virtual</code> 函数。  </li>
<li>第三步，声明基类指针，并指向派生类，调用<code>virtual</code>函数，此时虽然是基类指针，但调用的是派生类实现的基类<code>virtual</code> 函数。</li>
</ul>
<ul>
<li>虚函数引入了一种要<strong>动态分配</strong>的东西，一般通过<strong>虚表（vtable）</strong> 来实现编译。虚表就是一个包含类中所有虚函数映射的列表，通过虚表我们就可以在运行时找到正确的被重写的函数。</li>
<li>简单来说，你需要知道的就是<strong>如果你想重写一个函数，你么你必须要把基类中的原函数设置为虚函数</strong></li>
</ul>
<h4 id="虚函数表原理"><a href="#虚函数表原理" class="headerlink" title="虚函数表原理"></a>虚函数表原理</h4><p>[[01 C++八股#⭐虚函数表和动态绑定原理]]</p>
<h3 id="【C-11】overide说明符"><a href="#【C-11】overide说明符" class="headerlink" title="【C++11】overide说明符"></a>【C++11】overide说明符</h3><p>新标准允许给被重写的函数用 <strong>“override”</strong> 关键字标记,增强代码可读性。<br><strong>如果子类中的函数声明与父类中的函数声明不匹配，就会报错。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125; <span class="comment">//第一步，定义基类，声明基类函数为 virtual的。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string m_Name; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span> (name) &#123;&#125; </span><br><span class="line">    <span class="comment">//第二步，定义派生类(继承基类)，派生类实现了定义在基类的 virtual 函数。</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125;  <span class="comment">//C++11新标准允许给被重写的函数用&quot;override&quot;关键字标记,增强代码可读性。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity* entity)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity -&gt; <span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">printName</span>(e); </span><br><span class="line">    <span class="comment">//第三步，声明基类指针，并指向派生类，调用`virtual`函数，此时虽然是基类指针，但调用的是派生类实现的基类virtual函数。Entity* p = new Player(&quot;cherno&quot;);也可以</span></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;cherno&quot;</span>); </span><br><span class="line">    <span class="built_in">printName</span>(p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Entity</span><br><span class="line">cherno</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数（接口类）"><a href="#纯虚函数（接口类）" class="headerlink" title="纯虚函数（接口类）"></a>纯虚函数（接口类）</h3><p>#interface #纯虚函数 #接口</p>
<ul>
<li>防止派生类忘记实现虚函数，<strong>纯虚函数使得派生类必须实现基类的虚函数</strong>。  </li>
<li>含有纯虚函数的类称为<strong>抽象基类</strong>，抽象基类负责定义接口，子类可以重写该接口。</li>
<li>不能创建抽象基类的对象，但可以创建子类的对象，前提是子类重写了父类的纯虚函数。</li>
</ul>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li><strong>类中只要有一个纯虚函数</strong>就称为抽象类</li>
<li><strong>子类必须重写抽象类中的纯虚函数</strong>，否则也属于抽象类</li>
</ul>
<ul>
<li><strong>声明方法</strong>: 在基类中纯虚函数的方法的后面加 <strong>&#x3D;0</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的, 这通常被称为接口。<strong>接口就是一个只包含未实现的方法并作为一个模板的类</strong>。并且由于此<strong>接口类</strong>实际上不包含方法实现，所以我们<strong>无法实例化</strong>这个类。</li>
<li>C++ 中的纯虚函数本质上与其他语言（如 C#）中的接口相同。实际上，其他语言有 interface 关键字而不是叫 class，但 C++ 没有。接口只是 C++ 的类而已。</li>
<li>纯虚函数与虚函数的区别在于，纯虚函数的基类中的<code>virtual</code>函数，只定义了，但不实现。实现交给派生类来做。</li>
<li><strong>只能实例化一个实现了所有纯虚函数的类</strong>。<strong>纯虚函数必须被实现</strong>，然后我们才能创建这个类的实例。</li>
<li>纯虚函数允许我们在基类中定义一个没有实现的函数，然后<strong>强制子类</strong>去实现该函数。</li>
</ul>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//声明为纯虚函数。请记住，这仍然被定义为虚函数，但是=0实际上将它变成了一个纯虚函数，这意味着如果你想实例化这个类，那么这个函数必须在子类中实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	 std::string m_Name; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	 <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span> (name) &#123;&#125; </span><br><span class="line">	 <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125; <span class="comment">//实现纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> std::cout &lt;&lt; entity -&gt; <span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Entity* e = new Entity();  //会报错，在这里我们必须给它一个实际上实现了这个函数的子类</span></span><br><span class="line"> Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">//ok</span></span><br><span class="line"> <span class="built_in">printName</span>(e); </span><br><span class="line"></span><br><span class="line"> Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;cherno&quot;</span>); </span><br><span class="line"> <span class="built_in">printName</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一个更好的例子<br>假设我们想编写一个打印这儿所有类名的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">//接口。其实就是个类。之所以称它为接口，只是因为它有一个纯虚函数，仅此而已。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125;</span><br><span class="line"> <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125; <span class="comment">//实现接口的纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity <span class="comment">//因为Player已经是Entity（已有接口），所以Player不用去实现Printable接口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> std::string m_Name; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span> (name) &#123;&#125; </span><br><span class="line"> <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125; </span><br><span class="line"> <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>;&#125; <span class="comment">//实现接口的纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Print</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//我们需要某种类型能提供GetClassName函数，这就是接口。所有的打印都来自于这个Print函数，它接受printable对象，它不关心实际是什么类</span></span><br><span class="line">    std::cout &lt;&lt;obj -&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"> Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;cherno&quot;</span>); </span><br><span class="line"> <span class="built_in">Print</span>(e);</span><br><span class="line"> <span class="built_in">Print</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Entity</span><br><span class="line">Player</span><br></pre></td></tr></table></figure>

<p>上例中，如果 Player 不是 Entity 的话，就要添加接口，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> OtherClass,Printable  <span class="comment">//加逗号，添加接口Printable</span></span><br><span class="line">&#123;</span><br><span class="line"> ....</span><br><span class="line"> <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构与纯虚析构"><a href="#虚析构与纯虚析构" class="headerlink" title="虚析构与纯虚析构"></a>虚析构与纯虚析构</h3><p>继承时，要养成的一个好习惯就是，<strong>基类析构函数中，一定加上 virtual。</strong></p>
<p>当我们delete一个动态分配的对象的指针时执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现静态类型与被删除对象的动态类型不符的情况。例如：删除一个Quote* 类型的指针，此时它可能实际指向一个Bulk_quote派生类的的对象。<br>我们可以在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;  <span class="comment">//动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Quote *itemp = <span class="keyword">new</span> Quote;  <span class="comment">//静态类型与动态类型一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;  <span class="comment">//调用Quote的析构函数</span></span><br><span class="line">Quote *itemp = <span class="keyword">new</span> Bulk_quote;  <span class="comment">//静态类型与动态类型不一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;  <span class="comment">//调用Bulk quote的析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] Title</p>
<ul>
<li>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</li>
<li>虚析构函数将阻止编译器为这个类合成移动操作</li>
</ul>
</blockquote>
<p>虚析构语法：<code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：<code>virtual ~类名() = 0;</code>  </p>
<p>析构调用过程：<br>基类中只要定义了虚析构,在编译器角度来讲，那么由此基类派生出的所有子类地析构均为对基类的虚析构的重写，当多态发生时，用父类引用，引用子类实例时，此时的虚指针保存的子类虚表的地址，该函数指针数组中的第一元素永远留给虚析构函数指针。所以当 delete 父类引用时，即第一个调用子类虚表中的子类重写的虚析构函数此为第一阶段。然后进入第二阶段：（二阶段纯为内存释放而触发的逐级析构与虚析构就没有半毛钱关系了）而当子类发生析构时，子类内存开始释放，因内存包涵关系，触发父类析构执行，层层向上递进，至到子类所包涵的所有内存释放完成。</p>
<h2 id="4-this指针"><a href="#4-this指针" class="headerlink" title="4 this指针"></a>4 this指针</h2><ul>
<li>在（非 static）成员函数内部，我们可以通过 this 指针访问类成员，<strong>this 是指向这个函数所属的对象实例的指针</strong></li>
<li>this 指针本质上是一个<strong>指针常量（<code>T* const</code>）</strong><ul>
<li>对于<strong>非 const 成员函数</strong>，其 this 指针类型为 <code>T* const</code>，即可以改变成员变量值</li>
<li>对于<strong>const 成员函数</strong>，其 this 指针类型为 <code>const T* const</code>，所以不能改变成员变量的值</li>
</ul>
</li>
</ul>
<h2 id="5-static静态"><a href="#5-static静态" class="headerlink" title="5 static静态"></a>5 static静态</h2><p>#static</p>
<blockquote>
<p>[!NOTE] 总结</p>
<ol>
<li>静态成员函数只能访问静态成员；非静态成员函数既可以访问非静态成员，也可以访问静态成员。</li>
</ol>
</blockquote>
<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p><strong>首先要声明：<code>Java</code>、<code>C#</code> 等高级语言支持静态类，但 <code>C++</code> 不支持。</strong> <code>C++</code> 通过创建仅包含静态成员和私有构造函数（把构造函数放在 <code>private</code> 里）的类来模拟”静态类” (C++经常这样做，比如用抽象类模拟接口的概念)，私有构造函数可以阻止类被实例化。</p>
<h4 id="什么是静态类"><a href="#什么是静态类" class="headerlink" title="什么是静态类"></a>什么是静态类</h4><p>以下不适用于 C++特性，只是为了解释静态类的概念：</p>
<ul>
<li><strong>静态类内部的成员全是静态成员，没有非静态成员。</strong> 一些高级语言中在 class 声明时使用 static 修饰来表示整个类是个静态类，<strong>C++不支持这种语法，但是可以实现为所有成员都是静态来达到静态类的效果。</strong></li>
<li><strong>静态类不能被实例化</strong>，因为所有成员都是静态的，定义对象实际上就是实例化里面的非静态成员，但是静态类并没有非静态成员，所以不用实例化。</li>
<li>静态类是密封 (sealed)的。所谓是密封，就是<strong>不可被继承</strong>，不能拿来做父类。<strong>静态类不包括构造函数</strong>，因为构造函数就是在实例化对象是调用的，但是静态类又不能被实例化。静态类不能指定任何接口实现，不能有任何实例成员。</li>
<li>静态类不包含构造函数，但仍可声明静态构造函数以分配初始值或设置某个静态状态。</li>
<li><strong>静态类的成员不能有 protected 访问保护修饰符</strong>。</li>
</ul>
<h3 id="（面向对象的）静态成员变量"><a href="#（面向对象的）静态成员变量" class="headerlink" title="（面向对象的）静态成员变量"></a>（面向对象的）静态成员变量</h3><p>在类内成员变量的声明前加上关键字 <code>static</code>，该数据成员就是类内的静态数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestClass</span>(<span class="type">int</span> _a, <span class="type">int</span> _b, <span class="type">int</span> _c)</span><br><span class="line">    :<span class="built_in">a</span>(_a),</span><br><span class="line">     <span class="built_in">b</span>(_b),</span><br><span class="line">     <span class="built_in">c</span>(_c)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sum = a+b+c;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSum</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sum;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum; <span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TestClass::sum = <span class="number">0</span>;  <span class="comment">//⭐类外定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; TestClass::sum &lt;&lt;endl;   <span class="comment">//0, 通过类类型访问</span></span><br><span class="line">    <span class="function">TestClass <span class="title">object</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt; object.<span class="built_in">GetSum</span>() &lt;&lt;endl;  <span class="comment">//6, 通过对象访问</span></span><br><span class="line">    cout&lt;&lt; TestClass::sum &lt;&lt;endl;   <span class="comment">//6, 通过类类型访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>静态成员变量有以下特点：</strong></p>
<ol>
<li>static 成员变量都存储在全局（静态）区，在初始化时其分配内存（而不是在类的实例化过程中分配内存），在程序结束时释放。</li>
<li>static 成员变量由本类的所有对象共享，不占用对象的内存。</li>
<li>static 成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。</li>
<li><strong>静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型</strong>。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li>
<li>可以通过类类型访问，也可以通过类对象访问</li>
<li>sizeof 运算符不会计算静态成员变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s;</span><br><span class="line">&#125;;    <span class="comment">//sizeof（CMyclass）等于4，不包括s的大小，因为s不属于CMyclass</span></span><br></pre></td></tr></table></figure>

<p><strong>何时采用静态数据成员？</strong></p>
<p><strong>如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。</strong> 也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：</p>
<ol>
<li>不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。</li>
<li>一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</li>
</ol>
<p>你也许会问，用全局变量不是也可以达到这个效果吗？<br><strong>同全局变量相比，使用静态数据成员有两个优势：</strong></p>
<ol>
<li>静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。</li>
<li>可以实现信息隐藏。静态成员变量可以是 private 成员，而全局变量不能。</li>
</ol>
<hr>
<p>摘自网络，为什么要使用 static 变量？<br>（1）Static 表示普通变量时，是为了避免不同的文件中同名，将这个同名变量限制在当前 CPP  文件中使用。定了Static变量时，在这个文件中都可以使用。<br>（2）Static修饰类的成员变量，是为了将当前变量限制为类的变量，而不是类实例的变量。  该变量可以用来在类的外面进行初始化，而不受类构造函数的影响。比如可以用于表示一个类被创建了多少次。</p>
<h3 id="（面向对象的）静态成员函数"><a href="#（面向对象的）静态成员函数" class="headerlink" title="（面向对象的）静态成员函数"></a>（面向对象的）静态成员函数</h3><p>与静态成员变量类似，我们也可以声明一个静态成员函数。</p>
<p><strong>静态成员函数为类服务而不是为某一个类的具体对象服务。</strong> 静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而<strong>静态成员函数不与任何对象绑定到一起</strong>。</p>
<p>普通的成员函数一般都隐含了一个 this 指针，this 指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。如函数 fn() 实际上是 this-&gt;fn()。</p>
<p>与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此<strong>它不具有 this 指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span> *name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   <span class="type">float</span> score;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> num;  	<span class="comment">//学生人数</span></span><br><span class="line">   <span class="type">static</span> <span class="type">float</span> total;  <span class="comment">//总分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Student</span>(<span class="type">char</span> *, <span class="type">int</span>, <span class="type">float</span>);</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">getAverage</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数，用来获得平均成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Student::num = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student类构造函数</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">   <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">   <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">   num++;</span><br><span class="line">   total += score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是 &quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是 &quot;</span>&lt;&lt;score&lt;&lt;<span class="string">&quot;（当前共&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;名学生）&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Student::getAverage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> total / num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">15</span>, <span class="number">90</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;李磊&quot;</span>, <span class="number">16</span>, <span class="number">80</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;张华&quot;</span>, <span class="number">16</span>, <span class="number">99</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;王康&quot;</span>, <span class="number">14</span>, <span class="number">60</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;平均成绩为 &quot;</span>&lt;&lt;Student::<span class="built_in">getAverage</span>()&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">小明的年龄是 <span class="number">15</span>，成绩是 <span class="number">90</span>（当前共<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是 <span class="number">16</span>，成绩是 <span class="number">80</span>（当前共<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是 <span class="number">16</span>，成绩是 <span class="number">99</span>（当前共<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是 <span class="number">14</span>，成绩是 <span class="number">60</span>（当前共<span class="number">4</span>名学生）</span><br><span class="line">平均成绩为 <span class="number">82.25</span></span><br></pre></td></tr></table></figure>

<p><strong>静态成员函数的特点：</strong></p>
<ol>
<li>出现在类体外的函数定义不能指定关键字 static；</li>
<li><strong>静态成员函数只能访问静态成员；非静态成员函数既可以访问非静态成员，也可以访问静态成员。</strong></li>
<li>由于没有 this 指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</li>
<li>调用静态成员函数，两种方式：<ul>
<li>通过对象的成员访问操作符 (<code>.</code>) 和(<code>-&gt;</code>)</li>
<li>直接通过类来调用静态成员函数。</li>
</ul>
</li>
</ol>
<p><strong>为什么引入静态成员函数？什么情况下使用</strong><br>在研究静态成员函数之前，我们先来考虑考虑为什么C++中会引入静态成员函数。</p>
<p>我们来看下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStaticMember</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_nIntA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们定义一个 <code>CStaticMember</code> 类，里面包含一个<strong>私有</strong>的静态成员变量 <code>m_nIntA</code>，如果外部想访问或者更改 <code>m_nIntA</code> 的值，那么根据 C++语法的要求，我们必须提供一个成员函数来进行访问。如下我们提供一个公有的 <code>GetIntA</code> 函数来进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStaticMember</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIntA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nIntA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_nIntA</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们知道在C++中调用类的成员函数，会传递一个this指针，将类的实例化对象的首地址传递给成员函数，函数操作会根据对象首地址计算其成员变量的地址，然后进行操作。然而静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到this指针。所以需要一种独立于对象之外对对象静态成员变量的访问操作。在早期C++引入静态成员函数之前，你会看到下面这样奇怪的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( CStaticMember*)0)-&gt;GetIntA();</span><br></pre></td></tr></table></figure>

<p>这样的写法就是为了避免了<code>对象.GetIntA()</code>的操作从而避免了对象的实例化操作，如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019165.png"></p>
<p>编译器生成的代码是先将 ecx 清零，然后直接调用 CStaticMember:: GetIntA 函数。<strong>这种写法的优点就在于不用对进行对象实例化操作从而节省了时间和空间。</strong> </p>
<p><strong>当函数不操作类内非 static 成员变量时（即与类的实例无关的函数），既可以考虑使用静态成员函数。</strong></p>
<h3 id="（面向过程的）静态全局变量"><a href="#（面向过程的）静态全局变量" class="headerlink" title="（面向过程的）静态全局变量"></a>（面向过程的）静态全局变量</h3><p>在全局变量前，加上关键字 static，该变量就被定义成为一个静态全局变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n; <span class="comment">//定义静态全局变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">fn</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n++;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态全局变量有以下特点：</strong></p>
<ol>
<li>静态变量都在全局数据区分配内存</li>
<li>未经初始化的静态全局变量会被程序初始化为 0；</li>
<li>静态全局变量<strong>在声明它的整个文件都是可见的，而在文件之外是不可见的</strong>； （内部连接）</li>
</ol>
<p><strong>定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</strong></p>
<ol>
<li><strong>静态全局变量不能被其它文件所用；</strong></li>
<li><strong>其它文件中可以定义相同名字的变量，不会发生冲突；</strong></li>
</ol>
<p>将上述示例代码改为如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 2</span></span><br><span class="line"><span class="comment">//File1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n; <span class="comment">//定义静态全局变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">fn</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//File2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n++;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行 Example 2，会发现上述代码可以分别通过编译，但运行时出现错误。 这就是因为<strong>静态全局变量不能被其它文件所用，即使在其它文件中使用 extern 进行声明也不行。</strong></p>
<p>我们将</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> n; <span class="comment">//定义静态全局变量</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">//定义全局变量</span></span><br></pre></td></tr></table></figure>

<p>再次编译运行程序，程序可正常运行。</p>
<p><strong>因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。</strong></p>
<h3 id="（面向过程的）静态局部变量"><a href="#（面向过程的）静态局部变量" class="headerlink" title="（面向过程的）静态局部变量"></a>（面向过程的）静态局部变量</h3><p>在局部变量前，加上关键字 static，该变量就被定义成为一个静态局部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fn</span>(); <span class="comment">//10</span></span><br><span class="line">	<span class="built_in">fn</span>(); <span class="comment">//11</span></span><br><span class="line">	<span class="built_in">fn</span>(); <span class="comment">//12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> n=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。</p>
<p><strong>但有时候我们需要在两次调用之间对变量的值进行保存</strong>。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。</p>
<p>静态局部变量正好可以解决这个问题。<strong>静态局部变量保存在全局数据区，每次的值保持到下一次调用，直到下次赋新值。即静态局部变量不会随着函数调用结束而销毁，而是在程序运行结束才会被销毁</strong></p>
<p><strong>静态局部变量有以下特点：</strong></p>
<ol>
<li>静态局部变量在全局数据区分配内存；</li>
<li><strong>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</strong></li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；</li>
</ol>
<h3 id="（面向过程的）静态函数"><a href="#（面向过程的）静态函数" class="headerlink" title="（面向过程的）静态函数"></a>（面向过程的）静态函数</h3><p>在函数的返回类型前加上 <code>static</code> 关键字, 函数即被定义为静态函数。<strong>静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;<span class="comment">//声明静态函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span><span class="comment">//定义静态函数 &#123;</span></span></span><br><span class="line"><span class="function">	<span class="type">int</span> n</span>=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义静态函数的好处：（类似于静态全局变量）</strong></p>
<ol>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ol>
<h2 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6 构造函数"></a>6 构造函数</h2><ul>
<li>当创建对象的时候，构造函数被调用</li>
<li>构造函数最重要的<strong>作用就是初始化类</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="built_in">Entity</span>()&#123;&#125;  <span class="comment">//默认构造函数，不带参数</span></span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">int</span> m_x, <span class="type">int</span> m_y) : <span class="built_in">x</span>(m_x), <span class="built_in">y</span>(m_y) &#123;&#125;  <span class="comment">//类内定义构造函数，带参数，用来初始化x和y</span></span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">int</span> x1); <span class="comment">//声明，用于类外定义</span></span><br><span class="line">	 </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Entity::<span class="built_in">Entity</span>(<span class="type">int</span> x1) <span class="comment">//类外定义构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x1;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数没有返回类型</li>
<li>构造函数不能被声明为const</li>
<li><strong>构造函数的命名必须和类名一样</strong></li>
<li>如果你不指定构造函数，你仍然有一个构造函数，这叫做默认构造函数（default constructor），是默认就有的。但是，我们仍然可以删除该默认构造函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">delete</span>;  <span class="comment">//删除默认构造函数</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数不会再你没有实例化对象的时候运行，所以如果你只是使用类的静态方法，构造函数是不会执行的。</li>
<li>当你用 new 关键字创建对象实例的时候也会调用构造函数。</li>
</ul>
<p><strong>不适用默认构造函数的情况：</strong></p>
<ul>
<li>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内初始值是，这个类才适合于使用默认构造函数。</li>
<li>如果类中包含一个其他【类】类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员，此时我们必须自定义默认构造函数。</li>
<li>p449其他一些情况导致编译器无法生成默认构造函数。</li>
</ul>
<p><strong>构造函数必有有初始值的情况：</strong></p>
<ul>
<li>如果成员是const或者是引用，必须将其初始化。</li>
<li>党成员属于某种【类】类型且该类没有定义默认构造函数时，必须将这个成员初始化。</li>
</ul>
<h3 id="类对象的初始化和析构顺序"><a href="#类对象的初始化和析构顺序" class="headerlink" title="类对象的初始化和析构顺序"></a>类对象的初始化和析构顺序</h3><p>构造顺序总结：虚继承基类的构造-&gt;普通继承基类的构造-&gt;子类成员变量-&gt;子类构造函数<br>析构顺序相反</p>
<ol>
<li><p>基类初始化顺序<br>如果当前类继承自一个或多个基类，它们将按照声明顺序进行初始化，但是在有虚继承和一般继承存在的情况下，优先虚继承。<br>比如虚继承：<code>class MyClass : public Base1, public virtual Base2</code>，此时应当先调用 <code>Base2</code> 的构造函数，再调用 <code>Base1</code> 的构造函数。</p>
</li>
<li><p>成员变量初始化顺序<br>类的成员变量按照它们在类定义中的声明顺序进行初始化，第一个成员先初始化，以此类推。<strong>构造函数初始值列表的前后位置不会影响</strong>实际的初始化顺序。</p>
</li>
<li><p>执行构造函数<br><strong>在基类和成员变量初始化完成后，再执行子类的构造函数。(注意，成员变量初始化在构造函数执行前)。</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base1 constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base1</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base1 destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base2 constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base2</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2 destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base3</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base3 constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base3</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base3 destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Base3, <span class="keyword">public</span> Base1, <span class="keyword">public</span> <span class="keyword">virtual</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">num1</span>(<span class="number">1</span>), <span class="built_in">num2</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">    <span class="comment">// 这个是为了看成员变量的初始化顺序</span></span><br><span class="line">    Base base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//构造顺序</span></span><br><span class="line">Base3 constructor  <span class="comment">// 虚继承排第一</span></span><br><span class="line">Base2 constructor  <span class="comment">// 虚继承优先</span></span><br><span class="line">Base1 constructor  <span class="comment">// 普通基类</span></span><br><span class="line">Base constructor   <span class="comment">// 子类成员函数构造</span></span><br><span class="line">MyClass constructor <span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="comment">//析构顺序和构造顺序相反</span></span><br><span class="line">MyClass destructor</span><br><span class="line">Base destructor</span><br><span class="line">Base1 destructor</span><br><span class="line">Base2 destructor</span><br><span class="line">Base3 destructor</span><br></pre></td></tr></table></figure>


<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>先看下面代码<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019166.png"><br>代码内容很简单，定义了一个包含成员 x，y 的类 Point。在序列的地方可以使用这个类<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019167.png"><br>虽然我们并没有定义 Point 类的构造函数，我们依然可以定义 Point 类的 pt 对象并使用它，其原因是编译器会自动生成一个缺省的构造函数，其效果相当于<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019168.png"><br>但是，一旦添加了其他有参数的构造函数，编译器就不再生成缺省的构造函数了<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019169.png"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>默认构造函数：是<strong>无参调用的构造函数（重点是无参调用）</strong>，包括两种：</p>
<ul>
<li>没有参数</li>
<li>每个参数有初始值（默认实参）</li>
</ul>
<p><strong>调用时机</strong><br>如果构造函数在未指定参数或者提供了一个空初始化器列表，则会调用默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v1;</span><br><span class="line">vector v2&#123;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] Title<br>如果一个构造函数为所有参数都提供了默认实参，那它实际上也定义了默认构造函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Box</span>() &#123;&#125;  <span class="comment">//默认构造函数1（没有参数）</span></span><br><span class="line">		<span class="built_in">Box</span>(<span class="type">int</span> m_x = <span class="number">1</span>, <span class="type">int</span> m_y = <span class="number">2</span>) : <span class="built_in">x</span>(m_x), <span class="built_in">y</span>(m_y) &#123;&#125; <span class="comment">//默认构造函数2（每个参数有默认实参）</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Box b; <span class="comment">//一个类中默认构造函数只能有一个，上面的Box类中我们写了两个默认构造函数，编译器会报错。</span></span><br><span class="line">		b.<span class="built_in">print</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//不报错，因为指定了参数，这行代码不会调用默认构造函数</span></span><br><span class="line">		<span class="comment">//Box b(2,3) </span></span><br><span class="line">		<span class="comment">//b.print();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>默认构造函数是一种<strong>特殊的成员函数</strong>。如果未在类中声明任何构造函数，则编译器将提供隐式的<code>inline默认构造函数</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_width * m_height * m_length;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_width &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> m_height &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> m_length &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box box1; <span class="comment">//调用编译器生成的构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;box1.Volume: &quot;</span> &lt;&lt; box1.<span class="built_in">Volume</span>() &lt;&lt; endl; <span class="comment">// Outputs 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果声明了任何非默认构造函数、编译器不会提供默认构造函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> width, <span class="type">int</span> length, <span class="type">int</span> height)</span><br><span class="line">        : <span class="built_in">m_width</span>(width), <span class="built_in">m_length</span>(length), <span class="built_in">m_height</span>(height)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="type">int</span> m_length;</span><br><span class="line">    <span class="type">int</span> m_height;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    Box box2&#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    Box box3; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【C-11】-default"><a href="#【C-11】-default" class="headerlink" title="【C++11】&#x3D;default"></a>【C++11】&#x3D;default</h3><p>C++11 允许我们使用 <code>=default</code> 来要求编译器生成一个默认构造函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span> data</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//拷贝控制成员：使用default</span></span><br><span class="line">		<span class="function">Sales <span class="title">data</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">		<span class="function">Sales <span class="title">data</span><span class="params">(<span class="type">const</span> Sales data&amp;)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">		Sales data&amp;<span class="keyword">operator</span>=(<span class="type">const</span> Sales data &amp;);</span><br><span class="line">		~<span class="function">Sales <span class="title">data</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">		<span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales data&amp;Sales data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales data&amp;)=<span class="keyword">default</span>; <span class="comment">//类外定义=default</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>=default</code> 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。</li>
<li>和其他函数一样，如果 <code>=default</code> 在类的内部，那么默认构造函数是 inline 的；如果他在类的外部，则该成员默认不是 inline 的。</li>
<li><strong>我们只能对具有默认版本的成员函数使用&#x3D;default</strong>(即，默认构造函数或拷贝控制成员)。</li>
</ul>
<h3 id="【C-11】委托构造函数"><a href="#【C-11】委托构造函数" class="headerlink" title="【C++11】委托构造函数"></a>【C++11】委托构造函数</h3><p>委托构造函数使用他所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或全部）职责委托给了其他构造函数。</p>
<p>在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price):</span><br><span class="line">	<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cnt * price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="转换构造函数（隐式类类型转换）"><a href="#转换构造函数（隐式类类型转换）" class="headerlink" title="转换构造函数（隐式类类型转换）"></a>转换构造函数（隐式类类型转换）</h3><p><strong>转换构造函数的作用是将一个其他类型的数据<mark style="background: #FF5582A6;">隐式转换</mark>成该类的对象｡</strong>  （不能反过来将该类的对象转换为其他类型，[[#类型转换函数（类型转换运算符）]]可以实现）</p>
<p><strong>当一个构造函数只有一个参数，而且该参数又不是本类的 const 引用时（即不是拷贝构造函数时），这种构造函数又被称为转换构造函数。</strong>  </p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换构造函数：只接受一个参数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;单参数构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p = <span class="number">1000</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">单参数构造函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure>

<p>这里调用了转化构造函数，将 int 类型的 1000 通过调用转换构造函数转换成了一个<strong>临时的 Person 类型对象</strong>赋值给 p。<br>如果不想要这种隐式转换，可以通过<strong>将构造函数声明为 <code>explicit</code> 加以阻止</strong>。</p>
<p><strong>注意：隐式类类型转换只能连续进行一次</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">m_Age</span>(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">test1</span><span class="params">(<span class="string">&quot;lk&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">test2</span><span class="params">(<span class="number">23</span>)</span></span>; </span><br><span class="line">    Entity test3 = <span class="string">&quot;lk&quot;</span>; <span class="comment">//error!只能进行一次隐式转换</span></span><br><span class="line">    Entity test4 = std::<span class="built_in">string</span>(<span class="string">&quot;lk&quot;</span>);</span><br><span class="line">    Entity test5 = <span class="number">23</span>; <span class="comment">//发生隐式转换</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在 test5 中，int 型的 23 就被隐式转换为一个 Entity 对象，这是<strong>因为 Entity 类中有一个 Entity(int age) 构造函数，因此可以调用这个构造函数，然后把 23 作为他的唯一参数，就可以创建一个 Entity 对象。</strong></p>
<p>同时我们也能看到，对于语句<code>Entity test3 = &quot;lk&quot;;</code>会报错，原因是<strong>只能进行一次隐式转换</strong>，<code>&quot;lk&quot;</code>是<code>const char</code>数组，这里需要先转换为<code>std::string</code>，再从 string 转换为 Entity 变量，两次隐式转换是不行的，所以会报错。但是写为<code>Entity test4 = std::string(&quot;lk&quot;);</code>就可以进行隐式转换。</p>
<p>最好不写 <code>Entity test5 = 23</code> 这样的代码，应尽量避免类类型隐式转换。因为 <code>Entity test2(23);</code> 更清晰。</p>
<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h3><p>#explicit<br>explict 显式<br>implicit 隐式</p>
<p>将转换构造函数声明为 explicit，<strong>禁止转换构造函数进行隐式转换。</strong><br>[[#转换构造函数（隐式类类型转换）]]</p>
<p><strong>只能用于直接初始化，不能用于拷贝初始化（使用 <code>=</code> 进行初始化）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span>  <span class="comment">//声明为explicit</span></span></span><br><span class="line"><span class="function">        : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">test1</span><span class="params">(<span class="string">&quot;lk&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">test2</span><span class="params">(<span class="number">23</span>)</span></span>; </span><br><span class="line">      Entity test3 = <span class="string">&quot;lk&quot;</span>; </span><br><span class="line">    Entity test4 = std::<span class="built_in">string</span>(<span class="string">&quot;lk&quot;</span>);</span><br><span class="line">    Entity test5 = <span class="number">23</span>; <span class="comment">//error！禁用隐式转换</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>#聚合类<br>当一个类满足如下条件时，我们说它是聚合的：</p>
<ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类</li>
<li>没有virtual函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//聚合类例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> a; </span><br><span class="line">		string s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚合类使得用户可以直接访问其成员，且具有特殊的初始化语法形式。<br>初始值的顺序必须与生命的顺序一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data vall = &#123;<span class="number">0</span>, <span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//vall.a = 0; vall.s = &quot;test&quot;  //等价</span></span><br></pre></td></tr></table></figure>

<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>#字面值常量类<br><strong>数据成员都是字面值类型的聚合类是字面值常量类</strong></p>
<p>如果不是聚合类，符合下属要求也是字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr 构造函数。</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式; 或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li>
</ul>
<p>constexpr构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">int</span> a)</span>:a(_a) &#123;</span>&#125;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-拷贝控制"><a href="#7-拷贝控制" class="headerlink" title="7 拷贝控制"></a>7 拷贝控制</h2><p>综合案例P460</p>
<p>定义一个类时，显式或隐式地指定此类型的对象拷贝、移动、赋值和销毁，通过五钟特殊地成员函数来控制这些操作，称为<strong>拷贝控制操作：</strong></p>
<ul>
<li><strong>拷贝&#x2F;移动构造函数</strong>：定义用同类型的另一个对象初始化本对象时做什么</li>
<li><strong>拷贝&#x2F;移动赋值运算符</strong>：定义将一个对象赋予同类型的另一个对象时做什么</li>
<li><strong>析构函数</strong>：定义当此类型销毁时做什么</li>
</ul>
<blockquote>
<p>[!NOTE]<br>如果一个类没有定义这些拷贝控制成员，编译器会自动为它定义缺失的操作，但有时这不是我们想要的，所以才要自己定义。</p>
</blockquote>
<h3 id="7-1-拷贝构造函数"><a href="#7-1-拷贝构造函数" class="headerlink" title="7.1 拷贝构造函数"></a>7.1 拷贝构造函数</h3><p><strong>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</strong><br>拷贝构造函数的第一个参数必须是一个引用类型，且通常是隐式地使用</p>
<p>拷贝构造函数的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明：</span></span><br><span class="line"><span class="built_in">T</span>(<span class="type">const</span> T&amp; var);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="built_in">T</span>(<span class="type">const</span> T&amp; var)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数体，进行深拷贝 分配空间放副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用拷贝函数，禁止赋值</span></span><br><span class="line"><span class="built_in">T</span>(<span class="type">const</span> T&amp; var) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Foo</span> ()  <span class="comment">//默认构造函数</span></span><br><span class="line">		<span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认拷贝构造函数（又称合成拷贝构造函数）<strong>通常时将每个非static成员拷贝到正在创建地对象中</strong>，也有一些特别的会阻止拷贝该类的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//这种最简单的拷贝构造函数声明与默认拷贝构造函数等价</span></span><br><span class="line">		<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		std::string bookNo;</span><br><span class="line">		<span class="type">int</span> units_sold <span class="number">0</span>;</span><br><span class="line">		<span class="type">double</span> revenue <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原理：这个自定义的拷贝构造函数地等价于默认拷贝构造函数</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;orig):</span><br><span class="line">		<span class="built_in">bookNo</span> (orig.bookNo),  <span class="comment">//使用string的拷贝构造函数</span></span><br><span class="line">		<span class="function">units <span class="title">sold</span><span class="params">(orig.units_sold)</span>,<span class="comment">//orig.units_sold</span></span></span><br><span class="line"><span class="function">		<span class="title">revenue</span><span class="params">(orig.revenue)</span>  <span class="comment">//拷贝orig.revenue</span></span></span><br><span class="line"><span class="function">		</span>&#123;&#125;  <span class="comment">//空函数体</span></span><br></pre></td></tr></table></figure>

<h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><ol>
<li>用一个对象初始化新对象时</li>
<li>一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。</li>
<li>一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值。</li>
</ol>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><blockquote>
<p>[!NOTE] 总结<br>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<p><strong>浅拷贝</strong>：简单的赋值拷贝操作，仅复制对象的基本类型成员和指针成员的值（直接按 bit 位复制），而不复制指针所指向的内存。<br>这可能导致两个对象共享相同的资源，从而引发潜在的问题，如内存泄漏、意外修改共享资源等。</p>
<p>一般来说编译器实现的默认拷贝构造函数就是浅拷贝。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019186.png" alt="Pasted image 20230318234723"><br><strong>深拷贝：在堆区重新申请空间，进行拷贝操作</strong>。<br>进一步理解：在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要将指针所指向的数据复制到新的堆区。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019187.png" alt="Pasted image 20230318235705"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无参构造函数&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> _age, <span class="type">int</span> _height)</span><br><span class="line">    : <span class="built_in">age</span>(_age), </span><br><span class="line">      <span class="built_in">height</span>(<span class="keyword">new</span> <span class="built_in">int</span>(_height)) <span class="comment">// 在堆区分配内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果注释掉自定义的拷贝构造函数，则是浅拷贝</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    : <span class="built_in">age</span>(p.age),</span><br><span class="line">      <span class="built_in">height</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*p.height)) <span class="comment">//在堆区分配内存，深拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数，释放堆区内存</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">        <span class="keyword">delete</span> height;</span><br><span class="line">        height = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *height = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">18</span>, <span class="number">180</span>);</span><br><span class="line">    Person p2 = p1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.height = &quot;</span> &lt;&lt; *p1.height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放p1的height</span></span><br><span class="line">    <span class="comment">// 如果是浅拷贝，p2和p1的height指向同一块内存，释放p1的height后，p2的height也会被释放</span></span><br><span class="line">    <span class="comment">// 如果是深拷贝，p2和p1的height指向不同的内存，释放p1的height后，p2的height不会被释放</span></span><br><span class="line">    <span class="keyword">delete</span> p1.height;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.height = &quot;</span> &lt;&lt; *p2.height &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//浅拷贝</span><br><span class="line">有参构造函数</span><br><span class="line">p1.height = 180</span><br><span class="line">p2.height = 538094944  //垃圾值</span><br><span class="line">析构函数</span><br><span class="line"></span><br><span class="line">//深拷贝</span><br><span class="line">有参构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">p1.height = 180</span><br><span class="line">p2.height = 180</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure>

<p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(): <span class="built_in">m_a</span>(<span class="number">0</span>), <span class="built_in">m_b</span>(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。<strong>但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</strong></p>
<h4 id="使用浅拷贝还是深拷贝"><a href="#使用浅拷贝还是深拷贝" class="headerlink" title="使用浅拷贝还是深拷贝"></a>使用浅拷贝还是深拷贝</h4><p><strong>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝</strong>，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</p>
<p><strong>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作</strong>，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">//在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="type">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">    <span class="type">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = <span class="built_in">time</span>((<span class="type">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = <span class="built_in">time</span>((<span class="type">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;obj1: count = &quot;</span>&lt;&lt;obj1.<span class="built_in">getCount</span>()&lt;&lt;<span class="string">&quot;, time = &quot;</span>&lt;&lt;obj1.<span class="built_in">getTime</span>()&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;obj2: count = &quot;</span>&lt;&lt;obj2.<span class="built_in">getCount</span>()&lt;&lt;<span class="string">&quot;, time = &quot;</span>&lt;&lt;obj2.<span class="built_in">getTime</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>obj1: count &#x3D; 1, time &#x3D; 1488344372<br>obj2: count &#x3D; 2, time &#x3D; 1488344375</p>
<p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p>
<h3 id="7-2-拷贝赋值运算符"><a href="#7-2-拷贝赋值运算符" class="headerlink" title="7.2 拷贝赋值运算符"></a>7.2 拷贝赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Actor</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Actor</span>(<span class="type">const</span> Actor&amp; actor)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Actor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Actor&amp; actor)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;拷贝赋值运算符&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Actor actor1;  <span class="comment">//调用构造函数</span></span><br><span class="line">    Actor actor2;  <span class="comment">//调用构造函数</span></span><br><span class="line">    actor2 = actor1;  <span class="comment">//调用拷贝赋值运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>[!NOTE]<br>赋值运算符通常应该返回一个指向其左侧运算对象的引用</p>
</blockquote>
<p>如果类未定义自己的拷贝赋值运算符，编译器就会为它合成一个默认拷贝赋值运算符。<strong>通常默认拷贝赋值运算符将右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的代码等价于Sales_data的默认拷贝赋值运算符：</span></span><br><span class="line"></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">		bookNo =rhs.bookNo;  <span class="comment">//调用string::operator=</span></span><br><span class="line">		units_sold=rhs.units_sold;  <span class="comment">//使用内置的int赋值</span></span><br><span class="line">		revenue =rhs.revenue;  <span class="comment">//使用内置的double赋值</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回一个此对象的引用</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝构造和拷贝赋值的区别"><a href="#拷贝构造和拷贝赋值的区别" class="headerlink" title="拷贝构造和拷贝赋值的区别"></a>拷贝构造和拷贝赋值的区别</h4><blockquote>
<p>[!bug] Title<br>区分调用哪一个并不是看表达式是使用 <code>()</code> 还是 <code>=</code>，而是看是否有新的对象实例产生。</p>
<ul>
<li>产生了新对象实例，调用的是拷贝构造函数</li>
<li>没有产生新对象实例，调用的是赋值运算符</li>
</ul>
</blockquote>
<p>拷贝构造函数和拷贝赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个<strong>已经存在的实例</strong>。这种区别从两者的名字也可以很轻易的分辨出来：<br>拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。<br><strong>调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝赋值运算符&quot;</span> &lt;&lt; endl;</span><br><span class="line">		age = p.age;</span><br><span class="line">		name = p.name;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">	string name = <span class="string">&quot;LK&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以值的方式参传入Person对象，产生新的临时对象，调用拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以值的方式返回Person对象，调用拷贝构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line"> 	Person p2 = p1;    <span class="comment">// 1 调用拷贝构造函数，因为p2是创建的新对象</span></span><br><span class="line">	</span><br><span class="line"> 	Person p3;</span><br><span class="line">  	p3 = p1;           <span class="comment">// 2 调用拷贝赋值运算符，p3在之前已经被创建</span></span><br><span class="line">  	<span class="built_in">f1</span>(p3);            <span class="comment">// 3 调用拷贝构造函数构建f1可用的实参</span></span><br><span class="line"></span><br><span class="line">    Person p4;</span><br><span class="line">  	p4 = <span class="built_in">f2</span>();        <span class="comment">// 4 f2()调用拷贝构造函数，然后调用拷贝赋值运算符位p4赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-3-析构函数"><a href="#7-3-析构函数" class="headerlink" title="7.3 析构函数"></a>7.3 析构函数</h3><p>执行与构造函数相反的操作，<strong>释放对象使用的资源，并销毁对象的非static数据成员。</strong></p>
<ul>
<li>构造函数中，成员初始化在<strong>构造函数之前执行</strong>，按照在类中定义顺序进行初始化</li>
<li>析构函数中，首先执行析构函数，然后销毁成员，成员<strong>按初始化顺序的逆序销毁</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">		 ~<span class="built_in">Foo</span>();  <span class="comment">//析构函数没有返回值，也不接受参数，因此不能重载（唯一性）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>[!warning] 析构函数调用时机<br>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ol>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ol>
<p><strong>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</strong></p>
</blockquote>
<p>类中未定义时，编译器会合成一个默认析构函数，通常合成析构函数函数体为空，某些类的默认析构函数被用来阻止该类型的对象被销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码等价于Sales_data的默认析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">Sales_data</span>()&#123;&#125;</span><br><span class="line">		......</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure>

<h4 id="析构函数销毁的是什么？"><a href="#析构函数销毁的是什么？" class="headerlink" title="析构函数销毁的是什么？"></a>析构函数销毁的是什么？</h4><p>C++primer p446结尾说到：<br>认识到<strong>析构函数体自身</strong>并不<strong>直接销毁 <code>成员</code></strong> 是非常重要的。 <strong>成员</strong>是在<strong>析构函数体</strong>之后隐含的 <strong>析构</strong>阶段中被<strong>销毁</strong>的。在整个对象<strong>销毁</strong>过程中，<strong>析构函数体</strong>是作为<strong>成员销毁</strong>步骤之外的另一部分而进行的</p>
<p>我对这段话的理解如下：<br>析构函数体只会销毁对象申请的动态内存资源（new 的资源），而不会销毁成员变量所占的资源。<br>“隐含的析构阶段”即 C++在执行完析构函数体后，会自动执行以下三步进行成员的销毁：</p>
<ol>
<li>X 的析构函数调用 X 里所有直接的非 static 成员的析构函数</li>
<li>X 的析构函数会去调用 X 的所有直接父类的析构函数</li>
<li>如果 X 是该对象本身的类型，还会再去调用 X 的所有虚基类的析构函数</li>
</ol>
<h3 id="7-4-三-五法则"><a href="#7-4-三-五法则" class="headerlink" title="7.4 三&#x2F;五法则"></a>7.4 三&#x2F;五法则</h3><p>当定义一个类时，我们显式或隐式地定义了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊成员成员函数来控制拷贝操作：拷贝构造函数、拷贝赋值运算符、析构函数（C++11新标准加入了移动构造函数和移动赋值运算符）。</p>
<h4 id="三法则"><a href="#三法则" class="headerlink" title="三法则"></a>三法则</h4><blockquote>
<p>[!NOTE] 三法则</p>
<ul>
<li>如果一个类需要自定义析构函数，那么它一定也需要自定义拷贝赋值运算符和拷贝构造函数</li>
<li>如果一个类需要一个拷贝构造函数，那么肯定也需要一个拷贝赋值运算符，反之成立。</li>
<li>如果一个函数需要拷贝构造运算符或者拷贝赋值运算符，不必然意味着需要析构函数<blockquote>
<p>[!NOTE] 特例<br>基类的析构函数不遵循该原则，如果基类将析构函数设定为虚函数，此时该析构函数内容为空，我们无法由此判断该基类还需要赋值运算符或拷贝构造函数</p>
<blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<p>如何理解三法则，通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员。所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露。</p>
<p>那么为什么说“一定需要拷贝构造函数和赋值操作符”呢？</p>
<p>原因还是这样：类中出现了指针类型的成员。<strong>有指针类型的成员，我们必须防止浅拷贝问题</strong>，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的。</p>
<h4 id="五法则"><a href="#五法则" class="headerlink" title="五法则"></a>五法则</h4><p>在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”；</p>
<p><strong>也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“C++ 三&#x2F;五法则”；</strong></p>
<h3 id="7-6-阻止拷贝"><a href="#7-6-阻止拷贝" class="headerlink" title="7.6 阻止拷贝"></a>7.6 阻止拷贝</h3><p>有些类不需要拷贝构造函数和拷贝赋值运算符，比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>
<h4 id="【C-11】-delete-删除函数"><a href="#【C-11】-delete-删除函数" class="headerlink" title="【C++11】 &#x3D;delete 删除函数"></a>【C++11】 &#x3D;delete 删除函数</h4><p>#delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;  <span class="comment">//使用合成的默认构造函数</span></span><br><span class="line">		<span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;  <span class="comment">//阻止拷贝</span></span><br><span class="line">		NoCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">//阻止赋值</span></span><br><span class="line"></span><br><span class="line">		~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;  <span class="comment">//使用合成的析构函数</span></span><br><span class="line">		<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;delete通知编译器（以及我们代码的读者），我们不希望定义这些成员。</p>
<blockquote>
<p>[!NOTE] 与&#x3D;default的不同点</p>
<ol>
<li>&#x3D;delete必须出现在函数第一次声明的时候</li>
<li>可以对普通函数指定&#x3D;delete(&#x3D;defalut只能用于具有合成版本的成员函数)</li>
<li>不可删除析构函数</li>
</ol>
</blockquote>
<h4 id="声明为私有"><a href="#声明为私有" class="headerlink" title="声明为私有"></a>声明为私有</h4><p>C++11之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateCopy</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//无访问说明符；接下来的成员默认为private的</span></span><br><span class="line">		<span class="comment">//拷贝控制成员是private的，因此普通用户代码无法访问</span></span><br><span class="line">		<span class="built_in">PrivateCopy</span>(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">		PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">		<span class="comment">//其他成员</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">PrivateCopy</span>()=<span class="keyword">default</span>;<span class="comment">//使用合成的默认构造函数</span></span><br><span class="line">		~<span class="built_in">PrivateCopy</span>();<span class="comment">//用户可以定义此类型的对象，但无法拷贝它们</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-7-拷贝控制和资源管理"><a href="#7-7-拷贝控制和资源管理" class="headerlink" title="7.7 拷贝控制和资源管理"></a>7.7 拷贝控制和资源管理</h3><p>P452<br>通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。<br><strong>为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</strong><br><strong>类的行为像一个值，意味着它应该也有自己的状态。</strong> 当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。例如标准库容器和string类的行为像一个值。<br><strong>行为像指针的类则共享状态。</strong> 当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。例如shared ptr类提供类似指针的行为。<br>通常，类直接拷贝内置类型（不包括指针）成员：这些成员本身就是值，因此通常应该让它们的行为像值一样。<strong>我们如何拷贝指针成员决定了像HasPtr这样的类是具有类值行为还是类指针行为。</strong></p>
<h4 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h4><p>为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的string,每个HasPtr对象都必须有自己的拷贝。为了实现类值行为，HasPtr需要</p>
<ul>
<li>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</li>
<li>定义一个析构函数来释放string</li>
<li>定义一个拷贝赋值运算符来释放对象当前的string,并从右侧运算对象拷贝string</li>
</ul>
<p>类值版本的HasPtr如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hasptr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 构造函数</span></span><br><span class="line">		<span class="built_in">Hasptr</span>(<span class="type">const</span> std::string &amp;s = std:<span class="built_in">string</span>()) : </span><br><span class="line">				<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">				</span><br><span class="line">		<span class="comment">// 拷贝构造函数</span></span><br><span class="line">		<span class="comment">// 对ps指向的string,每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">		<span class="built_in">Hasptr</span>(<span class="type">const</span> HasPtr &amp;p) : </span><br><span class="line">				<span class="built_in">ps</span>(<span class="keyword">new</span> std:<span class="built_in">string</span>(*p.ps)),<span class="built_in">i</span>(p.i) &#123;&#125;</span><br><span class="line">				</span><br><span class="line">		Hasptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Hasptr &amp;)  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">		~<span class="built_in">Hasptr</span>() &#123; <span class="keyword">delete</span> ps &#125;;  <span class="comment">//析构</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string *ps;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义拷贝赋值运算符</span></span><br><span class="line">Hasptr&amp; Hasptr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);  <span class="comment">// 拷贝底层string</span></span><br><span class="line">		<span class="keyword">delete</span> ps;  <span class="comment">// 释放旧内存</span></span><br><span class="line">		ps = newp;  <span class="comment">// 从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">		i = rhs.i;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的类足够简单，在类内就已定义了除赋值运算符之外的所有成员函数。第一个构造函数接受一个（可选的）string参数。这个构造函数动态分配它自己的string副本，并将指向string的指针保存在ps中。拷贝构造函数也分配它自己的string副本。析构函数对指针成员ps执行delete,释放构造函数中分配的内存。<br>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的一当异常发生时能将左侧运算对象置于一个有意义的状态。</p>
<h4 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h4><p>对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但是，在本例中，析构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。<br>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。拷贝（或赋值）一个shared_ptr会拷贝（赋值）shared_ptr所指向的指针。shared_ptr类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，shared_ptr类负责释放资源。<br>但是，有时我们希望直接管理资源。在这种情况下，使用引用计数(reference count)就很有用了。为了说明引用计数如何工作，我们将重新定义HasPtr,令其行为像指针一样，但我们不使用shared_ptr,而是设计自己的引用计数。<br>引用计数的工作方式如下：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
<li>将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hasptr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">		<span class="built_in">Hasptr</span>(<span class="type">const</span> std:string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">			<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> std::size <span class="built_in">t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">		<span class="built_in">Hasptr</span>(<span class="type">const</span> Hasptr &amp;p) : <span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)</span><br><span class="line">		&#123; ++*use &#125;;</span><br><span class="line">		</span><br><span class="line">		Hasptr&amp;<span class="keyword">operator</span>=(<span class="type">const</span> Hasptr&amp;);</span><br><span class="line">		~<span class="built_in">Hasptr</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		std::string *ps;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		std::<span class="type">size_t</span> *use;<span class="comment">//用来记录有多少个对象共享*ps的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hasptr::~<span class="built_in">HasPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//如果引用计数变为0</span></span><br><span class="line">		<span class="keyword">if</span>(--*use==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> ps;  <span class="comment">//释放string内存</span></span><br><span class="line">			<span class="keyword">delete</span> use;  <span class="comment">//释放计数器内存</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hasptr&amp; Hasptr::<span class="keyword">operator</span>=(<span class="type">const</span> Hasptr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">		++*rhs.use;<span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">if</span> (--*use == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> ps;  <span class="comment">//如果没有其他用户</span></span><br><span class="line">			<span class="keyword">delete</span> use;  <span class="comment">//释放本对象分配的成员</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ps = rhs.ps;</span><br><span class="line">		<span class="comment">//将数据从rhs拷贝到本对象</span></span><br><span class="line">		i = rhs.i;</span><br><span class="line">		use = rhs.use;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="自定义类中的swap函数"><a href="#自定义类中的swap函数" class="headerlink" title="自定义类中的swap函数"></a>自定义类中的swap函数</h4><p>交换两个类值对象得代码可能是这样得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hasptr temp = v1;  <span class="comment">//创建v1的值的一个临时副本</span></span><br><span class="line">v1 = V2;  <span class="comment">//将v2的值赋予v1</span></span><br><span class="line">v2 = temp;  <span class="comment">//将保存的v1的值赋予v2</span></span><br></pre></td></tr></table></figure>
<p>拷贝了三次，我们不希望有这些多余的内存操作，可以通过交换指针实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *temp = v1.ps;  <span class="comment">//为v1.ps中的指针创建一个副本</span></span><br><span class="line">v1.ps = v2.ps;  <span class="comment">//将v2.ps中的指针赋予v1.ps</span></span><br><span class="line">v2.ps = temp;  <span class="comment">//将保存的v1.ps中原来的指针赋予v2.ps</span></span><br></pre></td></tr></table></figure>

<p>这样我们就能编写优化后的swap函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hasptr</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Hasptr&amp;, Hasptr&amp;)</span></span>;</span><br><span class="line">		<span class="comment">//其他成员定义，与&quot;行为像值的类&quot;小节中一样</span></span><br><span class="line">&#125;:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs,Hasptr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//std::swap是标准库中的swap函数，因为本例数据成员是内置类型，所以可以这样是哟个，如果一个类的数据成员有自己特定的swap函数，就不能使用std::swap</span></span><br><span class="line">		std::<span class="built_in">swap</span>(Ihs.ps,rhs.ps);  <span class="comment">//交换指针，而不是string数据</span></span><br><span class="line">		std::<span class="built_in">swap</span>(Ihs.i,rhs.i);  <span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义swap的类通常用swap来定义它们的赋值运算符</strong>。这些运算符使用了一种名为<strong>拷贝并交换(copy and swap)</strong> 的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; Hasptr::<span class="keyword">operator</span>=(Hasptr rhs)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">		<span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);  <span class="comment">//rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的string的一个新副本。<br>在赋值运算符的函数体中，我们调用swap来交换rhs和* this中的数据成员。这个调用将左侧运算对象中原来保存的指针存入rhs中，并将rhs中原来的指针存入* this中。因此，在swap调用之后，* this中的指针成员将指向新分配的string一右侧运算对象中string的一个副本。<br>当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即，释放掉左侧运算对象中原来的内存。<br><strong>这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的</strong>。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确。</p>
<h3 id="7-8-【C-11】对象移动（移动语义）"><a href="#7-8-【C-11】对象移动（移动语义）" class="headerlink" title="7.8 【C++11】对象移动（移动语义）"></a>7.8 【C++11】对象移动（移动语义）</h3><p><strong>重新分配内存的过程中，从旧内存拷贝到新内存是不必要的，更好的方式是移动元素，开销更低。（旧C++标准只能通过拷贝）</strong></p>
<blockquote>
<p>[!NOTE] </p>
<ol>
<li>标准库容器、string和shared_ptr类既支持移动也支持拷贝。</li>
<li>IO类和unique_ptr类可以移动但不能拷贝（因为包含不能被共享的资源（如指针或IO缓冲））。</li>
</ol>
</blockquote>
<h4 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std:: move 函数"></a>std:: move 函数</h4><p>#move<br><code>std::move</code> 显式地将一个<strong>左值对象转换为右值引用</strong>，该对象称为”移后源对象“。 </p>
<blockquote>
<p>可以使用 <code>static_cast</code> 显式地将一个左值对象转换为右值引用，不安全，还是用 <code>std::move</code> 比较好 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr = std::<span class="built_in">move</span>(i); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>std::move</code> 就意味着承诺：除了对 i 赋值或销毁它外，我们将不再使用它。如果后续使用了该值，会产生未定义行为。</p>
<p>标准库是这样定义 move 的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove_reference是在16.2.3节（第605页）中介绍的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span> <span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//内部使用了static_cast</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt; (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动构造函数，引用参数使用了右值引用符号&amp;&amp;</span></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line"><span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">: <span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first free),<span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//令S进入这样的状态：对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free =  s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动赋值运算符</span></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();  <span class="comment">//释放已有元素</span></span><br><span class="line">        elements = rhs.elements;  <span class="comment">//从rhs接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;  </span><br><span class="line">        <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="默认移动函数"><a href="#默认移动函数" class="headerlink" title="默认移动函数"></a>默认移动函数</h4><p>只有当一个类没有定义任何自己版本的拷贝控制成员，<strong>且它的所有数据成员都能移动构造或移动赋值时</strong>，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasX合成移动操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;  <span class="comment">//内置类型可以移动</span></span><br><span class="line">    std:string s;  <span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span></span><br><span class="line">&#123;</span><br><span class="line">    X mem; <span class="comment">//X有合成的移动操作</span></span><br><span class="line">&#125;</span><br><span class="line">X x;</span><br><span class="line">X x2 = std:<span class="built_in">move</span>(x);  <span class="comment">//使用合成的移动构造函数</span></span><br><span class="line"></span><br><span class="line">hasX hx;</span><br><span class="line">hasX hx2 = std:<span class="built_in">move</span>(hx);  <span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h4><p>一般的迭代器的解引用返回指向一个元素的左值，但移动迭代器的解引用生成一个右值引用。<br><code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器（可以使用和普通迭代器同样的操作）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//分配大小两倍于当前规模的内存空间</span></span><br><span class="line">    <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>()? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.<span class="built_in">allocate</span>(newcapacity);</span><br><span class="line">    <span class="comment">//移动元素</span></span><br><span class="line">    <span class="keyword">auto</span> last = <span class="built_in">uninitialized_copy</span>(<span class="built_in">make_move_iterator</span>(<span class="built_in">begin</span>()),make move <span class="built_in">iterator</span> (<span class="built_in">end</span>()),first);</span><br><span class="line">    <span class="built_in">free</span>();  <span class="comment">//释放旧空间</span></span><br><span class="line">    elements = first;  <span class="comment">//更新指针</span></span><br><span class="line">    first free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a>引用限定符</h4><p><strong>在参数列表后放置一个引用限定符</strong>，可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。<br>只能用于非static成员函数，且必须同时出现在函数的声明和定义中。</p>
<p><strong>对于&amp;限定的函数，我们只能将它用于左值：对于&amp;&amp;限定的函数，只能用于右值：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo &amp;<span class="title">retFoo</span><span class="params">()</span></span>;  <span class="comment">//返回一个引用；retFoo调用是一个左值</span></span><br><span class="line"><span class="function">Foo <span class="title">retval</span><span class="params">()</span></span>;  <span class="comment">//返回一个值；retVal调用是一个右值</span></span><br><span class="line">Foo i,j;  <span class="comment">//i和j是左值</span></span><br><span class="line">i=j;  <span class="comment">//正确：1是左值</span></span><br><span class="line"><span class="built_in">retFoo</span>() = j;  <span class="comment">//正确：retFoo()返回一个左值</span></span><br><span class="line"><span class="built_in">retval</span>() = j;  <span class="comment">//错误：retVal()返回一个右值</span></span><br><span class="line">i = <span class="built_in">retval</span>();  <span class="comment">//正确：我们可以将一个右值作为赋值操作的右侧运算对象</span></span><br></pre></td></tr></table></figure>

<p>一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;  <span class="comment">//正确：const限定符在前</span></span></span><br><span class="line"><span class="function">    Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="type">const</span></span>;  <span class="comment">//错误：const限定符必须在前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] Title<br>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符</p>
</blockquote>
<h1 id="七、IO-库"><a href="#七、IO-库" class="headerlink" title="七、IO 库"></a>七、IO 库</h1><h2 id="1-IO-类"><a href="#1-IO-类" class="headerlink" title="1 IO 类"></a>1 IO 类</h2><p>cin&gt;&gt; 读进去<br>cout &lt;&lt;写出去<br>endl是一个被称为<strong>操纵符</strong>的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019188.png" alt="Pasted image 20230211200011"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019189.png" alt="Pasted image 20230211195929"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019190.png" alt="Pasted image 20230211200859"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019191.png" alt="Pasted image 20230211200910"></p>
<ul>
<li>以上操作都是操纵char数据的，为了支持宽字符wchar_t的语言，只需要在操作符前面加上w就可，如wcout、wistream</li>
<li>ifstream和istringstream都继承自istream，因此他们也可以执行cin、cout、&gt;&gt;、getline等操作。</li>
<li>不能拷贝或对IO对象赋值</li>
</ul>
<blockquote>
<p>[!NOTE] Title<br>本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流以及char或宽字符流版本。</p>
</blockquote>
<h2 id="2-管理输出缓冲"><a href="#2-管理输出缓冲" class="headerlink" title="2 管理输出缓冲"></a>2 管理输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符（如endl）来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</li>
<li><strong>一个输出流可能被关联到另一个流。</strong> 在这种情况下，<strong>当读写被关联的流时，关联到的流的缓冲区会被刷新</strong>。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;hi!&quot;</span>&lt;&lt;endl;  <span class="comment">//输出hi和一个换行，然后刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi！&quot;</span>&lt;&lt;flush:  <span class="comment">//输出hi，然后刷新缓冲区，不附加任何额外字符</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi!&quot;</span>&lt;&lt;ends;  <span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin&gt;&gt;i; <span class="comment">//cin和cout关联，因此该句将cout的缓冲区刷新</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>[!warning] 警告<br>程序崩溃，输出缓冲区不会被刷新</p>
</blockquote>
<h2 id="3-文件-IO"><a href="#3-文件-IO" class="headerlink" title="3 文件 IO"></a>3 文件 IO</h2><p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>头文件 &lt; fstream &gt; 定义了三个类型来支持文件IO：</p>
<p><code>ifstream</code> 读文件<br><code>ofstream</code> 写文件<br><code>fstream</code> 读写文件<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019192.png" alt="Pasted image 20230211202030"></p>
<ul>
<li>当一个fstream对象被销毁时（比如离开作用域时），close会自动被调用，文件自动关闭。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019193.png" alt="Pasted image 20230211202818"></p>
<ul>
<li>每个文件流类型都定义了一个默认的文件模式，ifstream是in，ofstream是out，fstream是in和out。后面的例子我显式的写了出来</li>
<li>文件模式可以组合使用，利用 “|” 操作符。<br>例如：用二进制方式写文件 ofstream :: binary | ofstream :: out<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ofstream::binary | ofstream::out)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>以out模式打开文件，文件的内容会被丢弃，若想保留ofstream打开的文件中已有的数据，唯一办法是显式指定app或in模式<blockquote>
<p>[!NOTE] 【C++11】文件名<br>C++11中，文件名既可以是库类型string对象，也可以是指向C风格字符串的指针</p>
</blockquote>
</li>
</ul>
<h3 id="写文件ofstream"><a href="#写文件ofstream" class="headerlink" title="写文件ofstream"></a>写文件ofstream</h3><p>写文件步骤如下：</p>
<ol>
<li><strong>包含头文件</strong><br>&#96;#include <fstream></li>
<li><strong>创建流对象</strong><br><code>ofstream ofs;</code></li>
<li><strong>打开文件</strong><br><code>ofs.open(&quot;文件名&quot;,打开方式);</code></li>
<li><strong>写数据</strong><br><code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></li>
<li><strong>关闭文件</strong><br><code>ofs.close();</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ofstream::out);</span><br><span class="line">	<span class="comment">//ofstream ofs(&quot;test.txt&quot;, ofstream::out); //等价上面两句，提供文件名时，open自动被调用</span></span><br><span class="line">	</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读文件ifstream"><a href="#读文件ifstream" class="headerlink" title="读文件ifstream"></a>读文件ifstream</h3><p>步骤相似，有三种读取数据的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ifstream::in)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式  将数据存入数组</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//初始化一个数组</span></span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; buf)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf)))</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	string buf;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-string-流"><a href="#4-string-流" class="headerlink" title="4 string 流"></a>4 string 流</h2><p><code>sstream</code>头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，<br>从string读取数据，就像string是一个IO流一样。</p>
<p><code>istringstream</code>从string读取数据<br><code>ostringstream</code>向string写入数据<br><code>stringstream</code>既可从string读数据也可向string写数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019194.png" alt="Pasted image 20230211210322"></p>
<p>当我们想对整行文本进行处理，同时对行内每个单词进行处理时可以使用<code>istringstream</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件内列举了姓名和他拥有的电话号码</span></span><br><span class="line"><span class="comment">//test.txt</span></span><br><span class="line">morgan <span class="number">2015552368</span> <span class="number">8625550123</span></span><br><span class="line">drew <span class="number">9735550130</span></span><br><span class="line"><span class="number">1</span>ee <span class="number">6095550132</span> <span class="number">2015550175</span> <span class="number">8005550000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;	<span class="comment">//存姓名</span></span><br><span class="line">	vector&lt;string&gt; phones;	<span class="comment">//村电话</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line, word;	<span class="comment">//分别保存来自输入的一行和单词</span></span><br><span class="line">    vector&lt;PersonInfo&gt;people;	<span class="comment">//保存来自输入的所有记录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐行从输入读取数据，直至cin遇到文件尾（或其他错误）</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">	&#123;</span><br><span class="line">		PersonInfo info;	<span class="comment">//创建一个保存此记录数据的对象</span></span><br><span class="line">		<span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;	<span class="comment">//将记录绑定到刚读入的行</span></span><br><span class="line">		record &gt;&gt; info.name;	<span class="comment">//读取名字</span></span><br><span class="line">		<span class="keyword">while</span> (record &gt;&gt; word)	<span class="comment">//读取电话号码</span></span><br><span class="line">			info.phones.<span class="built_in">push_back</span>(word);	<span class="comment">//保存</span></span><br><span class="line"></span><br><span class="line">		people.<span class="built_in">push_back</span>(info);	<span class="comment">//将此记录追加到people末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-格式控制"><a href="#5-格式控制" class="headerlink" title="5 格式控制"></a>5 格式控制</h2><p>除了条件状态外，每个iostream对象还维护一个<strong>格式状态</strong>来控制IO如何格式化的细节。<br>格式状态控制格式化的某些方面，如整型值是几进制、浮点值的精度、一个输出元素的宽度等。<br>标注库定义了一组<strong>操纵符</strong>来修改流的格式状态。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019195.png" alt="Pasted image 20230227221944"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019196.png" alt="Pasted image 20230227221955"></p>
<ul>
<li>一个操纵符是一个函数或者是一个对象，会影响流的状态，并能用作输入或输出运算符的运算对象。</li>
<li>类似输入和输出运算符，操纵符也返回它所处理的流对象，因此我们可以在一条语句中组合操纵符和数据。</li>
</ul>
<p>操作符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。</p>
<p>大多数改变格式状态的操纵符都是设置&#x2F;复原成对的，当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolalpha控制布尔值的格式</span></span><br><span class="line"><span class="comment">//默认情况下，bool打印1或0，一个true输出整数1，使用boolalpha之后会直接打印true</span></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;default bool values:&quot;</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt;<span class="literal">false</span></span><br><span class="line">		&lt;&lt;<span class="string">&quot;\nalpha bool values:&quot;</span> &lt;&lt; boolalpha</span><br><span class="line">		&lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//default bool values:1 0</span></span><br><span class="line"><span class="comment">//alpha bool values:true false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用noboolapha复原</span></span><br><span class="line"><span class="type">bool</span> bool_val = <span class="built_in">get_status</span>();</span><br><span class="line">cout &lt;&lt; boolalpha  <span class="comment">//设置cout的内部状态</span></span><br><span class="line">&lt;&lt; bool_val</span><br><span class="line">&lt;&lt; noboolalpha;    <span class="comment">//将内部状态恢复为默认格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定整型值的进制</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;default:&quot;</span>&lt;&lt;<span class="number">20</span>&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="number">1024</span>&lt;&lt;endl;  <span class="comment">//默认十进制</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;octa1:&quot;</span>&lt;&lt;oct&lt;&lt;<span class="number">20</span>&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="number">1024</span>&lt;&lt;endl;  <span class="comment">//十六进制</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hex:&quot;</span>&lt;&lt;hex&lt;&lt;<span class="number">20</span>&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="number">1024</span>&lt;&lt;endl;  <span class="comment">//八进制</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;decimal:&quot;</span>&lt;&lt;dec&lt;&lt;<span class="number">20</span> &lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="number">1024</span>&lt;&lt;endl;  <span class="comment">//十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//default:20 1024</span></span><br><span class="line"><span class="comment">//octa1:242000</span></span><br><span class="line"><span class="comment">//hex:14400</span></span><br><span class="line"><span class="comment">//decimal:20 1024</span></span><br></pre></td></tr></table></figure>

<h1 id="八、动态内存"><a href="#八、动态内存" class="headerlink" title="八、动态内存"></a>八、动态内存</h1><p>到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。<br><strong>全局对象</strong>：在程序启动时分配，在程序结束时销毁。<br><strong>局部自动对象</strong>：当我们进入其定义所在的程序块时被创建，在离开块时销毁。<br><strong>局部static对象</strong>：在第一次使用前分配，在程序结束时销毁。</p>
<blockquote>
<p>[!NOTE] 自动对象<br> <strong>只有当定义它的函数被调用时才存在的对象</strong>称为自动对象。</p>
</blockquote>
<p>除了自动和static对象外，C++还支持<strong>动态分配对象</strong>。动态分配的对象的生存期与它们在哪里创建是无关的，<strong>只有当显式地被释放时，这些对象才会销毁。</strong><br>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>
<p>我们的程序到目前为止只使用过静态内存或栈内存。</p>
<p><strong>静态内存</strong>：保存局部static对象、类static数据成员以及定义在任何函数之外的变量。<br><strong>栈内存</strong>：保存定义在函数内的非static对象。</p>
<p><strong>分配在静态或栈内存中的对象由编译器自动创建和销毁</strong>。对于栈对象，仅在其定义的程序块运行时才存在：static对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。<br>这部分内存被称作<strong>自由空间(free store)或堆(heap)<strong>：程序</strong>用堆来存储动态分配(dynamically allocate)的对象</strong>，即那些在程序运行时分配的对象。<strong>动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们</strong>。</p>
<p>new：在动态内存中为对象分配空间并返回一个指向该对象的指针<br>delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存</p>
<blockquote>
<p>[!bug] 手动释放内存很不安全<br>忘记释放内存：内存泄漏<br>尚有指针引用内存的情况下释放了内存：产生引用非法内存的指针</p>
</blockquote>
<h2 id="手动管理内存"><a href="#手动管理内存" class="headerlink" title="手动管理内存"></a>手动管理内存</h2><h3 id="new动态分配和初始化对象"><a href="#new动态分配和初始化对象" class="headerlink" title="new动态分配和初始化对象"></a>new动态分配和初始化对象</h3><p>在自由空间分配的内存是无名的，所以new无法为其分配的对象命名，而是返回一个指向该对象的指针。<br>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，类类型用默认构造函数初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//pi指向一个动态分配的、未初始化的无名对象</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string;  <span class="comment">//初始化为空string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化/列表初始化</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); </span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">3</span>, <span class="string">&#x27;9&#x27;</span>); <span class="comment">//初始化为&quot;999&quot;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值初始化</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">//值初始化未空string，和默认初始化一样，都是调用构造函数</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">//！！！和默认初始化不同，int值初始化结果为0，即*pi为0</span></span><br></pre></td></tr></table></figure>

<p><strong>动态分配 const 对象</strong><br>合法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">//分配并初始化一个const int</span></span><br><span class="line"><span class="type">const</span> string *str = <span class="keyword">new</span> <span class="type">const</span> string; <span class="comment">//分配并默认初始化一个const的空string</span></span><br></pre></td></tr></table></figure>

<p><strong>内存耗尽</strong><br>内存不能分配所要求的内存空间，会抛出bad_alloc的异常，可以使用<strong>定位new（pacement new）</strong> 的方式阻止抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//如果分配失败，new抛出std: :bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;<span class="comment">//如果分配失败，new返回一个空指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="delete释放动态内存"><a href="#delete释放动态内存" class="headerlink" title="delete释放动态内存"></a>delete释放动态内存</h3><p>delete销毁给定的指针指向的对象，释放对应的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p； <span class="comment">//p必须指向一个动态分配的对象或是一个空指针</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pc = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>); </span><br><span class="line"><span class="keyword">delete</span> pci;  <span class="comment">//const对象不能改变，但可以销毁</span></span><br></pre></td></tr></table></figure>

<p>释放一块非new分配的内存，或将相同的指针值释放多次，其行为是未定义的。</p>
<h3 id="自定义内存分配细节"><a href="#自定义内存分配细节" class="headerlink" title="自定义内存分配细节"></a>自定义内存分配细节</h3><p>某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。它们常常需要<strong>自定义内存分配的细节</strong>，比如使用关键字 new 将对象放置在特定的内存空间中。为了实现这一目的，应用程序<strong>需要重载 new 运算符和 delete 运算符以控制内存分配的过程。</strong></p>
<h4 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h4><p>重载 new 和 delete 运算符与重载其他运算符的过程区别很大。</p>
<p>首先要了解这两个表达式的工作机理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>); <span class="comment">//初始化单个string对象</span></span><br><span class="line"><span class="keyword">delete</span> sp; <span class="comment">//销毁*sp，然后释放sp指向的内存空间</span></span><br><span class="line"></span><br><span class="line">string *arr = <span class="keyword">new</span> string[<span class="number">10</span>]; <span class="comment">//数组，包含10个默认初始化的string对象</span></span><br><span class="line"><span class="keyword">delete</span>[] arr; <span class="comment">//销毁数组中的元素，然后释放对应的内存空间</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>new</code> 操作符来分配对象内存时会经历三个步骤：</p>
<ol>
<li>调用 <code>operator new</code> 或 <code>operator new[]</code> 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>编译器运行相应的构造函数以构造对象，并为其传入初始值。</li>
<li>对象被分配空间并构造完成后，返回一个指向该对象的指针。</li>
</ol>
<p>使用 <code>delete</code> 操作符来释放对象内存时会经历两个步骤：</p>
<ol>
<li>调用对象的析构函数。</li>
<li>编译器调用 <code>operator delete</code> 或 <code>operator delete[]</code> 函数释放内存空间。</li>
</ol>
<blockquote>
<p>[!warning] 基本数据类型的 new 和delete<br>对于基本数据类型对象使用 new 和 delete 操作符，不会调用构造和析构函数</p>
</blockquote>
<p><strong>如果应用程序希望控制内存分配的过程，则它们需要定义自己的 operator new 函数和 operator delete 函数。</strong><br><strong>可以将函数定义在全局作用域或定义为成员函数。</strong> 如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有 operator new 成员或 operator delete 成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行 new 表达式或 delete 表达式; 如果没找到，则使用标准库定义的版本。我们还可以通过 <code>::new</code> 和 <code>::delete</code> 直接调用全局作用域中的重载函数。</p>
<p>标准库定义了 <code>operator new</code> 函数和 <code>operator delete</code> 函数的 8 个重载版本。其中前 4 个版本可能抛出 <code>bad_alloc</code>异常，后 4 个版本则不会抛出异常:</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019197.png" alt="Pasted image 20240217202545"></p>
<h4 id="定位-new-表达式"><a href="#定位-new-表达式" class="headerlink" title="定位 new 表达式"></a>定位 new 表达式</h4><p>P729<br>placement new</p>
<p><strong>定位 new 允许我们在一个预先分配的内存地址上构造对象</strong></p>
<p>形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br></pre></td></tr></table></figure>
<p>place_address 为一个指针，代表一块内存的地址。</p>
<p>当仅通过一个地址值调用时，定位 new 使用调用特殊的 <code>operator new</code>，也就是下面这个版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span>,<span class="type">void</span> *)</span> <span class="comment">//不允许重定义这个版本的operator new</span></span></span><br></pre></td></tr></table></figure>
<p>这个 <code>operator new</code> 不分配任何的内存，它只是简单地返回指针实参，然后 new 表达式负责在 place_address 指定的地址进行对象的初始化工作。</p>
<p>例如：我们没有为 entity 对象开辟新内存，而是使用已分配的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>]; </span><br><span class="line">Entity* entity = <span class="built_in">new</span>(b) <span class="built_in">Entity</span>(); </span><br></pre></td></tr></table></figure>


<h2 id="【C-11】智能指针"><a href="#【C-11】智能指针" class="headerlink" title="【C++11】智能指针"></a>【C++11】智能指针</h2><p>#智能指针<br>类似vector，智能指针也是模板。</p>
<p><strong>智能指针（smart pointer）：自动释放所指向的对象，避免程序员忘记释放申请的空间</strong></p>
<p><code>shared_ptr</code>：允许多个 <code>shared_ptr</code> 指针指向同一个对象，增加引用计数，一旦最后一个 shared_ptr 被销毁，对象就会被释放。</p>
<p><code>unique_ptr</code>：一对一，独占一个对象，当<code>unique_ptr</code>被销毁时，它所指向的对象也被销毁。</p>
<p><code>weak_ptr</code>：一种弱引用。指向一个<code>shared_ptr</code>管理的对象，不控制所指向对象的生存期，不会改变<code>shared_ptr</code>的引用计数。一旦最后一个<code>shared_ptr</code>被销毁，对象就会被释放，即使有<code>weak_ptr</code>指向该对象。</p>
<blockquote>
<p>[!warning] 注意：智能指针也不能乱用</p>
<p>优先使用 <code>unique_ptr</code>，因为它有一个较低的开销，但如果你需要在对象之间共享，不能使用 <code>unique_ptr</code> 的时候，就使用 <code>shared_ptr</code></p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。</p>
</blockquote>
<p><strong>为了正确使用智能指针，我们必须坚持一些基本规范：</strong></p>
<blockquote>
<ol>
<li>不使用相同的内置指针值初始化（或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（deleter)。</li>
</ol>
</blockquote>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019198.png" alt="Pasted image 20230214204519"></p>
<h4 id="shared-ptr独有操作"><a href="#shared-ptr独有操作" class="headerlink" title="shared_ptr独有操作"></a>shared_ptr独有操作</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019199.png" alt="Pasted image 20230214204528"><br><strong>定义和改变shared_ptr的方法</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019200.png" alt="Pasted image 20230213233552"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019201.png" alt="Pasted image 20230213233645"></p>
<blockquote>
<p>[!NOTE] 删除器（deleter）<br>上图中参数d更换为一个自定义的释放智能指针的函数，这个函数就是删除器</p>
</blockquote>
<h4 id="unique-ptr独的操作"><a href="#unique-ptr独的操作" class="headerlink" title="unique_ptr独的操作"></a>unique_ptr独的操作</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019202.png" alt="Pasted image 20230214204404"></p>
<h4 id="weak-ptr独有操作"><a href="#weak-ptr独有操作" class="headerlink" title="weak_ptr独有操作"></a>weak_ptr独有操作</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019203.png" alt="Pasted image 20230214211500"></p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化，空指针</span></span><br><span class="line">shared_ptr&lt;string&gt; p1;  <span class="comment">//指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;  <span class="comment">//指向元素类型为int的list</span></span><br></pre></td></tr></table></figure>

<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>最安全的分配和使用动态内存的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向一个值为42的int的shared ptr</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向一个值为&quot;9999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向一个值初始化的int </span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常使用auto简写</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h4><p>当进行拷贝或赋值操作时，每个share_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>): <span class="comment">//p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">q</span>(p);  <span class="comment">//p和g指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>

<p>每个<code>shared_ptr</code>指向的对象都有一个关联的计数器，通常称其为**引用计数(reference count)**。无论何时我们拷贝一个指向该对象的shared_ptr，计数器都会递增。</p>
<p><strong>计数器递增：</strong></p>
<ul>
<li>用一个shared_ptr初始化另一个shared_ptr</li>
<li>将shared_ptr作为参数传递给一个函数，函数调用实参会拷贝一次</li>
<li>shared_ptr作为函数的返回值时</li>
</ul>
<p><strong>计数器递减：</strong></p>
<ul>
<li>给shared_ptr赋予一个新值</li>
<li>shared_ptr被销毁（例如一个局部的shared ptr离开其作用域）</li>
</ul>
<p><strong>一旦计数器变为0，它就会自动释放自己所管理的对象：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);<span class="comment">//r指向的int只有一个引用者</span></span><br><span class="line">r=q;</span><br><span class="line"><span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line"><span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line"><span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line"><span class="comment">//r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr自动销毁所管理的对象</strong><br>通过<strong>析构函数</strong>实现，析构函数控制对象销毁时做什么操作。<br><strong>shared_ptr自动释放相关联的内存</strong></p>
<blockquote>
<p>[!warning] 容器存放动态指针<br>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的shared_ptr元素。</p>
</blockquote>
<h4 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用new返回的指针来初始化智能指针</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt;pl; <span class="comment">//shared_ptr可以指向一个double</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span> (<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>));  <span class="comment">//p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>接受指针参数的<strong>智能指针构造函数是 explicit（显式）的</strong>，禁止隐式转换，只能进行直接初始化，不能拷贝初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);  <span class="comment">//错误：不能将一个内置指针隐式转换为一个智能指针，不能拷贝初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (<span class="number">1024</span>))</span></span>;  <span class="comment">//正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure>

<p>相同的原因，一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p); <span class="comment">//错误：隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span> (p));  </span><br><span class="line">    <span class="comment">//正确：显式地用int*创建shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。<br>我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete，使用第二个谓词。</p>
<blockquote>
<p>[!bug] 警告<br>不要混合使用普通指针和智能指针，上述结合使用会引发错误，建议使用make_shared而不是new</p>
<p>不要使用get初始化另一个智能指针或为智能指针赋值，get返回一个内置指针指向智能指针管理的对象</p>
</blockquote>
<h4 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h4><p>reset将一个新的指针赋予一个shared_ptr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">1024</span>);  <span class="comment">//错误：不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>));  <span class="comment">//正确：p指向一个新对象</span></span><br></pre></td></tr></table></figure>

<p>reset会更新引用计数，经常与unique一起使用，来控制多个shared_ptr共享的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));  <span class="comment">//我们不是对象的唯一用户；分配新的拷贝</span></span><br><span class="line">*p += newVal;  <span class="comment">//现在我们知道自己是新对象唯一的用户，可以放心改变对象的值</span></span><br></pre></td></tr></table></figure>

<h4 id="【C-11】enable-shared-from-this"><a href="#【C-11】enable-shared-from-this" class="headerlink" title="【C++11】enable_shared_from_this"></a>【C++11】enable_shared_from_this</h4><p>C++11 开始支持 <code>enable_shared_from_this</code>，它是一个模板类，定义在头文件 <code>&lt;memory&gt;</code>，其原型为：<br><code>template&lt; class T &gt; class enable_shared_from_this;</code></p>
<p>从名字可以看出几个关键词：enable: 允许 shared 指 shared_ptr, from_this 则是指从类自身 this 构造 shared_ptr</p>
<p><code>std::enable_shared_from_this</code> 能让其一个对象（假设其名为 t ，且已被一个 std:: shared_ptr 对象 pt 管理）安全地生成其他额外的 <code>std::shared_ptr</code> 实例（假设名为 pt1, pt2, … ），它们与 pt 共享对象 t 的所有权。<br>例如：若一个类 T 继承自 <code>std::enable_shared_from_this&lt;T&gt;</code> ，则 T 类中有继承自父类的成员函数： <code>shared_from_this</code> 。当 T 类的对象 t 被一个为名为 pt 的 <code>std:: shared_ptr</code> 类对象管理时，调用 <code>T:: shared_from_this</code> 成员函数，将会返回一个新的 <code>std:: shared_ptr</code> 对象，它与 pt 共享 t 的所有权。</p>
<h5 id="为什么要用-？"><a href="#为什么要用-？" class="headerlink" title="为什么要用 ？"></a>为什么要用 ？</h5><ul>
<li>需要在类对象的内部中获得一个指向当前对象的 shared_ptr 对象。</li>
<li>如果在一个程序中，对象内存的生命周期全部由智能指针来管理。在这种情况下，要在一个类的成员函数中，对外部返回 this 指针就成了一个很棘手的问题。</li>
</ul>
<h5 id="什么时候用？"><a href="#什么时候用？" class="headerlink" title="什么时候用？"></a>什么时候用？</h5><ol>
<li>当一个类被共享智能指针 <code>share_ptr</code> 管理，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的 <code>share_ptr</code>。</li>
<li>当你需要在类的成员函数内部创建指向当前对象的 <code>std:: shared_ptr</code>，例如在回调函数或事件处理中。</li>
</ol>
<h5 id="如何安全地将-this-指针返回给调用者"><a href="#如何安全地将-this-指针返回给调用者" class="headerlink" title="如何安全地将 this 指针返回给调用者?"></a>如何安全地将 this 指针返回给调用者?</h5><p>一般来说，我们不能直接将 this 指针返回。如果函数将 this 指针返回到外部某个变量保存，然后这个对象自身已经析构了，但外部变量并不知道，此时如果外部变量再使用这个指针，就会使得程序崩溃。</p>
<h5 id="标准库中的源码"><a href="#标准库中的源码" class="headerlink" title="标准库中的源码"></a>标准库中的源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; &#125;</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      <span class="built_in">enable_shared_from_this</span>(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 赋值操作</span></span><br><span class="line">      enable_shared_from_this&amp;</span><br><span class="line">      <span class="keyword">operator</span>=(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 析构函数</span></span><br><span class="line">      ~<span class="built_in">enable_shared_from_this</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 成员函数，返回类型为共享智能指针 shared_ptr</span></span><br><span class="line">      <span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function">      <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this); &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// const 类型的成员函数</span></span><br><span class="line">      <span class="function">shared_ptr&lt;<span class="type">const</span> _Tp&gt;</span></span><br><span class="line"><span class="function">      <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) <span class="comment">// c++1z or gnu++11</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cpp_lib_enable_shared_from_this 201603</span></span><br><span class="line">     <span class="comment">// 成员函数，返回类型为弱类型的智能指针 weak_ptr</span></span><br><span class="line">      <span class="function">weak_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function">      <span class="title">weak_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_weak_this; &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// const 类型的成员函数</span></span><br><span class="line">      <span class="function">weak_ptr&lt;<span class="type">const</span> _Tp&gt;</span></span><br><span class="line"><span class="function">      <span class="title">weak_from_this</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_weak_this; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 函数模板</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">	<span class="type">void</span></span><br><span class="line">	_M_weak_assign(_Tp1* __p, <span class="type">const</span> __shared_count&lt;&gt;&amp; __n) <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">	&#123; _M_weak_this._M_assign(__p, __n); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Found by ADL when this is an associated class.</span></span><br><span class="line">      <span class="keyword">friend</span> <span class="type">const</span> enable_shared_from_this*</span><br><span class="line">      __enable_shared_from_this_base(<span class="type">const</span> __shared_count&lt;&gt;&amp;,</span><br><span class="line">				     <span class="type">const</span> enable_shared_from_this* __p)</span><br><span class="line">      &#123; <span class="keyword">return</span> __p; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, _Lock_policy&gt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__shared_ptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt;  _M_weak_this;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>enable_shared_from_this 类中的成员函数<ul>
<li>(constructor)：构造一个 enable_shared_from_this 对象，是一个受保护的成员函数，成员属性为 <code>protected</code>。</li>
<li>(destructor)：销毁一个 enable_shared_from_this 对象，是一个受保护的成员函数，成员属性为 <code>protected</code>。</li>
<li>operator&#x3D;：返回到 this 的引用，是一个受保护成员函数，成员属性为 <code>protected</code>。</li>
<li>shared_from_this：返回共享 <code>*this</code> 指针所有权的 shared_ptr，是一个 <code>public</code> 属性的成员函数。</li>
<li>weak_from_this (C++17)：返回共享 <code>*this</code> 所指针有权的 weak_ptr，是一个 <code>public</code> 属性的成员函数。</li>
</ul>
</li>
</ul>
<h5 id="具体的代码示例"><a href="#具体的代码示例" class="headerlink" title="具体的代码示例"></a>具体的代码示例</h5><figure class="highlight c++"><figcaption><span>nums</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较推荐的写法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Good</span> : std::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的用法：用不安全的表达式试图获得 this 的 shared_ptr 对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确的用法: 两个 shared_ptr 共享同一个对象</span></span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1 = std::<span class="built_in">make_shared</span>&lt;Good&gt;();</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;<span class="built_in">getptr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;gp2.use_count() = &quot;</span> &lt;&lt; gp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 错误的用法: 调用 shared_from_this 但其没有被 std::shared_ptr 占有 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Good not_so_good;</span><br><span class="line">        std::shared_ptr&lt;Good&gt; gp1 = not_so_good.<span class="built_in">getptr</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span>(std::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 在 C++17 之前，编译器不能捕获 enable_shared_from_this 抛出的std::bad_weak_ptr 异常</span></span><br><span class="line">        <span class="comment">// 这是在C++17之后才有的特性</span></span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 错误的用法，每个 shared_ptr 都认为自己是对象的唯一拥有者</span></span><br><span class="line">    <span class="comment">// 调用错误的用法，会导致两次析构 Bad的对象，第二次析构时，指针指向的空间已经被析构，</span></span><br><span class="line">    <span class="comment">// 会导致程序出错</span></span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1 = std::<span class="built_in">make_shared</span>&lt;Bad&gt;();</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;<span class="built_in">getptr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h5><ul>
<li><p>enable_shared_from_this 的常见实现为：其内部保存着一个对 this 的弱引用（例如 std:: weak_ptr )。 std:: shared_ptr 的构造函数检测无歧义且可访问的 (C++17 起) enable_shared_from_this 基类，并且若内部存储的弱引用没有被以存在的 std:: shared_ptr 占有，则 (C++17 起) 赋值新建的 std:: shared_ptr 为内部存储的弱引用。为另一个 std:: shared_ptr 所管理的对象构造一个 std:: shared_ptr ，将不会考虑内部存储的弱引用，从而将导致未定义行为 (undefined behavior)。</p>
</li>
<li><p>只允许在先前已被 std:: shared_ptr 管理的对象上调用 shared_from_this 。否则调用行为未定义 (C++17 前) 抛出 std:: bad_weak_ptr 异常（通过 shared_ptr 从默认构造的 weak_this 的构造函数） (自 C++17 起)。</p>
</li>
<li><p>enable_shared_from_this 提供安全的替用方案，以替代 std:: shared_ptr (this) 这样的表达式（这种不安全的表达式可能会导致 this 被多个互不知晓的所有者析构）。</p>
</li>
</ul>
<h3 id="unique-ptr类"><a href="#unique-ptr类" class="headerlink" title="unique_ptr类"></a>unique_ptr类</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>接受指针参数的<strong>智能指针构造函数是explicit（显示）的</strong>，禁止隐式转换，只能进行直接初始化，不能拷贝初始化。</p>
<p>当我们定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个 new 返回的指针上 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; p1;  <span class="comment">//可以指向一个double的unique ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;  <span class="comment">//p2指向一个值为42的int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make_unique返回一个unique_ptr在C++14引入，C++11 不支持。这种方式更安全，原理和make_shared类似</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; i = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="拷贝和赋值"><a href="#拷贝和赋值" class="headerlink" title="拷贝和赋值"></a>拷贝和赋值</h4><p>由于独占对象，所以unique_ptr不支持普通的拷贝或赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Stegosaurus&quot;</span>))</span></span>; </span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//错误：unique_ptr不支持拷贝</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p2;  <span class="comment">//错误：unique_ptr不支持赋值</span></span><br></pre></td></tr></table></figure>

<p>例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 从函数返回一个unique_ptr</span></span><br><span class="line">unique ptr&lt;<span class="type">int</span>&gt;<span class="built_in">clone</span>(<span class="type">int</span> p)  <span class="comment">//正确：从int*创建一个unique_ptr&lt;int&gt;</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span> (p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 返回一个局部对象的拷贝：</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">clone</span>(<span class="type">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span> (<span class="keyword">new</span> <span class="built_in">int</span> (p));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转移对象"><a href="#转移对象" class="headerlink" title="转移对象"></a>转移对象</h4><p>通过release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有权从p1(指向string Stegosaurus)转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;<span class="comment">//release将p1置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有权从p3转移给p2</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//reset释放了p2原来指向的内存，指向p3释放的内存</span></span><br></pre></td></tr></table></figure>

<p>release返回的是<code>unique_ptr&lt;string&gt;::pointer</code>类型的指针，是一个<code>string*</code>类型的普通指针，需要手动释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="built_in">release</span>();  <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> o = p2.<span class="built_in">release</span>(); <span class="comment">//正确，记得delete</span></span><br><span class="line"><span class="keyword">delete</span> o;</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr类"><a href="#weak-ptr类" class="headerlink" title="weak_ptr类"></a>weak_ptr类</h3><p>创建一个weak_ptr时，要哟个一个shared_ptr来初始化它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;  <span class="comment">//wp弱共享p;p的引用计数未改变</span></span><br></pre></td></tr></table></figure>

<p>lock检查指向的对象是否存在，如果存在，lock返回一个指向共享对象的shared_ptr，这样可以保证访问对象是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())  <span class="comment">//如果np不为空则条件成立</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和delete一次都是操作一个对象<br>C++提供两种一次分配一个对象数组的方法</p>
<blockquote>
<p>[!warning]<br><strong>大多数应用应该使用标准库容器而不是动态分配的数组</strong>。使用容器更为简单<br>更不容易出现内存管理错误并且可能有更好的性能。</p>
</blockquote>
<h3 id="new-delete数组"><a href="#new-delete数组" class="headerlink" title="new&#x2F;delete数组"></a>new&#x2F;delete数组</h3><p>用new分配一个动态数组，后面要跟方括号，指明分配数量，必须为整型。<br>new返回一个指向数组元素类型的指针，而不是数组类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1024</span>]; <span class="comment">//p指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价，使用类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">1024</span>]; </span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> arrT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] a2;  <span class="comment">//按逆序销毁动态数组中的元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>动态数组并不是数组类型，不支持begin、end、范围for循环</p>
</blockquote>
<h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1= <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">//默认初始化，10个未初始化的int</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();  <span class="comment">//加（）是值初始化，10个值初始化为0的int</span></span><br><span class="line">string *p3 = <span class="keyword">new</span> string[<span class="number">10</span>];  <span class="comment">//10个空string</span></span><br><span class="line">string *p4 = <span class="keyword">new</span> string[<span class="number">10</span>](); <span class="comment">//10个空string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11支持列表初始化</span></span><br><span class="line"><span class="comment">//10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="type">int</span> *p5 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;:</span><br><span class="line"><span class="comment">//10个string,前4个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line">string *p6 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>)&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr管理动态数组"><a href="#unique-ptr管理动态数组" class="headerlink" title="unique_ptr管理动态数组"></a>unique_ptr管理动态数组</h3><p>标准库提供了一个可以管理new分配的动态数组的unique_ptr版本<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019204.png" alt="Pasted image 20230214221250"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">//对象类型后加一个方括号</span></span><br><span class="line">up.<span class="built_in">release</span>(); <span class="comment">//释放后，自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>

<p>unique_ptr 指向数组（不是对象），不能用点和箭头运算符，但可以用下标运算符访问数组元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i !<span class="number">10</span>;++i)</span><br><span class="line">		up[i]=i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr若要管理动态数组，必须提供自定义的删除器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sp</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p) &#123;<span class="keyword">delete</span>[] p;&#125;)</span><br><span class="line">sp.<span class="built_in">reset</span>();  <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br></pre></td></tr></table></figure>
<p>shared_ptrmei没有定义下标运算符，可以用get获取一个内置指针，用它来访问数组元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared ptr未定义下标运算符，并且不支持指针的算术运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">		*(sp.<span class="built_in">get</span>()+i)=i;  <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new、delete将内存分配&#x2F;释放和对象构造&#x2F;销毁组合在了一起，不太灵活。</p>
<ul>
<li>allocator类将内存分配和对象构造分离</li>
<li>allocator类也是一个模板<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019205.png" alt="Pasted image 20230214222842"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;  <span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);  <span class="comment">//为n个未初始化的string分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);  <span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++,<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>);  <span class="comment">//*q为cccccccccc</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++,<span class="string">&quot;hi&quot;</span>);  <span class="comment">//*q为hi!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能使用未构造的内存</span></span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;  <span class="comment">//正确：p已经分配内存，使用string的输出运算符</span></span><br><span class="line">cout&lt;&lt; *g &lt;&lt;endl;  <span class="comment">//错误：q指向未构造的内存！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用完之后使用destroy销毁构造的对象</span></span><br><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">		alloc.<span class="built_in">destroy</span>(--q);  <span class="comment">//释放我们真正构造的string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁后内存可以保存其他string，或者释放内存</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, n);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>拷贝和填充未初始化内存</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019206.png" alt="Pasted image 20230214224148"></p>
<h1 id="九、重载运算符与函数对象"><a href="#九、重载运算符与函数对象" class="headerlink" title="九、重载运算符与函数对象"></a>九、重载运算符与函数对象</h1><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019207.png" alt="Pasted image 20230219235211"></p>
<blockquote>
<p>[!NOTE] Title<br>当一个重载运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。</p>
</blockquote>
<ol>
<li>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能为int重定义内置的运算符</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</li>
<li>我们只能重载已有的运算符，不能发明新的运算符号。</li>
<li>可以直接调用一个重载的运算符函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用非成员函数operator+</span></span><br><span class="line">datal + data2;  <span class="comment">//普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(datal,data2);  <span class="comment">//等价的函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用成员函数operator+=</span></span><br><span class="line">data1 += data2;  <span class="comment">//基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);  <span class="comment">//对成员运算符函数的等价调用，将this绑定到data1地址，将data2作为实参传入了函数。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-输入输出运算符"><a href="#1-输入输出运算符" class="headerlink" title="1 输入输出运算符"></a>1 输入输出运算符</h2><h3 id="输出运算符"><a href="#输出运算符" class="headerlink" title="输出运算符&lt;&lt;重载"></a>输出运算符&lt;&lt;重载</h3><p>第一个形参是（非常量）ostream对象的引用<br>第二个形参是一个常量的引用，该常量是我们想要打印的类类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> Sales data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">		os &lt;&lt; item.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.y;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] </p>
<ol>
<li>输出运算符应该负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</li>
<li>自定义IO运算符，必须将其定义为非成员函数</li>
<li>IO运算符通常需要读写类的非公有数据成员，所以一般声明为友元</li>
</ol>
</blockquote>
<h3 id="输入运算符-重载"><a href="#输入运算符-重载" class="headerlink" title="输入运算符&gt;&gt;重载"></a>输入运算符&gt;&gt;重载</h3><p>第一个形参是运算符将要读取的流的引用<br>第二个形参是将要读入的（非常量）对象的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">double</span> price;<span class="comment">//不需要初始化，因为我们将先读入数据到price,之后才使用它</span></span><br><span class="line">		is &gt;&gt; item.bookNo &gt;&gt; item.units sold &gt;&gt; price;</span><br><span class="line">		<span class="keyword">if</span> (is)</span><br><span class="line">		<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item.revenue = item.units sold price;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		item = <span class="built_in">Sales_data</span>();<span class="comment">//输入失败：对象被赋予默认的状态</span></span><br><span class="line">		<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>输入运算符必须处理输入可能失败的情况，输出运算符不需要。<br>当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>
</blockquote>
<h2 id="2-算术和关系运算符"><a href="#2-算术和关系运算符" class="headerlink" title="2 算术和关系运算符"></a>2 算术和关系运算符</h2><p>通常情况下定义为非成员函数以允许对左侧或右侧的运算对象进行转换。<br>运算符一般不需要改变运算对象的状态，所以形参都是常量的引用</p>
<h3 id="相等运算符-和"><a href="#相等运算符-和" class="headerlink" title="相等运算符 &#x3D;&#x3D; 和!&#x3D;"></a>相等运算符 &#x3D;&#x3D; 和!&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  <span class="comment">//定义操作符的重载,如果！=，这里做相应修改即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>！=(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  <span class="comment">//如果！=，这里做相应修改即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ！(*<span class="keyword">this</span> == other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    Vector2 result1 = position.<span class="built_in">Add</span>(speed.<span class="built_in">Multiply</span>(powerup));</span><br><span class="line">    Vector2 result2 = position + speed * powerup; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result1 == result2)   <span class="comment">//需要对==进行重载操作 （！=同理）</span></span><br><span class="line">    &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>如&lt;</p>
<h2 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3 赋值运算符&#x3D;"></a>3 赋值运算符&#x3D;</h2><blockquote>
<p>[!NOTE]<br>赋值运算符必须定义为成员函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">StrVec &amp;<span class="keyword">operator</span>=(std::initializer list&lt;std::string&gt;);</span><br><span class="line"><span class="comment">//其他成员与13.5节（第465页)一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符+&#x3D;"></a><strong>复合赋值运算符+&#x3D;</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></span><br><span class="line"><span class="comment">// 假定两个对象表示的是同一本书</span></span><br><span class="line">Sales data &amp;Sales data:<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">		units sold +rhs.units sold;</span><br><span class="line">		revenue +rhs.revenue;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。<br>这两类运算符都应该返回左侧运算对象的引用。</p>
</blockquote>
<h2 id="4-下标运算符"><a href="#4-下标运算符" class="headerlink" title="4 下标运算符 []"></a>4 下标运算符 []</h2><p>表示容器的类通常可以通过元素在容器中的访问元素，这些类一般会定义下标运算符operator[]</p>
<blockquote>
<p>[!NOTE] </p>
<ul>
<li>下标运算符必须是成员函数</li>
<li>下标运算符通常重载两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</li>
</ul>
</blockquote>
<p>举个例子，我们按照如下形式定义StrVec(参见13.5节，第465页)的下标运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">			<span class="keyword">return</span> elements[n];</span><br><span class="line">		<span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">			<span class="keyword">return</span> elements[n];</span><br><span class="line">		<span class="comment">//其他成员与13.5（第465页)一致</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std:string *elements;</span><br><span class="line">		<span class="comment">//指向数组首元素的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这两个下标运算符的用法类似于vector或者数组中的下标。因为下标运算符返回的是元素的引用，所以当StrVec是非常量时，我们可以给元素赋值：而当我们对常量对象取下标时，不能为其赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设svec是一个非const StrVec对象</span></span><br><span class="line"><span class="type">const</span> StrVec cvec = svec;  <span class="comment">//把svec的元素拷贝到cvec中</span></span><br><span class="line"><span class="comment">//如果svec中含有元素，对第一个元素运行string的empty函数</span></span><br><span class="line"><span class="keyword">if</span> (svec.<span class="built_in">size</span>() &amp;&amp; svec[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">		svec[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;  <span class="comment">//正确：下标运算符返回string的引用</span></span><br><span class="line">		cvec[<span class="number">0</span>] = <span class="string">&quot;Zip&quot;</span>;  <span class="comment">//错误：对cvec取下标返回的是常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-递增递减运算符"><a href="#5-递增递减运算符" class="headerlink" title="5 递增递减运算符"></a>5 递增递减运算符</h2><blockquote>
<p>[!NOTE]<br>建议设定为成员函数<br>同时定义前置和后置两个版本</p>
<ul>
<li>前置运算符返回递增或递减后的原对象的引用</li>
<li>后置运算符返回对象的原值（递增或递减之前的值）</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobptr</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//前置运算符</span></span><br><span class="line">		StrBlobPtr&amp; <span class="keyword">operator</span>++();  </span><br><span class="line">		StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//后置运算符</span></span><br><span class="line">		StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">//增加一个额外的int类型的形参，不参与运算，只是为了区分前置后置运算符，无须命名。</span></span><br><span class="line">		StrBlobptr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">		<span class="comment">//其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置版本：返回递增/递减对象的引用</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">		<span class="built_in">check</span>(curr,<span class="string">&quot;increment past end of StrBlobPtr&quot;</span>);</span><br><span class="line">		++curr;</span><br><span class="line">		<span class="comment">//将curr在当前状态下向前移动一个元素</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//如果curr是0，则继续递减它将产生一个无效下标</span></span><br><span class="line">		--curr;</span><br><span class="line">		<span class="comment">//将curr在当前状态下向后移动一个元素</span></span><br><span class="line">		<span class="built_in">check</span>(curr,<span class="string">&quot;decrement past begin of StrBlobPtr&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//后置版本：递增/递减对象的值但是返回原值</span></span><br><span class="line">StrBlobPtr StrBlobPtr:<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//此处无须检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">		StrBlobptr ret = *<span class="keyword">this</span>;  <span class="comment">//记录当前的值</span></span><br><span class="line">		++*<span class="keyword">this</span>;  <span class="comment">//向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">		<span class="keyword">return</span> ret;  <span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//此处无须检查有效性，调用前置递减运算时才需要检查</span></span><br><span class="line">		StrBlobPtr ret = *<span class="keyword">this</span>;   <span class="comment">//记录当前的值</span></span><br><span class="line">		--*<span class="keyword">this</span>;  <span class="comment">//向后移动一个元素，前置一-需要检查递减的有效性</span></span><br><span class="line">		<span class="keyword">return</span> ret;  <span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-成员访问运算符-和"><a href="#6-成员访问运算符-和" class="headerlink" title="6 成员访问运算符 * 和-&gt;"></a>6 成员访问运算符 * 和-&gt;</h2><blockquote>
<p>[!NOTE] Title<br>箭头运算符-&gt;必须是类的成员，解引用运算符 * 不一定<br>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobptr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		std:string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr,<span class="string">&quot;dereference past end&quot;</span>); <span class="comment">//检查curr是否在作用范围内，如果是则返回curr所指元素的引用</span></span><br><span class="line">			<span class="keyword">return</span> (*p)[curr];</span><br><span class="line">			<span class="comment">//(*p)是对象所指的vector</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		std:string*<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();  <span class="comment">//将实际工作委托给解引用运算符</span></span><br><span class="line">			<span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-函数对象（仿函数）与函数调用运算符"><a href="#7-函数对象（仿函数）与函数调用运算符" class="headerlink" title="7 函数对象（仿函数）与函数调用运算符()"></a>7 函数对象（仿函数）与函数调用运算符<code>()</code></h2><p>#函数对象 #仿函数</p>
<ol>
<li><strong>重载 <code>函数调用运算符()</code> 的类，其对象常称为函数对象 (function object)，也叫仿函数 (functor)，使得类对象可以像函数那样调用。</strong></li>
<li>STL 提供的算法往往有两个版本，一种是按照我们常规默认的运算来执行，另一种允许用户自己定义一些运算或操作，通常通过回调函数或模版参数的方式来实现，此时 functor 便派上了用场，特别是作为模版参数的时候，只能传类型。</li>
<li>函数对象超出了普通函数的概念，其内部可以拥有自己的状态 (其实也就相当于函数内的 static 变量)，可以通过成员变量的方式被记录下来。</li>
<li>函数对象可以作为函数的参数传递。</li>
<li>函数对象通常不定义构造和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用时的运行时问题。</li>
<li>模版函数对象使函数对象具有通用性，这也是它的优势之一。</li>
<li>STL 需要我们提供的 functor 通常只有一元和二元两种。</li>
<li>lambda 表达式的内部实现其实也是仿函数</li>
</ol>
<blockquote>
<p>[!NOTE] Title<br>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>
</blockquote>
<p>即使 <code>absnum</code> 只是一个对象而非函数，我们也能“调用”该对象。<strong>调用对象实际上是在运行重载的调用运算符</strong>。在此例中，该运算符接受一个 int 值并返回其绝对值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个名为absInt的struct含有一个调用运算符，该运算符负责返回其参数的绝对值：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">absInt absnum;  <span class="comment">//含有函数调用运算符的对象</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">absnum</span>(i);  <span class="comment">//将i传给absnum.operator()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数对象常常作为泛型算法的实参，例如使用标准库for_each算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(),vs.<span class="built_in">end</span>(),<span class="built_in">absInt</span>()); <span class="comment">//第三个实参是类型absInt的一个临时对象</span></span><br></pre></td></tr></table></figure>

<h3 id="STL-内置函数对象"><a href="#STL-内置函数对象" class="headerlink" title="STL 内置函数对象"></a>STL 内置函数对象</h3><p>#greater<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019208.png" alt="Pasted image 20230221223643"><br>使用时需要包含头文件 <code>&lt;functional&gt;</code><br>STL 内建了一些函数对象，分为：</p>
<ul>
<li>算术类函数对象</li>
<li>关系运算类函数对象</li>
<li>逻辑运算类函数对象</li>
</ul>
<h3 id="算术类函数对象"><a href="#算术类函数对象" class="headerlink" title="算术类函数对象"></a>算术类函数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt;; <span class="comment">// 加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T minus&lt;T&gt;; <span class="comment">// 减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T multiplies&lt;T&gt;; <span class="comment">// 乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T divides&lt;T&gt;; <span class="comment">// 除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T modulus&lt;T&gt;; <span class="comment">// 取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T negate&lt;T&gt;; <span class="comment">// 取反函数</span></span><br></pre></td></tr></table></figure>
<p><code>negate</code> 是一元运算，其他都是二元运算。</p>
<h3 id="关系运算类函数对象"><a href="#关系运算类函数对象" class="headerlink" title="关系运算类函数对象"></a>关系运算类函数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> equal_to&lt;T&gt;; <span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> not_equal_to&lt;T&gt;; <span class="comment">// 不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater&lt;T&gt;; <span class="comment">// 大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater_equal&lt;T&gt;; <span class="comment">// 大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less&lt;T&gt;; <span class="comment">// 小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less_equal&lt;T&gt;; <span class="comment">// 小于等于</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算类运算函数"><a href="#逻辑运算类运算函数" class="headerlink" title="逻辑运算类运算函数"></a>逻辑运算类运算函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_and&lt;T&gt;; <span class="comment">// 逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_or&lt;T&gt;; <span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_not&lt;T&gt;; <span class="comment">// 逻辑非</span></span><br></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;       <span class="comment">//可执行int加法的函数对</span></span><br><span class="line">negate&lt;<span class="type">int</span>&gt; intNegate;  <span class="comment">//可对int值取反的函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用intAdd::operator(int,int)求10和20的和</span></span><br><span class="line"><span class="type">int</span> sum =  <span class="built_in">intAdd</span> (<span class="number">10</span>,<span class="number">20</span>);  <span class="comment">//sum=30</span></span><br><span class="line">sum = <span class="built_in">intNegate</span>(<span class="built_in">intAdd</span>(<span class="number">10</span>,<span class="number">20</span>));  <span class="comment">//sum=-30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用intNegate::operator(int)生成-l0</span></span><br><span class="line"><span class="comment">//然后将-l0作为intAdd::operator(int,int)的第二个参数</span></span><br><span class="line">sum = <span class="built_in">intAdd</span>(<span class="number">10</span>,<span class="built_in">intNegate</span>(<span class="number">10</span>));  <span class="comment">//sum = 0</span></span><br></pre></td></tr></table></figure>

<p><strong>这些函数对象通常用来替换算法中的默认运算符。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认下排序算法使用&lt;运算符按升序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入greater不再使用默认的&lt;运算符，而是调用给定的greater函数对象，该对象负载在string元素之间执行&gt;比较运算，实现降序排列</span></span><br><span class="line"><span class="built_in">sort</span> (svec.<span class="built_in">begin</span>(),svec.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;string&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="仿函数的优缺点"><a href="#仿函数的优缺点" class="headerlink" title="仿函数的优缺点"></a>仿函数的优缺点</h3><p>优点：<br>1）仿函数比函数指针的执行速度快，函数指针时通过地址调用，而仿函数是对运算符 operator 进行自定义来提高调用的效率。<br>2）仿函数比一般函数灵活，可以同时拥有两个不同的状态实体，一般函数不具备此种功能。<br>3）仿函数可以作为模板参数使用，因为每个仿函数都拥有自己的类型。<br>缺点：<br>1）需要单独实现一个类。<br>2）定义形式比较复杂。</p>
<h3 id="仿函数作用"><a href="#仿函数作用" class="headerlink" title="仿函数作用"></a>仿函数作用</h3><p>仿函数通常有下面四个作用：<br>1）作为排序规则，在一些特殊情况下排序是不能直接使用运算符&lt;或者&gt;时，可以使用仿函数。<br>2）作为判别式使用，即返回值为bool类型。<br>3）同时拥有多种内部状态，比如返回一个值得同时并累加。<br>4）作为算法 for_each 的返回值使用。</p>
<h2 id="8-【C-11】-std-function-与可调用对象"><a href="#8-【C-11】-std-function-与可调用对象" class="headerlink" title="8 【C++11】 std:: function 与可调用对象"></a>8 【C++11】 std:: function 与可调用对象</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p> #可调用对象</p>
<p><strong>对于一个对象或一个表达式，如果可以对其使用调用运算符（），则称它为可调用的。</strong> </p>
<blockquote>
<p>[!NOTE] 可调用对象<br><strong>可调用对象有四种：</strong></p>
<ol>
<li>函数</li>
<li>函数指针</li>
<li>重载了函数调用运算符的类 <code>operator()</code>, 即函数对象（仿函数）[[#7 函数对象（仿函数）与函数调用运算符<code>()</code>]]</li>
<li>lambda 表达式 [[#【C++11】lambda表达式]] </li>
<li>bind 创建的对象 [[2 STL标准库#【C++11】参数绑定 bind 函数]]  ^snr6wf</li>
</ol>
</blockquote>
<p>和其他对象一样，<strong>可调用的对象也有类型</strong>。例如，每个 lambda 有它自己唯一的（末命名)类类型：函数及函数指针的类型则由其返回值类型和实参类型决定，等等。</p>
<p>然而，<strong>不同类型的可调用对象却可能共享同一种调用形式</strong>。调用形式指明了调用返回的类型以及传递给调用的实参类型。<strong>一种调用形式对应一个函数类型</strong>，例如：<code>int (int,int)</code> 是一个函数类型，它接受两个 int、返回一个 int。</p>
<h3 id="不同类型的相同调用形式"><a href="#不同类型的相同调用形式" class="headerlink" title="不同类型的相同调用形式"></a>不同类型的相同调用形式</h3><p>对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">//lambda,其产生一个未命名的函数对象类</span></span><br><span class="line"><span class="keyword">auto</span> mod=[](<span class="type">int</span> i,<span class="type">int</span> j )&#123;<span class="keyword">return</span> i % j；&#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator,<span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式：<code>int (int,int)</code></p>
<blockquote>
<p>[!NOTE] 函数表</p>
<hr>
<p>我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个<strong>函数表</strong>用于<strong>存储指向这些可调用对象的“指针”</strong>。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p>
</blockquote>
<p>在 C++中，<strong>函数表很容易通过 map 来实现</strong>。</p>
<p>对于此例来说，我们<strong>使用一个表示运算符符号的 string 对象作为关键字</strong>; <strong>使用实现运算符的函数作为值</strong>。当我们需要求给定运算符的值时，先通过运算符索引 map，然后调用找到的那个元素。<br>假定我们的所有函数都相互独立，并且只处理关于 int 的二元运算，则 map 可以定义成如下的形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建从运算符到函数指针的映射关系，其中函数接受两个 int、返回一个 int</span></span><br><span class="line">map&lt;string, <span class="type">int</span>(*) (<span class="type">int</span> ,<span class="type">int</span>) &gt; binops;</span><br></pre></td></tr></table></figure>
<p>我们可以按照下面的形式将 add 的指针添加到 binops 中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确: add 是一个指向正确类型函数的指针</span></span><br><span class="line">binops.<span class="built_in">insert</span> (&#123; <span class="string">&quot;+&quot;</span>, add&#125;);</span><br></pre></td></tr></table></figure>
<p>但是我们不能将 mod 或者 divide 存入 binops。问题在于 mod 是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类型与存储在 binops 中的值的类型不匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binops.<span class="built_in">insert</span>( &#123;<span class="string">&quot;%&quot;</span>, mod&#125; ); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 function 标准库类型来解决这个问题。</p>
<h3 id="std-function-偏函数"><a href="#std-function-偏函数" class="headerlink" title="std:: function 偏函数"></a>std:: function 偏函数</h3><p>#function<br>又称偏函数（partial function）</p>
<ul>
<li><code>function</code> 就是<strong>可调用对象的封装器</strong>，可以把 <code>function</code> 看做一个函数对象，用于表示函数这个抽象概念。</li>
<li><code>function</code> 的<strong>实例</strong>可以存储、复制和调用任何可调用对象，存储的可调用对象称为 <code>function</code> 的目标，</li>
<li>若 <code>function</code> 不含目标，则称它为空，调用空的 <code>function</code> 的目标会抛出 <code>bad_function_call</code> 异常。</li>
</ul>
<p>常用function类型来定义函数表。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281019209.png" alt="Pasted image 20230221224156"></p>
<p>接着讨论上一节的例子。<br>在这里我们声明了一个 function 类型，它可以表示接受两个 int、返回一个 int 的可调用对象。因此，我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function&lt;返回值类型(参数一类型，参数二类型)&gt;</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;  <span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="type">int</span> (<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();  <span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="type">int</span> (<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123; <span class="keyword">return</span> i*j; &#125;; <span class="comment">//lambda</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>)&lt;&lt;end1:  <span class="comment">//打印6</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f2</span>(<span class="number">4</span>,<span class="number">2</span>)&lt;&lt;end1:  <span class="comment">//打印2</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f3</span>(<span class="number">4</span>,<span class="number">2</span>)&lt;&lt;end1;  <span class="comment">//打印8</span></span><br></pre></td></tr></table></figure>

<p>使用这个 function 类型可以重新定义 map：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列举了可调用对象与二元运算符对应关系的表格</span></span><br><span class="line"><span class="comment">//所有可调用对象都必须接受两个int、返回一个int</span></span><br><span class="line"><span class="comment">//其中的元素可以是函数指针、函数对象或者lambda</span></span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span> (<span class="type">int</span>, <span class="type">int</span>) &gt;&gt; binops;</span><br></pre></td></tr></table></figure>

<p>我们能把所有可调用对象都添加到这个 map 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,function&lt;<span class="type">int</span> (<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    &#123; <span class="string">&quot;+&quot;</span>, add &#125; ,</span><br><span class="line">    <span class="comment">//标准库函数对象</span></span><br><span class="line">    &#123; <span class="string">&quot;-&quot;</span>,std::<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt; ( )&#125;,</span><br><span class="line">    <span class="comment">//用户定义的函数对象</span></span><br><span class="line">    &#123; <span class="string">&quot;/ &quot;</span>,<span class="built_in">divide</span> ( ) &#125;,</span><br><span class="line">    <span class="comment">//未命名的 lambda&#123; &quot;%&quot;, mod&#125; </span></span><br><span class="line">    &#123;<span class="string">&quot;*&quot;</span>，[ ](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;),</span><br><span class="line">    <span class="comment">//命名了的lambda对象</span></span><br><span class="line">    &#123;<span class="string">&quot;%&quot;</span>,mod&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一如往常，当我们索引 map 时将得到关联值的一个引用。如果我们索引 binops，将得到 function 对象的引用。function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binops [<span class="string">&quot;+&quot;</span>](<span class="number">10</span>,<span class="number">5</span>);  <span class="comment">//调用 add (10，5)</span></span><br><span class="line">binops [<span class="string">&quot;-&quot;</span>](<span class="number">10</span>,<span class="number">5</span>) ; <span class="comment">//使用 minus&lt;int&gt;对象的调用运算符 </span></span><br><span class="line">binops [<span class="string">&quot;/&quot;</span>](<span class="number">10</span>,<span class="number">5</span>);   <span class="comment">//使用 divide 对象的调用运算符 </span></span><br><span class="line">binops [<span class="string">&quot;*&quot;</span>](<span class="number">10</span>,<span class="number">5</span>);   <span class="comment">//调用 lambda 函数对象</span></span><br><span class="line">binops [<span class="string">&quot;%&quot;</span>]( <span class="number">10</span>,<span class="number">5</span>) ; <span class="comment">//调用 lambda 函数对象</span></span><br></pre></td></tr></table></figure>
<p>我们依次调用了 binops 中存储的每个操作。在第一个调用中，我们获得的元素存放着一个指向 add 函数的指针, 因此调用 <code>binops [ &quot;+&quot;](10，5) </code>实际上是使用该指针调用 add, 并传入 10 和 5。在接下来的调用中, <code>binops[&quot;-&quot;]</code>返回一个存放着 <code>std::minus&lt;int&gt;</code>类型对象的 function，我们将执行该对象的调用运算符。</p>
<h3 id="重载的函数与-function"><a href="#重载的函数与-function" class="headerlink" title="重载的函数与 function"></a>重载的函数与 function</h3><p>我们不能（直接）将重载函数的名字存入 function 类型的对象中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123; <span class="keyword">return</span> i +j;&#125;</span><br><span class="line"><span class="function">sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> sales_data&amp;,<span class="type">const</span> sales_data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span> (<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>, add&#125;); <span class="comment">//错误:哪个add?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决上述二义性问题的一条途径是<strong>存储函数指针而非函数的名字</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp) (<span class="type">int</span>,<span class="type">int</span>) = add; <span class="comment">//指针所指的add是接受两个int的版本</span></span><br><span class="line">binops.<span class="built_in">insert</span>( &#123; <span class="string">&quot;+&quot;</span>,fp&#125; ); <span class="comment">//正确:fp指向一个正确的add版本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样，我们也能使用 lambda 来消除二义性:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确: 使用 lambda 来指定我们希望使用的 add 版本</span></span><br><span class="line">binops.<span class="built_in">insert</span> ( &#123; <span class="string">&quot;+&quot;</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> <span class="built_in">add</span> (a, b); &#125; &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="十一、命名空间"><a href="#十一、命名空间" class="headerlink" title="十一、命名空间"></a>十一、命名空间</h1><p>大型程序使用多个库，难免命名冲突，<strong>命名空间</strong>就是防止名字冲突的机制。<br><strong>命名空间分割了全局命名空间，其中每个命名空间是一个作用域</strong>。通过在某个命名空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p>
<h2 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h2><p>命名空间的定义包含两部分：关键字namespace和命名空间的名字<br>只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">		Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Query</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Query</span> base &#123;<span class="comment">/*...*/</span>)</span><br><span class="line">&#125;<span class="comment">//命名空间结束后无须分号，这一点与块类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在命名空间之外的代码必须指出所属命名空间</span></span><br><span class="line">cplusplus_primer::Query q = AddisonWesley::<span class="built_in">Query</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间可以是不连续的</span></span><br><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//可以为cplusplus_primer添加新的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h3><p>全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式的添加到全局命名空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::member_name  <span class="comment">//表示全局命名空间中的一个成员</span></span><br></pre></td></tr></table></figure>
<h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>顾名思义，在命名空间中定义命名空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//嵌套的命名空间：定义了库的Query部分</span></span><br><span class="line">		<span class="keyword">namespace</span> QueryLib</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Query</span> <span class="comment">/*...*/</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">cplusplus_primer::QueryLib::Query</span><br></pre></td></tr></table></figure>

<h3 id="【C-11】内联命名空间"><a href="#【C-11】内联命名空间" class="headerlink" title="【C++11】内联命名空间"></a>【C++11】内联命名空间</h3><p>和普通的嵌套命名空间不同，<strong>内联命名空间可以被外层命名空间直接使用</strong>。也就是说，我们无需在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间就可以直接访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//嵌套的命名空间：定义了库的Query部分</span></span><br><span class="line">		<span class="keyword">inline</span> <span class="keyword">namespace</span> QueryLib</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Query</span> <span class="comment">/*...*/</span>)</span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">		<span class="comment">//关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline,也可以不写：</span></span><br><span class="line">		<span class="keyword">namespace</span> QueryLib <span class="comment">//隐式内联</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//其他声明</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">cplusplus_primer::Query</span><br></pre></td></tr></table></figure>
<h3 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h3><p><strong>未命名的命名空间中定义的变量拥有静态生命周期</strong>：它们在第一次使用前创建，并且直到程序结束才销毁。<br>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。<br>每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。<br><strong>如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。</strong></p>
<blockquote>
<p>[!NOTE]<br>和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。</p>
</blockquote>
<p>定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名字来限定它们。同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。<br>未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;  <span class="comment">//i的全局声明</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 二义性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中。</span></span><br><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>其他情况下，未命名的命名空间中的成员都属于正确的程序实体。</p>
<p>一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> local</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">namespace</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//正确：定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同</span></span><br><span class="line"><span class="number">1</span>ocal::<span class="number">1</span>=<span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间成员"><a href="#命名空间成员" class="headerlink" title="命名空间成员"></a>命名空间成员</h2><h3 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a>命名空间的别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer; <span class="comment">//primer作为别名，更短更方便使用</span></span><br><span class="line"><span class="keyword">namespace</span> Qlib = cplusplus_primer::QueryLib; <span class="comment">//别名也可以指向一个嵌套的命名空间</span></span><br><span class="line">Qlib::Query q;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p>
</blockquote>
<h3 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h3><p>前文我们通过<code>cplusplus_primer::Query</code>这样的方式调用成员，更简便的方法使用命名空间的成员：<strong>using声明</strong>。</p>
<p>一条<strong>using声明</strong>语句一次只引入命名空间的一个成员。</p>
<p>一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin; <span class="comment">//有了using声明后续就无需使用前缀::了</span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="comment">//每个名字都需要独立的using声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		cin&gt;&gt;i;  <span class="comment">//正确：cin和std::cin含义相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>头文件不应包含using声明，因为头文件的内容会拷贝到所有引用它的文件中去,会造成名字冲突。</p>
</blockquote>
<h3 id="using指示（不要使用）"><a href="#using指示（不要使用）" class="headerlink" title="using指示（不要使用）"></a>using指示（不要使用）</h3><p>和using声明不同，using指示使得某个特定命名空间中所有的名字都可见。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间的名字;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常见的</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br></pre></td></tr></table></figure>
<p>using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。</p>
<h2 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h2><p>P708</p>
<h1 id="十二、异常处理"><a href="#十二、异常处理" class="headerlink" title="十二、异常处理"></a>十二、异常处理</h1><p>C++中异常处理包括：<br>throw表达式<br>try语句块<br>异常类</p>
<p>入门：p172<br>深入：P684</p>
<h2 id="【C-11】noexcept"><a href="#【C-11】noexcept" class="headerlink" title="【C++11】noexcept"></a>【C++11】noexcept</h2><p>#noexcept<br><code>noexcept</code> 通知标准库我们的构造函数不抛出任何异常，必须在类头文件中的声明和定义中（如果定义在类外的话）都指定 <code>noexcept</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp; ) <span class="keyword">noexcept</span>;<span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="comment">//其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line">    StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>:<span class="comment">/*成员初始化器*/</span></span><br><span class="line">    &#123; <span class="comment">/*构造函数体*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数使用 <code>noexcept</code> 关键字指定为不抛出异常，而实际上在运行时抛出了异常，程序将终止。</p>
<p>需要注意的是，使用 <code>noexcept</code> 不会阻止函数抛出异常，它只是提供了一种明确的标识，并可以在一些情况下提高代码的性能和可维护性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/60549.html">http://liuke101.github.io/post/60549.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/19081.html" title="PBR理论"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292357277.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PBR理论</div></div></a></div><div class="next-post pull-right"><a href="/post/23284.html" title="C#精粹"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C#精粹</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/60457.html" title="Effective C++"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="title">Effective C++</div></div></a></div><div><a href="/post/37796.html" title="STL标准库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="title">STL标准库</div></div></a></div><div><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">模板与泛型编程</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">零、预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%AC%A6"><span class="toc-text">头文件保护符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F-macro"><span class="toc-text">宏 macro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%AD%E8%A1%8C%E7%AC%A6"><span class="toc-text">续行符 \</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text"># 和 ##</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82%E5%AE%8F"><span class="toc-text">... 变参宏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1"><span class="toc-text">1 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%88%86%E9%85%8D"><span class="toc-text">栈分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%88%86%E9%85%8D"><span class="toc-text">堆分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">new操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F"><span class="toc-text">2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">初始化方式的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">默认初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-text">声明和定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">extern 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%85%B6%E5%AE%83%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0"><span class="toc-text">使用在其它文件中定义的全局变量&#x2F;函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-%E5%8F%98%E9%87%8F%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">const 变量多文件编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">const 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%8F%98%E9%87%8F"><span class="toc-text">const 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">const 变量与常量的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-text">常量引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-text">常量指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-text">指针常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-int-const"><span class="toc-text">const int* const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E3%80%81%E5%BA%95%E5%B1%82const"><span class="toc-text">顶层const、底层const</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">拷贝操作的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-text">const形参和实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91constexpr-%E5%8F%98%E9%87%8F"><span class="toc-text">【C++11】constexpr 变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">字面值类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91constexpr%E5%87%BD%E6%95%B0"><span class="toc-text">【C++11】constexpr函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constexpr%E6%8C%87%E9%92%88"><span class="toc-text">constexpr指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">mutable关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">inline 内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91using%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">【C++11】using类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">【C++11】auto类型说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-text">【C++11】decltype类型指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEenum"><span class="toc-text">枚举enum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E6%8C%87%E5%AE%9Aenum%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">【C++11】指定enum的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E"><span class="toc-text">【C++11】枚举类型的前置声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">枚举的定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%BA%94%E7%94%A8"><span class="toc-text">枚举应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-text">位域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">二、字符串和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-text">数组的特殊性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0begin%E5%92%8Cend"><span class="toc-text">【C++11】标准库函数begin和end</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%95%B0%E7%BB%84%E5%92%8C%E5%A0%86%E6%95%B0%E7%BB%84"><span class="toc-text">栈数组和堆数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-str"><span class="toc-text">c_str()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">C++ 字符串字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf"><span class="toc-text">printf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">三、表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC-lvalue-and-rvalue"><span class="toc-text">1 左值与右值 (lvalue and rvalue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2 递增递减运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%AD%E5%A4%B4%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3 箭头操作符-&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4 sizeof 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">5 强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E9%A3%8E%E6%A0%BC%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">c 风格强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret-cast"><span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-text">运行时类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeid%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">typeid运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-info-%E7%B1%BB"><span class="toc-text">type_info 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-text">类型转换函数（类型转换运算符）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">6 运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">四、控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-text">for</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%A4%B4%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="toc-text">语句头多重定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E8%AF%AD%E5%8F%A5%E5%A4%B4%E7%9A%84%E6%9F%90%E4%BA%9B%E9%83%A8%E5%88%86"><span class="toc-text">省略语句头的某些部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E8%8C%83%E5%9B%B4for"><span class="toc-text">【C++11】范围for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while"><span class="toc-text">do while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-text">break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue"><span class="toc-text">continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">五、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A9%BA%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-text">1 空形参列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-text">2 main 处理命令行选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3argc%E5%92%8Cargv"><span class="toc-text">深入理解argc和argv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E3%80%90C-11%E3%80%91-%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">3 【C++11】 含有可变形参的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initialize-list-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">initialize_list 初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82"><span class="toc-text">省略符形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E3%80%90C-11%E3%80%91%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">4 【C++11】尾置返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-text">5 默认实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">6 函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">使用函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-text">函数指针作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%A6%96%E5%85%88%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">为什么要首先使用函数指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%90C-11%E3%80%91lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">7【C++11】lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-text">捕获列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98lambda"><span class="toc-text">可变lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Alambda%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">指定lambda返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%90C-11%E3%80%91-bind-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text">8【C++11】 bind 参数绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-%E5%87%BD%E6%95%B0"><span class="toc-text">bind 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text">函数参数绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-function-%E7%B1%BB%E5%9E%8B%E8%81%94%E7%94%A8"><span class="toc-text">与 function 类型联用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">修正参数的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="toc-text">重排参数顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E5%87%BD%E6%95%B0%EF%BC%9A%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-text">ref 函数：绑定引用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind1st-%E5%92%8C-bind2nd"><span class="toc-text">bind1st () 和 bind2nd ()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP"><span class="toc-text">六、面向对象 OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E7%B1%BB"><span class="toc-text">0 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-text">类成员指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-text">数据成员指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">成员函数指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">成员指针函数表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%94%A8%E4%BD%9C%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">将成员函数用作可调用对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="toc-text">局部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="toc-text">嵌套的局部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union%E8%81%94%E5%90%88%E7%B1%BB"><span class="toc-text">union联合类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8Dunion"><span class="toc-text">匿名union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%AE%A1%E7%90%86union%E6%88%90%E5%91%98"><span class="toc-text">使用类管理union成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85"><span class="toc-text">1 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">成员访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E4%B8%8Estruct"><span class="toc-text">class与struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83friend"><span class="toc-text">友元friend</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">全局函数做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">类做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">成员函数做友元</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-text">2 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">继承与静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E9%98%B2%E6%AD%A2%E7%BB%A7%E6%89%BF-final"><span class="toc-text">【C++11】防止继承 final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E6%94%B9%E5%8F%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">using改变访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">类作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81"><span class="toc-text">名字冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9D%A5%E4%BD%BF%E7%94%A8%E9%9A%90%E8%97%8F%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">通过作用域运算符来使用隐藏的成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">函数调用的解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text">派生类的拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">派生类的拷贝或移动构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">派生类赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">派生类析构函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">继承的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">容器与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">虚继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-text">3 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">静态多态与动态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">静态类型与动态类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0virtual"><span class="toc-text">虚函数virtual</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%8E%9F%E7%90%86"><span class="toc-text">虚函数表原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91overide%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">【C++11】overide说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%B1%BB%EF%BC%89"><span class="toc-text">纯虚函数（接口类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E4%B8%8E%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-text">虚析构与纯虚析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-this%E6%8C%87%E9%92%88"><span class="toc-text">4 this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-static%E9%9D%99%E6%80%81"><span class="toc-text">5 static静态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-text">静态类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-text">什么是静态类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">（面向对象的）静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">（面向对象的）静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%EF%BC%89%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">（面向过程的）静态全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%EF%BC%89%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">（面向过程的）静态局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%EF%BC%89%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">（面向过程的）静态函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">6 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">类对象的初始化和析构顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">默认构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E6%9D%A5"><span class="toc-text">由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91-default"><span class="toc-text">【C++11】&#x3D;default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">【C++11】委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E9%9A%90%E5%BC%8F%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">转换构造函数（隐式类类型转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">explicit 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-text">聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-text">字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text">7 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">7.1 拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-text">拷贝构造函数调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">使用浅拷贝还是深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">7.2 拷贝赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">拷贝构造和拷贝赋值的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">7.3 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%94%80%E6%AF%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">析构函数销毁的是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-text">7.4 三&#x2F;五法则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%B3%95%E5%88%99"><span class="toc-text">三法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-text">五法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-text">7.6 阻止拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91-delete-%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-text">【C++11】 &#x3D;delete 删除函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="toc-text">声明为私有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">7.7 拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB"><span class="toc-text">行为像值的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB"><span class="toc-text">行为像指针的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%AD%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-text">自定义类中的swap函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E3%80%90C-11%E3%80%91%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8%EF%BC%88%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="toc-text">7.8 【C++11】对象移动（移动语义）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-move-%E5%87%BD%E6%95%B0"><span class="toc-text">std:: move 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">移动构造函数和移动赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%A7%BB%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-text">默认移动函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">移动迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">引用限定符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81IO-%E5%BA%93"><span class="toc-text">七、IO 库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IO-%E7%B1%BB"><span class="toc-text">1 IO 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="toc-text">2 管理输出缓冲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6-IO"><span class="toc-text">3 文件 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6ofstream"><span class="toc-text">写文件ofstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6ifstream"><span class="toc-text">读文件ifstream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-string-%E6%B5%81"><span class="toc-text">4 string 流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">5 格式控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text">八、动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">手动管理内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">new动态分配和初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text">delete释放动态内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%BB%86%E8%8A%82"><span class="toc-text">自定义内存分配细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete"><span class="toc-text">重载new和delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">定位 new 表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">【C++11】智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">通用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%8B%AC%E6%9C%89%E6%93%8D%E4%BD%9C"><span class="toc-text">shared_ptr独有操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr%E7%8B%AC%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">unique_ptr独的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr%E7%8B%AC%E6%9C%89%E6%93%8D%E4%BD%9C"><span class="toc-text">weak_ptr独有操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%B1%BB"><span class="toc-text">shared_ptr类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#make-shared%E5%87%BD%E6%95%B0"><span class="toc-text">make_shared函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">shared_ptr的拷贝和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">shared_ptr和new结合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96shared-ptr%E6%93%8D%E4%BD%9C"><span class="toc-text">其他shared_ptr操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91enable-shared-from-this"><span class="toc-text">【C++11】enable_shared_from_this</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-%EF%BC%9F"><span class="toc-text">为什么要用 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F"><span class="toc-text">什么时候用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%B0%86-this-%E6%8C%87%E9%92%88%E8%BF%94%E5%9B%9E%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85"><span class="toc-text">如何安全地将 this 指针返回给调用者?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">标准库中的源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">具体的代码示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E7%B1%BB"><span class="toc-text">unique_ptr类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">拷贝和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">转移对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr%E7%B1%BB"><span class="toc-text">weak_ptr类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-delete%E6%95%B0%E7%BB%84"><span class="toc-text">new&#x2F;delete数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E7%AE%A1%E7%90%86%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">unique_ptr管理动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocator%E7%B1%BB"><span class="toc-text">allocator类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">九、重载运算符与函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1 输入输出运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">输出运算符&lt;&lt;重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="toc-text">输入运算符&gt;&gt;重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2 算术和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C"><span class="toc-text">相等运算符 &#x3D;&#x3D; 和!&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3 赋值运算符&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">复合赋值运算符+&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4 下标运算符 []</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5 递增递减运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C"><span class="toc-text">6 成员访问运算符 * 和-&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%89%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">7 函数对象（仿函数）与函数调用运算符()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">STL 内置函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">算术类函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">关系运算类函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-text">逻辑运算类运算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">仿函数的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8"><span class="toc-text">仿函数作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E3%80%90C-11%E3%80%91-std-function-%E4%B8%8E%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">8 【C++11】 std:: function 与可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%90%8C%E8%B0%83%E7%94%A8%E5%BD%A2%E5%BC%8F"><span class="toc-text">不同类型的相同调用形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-function-%E5%81%8F%E5%87%BD%E6%95%B0"><span class="toc-text">std:: function 偏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E-function"><span class="toc-text">重载的函数与 function</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">十一、命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89"><span class="toc-text">命名空间定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">全局命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">嵌套命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91%E5%86%85%E8%81%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">【C++11】内联命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%91%BD%E5%90%8D%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">未命名的命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98"><span class="toc-text">命名空间成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-text">命名空间的别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%A3%B0%E6%98%8E"><span class="toc-text">using声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E6%8C%87%E7%A4%BA%EF%BC%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-text">using指示（不要使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">重载与命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">十二、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91noexcept"><span class="toc-text">【C++11】noexcept</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2024-08-07T17:01:13.127Z" title="发表于 2024-08-08 01:01:13">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28208.html" title="UE伤害系统">UE伤害系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28207.html" title="UE输入系统">UE输入系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>