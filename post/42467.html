<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HLSL ShaderLab | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ShaderLab 语法基础1 组织结构Shader 中可以编写多个子着色器（SubShader），但至少需要一个。 在应用程序运行过程中，GPU 会先检测第一个子着色器能否正常运行，如果不能正常运行就会再检测第二个，以此类推。假如当前 GPU 的硬件版本太旧，以至于所有的子着色器都无法正常运行时，则执行最后的回退（Fallback）命令，运行指定的一个基础着色器。 如果编写的是顶点-片元着色器（">
<meta property="og:type" content="article">
<meta property="og:title" content="HLSL ShaderLab">
<meta property="og:url" content="http://liuke101.github.io/post/42467.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="ShaderLab 语法基础1 组织结构Shader 中可以编写多个子着色器（SubShader），但至少需要一个。 在应用程序运行过程中，GPU 会先检测第一个子着色器能否正常运行，如果不能正常运行就会再检测第二个，以此类推。假如当前 GPU 的硬件版本太旧，以至于所有的子着色器都无法正常运行时，则执行最后的回退（Fallback）命令，运行指定的一个基础着色器。 如果编写的是顶点-片元着色器（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-09-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.367Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/42467.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HLSL ShaderLab',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HLSL ShaderLab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-18T16:00:00.000Z" title="发表于 2023-09-19 00:00:00">2023-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.367Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HLSL ShaderLab"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/42467.html#post-comment"><span class="waline-comment-count" data-path="/post/42467.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ShaderLab-语法基础"><a href="#ShaderLab-语法基础" class="headerlink" title="ShaderLab 语法基础"></a>ShaderLab 语法基础</h1><h2 id="1-组织结构"><a href="#1-组织结构" class="headerlink" title="1 组织结构"></a>1 组织结构</h2><p>Shader 中可以编写多个子着色器（SubShader），但至少需要一个。</p>
<p>在应用程序运行过程中，GPU 会先检测第一个子着色器能否正常运行，如果不能正常运行就会再检测第二个，以此类推。<br>假如当前 GPU 的硬件版本太旧，以至于所有的子着色器都无法正常运行时，则执行最后的回退（Fallback）命令，运行指定的一个基础着色器。</p>
<p><strong>如果编写的是顶点-片元着色器（Vertex-Fragment Shader），每个子着色器中还会包含一个甚至多个 Pass</strong>。在运行的过程中，如果某个子着色器能够在当前 GPU 上运行，那么该子着色器内的所有 Pass 会依次执行，每个 Pass 的输出的结果会以指定的方式与上一步的结果进行<strong>混合</strong>，最终输出。</p>
<p>如果编写的是表面着色器（Surface Shader），着色器的代码也是包含在子着色器中，但是与顶点-片元着色器不同的是，表面着色器不会再嵌套 Pass。系统在编译表面着色器的时候会自动生成多个对应的 Pass，最终编译出来的 Shader 本质上就是顶点-片元着色器。</p>
<h2 id="2-名称"><a href="#2-名称" class="headerlink" title="2 名称"></a>2 名称</h2><p>Shader 程序的第一行代码用来声明该 Shader 的名称以及所在路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/NewUnlitShader&quot;</span><br></pre></td></tr></table></figure>

<p>这一行代码的意思是：这个 Shader 位于 Unlit 路径里，名称为 NewUnlitShader。最终在材质设置面板中选择 Shader 的下拉菜单，如图<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049694.png" alt="Pasted image 20230614182320|450"></p>
<p>当然也可以多加几级路径，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Path_1/Path_2/NewUnlitShader&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3-Properties"><a href="#3-Properties" class="headerlink" title="3 Properties"></a>3 Properties</h2><p>Unity Shader 的属性主要分为三大类：数值、颜色和向量、纹理贴图</p>
<figure class="highlight c"><figcaption><span>title:所有类型属性汇总</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Integer ( <span class="string">&quot;Integer&quot;</span>,Integer) = <span class="number">1</span>           <span class="comment">//真正的整数，但好像不能用？</span></span><br><span class="line">    _Int ( <span class="string">&quot;Int&quot;</span>,Int) = <span class="number">1</span>                       <span class="comment">//编译时转换为浮点类型</span></span><br><span class="line">    _Float ( <span class="string">&quot;Float&quot;</span>,Float) = <span class="number">1.5</span>               <span class="comment">//浮点类型</span></span><br><span class="line">    _Range ( <span class="string">&quot;Range&quot;</span> , Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span>       <span class="comment">//范围类型，也是float</span></span><br><span class="line">    _Color(<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    _Vector (<span class="string">&quot;Vector&quot;</span>, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    _Texture2D (<span class="string">&quot;Texture2D&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">    _Texture2DArray (<span class="string">&quot;Texture2DArray&quot;</span>, <span class="number">2</span>DArray) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">    _Texture3D (<span class="string">&quot;Texture3D&quot;</span>, <span class="number">3</span>D) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">    _Cubemap (<span class="string">&quot;Cubemap&quot;</span>, Cube) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">    _CubemapArray (<span class="string">&quot;CubemapArray&quot;</span>, CubeArray) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 URP 中声明对应变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line"><span class="type">int</span> _Int;</span><br><span class="line"><span class="type">float</span> _Float;</span><br><span class="line"><span class="type">float</span> _Range;</span><br><span class="line">float4 _Color;</span><br><span class="line">float4 _Vector;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line"><span class="title function_">TEXTURE2D</span><span class="params">(_Texture2D)</span>;</span><br><span class="line">SAMPLER(sampler_Texture2D);</span><br><span class="line">TEXTURE2D_ARRAY_FLOAT(_Texture2DArray);</span><br><span class="line">SAMPLER(sampler_Texture2DArray);</span><br><span class="line">TEXTURE3D(_Texture3D);</span><br><span class="line">SAMPLER(sampler_Texture3D);</span><br><span class="line">TEXTURECUBE(_Cubemap);</span><br><span class="line">SAMPLER(sampler_Cubemap);</span><br><span class="line">TEXTURECUBE_ARRAY(_CubemapArray);</span><br><span class="line">SAMPLER(sampler_CubemapArray);</span><br></pre></td></tr></table></figure>
<h4 id="颜色和向量属性"><a href="#颜色和向量属性" class="headerlink" title="颜色和向量属性"></a>颜色和向量属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Color(<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">_Vector (<span class="string">&quot;Vector&quot;</span>, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>使用给定 RGBA 分量的默认值定义颜色属性，或使用默认值定义 4D 矢量属性。颜色属性会显示拾色器，并根据颜色空间按需进行调整。矢量属性显示为四个数字字段。</p>
<p>有一点需要注意的是：用 Photoshop 处理图片一般会使用8位深度图，每个通道的亮度最大值为 $2^8&#x3D;256$，由于从 $0$ 开始计算，因此数值范围是 $[0，255]$。<br>而<strong>在 Shader 中，每个分量的数值范围是 $[0,1]$</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049695.png" alt="Pasted image 20230614183329|500"></p>
<h4 id="纹理贴图属性"><a href="#纹理贴图属性" class="headerlink" title="纹理贴图属性"></a>纹理贴图属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Texture2D (<span class="string">&quot;Texture2D&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">_Texture2DArray (<span class="string">&quot;Texture2DArray&quot;</span>, <span class="number">2</span>DArray) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">_Texture3D (<span class="string">&quot;Texture3D&quot;</span>, <span class="number">3</span>D) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">_Cubemap (<span class="string">&quot;Cubemap&quot;</span>, Cube) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br><span class="line">_CubemapArray (<span class="string">&quot;CubemapArray&quot;</span>, CubeArray) = <span class="string">&quot;&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>（1）2D 属性是纹理类属性中最常使用的，漫反射贴图、法线贴图等都属于 2D 类型。2D<br>（2）Cube 全称 Cube map texture（立方体纹理），是由前、后、左、右、上、下 6 张有联系的 2D 贴图拼成的立方体，主要用作反射，例如 Skybox 和 Reflection Prob。<br>（3）3D 纹理只能被脚本创建</p>
<p>2D 类型的属性，默认值可以为空字符串，也可以是内置的表示颜色的字符串：<code>“white”（RGBA: 1，1，1，1）</code>，<code>“black”（RGBA：0，0，0，0）</code>，<code>“gray”（RGBA：0.5，0.5，0.5，0.5）</code>，<code>“bump”（RGBA：0.5，0.5，1，0.5）</code> 和 <code>“red”（RGBA：1，0，0，0）</code>。<br>至于非2D 类型的属性（Cube，3D，2DArray），默认值为空字符串。当材质没有指定 Cubemap 或者3D 或者2DArray 纹理的时候，会默认使用 <code>gray（RGBA：0.5，0.5，0.5，0.5）</code>。</p>
<p>**注意：这些默认纹理在 Inspector 中不可见。</p>
<blockquote>
<p>[!info] 纹理贴图类的属性最后都有一对空的花括号<br>这是因为在 Unity 5.0 之前的版本，纹理属性可以在花括号内添加选项，用于控制固定函数纹理坐标的生成。但是<strong>该功能在 Unity 5.0 及以后的版本中已经被移除，所以无须考虑这个问题，直接加上一对空的花括号即可。</strong></p>
</blockquote>
<h4 id="特殊纹理属性"><a href="#特殊纹理属性" class="headerlink" title="特殊纹理属性"></a>特殊纹理属性</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纹理属性的 Tiling 和 Offset 字段</span></span><br><span class="line">float4 &#123;TextureName&#125;_ST</span><br><span class="line"><span class="comment">//#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理的纹素大小信息</span></span><br><span class="line"><span class="comment">//x 1.0/宽度</span></span><br><span class="line"><span class="comment">//y 1.0/高度</span></span><br><span class="line"><span class="comment">//z宽度</span></span><br><span class="line"><span class="comment">//w高度</span></span><br><span class="line">float4 &#123;TextureName&#125;_TexelSize</span><br><span class="line"><span class="comment">//half2 offs = _MainTex_TexelSize.xy * half2(1,0) *  _BlurSize;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理 HDR 参数</span></span><br><span class="line">float4 &#123;TextureName&#125;_HDR <span class="comment">//和DecodeHDR有关？</span></span><br></pre></td></tr></table></figure>

<h4 id="颜色空间和颜色-矢量着色器数据"><a href="#颜色空间和颜色-矢量着色器数据" class="headerlink" title="颜色空间和颜色&#x2F;矢量着色器数据"></a>颜色空间和颜色&#x2F;矢量着色器数据</h4><p>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/LinearLighting.html">线性颜色空间</a>时，所有材质颜色属性均以 sRGB 颜色提供，但在传递到着色器时会转换为线性值。</p>
<p>例如，如果 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Properties.html">Properties</a> 着色器代码块包含名为“_MyColor“的 <code>Color</code> 属性，则相应的”_MyColor”HLSL 变量将获得线性颜色值。</p>
<p>对于标记为 <code>Float</code> 或 <code>Vector</code> 类型的属性，默认情况下不进行颜色空间转换；而是假设它们包含非颜色数据。<strong>可为浮点&#x2F;矢量属性添加 <code>[Gamma]</code> 特性，以表示它们是以 sRGB 空间指定，就像颜色一样（请参阅<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Properties.html">属性</a>）。</strong></p>
<h4 id="如何向着色器提供属性值"><a href="#如何向着色器提供属性值" class="headerlink" title="如何向着色器提供属性值"></a>如何向着色器提供属性值</h4><p>在下列位置中查找着色器属性值并提供给着色器：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a> 中设置的每渲染器值。这通常是“每实例”数据（例如，全部共享相同材质的许多对象的自定义着色颜色）。</li>
<li>在渲染的对象上使用的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/class-Material.html">材质</a>中设置的值。</li>
<li>全局着色器属性，通过 Unity 渲染代码自身设置（请参阅<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-UnityShaderVariables.html">内置着色器变量</a>），或通过您自己的脚本来设置（例如 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/ScriptReference/Shader.SetGlobalTexture.html">Shader.SetGlobalTexture</a>）。</li>
</ul>
<p>优先顺序如上所述：</p>
<ol>
<li>每实例数据覆盖所有内容</li>
<li>然后使用材质数据</li>
<li>最后，如果这两个地方不存在着色器属性，则使用全局属性值。</li>
<li>最终，如果在任何地方都没有定义着色器属性值，则将提供“默认值”（浮点数的默认值为零，颜色的默认值为黑色，纹理的默认值为空的白色纹理）。</li>
</ol>
<h2 id="4-SubShader"><a href="#4-SubShader" class="headerlink" title="4 SubShader"></a>4 SubShader</h2><figure class="highlight cs"><figcaption><span>title:SubShader的大致结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//标签</span></span><br><span class="line">    Tags &#123; <span class="string">&quot;TagName1&quot;</span> = <span class="string">&quot;valuel&quot;</span> <span class="string">&quot;TagName2&quot;</span> = <span class="string">&quot;value2&quot;</span> ...&#125;</span><br><span class="line">    <span class="comment">//渲染状态</span></span><br><span class="line">    Cull Back</span><br><span class="line"></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一个 Pass</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第二个 Pass</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Unity 中，每一个 Shader 都会包含至少一个 SubShader。当 Unity 想要显示一个物体的时候，它就会去检测这些 SubShader，然后选择第一个能够在当前显卡运行的 SubShader。<br><strong>每个 SubShader 都可以设置一个或者多个标签（Tags）和渲染状态（States），然后定义至少一个 Pass</strong>。在 SubShader 中设置的渲染状态会影响到该 SubShader 中所有的 Pass，如果想要某些状态不影响其他 Pass，<strong>可以针对某个 Pass 单独设置渲染状态。但是需要注意的是，部分渲染状态在 Pass 中并不支持。</strong></p>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-SubShaderTags.html">ShaderLab：向子着色器分配标签 - Unity 手册 (unity3d.com)</a></p>
<blockquote>
<p>[!bug]<br>本节介绍的Tags仅可以在 SubShader 中声明，不可以在 Pass 块中声明。Pass 块有其独有的 Tags</p>
</blockquote>
<p>SubShader 通过标签来<strong>确定什么时候以及如何对物体进行渲染。</strong></p>
<p>标签通过<strong>键值对</strong>的形式进行声明，并且没有使用数量的限制。如果有需要，可以使用任意多个标签。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;ExampleShader&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line">    SubShader </span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalRenderPipeline&quot;</span></span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">            <span class="string">&quot;DisableBatching&quot;</span> = <span class="string">&quot;True&quot;</span> </span><br><span class="line">            <span class="string">&quot;ForceNoShadowCasting&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">            <span class="string">&quot;PreviewType&quot;</span> = <span class="string">&quot;Plane&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Pass </span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RenderPipeline"><a href="#RenderPipeline" class="headerlink" title="RenderPipeline"></a>RenderPipeline</h4><p>向 Unity 告知子着色器是否与通用渲染管线 (URP) 或高清渲染管线 (HDRP) 兼容，Built-in 管线中没有这个标签。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UniversalRenderPipeline</td>
<td align="left">此子着色器仅与 URP 兼容</td>
</tr>
<tr>
<td align="left">HighDefinitionRenderPipeline</td>
<td align="left">此子着色器仅与 HDRP 兼容</td>
</tr>
<tr>
<td align="left">任何其他值或未声明</td>
<td align="left">此子着色器与 URP 和 HDRP 不兼容。</td>
</tr>
</tbody></table>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><strong>渲染队列</strong>是确定 Unity 渲染顺序的因素之一。</p>
<table>
<thead>
<tr>
<th align="left">队列名称</th>
<th align="left"><strong>功能</strong></th>
<th align="left">队列号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Background</td>
<td align="left">指定背景渲染队列。最先执行渲染﹐一般用来渲染天空盒 (Skybox)或者背景</td>
<td align="left">1000</td>
</tr>
<tr>
<td align="left">Geometry</td>
<td align="left">指定几何体渲染队列。非透明的几何体通常使用这个队列, 当没有声明渲染队列的时候，Unity 会默认使用这个队列</td>
<td align="left">2000</td>
</tr>
<tr>
<td align="left">AlphaTest</td>
<td align="left">Alpha 测试的几何体会使用这个队列, 之所以从 Geometry 队列单独拆分出来，是因为当所有实体都绘制完之后再绘制 Alpha 测试会更高效</td>
<td align="left">2450</td>
</tr>
<tr>
<td align="left">Transparent</td>
<td align="left">在这个队列的几何体按由远及近的顺序进行绘制, 所有进行 Alpha 混合的几何体都应该使用这个队列, 例如玻璃材质、粒子特效等</td>
<td align="left">3000</td>
</tr>
<tr>
<td align="left">Overlay</td>
<td align="left">用来叠加渲染的效果，例如镜头光晕等, 放在最后渲染</td>
<td align="left">4000</td>
</tr>
</tbody></table>
<p>除了使用 Unity 预定义的渲染队列，使用者也可以自己指定一个队列，例如：<br><code>Tags &#123; &quot;Queue&quot; = &quot;Geometry+1&quot; &#125;</code><br>这个队列的队列号其实就是 2001，表示在所有的非透明几何体绘制完成之后再进行绘制。<br>使用自定义的渲染队列在某些情况下非常有用，例如：透明的水应该在所有不透明几何体之后，透明几何体之前被绘制，所以透明水的渲染队列一般会使用<code>&quot;Queue&quot;=&quot;Transparent-1&quot;</code>。</p>
<h4 id="RenderType"><a href="#RenderType" class="headerlink" title="RenderType"></a>RenderType</h4><p><strong>URP 可以自定义 Shader RenderType 标签的值</strong><br>在基于 SRP 的渲染管线中，可以使用 <code>RenderStateBlock</code> 结构覆盖在 Shader 对象中定义的渲染状态。可以使用 <code>RenderType</code> 标签的值标识要覆盖的子着色器。 ^d4529f</p>
<p>在内置渲染管线中，可以使用一种称为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ShaderReplacement.html">着色器替换</a>的技术在运行时交换子着色器。此技术的工作方式是标识具有匹配 <code>RenderType</code> 标签值的子着色器。这在某些情况下用于生成<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-CameraDepthTexture.html">摄像机的深度纹理</a>。</p>
<table>
<thead>
<tr>
<th align="left">类型名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Opaque</td>
<td align="left">用于普通 Shader, 例如: 不透明、自发光、反射、地形 Shader</td>
</tr>
<tr>
<td align="left">Transparent</td>
<td align="left">用于半透明 Shader, 例如: 透明﹑粒子</td>
</tr>
<tr>
<td align="left">TransparentCutout</td>
<td align="left">用于透明测试 Shader, 例如: 植物叶子</td>
</tr>
<tr>
<td align="left">Background</td>
<td align="left">用于 Skybox Shader</td>
</tr>
<tr>
<td align="left">Overlay</td>
<td align="left">用于 GUI 纹理、Halo、 Flare Shader</td>
</tr>
<tr>
<td align="left">TreeOpaque</td>
<td align="left">用于地形系统中的干</td>
</tr>
<tr>
<td align="left">TreeTransparentCutout</td>
<td align="left">用于地形系统中的树叶</td>
</tr>
<tr>
<td align="left">TreeBillboard</td>
<td align="left">用于地形系统中的 Billboarded 树</td>
</tr>
<tr>
<td align="left">Grass</td>
<td align="left">用于地形系统中的草</td>
</tr>
<tr>
<td align="left">GrassBillboard</td>
<td align="left">用于地形系统中的 Billboarded 草</td>
</tr>
</tbody></table>
<blockquote>
<p>适用于Built-in 管线下的标签</p>
</blockquote>
<h4 id="禁用动态批处理"><a href="#禁用动态批处理" class="headerlink" title="禁用动态批处理"></a>禁用动态批处理</h4><p>动态批处理会将所有几何体都变换为世界空间，这意味着着色器程序无法再访问模型空间。因此，依赖于模型空间的着色器程序不会正确渲染。为避免此问题，请使用此子着色器标签阻止 Unity 应用动态批处理。</p>
<p>开启 <code>DisableBatching</code> 可以禁用动态批处理<br>禁用批处理标签有三个数值可以使用：<br>（1）”DisableBatching”&#x3D;”True”：总是禁用批处理。<br>（2）”DisableBatching”&#x3D;”False”：不禁用批处理，这是默认数值。<br>（3）”DisableBatching”&#x3D;”LODFading”：当 LOD 效果激活的时候才会禁用批处理，主要用于地形系统上的树。</p>
<h4 id="禁止阴影投射"><a href="#禁止阴影投射" class="headerlink" title="禁止阴影投射"></a>禁止阴影投射</h4><p>阻止子着色器中的几何体投射（有时是接收）阴影。确切行为取决于渲染管线和渲染路径。<br>如果使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/SL-ShaderReplacement.html">着色器替换</a>，但是不希望从其他子着色器继承阴影通道，这可能非常有用。<br>&#96;”ForceNoShadowCasting” &#x3D; “True”&#x2F;“False”</p>
<h4 id="忽略-Projector"><a href="#忽略-Projector" class="headerlink" title="忽略 Projector"></a>忽略 Projector</h4><p><strong>此标签只适用于 Built-in 渲染管线，在其他渲染管线中无效。</strong><br>如果不希望物体受到 Projector（投影机）的投射，可以在 Shader 中添加 <code>IgnoreProjector</code> 标签。它有两个数值可以使用：”True”和”False”，分别为忽略投射机和不忽略投射机。一般半透明的 Shader 都会开启这个标签。</p>
<h4 id="PreviewType"><a href="#PreviewType" class="headerlink" title="PreviewType"></a>PreviewType</h4><p>Unity 编辑器用于显示使用此子着色器的<strong>材质预览的形状</strong>。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>球体</td>
<td>在球体上显示材质。这是默认值。</td>
</tr>
<tr>
<td>平面 (Plane)</td>
<td>在平面上显示材质。</td>
</tr>
<tr>
<td>Skybox</td>
<td>在天空盒上显示材质。</td>
</tr>
</tbody></table>
<h3 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h3><h4 id="自定义名称"><a href="#自定义名称" class="headerlink" title="自定义名称"></a>自定义名称</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br><span class="line">&#123;</span><br><span class="line">    Name  <span class="string">&quot;mypass&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个名称，我们可以使用 ShaderLab 的 <code>UsePass</code> 命令来直接<strong>使用其他 Unity Shader 中的 Pass</strong>，提高代码复用性。例如:<br><code>UsePass &quot;MyShader/MYPASSNAME&quot;</code></p>
<blockquote>
<p>[!warning] Title</p>
<ol>
<li>在内部，Unity 将名称转换为大写。在 ShaderLab 代码中引用名称时，必须使用大写变体；例如，如果值是 “example”，您必须使用 EXAMPLE 进行引用。</li>
<li>如果同一个子着色器中有多个 Pass 具有相同的名称，则 Unity 使用代码中的第一个 Pass</li>
</ol>
</blockquote>
<p><strong>注意</strong>：在基于可编程渲染管线的渲染管线中，您可以使用 <code>RenderStateBlock</code> 来更改 GPU 上的渲染状态，而无需单独的通道。</p>
<h4 id="Pass-专用-Tags"><a href="#Pass-专用-Tags" class="headerlink" title="Pass 专用 Tags"></a>Pass 专用 Tags</h4><p>Pass 也可以设置标签，但和 SubShader 不同。</p>
<p><strong>还可以使用自定义值创建自己的自定义通道标签，并从 C# 代码访问它们。</strong></p>
<h5 id="LightMode"><a href="#LightMode" class="headerlink" title="LightMode"></a>LightMode</h5><p><code>LightMode</code>（灯光模式）标签定义了 Pass 在光照渲染流水线中的渲染规则，确定是否在给定帧期间执行该通道，在该帧期间 Unity 何时执行该通道，以及 Unity 对输出执行哪些操作。</p>
<blockquote>
<p>[!NOTE] Title<br>LightMode 标签与 Light 组件的 LightMode 无关</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-shaders/urp-shaderlab-pass-tags.html">URP ShaderLab Pass tags | Universal RP | 14.0.8 — URP ShaderLab Pass标记|通用RP | 14.0.8 (unity3d.com)</a></p>
<p><strong>URP 前向渲染管线 LigtMode：</strong></p>
<table>
<thead>
<tr>
<th align="left">标签值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UniversalForward</td>
<td align="left">渲染对象并评估所有灯光贡献。URP在前向渲染路径中使用此标记值。</td>
</tr>
<tr>
<td align="left">Universal2D</td>
<td align="left">渲染对象并评估2D灯光贡献。URP在 2D Renderer 中使用此标记值。</td>
</tr>
<tr>
<td align="left">ShadowCaster</td>
<td align="left">将光源透视图中的深度信息渲染到到ShadowMap或Depth Texture</td>
</tr>
<tr>
<td align="left">DepthOnly</td>
<td align="left">仅将摄像机透视图中的深度信息渲染到 Depth Texture 中</td>
</tr>
<tr>
<td align="left">Meta</td>
<td align="left">仅在“Unity 编辑器”中烘焙光照贴图时执行此过程。Unity 在构建播放器时从着色器中删除此 Pass</td>
</tr>
<tr>
<td align="left">SRPDefaultUnlit</td>
<td align="left">使用此 LightMode 标记值可以在渲染对象时绘制额外的 Pass。应用示例：绘制对象轮廓。此标记值对“正向渲染路径”和“延迟渲染路径”都有效。<strong>当通行证没有 LightMode 标记时，URP 使用此标记值作为默认值。</strong></td>
</tr>
</tbody></table>
<p><strong>URP延迟渲染管线LightMode</strong>：UniversalGBuffer、UniversalForwardOnly、DepthNormalsOnly</p>
<p><strong>Built-in 的 LightMode</strong>：在内置渲染管线中，如果不设置 <code>LightMode</code> 标签，Unity 会在没有任何光照或阴影的情况下渲染通道；这本质上相当于 <code>LightMode</code> 的值为 <code>Always</code>。</p>
<blockquote>
<p>Unity 创建的 Unlit 材质就是没有指定 LightMode 的，在 SRP 中，旧的着色器大部分基本不能再使用，但没有光照的内置着色器 Unlit 被保留了下来，可以使用 <code>SRPDefaultUnlit</code> 值来引用没有 LightMode 标签的通道。</p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049696.png" alt="Pasted image 20230615142758"></p>
<h5 id="UniversalMaterialType"><a href="#UniversalMaterialType" class="headerlink" title="UniversalMaterialType"></a>UniversalMaterialType</h5><p>Unity在URP延迟渲染路径中使用Tag。</p>
<h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>Fallback 在所有 SubShader 之后进行定义。当所有的 SubShader 都不能在当前显卡上运行的时候，就会运行 Fallback 定义的 Shader。它的语法如下：<br><code>Fallback &quot;name&quot;</code><br>最常用于 Fallback 的 Shader 为 Unity 内置的 Diffuse。<br>如果觉得某些 Shader 肯定可以在目标显卡上运行，没有指定 Fallback 的必要，可以使用 Fallback Off 关闭 Fallback 功能，或者直接什么都不写。</p>
<h3 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h3><p>LOD：Level of Detail<br><strong>shader 的 LOD 和模型的 LOD 作用不同！shader 的 LOD 只是用来选择 SubShader 的</strong><br>作用：unity 引擎会根据不同的 LOD 值在使用不同的 SubShader  </p>
<p>Unity 选择对应的 Subshader 会<strong>从上往下寻找第一个小于等于  <code>shader.maximumLOD</code>  值的 SubShader</strong>。</p>
<blockquote>
<p>[!bug]<br>在 Shader 代码块中，<strong>必须将子着色器按 LOD 降序排列</strong>。例如，如果您有 LOD 值为 200、100 和 500 的子着色器，则必须先放置 LOD 值为 500 的子着色器，然后是 LOD 值为 200 的子着色器，然后是 LOD 值为 100 的子着色器。这是因为 Unity 选择所找到的第一个有效子着色器，所以如果它首先找到一个 LOD 较低的子着色器，它将始终使用它。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    LOD <span class="number">600</span> <span class="comment">// LOD这里设置为600</span></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    ...</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    LOD <span class="number">500</span> <span class="comment">// LOD这里设置为500</span></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    ...</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    LOD <span class="number">400</span> <span class="comment">// LOD这里设置为400</span></span><br><span class="line">    </span><br><span class="line">    CGPROGRAM</span><br><span class="line">    ...</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过脚本调整 <code>shader.maximumLOD</code></p>
<p><code>Shader.maximumLOD</code>：控制单个 shader 的最大 LOD<br><code>Shader.globalMaximumLOD</code>：控制全部 shader 的最大 LOD</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LODCtrl</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shader shader;<span class="comment">//将Shader拖进来即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="keyword">this</span>.shader.maximumLOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前这个shader最大的LOD_value;</span></span><br><span class="line">            <span class="keyword">this</span>.shader.maximumLOD = <span class="number">600</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.B))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.shader.maximumLOD = <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.C))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.shader.maximumLOD = <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）运行，查看效果，通过按 ABC 按键，修改 maximumLOD 的值。查看 Cube 颜色的变化。</p>
<h2 id="5-命令"><a href="#5-命令" class="headerlink" title="5 命令"></a>5 命令</h2><h3 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h3><p>在 Pass 代码块中使用这些命令可为该 Pass 设置渲染状态，或者在 SubShader 代码块中使用这些命令可为该 SubShader 以及其中的所有 Pass 设置渲染状态。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-AlphaToMask.html">AlphaToMask</a>：设置 alpha-to-coverage 模式。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Blend.html">Blend</a>：启用和配置 alpha 混合。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-BlendOp.html">BlendOp</a>：设置 Blend 命令使用的操作。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ColorMask.html">ColorMask</a>：设置颜色通道写入掩码。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Conservative.html">Conservative</a>：启用和禁用保守光栅化。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Cull.html">Cull</a>：设置多边形剔除模式。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Offset.html">Offset</a>：设置多边形深度偏移。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-Stencil.html">Stencil</a>：配置模板测试，以及向模板缓冲区写入的内容。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ZClip.html">ZClip</a>：设置深度剪辑模式。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ZTest.html">ZTest</a>：设置深度测试模式。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ZWrite.html">ZWrite</a>：设置深度缓冲区写入模式。</li>
</ul>
<p><strong>常用：</strong></p>
<table>
<thead>
<tr>
<th align="left">渲染状态</th>
<th align="left">数值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cull</td>
<td align="left">Cull Back&#x2F;Front&#x2F; Off</td>
<td align="left">设置多边形的剔除方式, 有背面剔除、正面剔除、不剔除﹐默认为 Back</td>
</tr>
<tr>
<td align="left">ZTest</td>
<td align="left">ZTest (Less&#x2F;Greater&#x2F;LEqual&#x2F;GEqual&#x2F;Equal&#x2F;NotEquall &#x2F;Always)</td>
<td align="left">设置深度测试的对比方式, 默认为 LEqual</td>
</tr>
<tr>
<td align="left">ZWrite</td>
<td align="left">ZWrite On&#x2F; Off</td>
<td align="left">设置是否写入深度缓存, 默认为 On</td>
</tr>
<tr>
<td align="left">Blend</td>
<td align="left">Blend  sourceBlendMode  destBlendMode</td>
<td align="left">设置渲染图像的混合方式</td>
</tr>
<tr>
<td align="left">ColorMask</td>
<td align="left">ColorMask RGB&#x2F;A&#x2F;0&#x2F;或者 R、G、B、A 的任意组合</td>
<td align="left">设置颜色通道的写入蒙版﹐默认蒙版为 RGBA, 当设置为 0 时, 则无法写入任何颜色</td>
</tr>
</tbody></table>
<h3 id="通道命令"><a href="#通道命令" class="headerlink" title="通道命令"></a>通道命令</h3><p>在 SubShader 中使用这些命令可定义具有特定用途的通道。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-UsePass.html">UsePass</a> 定义一个通道，它从另一个 Shader 对象导入指定的通道的内容。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-GrabPass.html">GrabPass</a> 创建一个通道，将屏幕内容抓取到纹理中，以便在之后的通道中使用。</li>
</ul>
<h3 id="使用-Category-代码块对命令进行分组"><a href="#使用-Category-代码块对命令进行分组" class="headerlink" title="使用 Category 代码块对命令进行分组"></a>使用 Category 代码块对命令进行分组</h3><p>使用 <strong>Category</strong> 代码块可对设置渲染状态的命令进行分组，这样您可以“继承”该代码块内的分组渲染状态。</p>
<p>例如，您的 Shader 对象可能有多个子着色器，每个都需要混合设置为加法。可以如下所示使用 Category 代码块：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;example&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line">    Category </span><br><span class="line">    &#123;</span><br><span class="line">        Blend One One</span><br><span class="line">        </span><br><span class="line">        SubShader </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SubShader </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Unity-中的-HLSL"><a href="#Unity-中的-HLSL" class="headerlink" title="Unity 中的 HLSL"></a>Unity 中的 HLSL</h1><h2 id="HLSL-预处理器指令"><a href="#HLSL-预处理器指令" class="headerlink" title="HLSL 预处理器指令"></a>HLSL 预处理器指令</h2><h3 id="着色器阶段"><a href="#着色器阶段" class="headerlink" title="着色器阶段"></a>着色器阶段</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex &lt;name&gt;    //编译具有给定名称的函数作为顶点着色器</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment &lt;name&gt;  //编译具有给定名称的函数作为片元着色器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译具有给定名称的函数作为几何体着色器，此选项自动打开 #pragma require geometry</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> geometry &lt;name&gt;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译具有给定名称的函数作为DirectX 11外壳着色器，此选项自动打开 #pragma require tessellation</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> hull &lt;name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译具有给定名称的函数作为DirectX 11域着色器。此选项自动打开 #pragma require tessellation</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> domain &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="shader-mode"><a href="#shader-mode" class="headerlink" title="shader mode"></a>shader mode</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-ShaderCompileTargets.html">Targeting shader models and GPU features in HLSL - Unity 手册 — 针对HLSL-Unity中的着色器模型和GPU功能手册 (unity3d.com)</a></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> target &lt;value&gt;  //此着色器程序兼容的最小着色器模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> require &lt;value&gt; //此着色器兼容的最低GPU功能</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> instancing_options &lt;options&gt; //启用GPU Instancing</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br></pre></td></tr></table></figure>

<h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><p>参数后被冒号隔开并且全部大写的关键词就是语义。<br>输入和输出变量需要通过<strong>语义</strong>来表明其意图</p>
<h3 id="顶点着色器输入语义"><a href="#顶点着色器输入语义" class="headerlink" title="顶点着色器输入语义"></a>顶点着色器输入语义</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049697.png" alt="Pasted image 20230614195139"><br>当顶点信息包含的元素少于顶点着色器输入所需要的元素时，<strong>缺少的部分会被 0 填充，而 w 分量会被 1 填充</strong>。例如：顶点的 UV 坐标通常是二维向量，只包含 x 和 y 元素。如果输入的语义 TEXCOORD0 被声明为 float4 类型，那么顶点着色器最终获取到的数据将变成（x，y，0，1）。</p>
<blockquote>
<p>[!NOTE] 数据来源：MeshRender<br>填充到这些语义中的数据由使用该材质的 MeshRender 组件提供，每帧调用 DrawCall 的时候，MeshRender 组件会把它负责渲染的模型数据发送给 UnityShader。</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器输入结构</span></span><br><span class="line"><span class="keyword">struct</span> Attributes</span><br><span class="line">&#123;</span><br><span class="line">    float4 positionOS : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="顶点着色器输出语义和片元着色器输入语义"><a href="#顶点着色器输出语义和片元着色器输入语义" class="headerlink" title="顶点着色器输出语义和片元着色器输入语义"></a>顶点着色器输出语义和片元着色器输入语义</h3><p>在整个渲染流水线中，顶点着色器最重要的一项任务就是需要输出顶点在裁切空间中的坐标，这样 GPU 就可以知道顶点在屏幕上的栅格化位置以及深度值。在顶点函数中，这个输出参数需要使用 float4 类型的 <code>SV_POSITION</code> 语义进行填充。</p>
<p>顶点着色器产生的输出值将会在三角形遍历阶段经过插值计算，最终作为像素值输入到片元着色器。换句话说，顶点着色器的输出即为片元着色器的输入。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049698.png" alt="Pasted image 20230614195313"></p>
<p><strong>片元着色器会自动获取顶点着色器输出的裁切空间顶点坐标，所以片段函数输入的 SV_POSITION 可以省略。</strong> 这也解释了为什么有些 Shader 的片段函数中只有输出参数，但是没有输入参数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器输出结构</span></span><br><span class="line"><span class="keyword">struct</span> Varyings</span><br><span class="line">&#123;</span><br><span class="line">    float4 positionCS : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//顶点着色器函数</span></span><br><span class="line"><span class="function">Varyings <span class="title">vert</span>(<span class="params">Attributes input</span>) : SV_POSITION</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是，与顶点函数的输入语义不同，<code>TEXCOORDn</code> 不再特指模型的 UV 坐标，<code>COLORn</code> 也不再特指顶点颜色。它们的使用范围更广，可以用于声明任何符合要求的数据，所以在使用过程中不要被语义的名称欺骗了。</strong></p>
<p>许多现代 GPU 并不真正关心这些变量具有什么语义；然而，一些旧的系统（最值得注意的是，着色器模型2 GPU）确实有关于语义的特殊规则，即上述列表中对 TEXCOORD 和 COLOR 语义的描述，为了获得最佳的跨平台支持，应将顶点输出和片元输入标记为 <code>TEXCOORDn</code> 语义。</p>
<h3 id="片元着色器输出语义"><a href="#片元着色器输出语义" class="headerlink" title="片元着色器输出语义"></a>片元着色器输出语义</h3><p>片元着色器通常只会输出一个 fixed4 类型的颜色信息，输出的值会存储到渲染目标（Render Target）中，输出参数使用 <code>SV_TARGET</code> 语义进行填充。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片元着色器函数</span></span><br><span class="line"><span class="function">float4 <span class="title">frag</span>(<span class="params">Varyings input</span>) : SV_TARGET</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他语义：</strong><br><strong><code>SV_TargetN</code>：多个渲染目标：</strong><br><code>SV_Target1</code>、<code>SV_Target2</code> 等等：这些是着色器写入的附加颜色。这在一次渲染到多个渲染目标（称为“多渲染目标”渲染技术，简称 MRT）时使用。<code>SV_Target0</code> 等同于 <code>SV_Target</code>。</p>
<p><strong><code>SV_Depth</code>：像素着色器深度输出</strong><br>通常，片元着色器不会覆盖 Z 缓冲区值，而是使用正三角形光栅化中的默认值。但是，对于某些效果，按像素输出自定义 Z 缓冲区深度值是有用的。深度输出值必须为单个 <code>float</code>。</p>
<h3 id="其他特殊语义"><a href="#其他特殊语义" class="headerlink" title="其他特殊语义"></a>其他特殊语义</h3><h4 id="VPOS-屏幕空间像素位置"><a href="#VPOS-屏幕空间像素位置" class="headerlink" title="VPOS 屏幕空间像素位置"></a>VPOS 屏幕空间像素位置</h4><p>片元着色器可以接收渲染为特殊 <code>VPOS</code> 语义的像素位置。<strong>此功能仅从着色器模型 3.0 开始存在，因此着色器需要具有 <code>#pragma target 3.0</code> 编译指令。</strong></p>
<blockquote>
<p>Unity 文档：“在不同的平台上，屏幕空间位置输入的基本类型各不相同，因此为了最大限度地实现可移植性，请使用 <code>UNITY_VPOS_TYPE</code> 类型。”</p>
<p>查阅源码如下：<strong>现在直接使用 float4 类型即可！</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用UNITY_VPOS_TYPE宏需要引用：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HLSLSupport.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//看下源码：</span></span><br><span class="line"><span class="comment">//用于“屏幕空间位置”像素着色器输入语义的数据类型;现在是float4(以前是float2在D3D9上)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNITY_VPOS_TYPE float4</span></span><br></pre></td></tr></table></figure>

<p>此外，使用像素位置语义使得裁剪空间位置（SV_position）和 VPOS 很难在同一个顶点到片段结构中。因此，<strong>顶点着色器应将裁剪空间位置输出为单独的<code>out</code>变量</strong>。</p>
<figure class="highlight c"><figcaption><span>h:11,19,27,39,45</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> target 3.0   <span class="comment">//注意设置shader model为3.0以上</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> Attributes</span><br><span class="line">    &#123;</span><br><span class="line">        float4 positionOS : POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：此结构中没有 SV_POSITION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Varyings <span class="title function_">vert</span><span class="params">(</span></span><br><span class="line"><span class="params">        Attributes input,</span></span><br><span class="line"><span class="params">        out float4 positionCS : SV_POSITION)</span>  <span class="comment">// 裁剪空间位置输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        Varyings output = (Varyings)<span class="number">0</span>;</span><br><span class="line">        output.uv =input.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    </span><br><span class="line">        positionCS = TransformObjectToHClip(input.positionOS.xyz);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float4 <span class="title function_">frag</span><span class="params">(</span></span><br><span class="line"><span class="params">        Varyings input,</span></span><br><span class="line"><span class="params">        float4 screenPos : VPOS <span class="comment">//声明VPOS语义，输入屏幕空间坐标</span></span></span><br><span class="line"><span class="params">        )</span> : SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// screenPos.xy 为屏幕空间像素坐标。</span></span><br><span class="line">        <span class="comment">// _ScreenParams.xy为屏幕分辨率</span></span><br><span class="line">        <span class="comment">//用屏幕坐标除以屏幕分辨率，得到视口空间中的坐标，即归一化的屏幕空间坐标[0,1]</span></span><br><span class="line">        <span class="keyword">return</span> float4 (screenPos.xy/_ScreenParams.xy,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VPOS&#x2F;WPOS（Built-in 中是WPOS）</strong> 语义定义的输入是个 float4 类型的变量:</p>
<ol>
<li><code>xy</code> 分量代表<strong>屏幕空间</strong>中的像素坐标。<ul>
<li>如果屏幕分辨率为 400x300，那么 x 的范围就是 $[0.5,400.5]$ ,y 的范围是 $[0.5,300.5]$</li>
<li><strong>注意</strong>：这里的像素坐标并不是整数值，这是因为 OpenGL 和 DirectX 10 以后的版本认为像素重心对应的是浮点值中的 0.5</li>
</ul>
</li>
<li><code>z</code> 分量范围是  , 在相机的近裁剪平面处 z 为 0，远裁剪平面处 z 为 1</li>
<li><code>w</code> 分量范围是 $\displaystyle[\frac{1}{Near},\frac{1}{Far}]$ , $Near$ 和 $Far$ 对应 Camera 组件中设置的近裁切平面和远裁切平面距离相机的远近，若为正交投影，则 $w$ 恒为 1</li>
</ol>
<p>代码最后：用屏幕坐标除以屏幕分辨率，得到<strong>视口空间</strong>中的坐标，<strong>视口空间 (viewport space)</strong> 就是把屏幕坐标归一化，屏幕左下角为 $(0,0)$ , 右上角为 $(1,1)$</p>
<h4 id="VFACE-面对方向"><a href="#VFACE-面对方向" class="headerlink" title="VFACE 面对方向"></a>VFACE 面对方向</h4><p><strong>片元着色器可以接收一种指示渲染表面是面向摄像机还是背对摄像机的变量。</strong><br>这在渲染应从两侧可见的几何体时非常有用，通常用于树叶和类似的薄型物体。**<code>VFACE</code> 语义输入变量将包含表示正面三角形的正值，以及表示背面三角形的负值。**</p>
<p>此功能从着色器模型 3.0 开始才存在，因此着色器需要具有 <code>#pragma target 3.0</code> 编译指令。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049699.gif" alt="2023711422"></p>
<figure class="highlight c"><figcaption><span>h:1,6,28,34</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Cull Off <span class="comment">//关闭背面剔除  </span></span><br><span class="line">  </span><br><span class="line">HLSLPROGRAM  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0 <span class="comment">//注意设置shader model为3.0以上</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionCS : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">            </span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes input)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    Varyings output = (Varyings)<span class="number">0</span>;  </span><br><span class="line">    output.positionCS = TransformObjectToHClip(input.positionOS.xyz);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span><span class="params">(Varyings input, <span class="type">float</span> facing : VFACE)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _ColorFront, _ColorBack分别设置为红色蓝色</span></span><br><span class="line">    <span class="comment">// 正面的 VFACE 输入为正，</span></span><br><span class="line">    <span class="comment">// 背面的为负。根据这种情况</span></span><br><span class="line">    <span class="comment">// 输出两种颜色中的一种。</span></span><br><span class="line">    <span class="keyword">return</span> facing &gt; <span class="number">0</span> ?_ColorFront : _ColorBack;</span><br><span class="line">&#125;</span><br><span class="line">ENDHLSL</span><br></pre></td></tr></table></figure>

<h4 id="顶点-ID：SV-VertexID"><a href="#顶点-ID：SV-VertexID" class="headerlink" title="顶点 ID：SV_VertexID"></a>顶点 ID：SV_VertexID</h4><p><strong>顶点着色器可以接收具有“顶点编号”（为无符号整数 <code>uint</code>）的变量</strong>。当您想要从纹理或 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/class-ComputeShader.html">ComputeBuffers</a> 中<strong>获取额外的每顶点数据</strong>时，这非常有用。</p>
<p>此功能从 DX10（着色器模型 4.0）和 GLCore&#x2F;OpenGL ES 3 开始才存在，因此着色器需要具有 <code>#pragma target 3.5</code> 编译指令。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049700.png" alt="Pasted image 20230701143251"></p>
<figure class="highlight c"><figcaption><span>h:4,10,26</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.5 <span class="comment">//注意设置shader model为3.5以上</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    uint vid : SV_VertexID; <span class="comment">//顶点 ID，必须为uint</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionCS : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    float4 color : COLOR;  <span class="comment">//顶点颜色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes input)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    Varyings output = (Varyings)<span class="number">0</span>;</span><br><span class="line">    output.positionCS = TransformObjectToHClip(input.positionOS.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于顶点 ID 输出顶点颜色</span></span><br><span class="line">    <span class="type">float</span> f = input.vid;</span><br><span class="line">    output.color = float4(<span class="built_in">sin</span>(f/<span class="number">10</span>),<span class="built_in">sin</span>(f/<span class="number">100</span>),<span class="built_in">sin</span>(f/<span class="number">1000</span>),<span class="number">0</span>) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span><span class="params">(Varyings input)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> input.color;</span><br><span class="line">&#125;</span><br><span class="line">ENDHLSL</span><br></pre></td></tr></table></figure>

<h1 id="图形-API-平台差异"><a href="#图形-API-平台差异" class="headerlink" title="图形 API 平台差异"></a>图形 API 平台差异</h1><p><strong>Unity 默认是以 OpenGL 的标准体系进行描述的：左手坐标系、屏幕坐标系左下角为（0,0）等。为了确保统一性，所有非OpenGL 的平台的特性，Unity 会做出转换，使得该特性能够以 OpenGL 的标准来描述。</strong></p>
<p>在某些情况下，不同图形 API 之间的图形渲染行为方式存在差异。大多数情况下，Unity 编辑器会隐藏这些差异，<strong>但在某些情况下，编辑器无法为您执行此操作。下面列出了这些情况以及发生这些情况时需要采取的操作。</strong></p>
<h2 id="渲染纹理坐标"><a href="#渲染纹理坐标" class="headerlink" title="渲染纹理坐标"></a>渲染纹理坐标</h2><p>平台差异：</p>
<ul>
<li><strong>Direct3D</strong>：纹理坐标原点在左上角</li>
<li><strong>OpenGL</strong>：纹理坐标原点在左下角<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049701.webp" alt="v2-11bac0a9fd7fee29687f222ef4b317fd_1440w"><br>我们知道，Unity 是用 OpenGL 的标准进行描述的，右边的图像用左边的 OpenGL 坐标系来描述的话，得到的将会是下面这样一幅颠倒的图像。</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049702.webp" alt="v2-4ead41b0f3d7e5842f047d15f067e285_1440w|450"></p>
<blockquote>
<p><strong>为什么换了坐标系图像会颠倒？</strong><br>首先我们得理解，<strong>纹理本身就是以二维的数组的形式储存的</strong>。从上面的参考图的网格可以理解，每个像素都有一个明确的数组下标（x,y），数组下标是不变的，但是坐标系会变。比如：在 D3D 中，像素点（512,0）是在右上角的，但是在 OpenGL 的坐标系中，就变成右下角了。这就是坐标系变换造成图像颠倒的原因。</p>
</blockquote>
<p><strong>为了避免这种颠倒</strong>，在 Direct3D 类平台上渲染到纹理时，Unity 会在内部上下翻转渲染。这样就会使坐标约定在平台之间匹配，并以 OpenGL 类平台约定作为标准。</p>
<p>在着色器中，有两种常见情况需要您采取操作确保不同的坐标约定不会在项目中产生问题，这两种情况就是<strong>后处理</strong>和 <strong>UV 空间中的渲染</strong>。</p>
<h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p><strong>抗锯齿：</strong><br><strong>在 non-OpenGL 平台，MSAA 开启的情况下，Unity 不会对图像进行 Filp 翻转操作</strong>。但是由于 Unity 还是以 OpenGL 的 RenderTexture 的坐标系去描述这个 <code>_MainTex</code>，所以 <code>_MainTex_TexelSize.y</code> 为负数。<code>UNITY_UV_STARTS_AT_TOP</code> 这个宏其实就判断图形 api 平台是否为规定 uv 在原点在顶部，即非 OpenGL 平台平台。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是OpenGL平台，翻转纹理的采样</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line"><span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">        uv.y = <span class="number">1</span>-uv.y;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意有的内置方法已经进行了判断，如果我们多写一个就会造成翻转失败</p>
</blockquote>
<h3 id="在-UV-空间中渲染"><a href="#在-UV-空间中渲染" class="headerlink" title="在 UV 空间中渲染"></a>在 UV 空间中渲染</h3><p>在纹理坐标 (UV) 空间中渲染特殊效果或工具时，您可能需要调整着色器，以便在 Direct3D 类和 OpenGL 类系统之间进行一致渲染。您还可能需要在渲染到屏幕和渲染到纹理之间进行渲染调整。为进行此类调整，应上下翻转 Direct3D 类投影，使其坐标与 OpenGL 类投影坐标相匹配。</p>
<p>内置变量 <code>ProjectionParams.x</code> 包含值 <code>+1</code> 或 <code>–1</code>。<br><code>-1</code> 表示投影已上下翻转以匹配 OpenGL 类投影坐标，而 <code>+1</code> 表示尚未翻转。</p>
<p>您可以在着色器中检查此值，然后执行不同的操作。下面的示例将检查是否已翻转投影，如果已翻转，则再次进行翻转，然后返回 UV 坐标以便匹配。</p>
<p><code>_ProjectionParams</code> ：<br><code>x</code>  是 1.0（如果当前使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/SL-PlatformDifferences.html">翻转投影矩阵</a>进行渲染，则为 –1.0）<br><code>y</code> 近平面$near$<br><code>z</code> 远平面$far$<br><code>w</code>  $\frac{1}{far}$ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float4 <span class="title function_">vert</span><span class="params">(float2 uv : TEXCOORD0)</span> : SV_POSITION</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos;</span><br><span class="line">    pos.xy = uv;</span><br><span class="line">    <span class="comment">// 此示例使用上下翻转的投影进行渲染，</span></span><br><span class="line">    <span class="comment">// 因此也翻转垂直 UV 坐标</span></span><br><span class="line">    <span class="keyword">if</span> (_ProjectionParams.x &lt; <span class="number">0</span>)</span><br><span class="line">        pos.y = <span class="number">1</span> - pos.y;</span><br><span class="line">    pos.z = <span class="number">0</span>;</span><br><span class="line">    pos.w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲区数据结构"><a href="#缓冲区数据结构" class="headerlink" title="缓冲区数据结构"></a>缓冲区数据结构</h2><p>执行以下操作以确保所有图形 API 编译具有相同数据布局的缓冲区：</p>
<ul>
<li>使用“float4”和“float4x4”而不是“float3”和“float3x3”，因为“float4”变量在所有图形 API 上的大小相同，而“float3”变量在某些图形 API 上的大小可能不同。</li>
<li>按大小递减的顺序声明变量，例如“float4”，然后“float2”，然后“float”，因此所有图形 API 都以相同的方式构造数据。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cbuffer myConstantBuffer &#123; </span><br><span class="line">    float4x4 matWorld;</span><br><span class="line">    float4 vObjectPosition; <span class="comment">// Uses a float4 instead of a float3</span></span><br><span class="line">    <span class="type">float</span> arrayIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h1><h2 id="变体基础"><a href="#变体基础" class="headerlink" title="变体基础"></a>变体基础</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049703.png" alt="Pasted image 20230628192002"></p>
<p>能否写一个 All in One 的 Shader？<br>有三种方式，根据具体需求选择：</p>
<ol>
<li>静态分支 <code>#if</code></li>
<li>动态分支 <code>if</code></li>
<li>着色器变体 <code>#pragma</code></li>
</ol>
<h3 id="静态分支-if"><a href="#静态分支-if" class="headerlink" title="静态分支 #if"></a>静态分支 <code>#if</code></h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049704.png" alt="Pasted image 20230628192227|500"></p>
<p><strong>原理</strong>：着色器<strong>编译时</strong>选择代码分支</p>
<p><strong>选择</strong>：编译时，能够确定 Shader 执行的条件</p>
<p><strong>用法</strong>：</p>
<ul>
<li>使用 <code>#define</code> 定义激活分支</li>
<li>使用 <code>#if</code> 、 <code>#elif</code> 、 <code>#else</code> 和 <code>#endif</code> 预处理程序指令来创建静态分支</li>
<li>让 shader 代码执行其中一个分支</li>
<li>编译器会裁剪未激活代码分支，只会将执行的部分编译</li>
</ul>
<p><strong>注意</strong>：静态分支仅在手写代码可用，不能在 Shader Graph 中创建静念分文。</p>
<h3 id="动态分支-if"><a href="#动态分支-if" class="headerlink" title="动态分支 if"></a>动态分支 <code>if</code></h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049705.png" alt="Pasted image 20230628192654|300"><br><strong>原理</strong>：着色器<strong>运行时</strong>选择代码分支</p>
<p><strong>选择</strong>：运行时，是否有可能动态选择分支? </p>
<p><strong>用法</strong>:</p>
<ul>
<li>在手写代码中，使用 if 语句来执行分支</li>
<li>在 Shader Graph 中，使用 Branch 节点</li>
</ul>
<p>动态分支的优点（相对于着色器变体方式)：</p>
<ul>
<li>可以动态选择分支</li>
<li>不会造成代码膨胀</li>
</ul>
<p>动态分支缺点（相对于着色器变体方式)：会导致运行时性能损失</p>
<h3 id="着色器变体-pragma"><a href="#着色器变体-pragma" class="headerlink" title="着色器变体 #pragma"></a>着色器变体 <code>#pragma</code></h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049706.png" alt="Pasted image 20230628193118"></p>
<p><strong>着色器变体原理： (静态分支的加强版)</strong></p>
<ul>
<li>编译时，生成多个<strong>静态分支</strong>的着色器版本</li>
<li>运行时，根据选择的变体<strong>动态确定</strong>要执行的着色器版本</li>
</ul>
<p><strong>变体形成的 Shader 集合:</strong> shader variants (SL) &#x2F; shader states (SG)</p>
<blockquote>
<p>SL 意思是手写的 shaderlab ，SG 意思是 shadergraph</p>
</blockquote>
<p><strong>变体关键字:</strong> shader keyword (SL) &#x2F; keyword node (SG)</p>
<p><strong>包含多个变体的 Shader 被称为 Mega &#x2F; Uber Shader</strong></p>
<ul>
<li>例如: Standard&#x2F;Lit Shader</li>
<li>详见《TA 进阶之路》: Unity Shader 源码解析</li>
</ul>
<p><strong>着色器变体优点</strong>：不会导致运行时性能损失<br><strong>着色器变体缺点</strong>：构建时间、文件大小、运行时内存使用、加载时间</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049707.png" alt="Pasted image 20230628193737"></p>
<p>变体分类<br>  <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049708.png" alt="Pasted image 20230628194409|700"><br><strong>使用方法：</strong><br>属性快：声明变体<br>代码头：定义变体<br>代码体：使用变体</p>
<blockquote>
<p>[!Bug]<br>变体关键词必须大写！</p>
</blockquote>
<h4 id="全局关键字"><a href="#全局关键字" class="headerlink" title="全局关键字"></a>全局关键字</h4><p><strong>变体分类：</strong></p>
<ol>
<li><code>multi_ compile</code>：打包会为所有关键词生成变体，因此**可以在运行的时候通过脚本切换效果</li>
<li><strong><code>shader_feature</code>：只会为材质使用到的关键词生成变体，没有使用到的关键词被裁剪不会生成变体，减小打包体积，</strong>但无法在运行的时候通过脚本切换效果**。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shader_feature 可以看作 multi_compile 的子集 </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature FANCY_STUFF</span></span><br><span class="line"><span class="comment">//这只是 #pragma shader_feature _ FANCY_STUFF 的快捷方式。它会扩展为两个着色器变体（第一个没有定义；第二个有定义）。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li>变体用于所有 Shader 还是单个材质?<ul>
<li>应该将 shader_feature 用于单个材质中设置的关键字</li>
<li>而 multi_compile 更适合<strong>通过代码</strong>来全局设置的</li>
</ul>
</li>
<li>关键字运行时是否会通过 CS 脚本修改？<br>如果设定好的变体在运行时不会通过 CS ，则应选择 shader_feature，否则选择 multi_compile</li>
</ol>
<h4 id="局部关键字"><a href="#局部关键字" class="headerlink" title="局部关键字"></a>局部关键字</h4><p><strong>shader_feature</strong> 和 <strong>multi_compile</strong> 的主要缺点是其中定义的所有关键字均会影响 Unity 的全局关键字计数上限（384 个全局关键字，外加 64 个本地关键字）。为了避免此问题，可以使用不同的着色器变体指令：<strong>shader_feature_local</strong> 和 <strong>multi_compile_local</strong>。</p>
<ul>
<li><code>shader_feature_local</code>：类似于 <code>shader_feature</code>，但是枚举的关键字为本地关键字。</li>
<li><code>multi_compile_local __</code>：类似于 <code>multi_compile</code>，但是枚举的关键字为本地关键字。</li>
</ul>
<p>如果全局关键字和本地关键字同名，Unity 会优先考虑本地关键字。</p>
<p><strong>限制：</strong></p>
<ul>
<li>不能将本地关键字与进行全局关键字更改的 API 一起使用（例如 Shader. EnableKeyword 或 CommandBuffer. EnableShaderKeyword）。</li>
<li>每个着色器最多有 64 个唯一性的本地关键字。</li>
<li>如果材质启用了本地关键字，并且其着色器变为不再声明的着色器，Unity 将创建新的全局关键字。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> multi_compile_local __ FOO_ON</span></span><br></pre></td></tr></table></figure>

<p>此指令生成两个着色器变体：一个未定义任何关键字 (<code>__</code>)，另一个定义了 <code>FOO_ON</code>（本地关键字）。</p>
<p>启用本地关键字的过程与启用全局关键字的过程相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Material mat;</span><br><span class="line">Private <span class="type">void</span> <span class="title function_">Start</span><span class="params">()</span> &#123;</span><br><span class="line">    mat.EnableKeyword(<span class="string">&quot;FOO_ON&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特定于阶段的关键字指令"><a href="#特定于阶段的关键字指令" class="headerlink" title="特定于阶段的关键字指令"></a>特定于阶段的关键字指令</h4><p>创建着色器变体时，<strong>Unity 编辑器的默认行为是在每个变体中生成着色器程序的每个阶段</strong>。例如，如果您的着色器程序包含一个顶点阶段和一个片元阶段，Unity 会为每个关键字组合生成一个顶点阶段和一个片元阶段。</p>
<p>如果关键字不影响所有阶段，则此默认行为会导致冗余工作。</p>
<p>为避免此问题，您可以使用特定于阶段的关键字指令。这些是应用于常规关键字指令的后缀。它们告诉编辑器给定关键字影响哪个着色器阶段，因此在为支持的图形 API 构建着色器时，它可以跳过多余的工作。</p>
<p><strong>使用特定于阶段的关键字指令</strong></p>
<p>可用的后缀是 <code>_vertex</code>、<code>_fragment</code>、<code>_hull</code>、<code>_domain</code>、<code>_geometry</code> 和 <code>_raytracing</code>。您在关键字指令的末尾应用后缀，例如：<code>multi_compile_fragment</code> 或 <code>shader_feature_local_vertex</code>。<strong>要针对多个着色器阶段，您可以使用多个特定于阶段的关键字指令来声明同一个关键字。</strong></p>
<p>注意：您应确保关键字仅用于指定的着色器阶段。</p>
<p> <strong>支持的图形 API：</strong><br>Unity 并不完全支持在所有图形 API 中使用特定于阶段的关键字指令。</p>
<ul>
<li>为 OpenGL 和 Vulkan 编译着色器时，编辑器会自动将任何特定于阶段的关键字指令恢复为常规关键字指令。</li>
<li>为 Metal 编译着色器时，任何针对顶点阶段的关键字也会影响曲面细分阶段，反之亦然。</li>
</ul>
<h2 id="multi-compile"><a href="#multi-compile" class="headerlink" title="multi_ compile"></a>multi_ compile</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049709.png" alt="Pasted image 20230628194839"></p>
<h3 id="变体激活"><a href="#变体激活" class="headerlink" title="变体激活"></a>变体激活</h3><p>Unity 默认激活第一个变体，因此我们可以将默认关闭的开关放在第一个，防止意外打开开关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下：将产生两个变体，默认激活LIGHT_OFF变体</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile LIGHT_OFF LIGHT_ON </span></span><br></pre></td></tr></table></figure>

<p>Unity 中的关键字数量上限是 384，Unity 将大约 60 个关键字保留供内部使用（因此降低了可用上限）<br>因此，可以用 <code>_</code> 或 <code>__</code> 表示开关关闭 6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile _ LIGHT_ON</span></span><br><span class="line"><span class="comment">//生成两个变体</span></span><br><span class="line"><span class="comment">//_或__:无关键字，即表示不用 LIGHT_ON，又不产生变体LIGHT_ON</span></span><br><span class="line"><span class="comment">//第二个就是变体LIGHT_ON</span></span><br></pre></td></tr></table></figure>

<p>对于单一条件的判定，没必要写两个变体浪费变体数量。<br>直接使用以下方式即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LIGHT_ON)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="变体组合"><a href="#变体组合" class="headerlink" title="变体组合"></a>变体组合</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049710.png" alt="Pasted image 20230628195933"><br> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049711.png" alt="Pasted image 20230628195959"></p>
<h3 id="变体开关"><a href="#变体开关" class="headerlink" title="变体开关"></a>变体开关</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049712.png" alt="Pasted image 20230628200255"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shader.EnableKeyword  <span class="comment">//启用全局关键字</span></span><br><span class="line">Shader.DisableKeyword  <span class="comment">//禁用全局关键字</span></span><br><span class="line">CommandBuffer.EnableShaderKeyword  <span class="comment">//使用 CommandBuffer 来启用全局关键字</span></span><br><span class="line">CommandBuffer.DisableShaderKeyword  <span class="comment">//使用 CommandBuffer 来禁用全局关键字</span></span><br><span class="line">Material.EnableKeyword  <span class="comment">//为常规着色器启用本地关键字</span></span><br><span class="line">Material.DisableKeyword  <span class="comment">//为常规着色器禁用本地关键字</span></span><br><span class="line">ComputeShader.EnableKeyword  <span class="comment">//为计算着色器启用本地关键字</span></span><br><span class="line">ComputeShader.DisableKeyword  <span class="comment">//计算着色器禁用本地关键字</span></span><br></pre></td></tr></table></figure>
<h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><p>有些情况需要定义很多变体，代码很长，Unity 提供了一些快捷方式</p>
<p>URP 支持着色器的变体，可以使用 #pragma multi_compile 宏实现编译不同需求下的着色器，常见的内置关键字有：</p>
<ul>
<li><code>_MAIN_LIGHT_SHADOWS</code></li>
<li><code>_MAIN_LIGHT_SHADOWS_CASCADE</code></li>
<li><code>_ADDITIONAL_LIGHTS_VERTEX</code></li>
<li><code>_ADDITIONAL_LIGHTS</code></li>
<li><code>_ADDITIONAL_LIGHT_SHADOWS</code></li>
<li><code>_SHADOWS_SOFT</code></li>
<li><code>_MIXED_LIGHTING_SUBTRACTIVE</code></li>
</ul>
<p>大多数内置快捷方式会产生许多着色器变体。如果知道项目不需要这些变体，可以使用 <code>#pragma skip_variants</code> 来跳过对其中一些变体的编译。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> skip_variants POINT POINT_COOKIE</span></span><br></pre></td></tr></table></figure>

<p>该指令会跳过包含 <code>POINT</code> 或 <code>POINT_COOKIE</code> 的所有变体。</p>
<h2 id="变体剥离"><a href="#变体剥离" class="headerlink" title="变体剥离"></a>变体剥离</h2><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/shader-stripping.html">Shader Stripping | Universal RP | 14.0.8 — 着色器剥离|通用RP | 14.0.8 (unity3d.com)</a></p>
<h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>通过外部控制变体切换有两种方式：</p>
<ol>
<li>Properties 控制（KeywordEnum、Toggle 等）</li>
<li>代码控制，当使用代码控制时，不要写 Properties，会有冲突。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190049713.gif" alt="6a7sdASdsssssadasd"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当使用代码控制时，注释掉该代码</span></span><br><span class="line">    <span class="comment">//[KeywordEnum(Red,Green,Blue)] _TestColor(&quot;Instancing&quot;, Float) = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">frag</span>(<span class="params">Varyings input</span>) : SV_Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _TESTCOLOR_RED</span></span><br><span class="line">        <span class="keyword">return</span> float4(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> _TESTCOLOR_GREEN</span></span><br><span class="line">        <span class="keyword">return</span>  float4(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> _TESTCOLOR_BLUE</span></span><br><span class="line">        <span class="keyword">return</span> float4(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> float4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestMultiCompile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TMP_Dropdown dropdown; <span class="comment">//使用一个dropdown来控制</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; showOptions = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; dataOptions = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        dropdown.options.Clear();</span><br><span class="line">        </span><br><span class="line">        showOptions.Add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">        showOptions.Add(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">        showOptions.Add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        dataOptions.Add(<span class="string">&quot;_TESTCOLOR_RED&quot;</span>);</span><br><span class="line">        dataOptions.Add(<span class="string">&quot;_TESTCOLOR_GREEN&quot;</span>);</span><br><span class="line">        dataOptions.Add(<span class="string">&quot;_TESTCOLOR_BLUE&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dropdown.AddOptions(showOptions);</span><br><span class="line">        dropdown.onValueChanged.AddListener(ChangeValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeValue</span>(<span class="params"><span class="built_in">int</span> arg0</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dataOptions.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == arg0)</span><br><span class="line">            &#123;</span><br><span class="line">                Shader.EnableKeyword(dataOptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Shader.DisableKeyword(dataOptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        dropdown.onValueChanged.RemoveListener(ChangeValue);</span><br><span class="line">        dropdown.options.Clear();</span><br><span class="line">        showOptions.Clear();</span><br><span class="line">        dataOptions.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变体编辑器拓展（待续）"><a href="#变体编辑器拓展（待续）" class="headerlink" title="变体编辑器拓展（待续）"></a>变体编辑器拓展（待续）</h2><p>TestMultiCompile 属性面板如何自定义显示?<br>需求:<br>看到材质球当前启用了哪些全局和局部的变体<br>并且把全局和局部变体分两栏显示，两栏可折叠</p>
<h2 id="局部变体的管理（待续）"><a href="#局部变体的管理（待续）" class="headerlink" title="局部变体的管理（待续）"></a>局部变体的管理（待续）</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/42467.html">http://liuke101.github.io/post/42467.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/60457.html" title="Effective C++"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Effective C++</div></div></a></div><div class="next-post pull-right"><a href="/post/28735.html" title="【图形系统09】阴影"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292335674.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【图形系统09】阴影</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/42466.html" title="CG ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">CG ShaderLab</div></div></a></div><div><a href="/post/17861.html" title="Renderer Feature"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-14</div><div class="title">Renderer Feature</div></div></a></div><div><a href="/post/19285.html" title="材质脚本控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="title">材质脚本控制</div></div></a></div><div><a href="/post/56280.html" title="Shader Trick"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Shader Trick</div></div></a></div><div><a href="/post/32635.html" title="UV操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">UV操作</div></div></a></div><div><a href="/post/11097.html" title="描边"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-29</div><div class="title">描边</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ShaderLab-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">ShaderLab 语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-text">1 组织结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%8D%E7%A7%B0"><span class="toc-text">2 名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Properties"><span class="toc-text">3 Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%92%8C%E5%90%91%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">颜色和向量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">纹理贴图属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%BA%B9%E7%90%86%E5%B1%9E%E6%80%A7"><span class="toc-text">特殊纹理属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E9%A2%9C%E8%89%B2-%E7%9F%A2%E9%87%8F%E7%9D%80%E8%89%B2%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">颜色空间和颜色&#x2F;矢量着色器数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%91%E7%9D%80%E8%89%B2%E5%99%A8%E6%8F%90%E4%BE%9B%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-text">如何向着色器提供属性值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SubShader"><span class="toc-text">4 SubShader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tags"><span class="toc-text">Tags</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RenderPipeline"><span class="toc-text">RenderPipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RenderType"><span class="toc-text">RenderType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-text">禁用动态批处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E9%98%B4%E5%BD%B1%E6%8A%95%E5%B0%84"><span class="toc-text">禁止阴影投射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5-Projector"><span class="toc-text">忽略 Projector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PreviewType"><span class="toc-text">PreviewType</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass"><span class="toc-text">Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0"><span class="toc-text">自定义名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-%E4%B8%93%E7%94%A8-Tags"><span class="toc-text">Pass 专用 Tags</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LightMode"><span class="toc-text">LightMode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UniversalMaterialType"><span class="toc-text">UniversalMaterialType</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fallback"><span class="toc-text">Fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOD"><span class="toc-text">LOD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%91%BD%E4%BB%A4"><span class="toc-text">5 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="toc-text">设置渲染状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%91%BD%E4%BB%A4"><span class="toc-text">通道命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Category-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AF%B9%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84"><span class="toc-text">使用 Category 代码块对命令进行分组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity-%E4%B8%AD%E7%9A%84-HLSL"><span class="toc-text">Unity 中的 HLSL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HLSL-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">HLSL 预处理器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E9%98%B6%E6%AE%B5"><span class="toc-text">着色器阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shader-mode"><span class="toc-text">shader mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89"><span class="toc-text">语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%85%A5%E8%AF%AD%E4%B9%89"><span class="toc-text">顶点着色器输入语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%87%BA%E8%AF%AD%E4%B9%89%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%85%A5%E8%AF%AD%E4%B9%89"><span class="toc-text">顶点着色器输出语义和片元着色器输入语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%87%BA%E8%AF%AD%E4%B9%89"><span class="toc-text">片元着色器输出语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E8%AF%AD%E4%B9%89"><span class="toc-text">其他特殊语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VPOS-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%83%8F%E7%B4%A0%E4%BD%8D%E7%BD%AE"><span class="toc-text">VPOS 屏幕空间像素位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VFACE-%E9%9D%A2%E5%AF%B9%E6%96%B9%E5%90%91"><span class="toc-text">VFACE 面对方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9-ID%EF%BC%9ASV-VertexID"><span class="toc-text">顶点 ID：SV_VertexID</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2-API-%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82"><span class="toc-text">图形 API 平台差异</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="toc-text">渲染纹理坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-text">后处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-UV-%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%B8%B2%E6%9F%93"><span class="toc-text">在 UV 空间中渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">缓冲区数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E4%BD%93"><span class="toc-text">变体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E5%9F%BA%E7%A1%80"><span class="toc-text">变体基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%94%AF-if"><span class="toc-text">静态分支 #if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF-if"><span class="toc-text">动态分支 if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93-pragma"><span class="toc-text">着色器变体 #pragma</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">全局关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">局部关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%98%B6%E6%AE%B5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-text">特定于阶段的关键字指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multi-compile"><span class="toc-text">multi_ compile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E6%BF%80%E6%B4%BB"><span class="toc-text">变体激活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E7%BB%84%E5%90%88"><span class="toc-text">变体组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E5%BC%80%E5%85%B3"><span class="toc-text">变体开关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="toc-text">快捷方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E5%89%A5%E7%A6%BB"><span class="toc-text">变体剥离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6"><span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E7%BC%96%E8%BE%91%E5%99%A8%E6%8B%93%E5%B1%95%EF%BC%88%E5%BE%85%E7%BB%AD%EF%BC%89"><span class="toc-text">变体编辑器拓展（待续）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E4%BD%93%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%88%E5%BE%85%E7%BB%AD%EF%BC%89"><span class="toc-text">局部变体的管理（待续）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/24808.html" title="蓝图精粹"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070002240.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝图精粹"/></a><div class="content"><a class="title" href="/post/24808.html" title="蓝图精粹">蓝图精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>