<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C#精粹 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="零、特性1 预处理器指令编译器是一种翻译程序它用于将源语言程序翻译为目标语言程序  源语言程序: 某种程序设计语言写成的, 比如 C#、C、C++、Java 等语言写的程序 目标语言程序: 二进制数表示的伪机器代码写的程序  预处理器指令指导编译器在实际编译开始之前对信息进行预处理预处理器指令都是以#开始预处理器指令不是语句，所以它们不以分号 ; 结束 title:折叠代码123#region 折">
<meta property="og:type" content="article">
<meta property="og:title" content="C#精粹">
<meta property="og:url" content="http://liuke101.github.io/post/23284.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="零、特性1 预处理器指令编译器是一种翻译程序它用于将源语言程序翻译为目标语言程序  源语言程序: 某种程序设计语言写成的, 比如 C#、C、C++、Java 等语言写的程序 目标语言程序: 二进制数表示的伪机器代码写的程序  预处理器指令指导编译器在实际编译开始之前对信息进行预处理预处理器指令都是以#开始预处理器指令不是语句，所以它们不以分号 ; 结束 title:折叠代码123#region 折">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png">
<meta property="article:published_time" content="2024-05-18T16:28:28.000Z">
<meta property="article:modified_time" content="2024-05-18T16:29:40.390Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/23284.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C#精粹',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-19 00:29:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C#精粹</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-18T16:28:28.000Z" title="发表于 2024-05-19 00:28:28">2024-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-18T16:29:40.390Z" title="更新于 2024-05-19 00:29:40">2024-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C#精粹"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/23284.html#post-comment"><span class="waline-comment-count" data-path="/post/23284.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零、特性"><a href="#零、特性" class="headerlink" title="零、特性"></a>零、特性</h1><h2 id="1-预处理器指令"><a href="#1-预处理器指令" class="headerlink" title="1 预处理器指令"></a>1 预处理器指令</h2><p>编译器是一种翻译程序<br>它用于将源语言程序翻译为目标语言程序</p>
<ul>
<li>源语言程序: 某种程序设计语言写成的, 比如 C#、C、C++、Java 等语言写的程序</li>
<li>目标语言程序: 二进制数表示的伪机器代码写的程序</li>
</ul>
<p>预处理器指令指导编译器在实际编译开始之前对信息进行预处理<br>预处理器指令都是以<code>#</code>开始<br>预处理器指令不是语句，所以它们不以分号 <code>;</code> 结束</p>
<figure class="highlight cs"><figcaption><span>title:折叠代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 折叠块名字</span></span><br><span class="line">... <span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  //定义一个符号，类似一个没有值的变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> //取消<span class="keyword">define</span>定义的符号，让其失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两者都是写在脚本文件最前面</span></span><br><span class="line"><span class="comment">//一般配合if指令使用或配合特性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>  //即elseif</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//和if语句规则一样，一般配合#define定义的符号使用</span></span><br><span class="line"><span class="comment">//用于告诉编译器进行编译代码的流程控制</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">warning</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span></span></span><br><span class="line"><span class="comment">//告诉编译器是报警告还是报错误</span></span><br><span class="line"><span class="comment">//一般还是配合if使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tag1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag2</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> tag2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> tag1</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">//执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> tag2</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hi world!&quot;</span>);     <span class="comment">//不执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Exit!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-控制台方法"><a href="#2-控制台方法" class="headerlink" title="2 控制台方法"></a>2 控制台方法</h2><figure class="highlight cs"><figcaption><span>title:打印输入输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(<span class="string">&quot;xxx&quot;</span>); <span class="comment">// 打印，不自动空行</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;xxx&quot;</span>); <span class="comment">// 打印，自动空行</span></span><br><span class="line">Console.ReadLine(); <span class="comment">//等待直到用户按下回车，一次读入一行。</span></span><br><span class="line">Console.ReadKey();  <span class="comment">// 等待用户按下任意键，一次读入一个字符。</span></span><br><span class="line"></span><br><span class="line">Console.ReadKey(<span class="literal">true</span>).KeyChar; </span><br><span class="line"><span class="comment">//Console 类的一个静态方法，它读取当前控制台上的任意键盘输入。参数 true 表示在读取输入后不显示读入的字符，如果是 false 则会显示读入的字符。</span></span><br><span class="line"><span class="comment">//返回值是 ConsoleKeyInfo 类型，包含了该字符的 KeyChar 属性（即按下的按键字符），以及关于按键是否有控制字符等其他信息。</span></span><br><span class="line"></span><br><span class="line">Console.KeyAvailable <span class="comment">//判断有无键盘输入，如果有则为true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:其他方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.清空</span></span><br><span class="line">Console.Clear();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 设置控制台大小</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.先设置窗口大小，在设置缓冲区大小</span></span><br><span class="line"><span class="comment">//2.缓冲区大小不能小于窗口大小</span></span><br><span class="line"><span class="comment">//3.窗口大小不能大于控制台的最大尺寸</span></span><br><span class="line">Console.SetWindowSize(<span class="number">50</span>,<span class="number">40</span>);  <span class="comment">// 设置窗口大小</span></span><br><span class="line">Console.SetBufferSize(<span class="number">1000</span>, <span class="number">1000</span>); <span class="comment">// 设置缓冲区大小（可打印内容区域的宽高）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设置光标的位置</span></span><br><span class="line"><span class="comment">//控制台左上角为原点，右侧是x轴正方向，下方是Y轴正方向，它是一个平面二维坐标系</span></span><br><span class="line"><span class="comment">//注意:</span></span><br><span class="line"><span class="comment">//1.边界问题</span></span><br><span class="line"><span class="comment">//2.横纵距离单位不同 1y = 2x 视觉上的</span></span><br><span class="line">Console.SetCursorPosition(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.设置颜色相关</span></span><br><span class="line"><span class="comment">//文字颜色设置</span></span><br><span class="line">Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line"><span class="comment">//背景颜色设置</span></span><br><span class="line">Console.BackgroundColor = ConsoleColor.White;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.光标显隐</span></span><br><span class="line">Console.CursorVisible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.关闭控制台</span></span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-Path-类"><a href="#3-Path-类" class="headerlink" title="3 Path 类"></a>3 Path 类</h2><p>用于操作路径</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">@&quot;C:\Users\22625\Desktop\1.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//快速获得文件名，输出：1.txt</span></span><br><span class="line">    Console.WriteLine(Path.GetFileName(str));</span><br><span class="line">    <span class="comment">//只获得扩展名，输出：.txt</span></span><br><span class="line">    Path.GetExtension(str);</span><br><span class="line">    <span class="comment">//不包含扩展名，输出：1</span></span><br><span class="line">    Path.GetFileNameWithoutExtension(str)</span><br><span class="line">   	<span class="comment">//文件目录，输出：C:\Users\22625\Desktop</span></span><br><span class="line">   	Path.GetDirectoryName(str);</span><br><span class="line">    <span class="comment">//文件全路径</span></span><br><span class="line">    Path.GetFullPath(str);</span><br><span class="line">    <span class="comment">//链接两个字符串作为路径</span></span><br><span class="line">    Path.Combine(<span class="string">@&quot;C:\Users\22625\Desktop\&quot;</span>,<span class="string">&quot;1.txt&quot;</span>)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-垃圾回收-GC"><a href="#4-垃圾回收-GC" class="headerlink" title="4 垃圾回收 GC"></a>4 垃圾回收 GC</h2><p>垃圾回收, 英文简写 GC (Garbage Collector)</p>
<p>垃圾回收的过程是在遍历堆 (Heap)上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。<br>所谓的垃圾就是没有被任何变量，对象引用的内容。垃圾就需要被回收释放，</p>
<p>垃圾回收有很多种算法，比如</p>
<ul>
<li>引用计数 (Reference Counting)</li>
<li>标记清除 (Mark Sweep)</li>
<li>标记整理 (Mark Compact)</li>
<li>复制集合 (Copy collection)</li>
</ul>
<p><strong>GC 只负责堆 (Heap)内存的垃圾回收，引用类型都是存在堆 (Heap)中的，所以它的分配和释放都通过垃圾回收机制来管理<br>栈 (Stack)上的内存是由系统自动管理的，值类型在栈 (Stack)中分配内存的。他们有自己的生命周期，不用对他们进行管理，会自动分配和释放</strong></p>
<p><strong>CS 中内存回收机制的大概原理:</strong><br>0 代内存 1 代内存 2 代内存<br><strong>代的概念:</strong> </p>
<ol>
<li>代是垃圾回收机制使用的一种算法 (分代算法)</li>
<li>新分配的对象都会被配置在第 0 代内存中</li>
<li>每次分配都可能会进行垃圾回收以释放内存 (0 代内存满时)</li>
</ol>
<ul>
<li><p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步</p>
<ol>
<li>标记对象从根（静态字段、方法参数）开始检查引用对象（引用类型，比如类、数组），标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾</li>
<li>搬迁对象压缩堆 (挂起执行托管代码线程), 释放未标记的对象，搬迁可达对象，修改引用地址</li>
</ol>
</li>
<li><p>大对象总被认为是第二代内存，目的是减少性能损耗，提高性能</p>
</li>
<li><p>不会对大对象进行搬迁压缩（85080 字节 (83kb）以上的对象为大对象）<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027433.png"></p>
</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:手动垃圾回收</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况下，我们不会频繁调用、</span></span><br><span class="line"><span class="comment">// 都是在Loading过场景时，才调用</span></span><br><span class="line">CG.Collect();</span><br></pre></td></tr></table></figure>

<h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5 类型转换"></a>5 类型转换</h2><p>我们要求等号两边参与运算的操作数必须一致，如果不一致，满足下列条件会发生转换。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ul>
<li>低精度可以转换成高精度</li>
<li>char→整数（有符号、无符号）→float→double $\nrightarrow$ decimal</li>
<li>char→整数（有符号、无符号）→decimal</li>
<li>string 和 bool 不参与隐式转换规则</li>
<li>有符号 $\nrightarrow$ 无符号</li>
<li>无符号→有符号（精度低到高）</li>
</ul>
<h3 id="显式（强制）类型转换"><a href="#显式（强制）类型转换" class="headerlink" title="显式（强制）类型转换"></a>显式（强制）类型转换</h3><h4 id="括号强转"><a href="#括号强转" class="headerlink" title="括号强转"></a>括号强转</h4><p>用于将高精度转换位低精度</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//double-&gt;int 强制类型转换（显式类型转换）</span></span><br><span class="line"><span class="built_in">double</span> a =(<span class="built_in">int</span>)b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果n1/n2有一个是double类型则整个式子提升为double类型：</span></span><br><span class="line"><span class="comment">//全int：输出结果d=3</span></span><br><span class="line"><span class="built_in">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> n2 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">double</span> d = n1 / n2;</span><br><span class="line">Console.WriteLine(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将n1改为double类型：输出d=3.333...</span></span><br><span class="line"><span class="built_in">double</span> d = n1*<span class="number">1.0</span> / n2;  <span class="comment">//n1*1.0将n1转换为double类型</span></span><br><span class="line">Console.WriteLine(d);</span><br></pre></td></tr></table></figure>
<h4 id="Convert-类型转换"><a href="#Convert-类型转换" class="headerlink" title="Convert 类型转换"></a>Convert 类型转换</h4><ul>
<li>如果两个变量类型不兼容，比如 string 与 int 或 string 与 double，可以使用 Convert 函数进行转换。</li>
<li>string 字符串的内容必须为要转换的类型。</li>
</ul>
<p><code>Convert.ToInt32()</code><br><code>Convert.ToDouble()</code><br>…</p>
<figure class="highlight cs"><figcaption><span>string a </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;123&quot;</span>;  <span class="comment">//但是只能转换int，如果a=”123abc“或“6.5”则会异常</span></span><br><span class="line"><span class="built_in">int</span> b = Convert.ToInt32(a);</span><br><span class="line">Console.WriteLine(b);</span><br></pre></td></tr></table></figure>

<h4 id="Parse-类型转换"><a href="#Parse-类型转换" class="headerlink" title=".Parse 类型转换"></a>.Parse 类型转换</h4><p>效果同 Convert:</p>
<p><code>int.Parse()</code><br><code>double.Parse()</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;123&quot;</span>; </span><br><span class="line"><span class="built_in">int</span> b = <span class="built_in">int</span>.Parse(a);</span><br><span class="line"><span class="comment">//double b = double.Parse(a)</span></span><br></pre></td></tr></table></figure>

<h4 id="TryParse-类型转换"><a href="#TryParse-类型转换" class="headerlink" title=".TryParse 类型转换"></a>.TryParse 类型转换</h4><p><code>int.TryParse()</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> b = <span class="built_in">int</span>.TryParse(<span class="string">&quot;123&quot;</span>, <span class="keyword">out</span> a);</span><br><span class="line"><span class="comment">//尝试将”123“转换为int类型，如果成功就将转换后的123赋值给a，并返回true给b。如果失败则返回false给b，a赋值为0。</span></span><br><span class="line">Console.WriteLine(b);</span><br><span class="line">Console.WriteLine(a);</span><br></pre></td></tr></table></figure>
<h2 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6 命名空间"></a>6 命名空间</h2><p><strong>概念：</strong> 命名空间是用来组织和重用代码的</p>
<p><strong>作用：</strong> 就像是一个工具包，类就像是一件一件的工具，都是申明在命名空间中的</p>
<ol>
<li>不同命名空间中相互使用需要引用命名空间（<code>using namespace;</code>）或指明出处（<code>namespace.test ()</code>）</li>
<li>不同命名空间中允许有同名类</li>
<li>命名空间可以嵌套命名</li>
</ol>
<h1 id="一、变量和类型"><a href="#一、变量和类型" class="headerlink" title="一、变量和类型"></a>一、变量和类型</h1><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p><strong>值类型：</strong> 无符号整形，有符号整形，浮点数 char bool enum 结构体</p>
<p><strong>引用类型：</strong> string 类, 自定义类, 集合类，object 类，接口，委托，数组</p>
<p>值类型和引用类型<strong>区别：</strong></p>
<ol>
<li>值类型和引用类型在内存上存储的地方不一样。</li>
<li>在传递值类型和传递引用类型的时候，传递的方式不一样。值类型我们称之为值传递，引用类型我们称之为引用传递。</li>
<li>值类型的值存储在内存的<strong>栈</strong>中 (系统自动回收，小而快)，引用类型的值存储在内存的<strong>堆</strong>中（手动释放，大而慢）<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027434.png" alt="image-20220623150217728|650"></li>
</ol>
<ul>
<li>@ 引用类型的数据存在堆中，栈中只存一个地址指向堆中存储的数据<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始变量</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;                   <span class="comment">//值类型</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">//引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增变量</span></span><br><span class="line"><span class="built_in">int</span> b = a;         <span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">int</span>[] arr2 = arr1; <span class="comment">// 引用传递</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改新增变量</span></span><br><span class="line">b = <span class="number">5</span>; </span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//值传递：b是a的一个拷贝，修改b的值，不会改变a的值</span></span><br><span class="line"><span class="comment">// 引用传递：arr2是arr1的一个引用，修改arr2，会改变arr1</span></span><br><span class="line">Console.WriteLine(a);       <span class="comment">//输出1</span></span><br><span class="line">Console.WriteLine(arr1[<span class="number">0</span>]); <span class="comment">//输出5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><table>
<thead>
<tr>
<th>有符号整数类型</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>sbyte</td>
<td>8 位有符号整数类型</td>
<td>-128 到 127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16 位有符号整数类型</td>
<td>-32,768 到 32,767</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>32 位有符号整数类型</td>
<td>-2,147,483,648 到 2,147,483,647</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64 位有符号整数类型</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td>0L</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>无符号整数</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>8 位无符号整数</td>
<td>0 到 255</td>
<td>0</td>
</tr>
<tr>
<td>ushort</td>
<td>16 位无符号整数类型</td>
<td>0 到 65,535</td>
<td>0</td>
</tr>
<tr>
<td>uint</td>
<td>32 位无符号整数类型</td>
<td>0 到 4,294,967,295</td>
<td>0</td>
</tr>
<tr>
<td>ulong</td>
<td>64 位无符号整数类型</td>
<td>0 到 18,446,744,073,709,551,615</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>浮点数</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>32 位单精度浮点型</td>
<td>-3.4 x 1038 到 + 3.4 x 1038</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>64 位双精度浮点型</td>
<td>(+&#x2F;-) 5.0 x 10-324 到 (+&#x2F;-) 1.7 x 10308</td>
<td>0.0D</td>
</tr>
<tr>
<td>decimal</td>
<td>128 位精确的十进制值，28-29 有效位数</td>
<td>(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td>
<td>0.0M</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他类型</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>16 位 Unicode 字符</td>
<td>U +0000 到 U +ffff</td>
<td>‘\0’</td>
</tr>
<tr>
<td>bool</td>
<td>8 位布尔值</td>
<td>True 或 False</td>
<td>False</td>
</tr>
</tbody></table>
<ol>
<li>c# 中的小数默认为 double 类型，所以声明 float 时末尾加 f (或大写 F)显示表示 ：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> a = <span class="number">0.1654646f</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>sizeof()</code> 返回<strong>值类型</strong>变量的大小（字节）</li>
<li><strong>保留指定小数位数</strong><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="comment">//&#123;变量：0.00&#125;  保留两位</span></span><br><span class="line"><span class="built_in">double</span> n1 = <span class="number">3.33333</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;n1:<span class="number">0.00</span>&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3.33</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><table>
<thead>
<tr>
<th>C# 类型关键字</th>
<th>. NET 类型</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>System. Object</td>
</tr>
<tr>
<td>string</td>
<td>System. String</td>
</tr>
<tr>
<td>dynamic</td>
<td>System. Object</td>
</tr>
</tbody></table>
<p>在上表中，左侧列中的每个类型关键字（dynamic 除外）都是相应 .NET 类型的别名。它们是可互换的。例如，以下声明声明了相同类型的变量： </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;</span><br><span class="line">System.Int32 b = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">struct</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;  <span class="comment">//字段前要加_，用来区分变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">char</span> _gender;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!summary] 结构体和类的区别<br><strong>概述：</strong></p>
<ol>
<li>结构体和类最大的区别是在存储空间上的，因为结构体是值，类是引用，因此他们的存储位置一个在栈上，一个在堆上，</li>
<li>结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。</li>
<li>结构体具备着面向对象思想中封装的特性，但是它<strong>不具备继承和多态的特性，由于结构体不具备继承的特性，所以它不能够使用 protected 访问修饰符</strong></li>
<li>特别的，结构体可以继承接口，因为接口是行为的抽象</li>
</ol>
<p><strong>细节：</strong></p>
<ol>
<li>结构体是值类型，类是引用类型</li>
<li>结构体存在栈中，类存在堆中</li>
<li>结构体成员不能使用 protected 访问修饰符，而类可以</li>
<li>结构体成员变量声明不能指定初始值，而类可以</li>
<li>结构体不能声明无参的构造函数，而类可以</li>
<li>结构体申明有参构造函数后，无参构造不会被顶掉</li>
<li>结构体不能申明析构函数，而类可以</li>
<li>结构体不能被继承, 而类可以</li>
<li>结构体需要在构造函数中初始化所有成员变量，而类随意</li>
<li>结构体不能被静态 static 修饰 (不存在静态结构体)，而类可以</li>
<li>结构体不能在自己内部申明和自已一样的结构体变量, 而类可以</li>
</ol>
</blockquote>
<blockquote>
<p>[!info] 如何选择结构体和类</p>
<ol>
<li>想要用继承和多态时，使用类，比如玩家、怪物等等</li>
<li>对象是数据集合时，优先考虑结构体，比如位置、坐标等等</li>
<li>从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等</li>
</ol>
</blockquote>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串本质是char数组</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为char数组</span></span><br><span class="line"><span class="built_in">char</span>[] chars = str.ToCharArray();</span><br><span class="line">Console.WriteLine(chars[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="具有值类型特征"><a href="#具有值类型特征" class="headerlink" title="具有值类型特征"></a>具有值类型特征</h4><p>string 虽然是引用类型，但他有值类型的特征，每次重新赋值或拼接时会分配新的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;123&quot;</span></span><br><span class="line">string str2 = str1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若改变str2, str1不会发生改变,str2会在堆中重新分配空间</span></span><br><span class="line">str2 = <span class="string">&quot;321&quot;</span>;</span><br><span class="line"><span class="comment">//因此，频繁对string赋值会产生内存垃圾</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027439.png" alt="Pasted image 20230526153510|350"></p>
<h4 id="字符串类型拼接方式"><a href="#字符串类型拼接方式" class="headerlink" title="字符串类型拼接方式"></a>字符串类型拼接方式</h4><ol>
<li>“+” “+&#x3D;”号，不能用其他运算符</li>
<li><code>string. Format (&quot;待拼接的内容&quot;,内容 1,内容 2，......)</code><br>使用占位符 <code>&#123;数字&#125;</code> 控制拼接顺序<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="built_in">string</span>.Format(<span class="string">&quot;我是&#123;0&#125;,我今年&#123;1&#125;岁,我喜欢&#123;2&#125;&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;16&quot;</span>,<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;我是&#123;0&#125;,我今年&#123;1&#125;岁,我喜欢&#123;2&#125;&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;16&quot;</span>,<span class="string">&quot;玩游戏&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><code>$</code> 替代 <code>string.format()</code><br>原先赋值需要占位符和变量，当需要拼接多个变量会造成语句过长等不易理解问题，<code>$</code> 可以把字符串中的变量 <code>&#123;&#125;</code> 包含起来达到识别变量的目的 <code>$&quot;&#123;id&#125;&quot;</code>；也支持表达式，使用 <code>$&quot;&#123;(你的表达式)&#125;&quot;</code><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k = <span class="string">&quot;a&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> a0 = <span class="string">&quot;User&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> a1 = <span class="string">&quot;Id&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> a2 = <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> ccb = <span class="string">$&quot;select * from <span class="subst">&#123;a0&#125;</span> where <span class="subst">&#123;a1&#125;</span>=<span class="subst">&#123;a2&#125;</span>&quot;</span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">var</span> ccc = <span class="built_in">string</span>.Format(<span class="string">&quot;select * from &#123;0&#125; where &#123;1&#125; = &#123;2&#125;&quot;</span>, a0, a1, a2);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><h5 id="查找字符位置"><a href="#查找字符位置" class="headerlink" title="查找字符位置"></a>查找字符位置</h5><figure class="highlight cs"><figcaption><span>title:IndexOf查找字符位置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽管搜索方向不一样，但是字符下标依然从左向右加1，从0开始。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向查找字符位置 从左到右</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;这是一句话&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index1 = str.IndexOf(<span class="string">&quot;是&quot;</span>);  <span class="comment">//返回字符&quot;e&quot;在字符串中的索引，若查不到则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向查找字符位置 从右到左</span></span><br><span class="line"><span class="built_in">int</span> index2 = str.LastIndexOf(<span class="string">&quot;是&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="移除字符"><a href="#移除字符" class="headerlink" title="移除字符"></a>移除字符</h5><figure class="highlight cs"><figcaption><span>title:Remove移除指定位置后的字符</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;这是一句话&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单参数</span></span><br><span class="line">str = str.Remove(<span class="number">2</span>);  <span class="comment">//注意string的很多方法不会改变原字符串，都要存在一个新的字符串中或者重新赋值</span></span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="comment">//输出：这是</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定两个参数进行移除</span></span><br><span class="line">str = str.Remove(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="comment">//输出：这话</span></span><br></pre></td></tr></table></figure>
<h5 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h5><figure class="highlight cs"><figcaption><span>title:Replace替换字符</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;这是一句话&quot;</span>;</span><br><span class="line">str = str.Replace(<span class="string">&quot;一句话&quot;</span>, <span class="string">&quot;歌词&quot;</span>);</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="comment">//输出：这是歌词</span></span><br></pre></td></tr></table></figure>
<h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str = str.ToUpper();  <span class="comment">//转大写</span></span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="comment">//输出ABCDEFG</span></span><br><span class="line"></span><br><span class="line">str = str.ToLower();  <span class="comment">//转小写</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><figure class="highlight cs"><figcaption><span>title:Substringj截取字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取从指定位置开始之后的字符串</span></span><br><span class="line"><span class="comment">//单参数</span></span><br><span class="line">str = str.Substring(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出cdefg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//双参数指定范围</span></span><br><span class="line">str = str.Substring(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//输出bcd</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h5><figure class="highlight cs"><figcaption><span>title:Split切割字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;a|b|c|d|e|f|g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;|&#x27;</span> &#125;); <span class="comment">//指定切割符号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i++) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul>
<li><strong>用于处理字符串的公共类</strong></li>
<li><strong>主要解决的问题</strong>：<strong>修改字符串而不创建新的对象,</strong> 需要频繁修改和拼接的字符串可以使用它，可以提升性能</li>
<li>使用前需要引用命名空间 <code>using System.Text;</code><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，直接指明内容</span></span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456&quot;</span>);</span><br><span class="line"><span class="comment">//StringBuilder str = new StringBuilder(&quot;0123456&quot;,100); 使用第二个参数可以指定初始容量</span></span><br><span class="line">Console.WriteLine(str.ToString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder会自动扩容</span></span><br><span class="line"><span class="comment">//获得容量</span></span><br><span class="line">Console.WriteLine(str.Capacity);</span><br><span class="line"><span class="comment">//获得字符长度</span></span><br><span class="line">Console.WriteLine(str.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">str.Append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">str.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断相等</span></span><br><span class="line"><span class="keyword">if</span>(str.Equals(<span class="string">&quot;A&quot;</span>)) &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>string 和 StringBuilder 的区别</strong></p>
<ol>
<li>string 相对 StringBuilder 更容易产生垃圾，每次修改拼接都会产生垃圾</li>
<li>string 相对 StringBuilder 更加灵活因为它提供了更多的方法供使用</li>
</ol>
<p><strong>如何选择？</strong></p>
<ol>
<li>需要频繁修改拼接的字符串可以使用 StringBuilder</li>
<li>需要使用 string 独特的一些方法来处理一些特殊逻辑时可以使用 string</li>
</ol>
<blockquote>
<p>[!NOTE] 如何优化内存<br>内存优化从两个方面去解答</p>
<ol>
<li>如何节约内存</li>
<li>如何尽量少的 GC (垃圾回收)？</li>
</ol>
<p>答案：</p>
<ul>
<li>少 new 对象少产生垃圾</li>
<li>合理使用 static<br> - 合理使用 string 和 stringbuilder</li>
</ul>
</blockquote>
<h3 id="万物之父-Object-类"><a href="#万物之父-Object-类" class="headerlink" title="万物之父 Object 类"></a>万物之父 Object 类</h3><p>关键字：<code>object</code></p>
<p><strong>概念：</strong><br>object 是<strong>所有类型的基类</strong>，它是一个类 (引用类型)</p>
<p><strong>作用：</strong></p>
<ol>
<li>可以利用里氏替换原则，用 object 容器装所有对象</li>
<li>可以用来表示不确定类型，作为函数参数类型</li>
</ol>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight cs"><figcaption><span>title:object类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文讲过的里氏替换</span></span><br><span class="line">Father f = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">if</span> (f <span class="keyword">is</span> Son)</span><br><span class="line">&#123;</span><br><span class="line">    (f <span class="keyword">as</span> Son).Speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用object类</span></span><br><span class="line"><span class="comment">//引用类型</span></span><br><span class="line"><span class="built_in">object</span> o = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> Son)</span><br><span class="line">&#123;</span><br><span class="line">    (o <span class="keyword">as</span> Son).Speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值类型</span></span><br><span class="line"><span class="built_in">object</span> o2 = <span class="number">10.0f</span>;     <span class="comment">//装箱</span></span><br><span class="line"><span class="built_in">float</span> f2 = (<span class="built_in">float</span>)o2;  <span class="comment">//拆箱，强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="built_in">object</span> ostr = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str1 = ostr.ToString();</span><br><span class="line"><span class="built_in">string</span> str2 = ostr <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">//建议引用类型都用as的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="built_in">object</span> oarr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr1 = (<span class="built_in">int</span>[])oarr;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = oarr <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>发生条件</strong></p>
<ol>
<li>用 object 存值类型（装箱)</li>
<li>再把 object 转为值类型 (拆箱)</li>
</ol>
<p><strong>装箱</strong></p>
<ul>
<li>把值类型用引用类型存储，如 <code>object o = 10.0f;</code></li>
<li>栈内存会迁移到堆内存中</li>
</ul>
<p><strong>拆箱</strong></p>
<ul>
<li>把引用类型存储的值类型取出来，如 <code>float f = (float)o;</code></li>
<li>堆内存会迁移到栈内存中</li>
</ul>
<p><strong>好处:</strong> 不确定类型时可以方便参数的存储和传递<br><strong>坏处:</strong> 存在内存迁移，增加性能消耗</p>
<h4 id="object-的方法"><a href="#object-的方法" class="headerlink" title="object 的方法"></a>object 的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027435.png">  </p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><ol>
<li><p><code>Equals</code>： 判断两个对象是否相等<br>最终的判断权，交给左侧对象的 Equals 方法，<br>不管值类型引用类型都会按照左侧对象 Equals 方法的规则来进行比较</p>
</li>
<li><p><code>ReferenceEquals</code>：比较两个对象是否是相同的引用，主要是用来比较引用类型的对象。值类型对象返回值始终是 false。</p>
</li>
</ol>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ol>
<li>普通方法 <code>GetType</code></li>
</ol>
<ul>
<li>该方法在反射相关知识点中是非常重要的方法，之后我们会具体的讲解这里返回的 Type 类型。</li>
<li>该方法的主要作用就是获取对象运行时的类型 Type,</li>
<li>通过 Type 结合反射相关知识点可以做很多关于对象的操作。</li>
</ul>
<ol start="2">
<li>普通方法 <code>Memberwiseclone</code></li>
</ol>
<ul>
<li>该方法用于获取对象的浅拷贝对象，口语化的意思就是会返回一个新的对象, 但是新对象中的引用变量会和老对象中一致。</li>
</ul>
<h5 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h5><ol>
<li><code>Equals</code></li>
</ol>
<ul>
<li>默认实现还是比较两者是否为同一个引用，即相当于 <code>ReferenceEquals</code>。</li>
<li>但是微软在所有值类型的基类 <code>system. ValueType</code> 中重写了该方法, 用来比较值相等。</li>
<li>我们也可以重写该方法，定义自己的比较相等的规则</li>
</ul>
<ol start="2">
<li><code>GetHashcode</code></li>
</ol>
<ul>
<li>该方法是获取对象的哈希码</li>
<li>一种通过算法算出的，表示对象的唯一编码，不同对象哈希码有可能一样，具体值根据</li>
<li>我们可以通过重写该函数来自己定义对象的哈希码算法，正常情况下，我们使用的极少</li>
</ul>
<ol start="3">
<li><code>ToString</code></li>
</ol>
<ul>
<li>该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，</li>
<li>该方法非常常用。当我们调用打印方法时，默认使用的就是对象的 Tostring 方法后打印出来的内容。</li>
</ul>
<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 变量类型 变量名 = 值</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> a = <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>? 常量是特殊的静态 static？</li>
<li><strong>const (常量)可以理解为特殊的 static (静态)</strong></li>
<li><strong>相同点</strong><br>他们都可以通过类名点出使用</li>
<li><strong>不同点</strong><ol>
<li>const 必须初始化，不能修改， static 没有这个规则</li>
<li>const 只能修饰变量、static 可以修饰很多</li>
<li>const 一定是写在访问修饰符后面的，static 没有这个要求</li>
</ol>
</li>
</ul>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建能够产生随机数的对象</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//2. 让产生随机数的这个对象调用方法来产生随机数</span></span><br><span class="line">r.Next(); <span class="comment">//生成一个非负的随机数  </span></span><br><span class="line">r.Next(<span class="number">100</span>); <span class="comment">//生成[0,99)的随机数  </span></span><br><span class="line">r.Next(<span class="number">5</span>,<span class="number">100</span>); <span class="comment">//生成[5,99)的随机数</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight cs"><figcaption><span>title:声明枚举</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> 枚举名</span><br><span class="line">&#123;</span><br><span class="line">    值<span class="number">1</span>, <span class="comment">//默认值为0，后面依次递增</span></span><br><span class="line">    值<span class="number">2</span>,</span><br><span class="line">    值<span class="number">3</span>,</span><br><span class="line">    ......</span><br><span class="line">    值n  <span class="comment">//最后一个逗号可加可不加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>枚举通常声明到 namespace 的下面，class 的外面，表示这个命名空间下，所有的类都可以使用这个枚举。</li>
<li>不可以在函数中声明</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:枚举搭配switch使用：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> EPlayer</span><br><span class="line">    &#123;</span><br><span class="line">        singer,</span><br><span class="line">        writer,</span><br><span class="line">        teacher,</span><br><span class="line">        student</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            EPlayer Player1 = EPlayer.singer; <span class="comment">//定义枚举变量</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (Player1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> EPlayer.singer:</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EPlayer.student:</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:枚举类型转换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPlayer Player = EPlayer.singer;  </span><br><span class="line"><span class="comment">// 枚举转int  </span></span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)Player;  </span><br><span class="line"><span class="comment">// int转枚举  </span></span><br><span class="line">Player = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 枚举转string  </span></span><br><span class="line"><span class="built_in">string</span> str = Player.ToString();  </span><br><span class="line"><span class="comment">// string转枚举  </span></span><br><span class="line">Player = (EPlayer)Enum.Parse(<span class="keyword">typeof</span>(EPlayer), <span class="string">&quot;teacher&quot;</span>); <span class="comment">// 注意第二个变量值必须是枚举声明中的成员</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组<strong>声明后不可以改变长度</strong>，若想在原数组的基础上进行收缩，需要新建一个数组，将值复制到新数组。</p>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight cs"><figcaption><span>title:一维数组的声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums;  <span class="comment">//只声明不初始化</span></span><br><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]; <span class="comment">//全部为默认值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式等价</span></span><br><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:一维数组方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> len = nums.Lenght()  <span class="comment">//数组长度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:增加和减少数组中的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加数组中的元素</span></span><br><span class="line"><span class="built_in">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array1[i] = array[i];</span><br><span class="line">&#125;</span><br><span class="line">array = array1;  <span class="comment">//最后将新数组赋值给旧数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历打印array结果为</span></span><br><span class="line"><span class="comment">//1，2，3，4，5，0，0，0，0，0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//j减少数组中的元素</span></span><br><span class="line"><span class="built_in">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] array2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array2.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array2[i] = array[i];</span><br><span class="line">&#125;</span><br><span class="line">array = array2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历打印array结果为</span></span><br><span class="line"><span class="comment">//1，2，3，4，5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight cs"><figcaption><span>title:二维数组的声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] nums;  <span class="comment">//只声明不初始化</span></span><br><span class="line"><span class="built_in">int</span>[,] nums = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">3</span>]; <span class="comment">//全部为默认值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式等价</span></span><br><span class="line"><span class="built_in">int</span>[,] nums = <span class="keyword">new</span> <span class="built_in">int</span>[,]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">                           </span><br><span class="line"><span class="built_in">int</span>[,] nums = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">                           </span><br><span class="line"><span class="built_in">int</span>[,] nums = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">               &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:二维数组方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums.GetLength(<span class="number">0</span>) <span class="comment">//获取行数</span></span><br><span class="line">nums.GetLength(<span class="number">1</span>) <span class="comment">//获取列数</span></span><br></pre></td></tr></table></figure>
<h4 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h4><p>不常用，和二维数组的区别在于，每行的列数可以不同</p>
<figure class="highlight cs"><figcaption><span>title:交错数组的声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] arr1;</span><br><span class="line"><span class="built_in">int</span>[][] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[][] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[][]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="built_in">int</span>[][] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="built_in">int</span>[][] arr5 = </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><figcaption><span>title:交错数组方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums.<span class="built_in">GetLength</span>(<span class="number">0</span>) <span class="comment">//获取行数</span></span><br><span class="line">nums[<span class="number">0</span>].<span class="built_in">Length</span>(<span class="number">1</span>) <span class="comment">//获取某一行的列数</span></span><br></pre></td></tr></table></figure>
<h2 id="集合类（Collection）"><a href="#集合类（Collection）" class="headerlink" title="集合类（Collection）"></a>集合类（Collection）</h2><p>集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。</p>
<p>集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。<strong>这些类创建 Object 类的对象的集合</strong>。在 C# 中，Object 类是所有数据类型的基类。</p>
<p>下面是各种常用的 <strong>System. Collection</strong> 命名空间的类：</p>
<h3 id="ArrayList-（动态数组）"><a href="#ArrayList-（动态数组）" class="headerlink" title="ArrayList （动态数组）"></a>ArrayList （动态数组）</h3><p><strong>ArrayList 和数组的区别</strong><br>ArrayList：长度可以随意改变，可以存储任意类型的数据<br>数组：长度不可变，类型单一</p>
<p>每次集合中实际包含的元素个数 (count)超过了可以包含的元素的个数 (capcity)的时候，集合就会向内存中申请<strong>多开辟一倍</strong>的空间，来保证集合的长度一直够用。</p>
<p>ArrayList 中的元素都存储为 <code>object</code> 类型（可以存储任何类型数据），存在装箱拆箱的损耗，所以 ArrayList 尽量少用。<strong>用 List 即可！</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">array.Add(<span class="number">1</span>); <span class="comment">//添加单个元素：list.Add();</span></span><br><span class="line">array.Add(<span class="number">2.1</span>);</span><br><span class="line">array.Add(<span class="literal">true</span>);</span><br><span class="line">array.Add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">array.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);  <span class="comment">//添加集合：list.AddRange();</span></span><br><span class="line">array.insert(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>); <span class="comment">//插入指定位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">array.Remove(<span class="string">&quot;张三&quot;</span>); <span class="comment">//指定删除单个元素</span></span><br><span class="line">array.RemoveAt(<span class="number">0</span>); <span class="comment">//根据指定位置单个元素</span></span><br><span class="line">array.RemoveRange(<span class="number">0</span>，n); <span class="comment">//（从下标0开始删除n个）</span></span><br><span class="line">array.Clear(); <span class="comment">//清空所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">array[<span class="number">0</span>];  <span class="comment">//按下标查找</span></span><br><span class="line">array.Contains(<span class="string">&quot;张三&quot;</span>); <span class="comment">//查看元素是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管搜索方向不一样，但是字符下标依然从左向右加1，从0开始。</span></span><br><span class="line">array.IndexOf(<span class="string">&quot;张三&quot;</span>);      <span class="comment">//从左往右查找，找到返回下标，找不到返回-1</span></span><br><span class="line">array.LastIndexOf(<span class="string">&quot;张三&quot;</span>);  <span class="comment">//从右往左查找，找到返回下标，找不到返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;李四&quot;</span>; <span class="comment">//通过下标改</span></span><br><span class="line">array.Sort(); <span class="comment">//升序排列</span></span><br><span class="line">array.Reverse(); <span class="comment">//反转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array.Count;   <span class="comment">//元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> array)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>栈，先进后出</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈  </span></span><br><span class="line">stack.Push(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出栈  </span></span><br><span class="line">stack.Pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="comment">//栈无法查看指定位置的元素,只能查看栈顶的内容  </span></span><br><span class="line">s = stack.Peek(); <span class="comment">//注意只是查看，不是出栈  </span></span><br><span class="line">stack.Contains(<span class="string">&quot;1&quot;</span>); <span class="comment">//查看元素是否存在于栈中  </span></span><br><span class="line">stack.Count; <span class="comment">//栈的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">stack.Clear(); <span class="comment">//清空栈  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈不能使用[]访问，所以无法使用for循环遍历，一般使用foreach</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line"><span class="comment">//将队列转换为object数组</span></span><br><span class="line"><span class="built_in">object</span>[] array = stack.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环出栈</span></span><br><span class="line"><span class="keyword">while</span> (stack.Count&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> p = stack.Pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列，先进先出</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;1&quot;</span>);   、</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">queue.Dequeue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">queue.Peek();  <span class="comment">//查看队列头元素但不会移除  </span></span><br><span class="line">queue.Contains(<span class="string">&quot;1&quot;</span>); <span class="comment">//查看队列中是否包含某个元素  </span></span><br><span class="line">queue.Count;<span class="comment">//队列长度  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">queue.Clear();  <span class="comment">//清空队列  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列不能使用[]访问，所以无法使用for循环遍历，一般使用foreach</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line"><span class="comment">//将队列转换为object数组</span></span><br><span class="line"><span class="built_in">object</span>[] array = queue.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环出队</span></span><br><span class="line"><span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">object</span> v5 = queue.Dequeue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>哈希表（又称散列表），键值对</p>
<figure class="highlight cs"><figcaption><span>title:增删查改</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增：键不能相同  </span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="string">&quot;value1&quot;</span>);  </span><br><span class="line">hashtable.Add(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);  </span><br><span class="line">hashtable.Add(<span class="literal">true</span>, <span class="string">&quot;value3&quot;</span>);、</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">hashtable.Remove(<span class="number">1</span>);   <span class="comment">//根据键删除  </span></span><br><span class="line">hashtable.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">hashtable[<span class="string">&quot;2&quot;</span>];  <span class="comment">//根据键查找值，如果键不存在，返回 null  </span></span><br><span class="line">hashtable.ContainsKey(<span class="string">&quot;key&quot;</span>);  <span class="comment">//判断是否包含某个键  </span></span><br><span class="line">hashtable.ContainsValue(<span class="string">&quot;value4&quot;</span>);  <span class="comment">//判断是否包含某个值  </span></span><br><span class="line">hashtable.Count; <span class="comment">//获取键值对数量  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">hashtable[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value4&quot;</span>;  <span class="comment">//根据键修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有键</span></span><br><span class="line">ICollection keys = hashtable.Keys;  <span class="comment">//获取键的集合</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> keys) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有值</span></span><br><span class="line">ICollection values = hashtable.Values; <span class="comment">//获取值的集合</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对一起遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (DictionaryEntry item <span class="keyword">in</span> hashtable)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Key + <span class="string">&quot;:&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line">IEnumerator enumerator1 = hashtable.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator1.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    DictionaryEntry item = (DictionaryEntry)enumerator1.Current;</span><br><span class="line">    Console.WriteLine(item.Key + <span class="string">&quot;:&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDictionaryEnumerator enumerator2 = hashtable.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator2.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(enumerator2.Key + <span class="string">&quot;:&quot;</span> + enumerator2.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h2><p>泛型数据结构类和集合类区别：</p>
<ol>
<li>泛型数据结构类可以<strong>指定泛型类型</strong>，避免了装箱拆箱的性能损耗</li>
<li>集合类数据类型都是 Object 类型，有装箱拆箱的性能损耗</li>
</ol>
<h3 id="List"><a href="#List" class="headerlink" title="List&lt;&gt;"></a>List&lt;&gt;</h3><p>本质是一个<strong>可变类型的泛型数组</strong>，和 ArrayList 主要区别在于可以指定泛型类型，避免了装箱拆箱的性能损耗</p>
<figure class="highlight cs"><figcaption><span>title:增删查改</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line"></span><br><span class="line">list.Add(<span class="number">1</span>);<span class="comment">//添加单个元素</span></span><br><span class="line">list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;);<span class="comment">//添加集合</span></span><br><span class="line">list.Insert(<span class="number">1</span>, <span class="number">66</span>);<span class="comment">//插入指定位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">list.Remove(<span class="string">&quot;张三&quot;</span>); <span class="comment">//指定删除单个元素</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>); <span class="comment">//根据指定位置单个元素</span></span><br><span class="line">list.RemoveRange(<span class="number">0</span>，n); <span class="comment">//（从下标0开始删除n个）</span></span><br><span class="line">list.Clear(); <span class="comment">//清空所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">list[<span class="number">0</span>];  <span class="comment">//按下标查找</span></span><br><span class="line">list.Contains(<span class="number">1</span>); <span class="comment">//查看元素是否存在</span></span><br><span class="line">list.Count;   <span class="comment">//list长度</span></span><br><span class="line"><span class="comment">// 尽管搜索方向不一样，但是字符下标依然从左向右加1，从0开始。</span></span><br><span class="line">list.IndexOf(<span class="number">1</span>);      <span class="comment">//从左往右查找，找到返回下标，找不到返回-1</span></span><br><span class="line">list.LastIndexOf(<span class="number">1</span>);  <span class="comment">//从右往左查找，找到返回下标，找不到返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">list[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//通过下标改</span></span><br><span class="line">list.Reverse(); <span class="comment">//反转</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用迭代器遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(item);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//for循环遍历  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(list[i]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="List-的排序"><a href="#List-的排序" class="headerlink" title="List 的排序"></a>List 的排序</h4><p>内置变量一般通过 Sort 方法进行进行排序，自定义类则需要自己写方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Sort(); <span class="comment">//升序排列</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义类的排序"><a href="#自定义类的排序" class="headerlink" title="自定义类的排序"></a>自定义类的排序</h5><ol>
<li>继承 <code>IComparable&lt;Item&gt;</code> 接口</li>
<li>实现接口的方法 <code>CompareTo(Item other)</code> 方法</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:自定义类的排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Item</span> : <span class="title">IComparable</span>&lt;<span class="title">Item</span>&gt; <span class="comment">//继承IComparable接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">int</span> money</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Item other</span>)  <span class="comment">//实现接口的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回值的含义</span></span><br><span class="line">        <span class="comment">// &lt;0：放在传入对象的前面</span></span><br><span class="line">        <span class="comment">// =0：保持当前的位置不变</span></span><br><span class="line">        <span class="comment">// &gt;0：放在传入对象的后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以简单理解传入对象的位置就是0</span></span><br><span class="line">        <span class="comment">//返回负数就放在它的左边，也就是前面</span></span><br><span class="line">        <span class="comment">//返回正数就放在它的右边，也就是后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下实现类的升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.money &gt; other.money) <span class="comment">//如果当前对象的money大于传入对象的money</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回正数，放在传入对象的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.money == other.money) <span class="comment">//如果当前对象的money等于传入对象的money</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//返回0，保持当前位置不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果当前对象的money小于传入对象的money</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//返回负数，放在传入对象的前面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自定义类的排序</span></span><br><span class="line">        List&lt;Item&gt; itemList = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">        </span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">10</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">25</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">13</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">40</span>));</span><br><span class="line">        itemList.Sort();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;itemList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(itemList[i].money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//13</span></span><br><span class="line"><span class="comment">//25</span></span><br><span class="line"><span class="comment">//40</span></span><br></pre></td></tr></table></figure>
<h5 id="通过委托函数排序"><a href="#通过委托函数排序" class="headerlink" title="通过委托函数排序"></a>通过委托函数排序</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">int</span> money</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自定义类的排序</span></span><br><span class="line">        List&lt;Item&gt; itemList = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">        </span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">10</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">25</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">13</span>));</span><br><span class="line">        itemList.Add(<span class="keyword">new</span> Item(<span class="number">40</span>));</span><br><span class="line">        itemList.Sort(SortItem);   <span class="comment">//传入一个委托,委托的参数为两个对象,返回值为int</span></span><br><span class="line">        <span class="comment">// 也可以使用匿名函数简化</span></span><br><span class="line">        <span class="comment">// itemList.Sort((Item a, Item b) =&gt; &#123;  if (a.money &gt; b.money)</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         return 1;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     else if (a.money == b.money)</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         return 0;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     else</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         return -1;</span></span><br><span class="line">        <span class="comment">//     &#125;     &#125;);  </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;itemList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(itemList[i].money);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下实现类的升序排序</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortItem</span>(<span class="params">Item a, Item b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//传入的两个对象为列表中的两个对象</span></span><br><span class="line">            <span class="comment">//进行两两的比较,用左边的和右边的条件比较</span></span><br><span class="line">            <span class="comment">//返回值规则和之前一样, 0做标准,负数在左（前),正数在右（后)</span></span><br><span class="line">            <span class="keyword">if</span> (a.money &gt; b.money)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.money == b.money)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//13</span></span><br><span class="line"><span class="comment">//25</span></span><br><span class="line"><span class="comment">//40</span></span><br></pre></td></tr></table></figure>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary&lt;&gt;"></a>Dictionary&lt;&gt;</h3><p>字典，可以将 <code>Dictionary</code> 理解为拥有<strong>泛型的 <code>Hashtable</code><strong>，它也是基于键的哈希代码组织起来的键&#x2F;值对，</strong>键值对类型从 Hashtable 的 object 变为了可以自己制定的泛型</strong></p>
<figure class="highlight cs"><figcaption><span>title:增删查改</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增：键不能相同  </span></span><br><span class="line">dictionary.Add(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删：根据键删除 </span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br><span class="line">dictionary.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="built_in">string</span> v1 = dictionary[<span class="number">1</span>];  <span class="comment">//通过建获取值如果，不存在会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过TryGetValue获取值</span></span><br><span class="line"><span class="built_in">string</span> v2;</span><br><span class="line"><span class="keyword">if</span> (dictionary.TryGetValue(<span class="number">1</span>, <span class="keyword">out</span> v2))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictionary.ContainsValue(<span class="string">&quot;one&quot;</span>)  <span class="comment">//判断是否包含某个键  </span></span><br><span class="line">dictionary.ContainsKey(<span class="number">1</span>)  <span class="comment">//判断是否包含某个值  </span></span><br><span class="line">dictionary.Count  <span class="comment">//获取键值对数量  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;ONE&quot;</span>;  <span class="comment">//根据键修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有键</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> key <span class="keyword">in</span> dictionary.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有值</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> <span class="keyword">value</span> <span class="keyword">in</span> dictionary.Values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对一起遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> key = item.Key;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">value</span> = item.Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line">IEnumerator&lt;KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;&gt; enumerator = dictionary.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; item = enumerator.Current;</span><br><span class="line">    <span class="built_in">int</span> key = item.Key;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">value</span> = item.Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList-和-LinkedListNode"><a href="#LinkedList-和-LinkedListNode" class="headerlink" title="LinkedList&lt;&gt; 和 LinkedListNode&lt;&gt;"></a>LinkedList&lt;&gt; 和 LinkedListNode&lt;&gt;</h3><p><code>LinkedList</code> 本质是一个<strong>可变类型的泛型双向链表</strong><br><code>LinkedListNode</code> 是<strong>链表节点类</strong></p>
<figure class="highlight cs"><figcaption><span>title:增删查改</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();  </span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First; <span class="comment">//获取头节点  </span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last; <span class="comment">//获取尾节点  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//增  </span></span><br><span class="line">linkedList.AddLast(<span class="number">1</span>); <span class="comment">//尾部添加  </span></span><br><span class="line">linkedList.AddFirst(<span class="number">2</span>); <span class="comment">//头部添加  </span></span><br><span class="line">linkedList.AddAfter(first, <span class="number">3</span>); <span class="comment">//指定节点后添加  </span></span><br><span class="line">linkedList.AddBefore(first, <span class="number">4</span>); <span class="comment">//指定节点前添加  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//删  </span></span><br><span class="line">linkedList.Remove(<span class="number">1</span>); <span class="comment">//删除指定元素  </span></span><br><span class="line">linkedList.RemoveFirst(); <span class="comment">//删除头部元素  </span></span><br><span class="line">linkedList.RemoveLast(); <span class="comment">//删除尾部元素  </span></span><br><span class="line">linkedList.Remove(first); <span class="comment">//删除指定节点  </span></span><br><span class="line">linkedList.Clear(); <span class="comment">//清空链表  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//查  </span></span><br><span class="line">linkedList.Contains(<span class="number">1</span>); <span class="comment">//是否包含指定元素  </span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node1 = linkedList.Find(<span class="number">1</span>); <span class="comment">//查找指定元素  </span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node2 = linkedList.FindLast(<span class="number">1</span>); <span class="comment">//查找最后一个指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改  </span></span><br><span class="line"><span class="comment">//要先得到再改，得到节点，再改变其中的值  </span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node3 = linkedList.Find(<span class="number">1</span>);  </span><br><span class="line">node3.Value = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:b遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过foreach遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> linkedList)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过节点遍历 </span></span><br><span class="line"><span class="comment">//从头到尾</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br><span class="line"><span class="keyword">while</span> (first != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(node.Value);</span><br><span class="line">    node = node.Next;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//从尾到头</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br><span class="line"><span class="keyword">while</span> (last != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(node4.Value);</span><br><span class="line">    node4 = node4.Previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack&lt;&gt;"></a>Stack&lt;&gt;</h3><p>栈，先进后出</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈  </span></span><br><span class="line">stack.Push(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出栈  </span></span><br><span class="line">stack.Pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="comment">//栈无法查看指定位置的元素,只能查看栈顶的内容  </span></span><br><span class="line">s = stack.Peek(); <span class="comment">//注意只是查看，不是出栈  </span></span><br><span class="line">stack.Contains(<span class="string">&quot;1&quot;</span>); <span class="comment">//查看元素是否存在于栈中  </span></span><br><span class="line">stack.Count; <span class="comment">//栈的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">stack.Clear(); <span class="comment">//清空栈  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈不能使用[]访问，所以无法使用for循环遍历，一般使用foreach</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line"><span class="comment">//将队列转换为object数组</span></span><br><span class="line"><span class="built_in">object</span>[] array = stack.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环出栈</span></span><br><span class="line"><span class="keyword">while</span> (stack.Count&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> p = stack.Pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue&lt;&gt;"></a>Queue&lt;&gt;</h3><p>队列，先进先出</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="built_in">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;1&quot;</span>);   、</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">queue.Dequeue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"></span><br><span class="line">queue.Peek();  <span class="comment">//查看队列头元素但不会移除  </span></span><br><span class="line">queue.Contains(<span class="string">&quot;1&quot;</span>); <span class="comment">//查看队列中是否包含某个元素  </span></span><br><span class="line">queue.Count;<span class="comment">//队列长度  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">queue.Clear();  <span class="comment">//清空队列  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列不能使用[]访问，所以无法使用for循环遍历，一般使用foreach</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line"><span class="comment">//将队列转换为object数组</span></span><br><span class="line"><span class="built_in">object</span>[] array = queue.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环出队</span></span><br><span class="line"><span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">object</span> v5 = queue.Dequeue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、函数（方法）"><a href="#二、函数（方法）" class="headerlink" title="二、函数（方法）"></a>二、函数（方法）</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> 返回值类型 函数名（参数列表）</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public：访问修饰符</span></span><br><span class="line"><span class="comment">//static：静态的</span></span><br><span class="line"><span class="comment">//返回值类型：如果不需要写返回值，写void</span></span><br><span class="line"><span class="comment">//方法名：Pascal 每个单词首字母都大写</span></span><br><span class="line"><span class="comment">//参数列表：完成这个方法所必须要提供给这个方法的条件</span></span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetMax</span>(<span class="params"><span class="built_in">int</span> n1, <span class="built_in">int</span> n2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n1&gt; n2 ? n1 : n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ref-和-out-参数"><a href="#ref-和-out-参数" class="headerlink" title="ref 和 out 参数"></a>ref 和 out 参数</h2><p>#ref #out<br>他们使用的方式和效果都是一样：</p>
<ol>
<li><strong>解决值类型和引用类型在函数内部改值</strong></li>
<li>重新声明能够影响外部传入的变量，让其也被修改（使传入的参数在函数外也修改 ）</li>
</ol>
<p><strong>ref 和 out 的区别：</strong>  </p>
<ol>
<li>ref 传入的变量 (参数) 必须初始化，out 不用。  </li>
<li>out 传入的变量必须在内部赋值，ref 不用。</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:ref参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeValue</span> (<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> b = <span class="number">10</span></span><br><span class="line">ChangeValue(b); </span><br><span class="line"><span class="comment">//因为值传递的原因，b的值没有改变，我们想让b被改成20可以使用ref：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数前添加 ref 修饰符 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeValue</span> (<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">10</span></span><br><span class="line">ChangeValue(b);</span><br><span class="line"><span class="comment">//b改变为20 在函数内修改传入参数 传入的参数在外部也会修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你在一个方法中，返回多个相同类型的值的时候，可以考虑返回一个数组。<br>但是，如果返回多个不同类型的值的时候，返回数组就不行了，那么这个时候，<br>我们可以考虑使用 out 参数。<strong>out 参数就侧重于在一个方法中可以返回多个不同类型的值。</strong></p>
<figure class="highlight cs"><figcaption><span>title:out参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span>[]nums,<span class="keyword">out</span> <span class="built_in">int</span> max.<span class="keyword">out</span> <span class="built_in">int</span> min,<span class="keyword">out</span> <span class="built_in">int</span> sum,<span class="keyword">out</span> <span class="built_in">float</span> avr</span>)</span></span><br><span class="line"><span class="function"><span class="comment">//out int max写到形参列表中</span></span></span><br><span class="line">&#123;</span><br><span class="line">    max = nums[<span class="number">0</span>];</span><br><span class="line">    min = nums[<span class="number">1</span>];</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    avr = sum / nums.Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部调用：</span></span><br><span class="line">Test（nums,<span class="keyword">out</span> max,<span class="keyword">out</span> min,<span class="keyword">out</span> sun,<span class="keyword">out</span> avr）;</span><br></pre></td></tr></table></figure>

<h2 id="params-可变参数"><a href="#params-可变参数" class="headerlink" title="params 可变参数"></a>params 可变参数</h2><ul>
<li>可以输入不定的多个参数，并把这些参数存入数组。将实参列表中跟可变参数数组类型一致的元素都当做数组的元素去处理。</li>
<li>在函数参数中只能最多出现一个 <code>params</code> 关键字且一定在形参列表最后</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用可变参数：</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] s = &#123; <span class="number">100</span>, <span class="number">80</span>, <span class="number">95</span> &#125;;</span><br><span class="line">    Test(<span class="string">&quot;张三&quot;</span>, s);   <span class="comment">//主要区别再第二个参数这里</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span> (<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span>[] score</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;score.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += score[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span>这次考试总成绩是<span class="subst">&#123;sum&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改用params后：</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// int[] s = &#123; 100, 80, 95 &#125;;</span></span><br><span class="line">    Test(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">95</span>); <span class="comment">//可变长度，可以增加其他成绩</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span> (<span class="params"><span class="built_in">string</span> name, <span class="keyword">params</span> <span class="built_in">int</span>[] score</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;score.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += score[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span>这次考试总成绩是<span class="subst">&#123;sum&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p><strong>有参数默认值的参数一般称为可选参数</strong><br>作用是当调用函数时可以不传入参数，不传就会使用默认值作为参数的值</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Speak</span> (<span class="params"><span class="built_in">string</span> str == <span class="string">&quot;hello&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持多个参数默认值</li>
<li>可选参数必须写在普通参数后面</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>概念：方法的重载指的就是<strong>方法的名称相同，但是参数不同</strong>。<br><strong>参数不同，分为三种情况</strong></p>
<ol>
<li>如果参数的个数相同，那么参数的类型就不能相同。</li>
<li>果参数的类型相同，那么参数的个数就不能相同。</li>
<li>参数顺序不同</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span> (<span class="params"><span class="built_in">int</span> n1,<span class="built_in">int</span> n2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">M</span>(<span class="params"><span class="built_in">double</span> d1,<span class="built_in">double</span> d2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> d1 + d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"><span class="built_in">int</span> n1,<span class="built_in">int</span> n2,<span class="built_in">int</span> n3</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = n1 + n2 + n3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">M</span>(<span class="params"><span class="built_in">string</span> s1,<span class="built_in">string</span> s2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、表达式和运算符"><a href="#三、表达式和运算符" class="headerlink" title="三、表达式和运算符"></a>三、表达式和运算符</h1><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ol>
<li>换行 <code>\n</code>  ：(windows 操作系统只认识 <code>\r\n</code>，不认识 <code>\n</code>)</li>
<li>英文半角双引号：<code>\&quot;\&quot;</code>  中文半角可以直接打印出</li>
<li>一个 Tab 空格: <code>\t</code></li>
<li>警报音：<code>\a</code></li>
<li>退格：<code>\b</code></li>
<li>斜杠：<code>\\ </code></li>
<li><code>@</code> ：取消转义符的作用（用来存路径）&#x2F;将字符串按照原格式输出</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">@&quot;C：\mycode\a\文件.txt&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑与：&amp;&amp;<br>逻辑或：||<br>逻辑非：！</p>
<p>运算符优先级：</p>
<ol>
<li><strong>非</strong>优先级最高</li>
<li>逻辑<strong>与</strong>优先级大于逻辑<strong>或</strong></li>
<li><strong>逻辑与</strong>、<strong>逻辑或</strong>优先级<strong>低</strong>于算术运算符和条件运算符</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符主要用数值类型进行计算，将数值转换为 2 进制，在进行位运算</p>
<ol>
<li><p>位与：&amp;<br>对位运算，有 0 则 0</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>; <span class="comment">//001</span></span><br><span class="line"><span class="built_in">int</span> b = <span class="number">5</span>; <span class="comment">//101</span></span><br><span class="line"><span class="built_in">int</span> c = a &amp; b;</span><br><span class="line"><span class="comment">//得 c = 1  //001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位或：|<br>对位运算，有 1 则 1</p>
</li>
<li><p>异或：^<br>对位运算，相同为 0，不同为 1</p>
</li>
<li><p>位取反：~<br>对位运算，0 变 1，1 变 0</p>
</li>
<li><p>左移：&lt;&lt;</p>
</li>
<li><p>右移：&gt;&gt;<br>让一个数的 2 进制数进行左移和右移</p>
</li>
</ol>
<ul>
<li>左移几位，右侧就加几个 0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>; <span class="comment">// 101</span></span><br><span class="line">c = a &lt;&lt; <span class="number">5</span> </span><br><span class="line"><span class="comment">// 1位 1010</span></span><br><span class="line"><span class="comment">// 2位 10100</span></span><br><span class="line"><span class="comment">// 3位 101000</span></span><br><span class="line"><span class="comment">// 4位 1010000</span></span><br><span class="line"><span class="comment">// 5位 10100000 = 160</span></span><br></pre></td></tr></table></figure></li>
<li>右移几位，右侧去掉几个数<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>;  <span class="comment">// 101</span></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 1位 10</span></span><br><span class="line"><span class="comment">// 2位 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><blockquote>
<p>[!success] 可重载运算符<br>算数运算符： + - * &#x2F; % ++ –  </p>
</blockquote>
<p>逻辑运算符： ！  </p>
<blockquote>
</blockquote>
<p>位运算符： &amp; | ^ ~ &lt;&lt; &gt;&gt;  </p>
<blockquote>
</blockquote>
<p>条件运算符: &lt; &lt;&#x3D; &gt; &gt;&#x3D; &#x3D;&#x3D; !&#x3D;  </p>
<blockquote>
<p>[!error] 不可重载运算符</p>
</blockquote>
<p>逻辑运算符 ： &amp;&amp; || [ ] () . &#x3D; ?:  </p>
<p><strong>作用</strong><br>让自定义类和结构体，能够使用运算符</p>
<p>使用关键字 <code>operator</code></p>
<p><strong>特点</strong></p>
<ol>
<li>一定是一个公共的静态方法 <code>public static</code> </li>
<li>返回值写在 <code>operator</code> 前</li>
<li>逻辑处理自定义</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>条件运算符需要成对实现（比如 <code>==</code> 和 <code>!=</code> 必须成对实现）</li>
<li>一个符号可以多个重载</li>
<li>不能使用 <code>ref</code> 和 <code>out</code></li>
</ol>
<figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">p1.x =<span class="number">1</span>;</span><br><span class="line">p1.y =<span class="number">1</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line">p2.x= <span class="number">2</span>;</span><br><span class="line">p2.y = <span class="number">2</span>;</span><br><span class="line">Point p3 =p1 + p2; <span class="comment">//使用重载的+</span></span><br><span class="line">Console.WriteLine(p3.x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、语句（控制流）"><a href="#四、语句（控制流）" class="headerlink" title="四、语句（控制流）"></a>四、语句（控制流）</h1><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>增加代码健壮性：哪行代码有可能出现异常，就 try 它。</p>
<p>语法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//出现异常后要执行的代码；</span></span><br><span class="line">    <span class="comment">//catch(Exception e)具体报错跟踪，通过e得到具体的错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （可选）最后执行的代码，不管有没有出错都会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果无异常，则catch内代码不会执行。如果出现异常，则后续代码不再执行，而是跳到catch的代码。（try-catch中间不能有其他代码）</span></span><br><span class="line"><span class="comment">// 注意三个语句后面不需要加;</span></span><br></pre></td></tr></table></figure>

<p>我们使用编辑器自动实现一些函数时，IDE 会自动添加</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意思是说明该方法未实现，如果运行会抛出异常。</p>
<h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>foreach 循环用于列举出集合中所有的元素，foreach 语句中的表达式由关键字 in 隔开的两个项组成。</p>
<p>in 右边的项是集合名，in 左边的项是变量名，用来存放该集合中的每个元素。</p>
<p><strong>该循环的运行过程</strong>如下：每一次循环时，从集合中取出一个新的元素值。放到只读变量中去，如果括号中的整个表达式返回值为 true，foreach 块中的语句就能够执行。</p>
<p>一旦集合中的元素都已经被访问到，整个表达式的值为 false，控制流程就转入到 foreach 块后面的执行语句。</p>
<p><strong>foreach 语句经常与数组一起使用</strong>，在 C# 语言中提供了 foreach 语句<strong>遍历数组中的元素</strong>，具体的语法形式如下。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(数据类型 变量名 <span class="keyword">in</span> 数组名)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//语句块；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里变量名的数据类型必须与数组的数据类型相兼容。</p>
<p>在 foreach 循环中，如果要输出数组中的元素，不需要使用数组中的下标，直接输出变量名即可。</p>
<p><strong>foreach 语句仅能用于数组、字符串或集合类数据类型。</strong></p>
<p>【实例】在 Main 方法中创建一个 double 类型的数组，并在该数组中存入 5 名学生的考试成绩，计算总成绩和平均成绩。<br>根据题目要求，使用 foreach 语句实现该功能，代码如下。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span>[] points = &#123; <span class="number">80</span>, <span class="number">88</span>, <span class="number">86</span>, <span class="number">90</span>, <span class="number">75.5</span> &#125;;</span><br><span class="line">        <span class="built_in">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">double</span> avg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">double</span> point <span class="keyword">in</span> points)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum + point;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / points.Length;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总成绩为：&quot;</span> + sum);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;平均成绩为：&quot;</span> + avg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在计算平均成绩时，通过数组的 Length 属性即可得到数组中元素的个数，使用总成绩除以元素的个数即为结果。</p>
<p>执行上面的语句，效果如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027436.gif" alt="求总成绩和平均成绩"></p>
<p>从上面的执行效果可以看出，在使用 foreach 语句时可以免去使用下标的麻烦，这也给遍历数组中的元素带来很多方便。</p>
<h2 id="表达式主体成员"><a href="#表达式主体成员" class="headerlink" title="表达式主体成员 &#x3D;&gt;"></a>表达式主体成员 &#x3D;&gt;</h2><p>通过表达式主体定义，可采用非常简洁的可读形式提供成员的实现。<strong>只要任何支持的成员（如方法或属性）的逻辑包含单个表达式，就可以使用表达式主体定义</strong>。表达式主体定义具有下列常规语法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member =&gt; expression;</span><br></pre></td></tr></table></figure>
<p>表达式主体定义可用于以下类型成员：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#methods">方法</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#read-only-properties">只读属性</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#properties">属性</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#constructors">构造函数</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#finalizers">终结器</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#indexers">索引器</a></li>
</ul>
<h3 id="return-单句时可以用-代替"><a href="#return-单句时可以用-代替" class="headerlink" title="return 单句时可以用 =&gt; 代替"></a>return 单句时可以用 <code>=&gt;</code> 代替</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; <span class="string">&quot;lk&quot;</span>;</span><br><span class="line">    <span class="keyword">set</span> =&gt; Name = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意和lambda表达式中的=&gt;用法不同，后者可以用大括号包含完整逻辑</span></span><br><span class="line">(参数列表)=&gt;&#123; 函数逻辑 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只读属性可以将 <code>get</code> 访问器作为 expression-bodied 成员实现。在这种情况下，既不使用 <code>get</code> 访问器关键字，也不使用 <code>return</code> 关键字。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name =&gt; locationName;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>=&gt;locationName; &#125;</span><br></pre></td></tr></table></figure>


<h1 id="五、面向对象-OOP"><a href="#五、面向对象-OOP" class="headerlink" title="五、面向对象 OOP"></a>五、面向对象 OOP</h1><h2 id="1-类-class"><a href="#1-类-class" class="headerlink" title="1 类 class"></a>1 类 class</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">	字段;</span><br><span class="line">	属性;</span><br><span class="line">	方法;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规范:每写一个类要新建一个类文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CHLSS</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;<span class="keyword">this</span>._name&#125;</span>,我今年<span class="subst">&#123;<span class="keyword">this</span>._age&#125;</span>岁了，我性别是<span class="subst">&#123;<span class="keyword">this</span>._gender&#125;</span>。&quot;</span>);</span><br><span class="line"><span class="comment">//this:表示当前这个类的对象。类是不占内存的，而对象是占内存的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类调用：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//类的实例化，使用关键字 new.</span></span><br><span class="line">    Person sunQuan = <span class="keyword">new</span> Person();</span><br><span class="line">    sunQuan._name = <span class="string">&quot;孙权&quot;</span>;</span><br><span class="line">    sunQuan._age = <span class="number">23</span>;</span><br><span class="line">    sunQuan._gender = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    sunQuan.CHLSS();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下都是空对象，没有申请堆空间，不可以访问成员变量和成员函数</span></span><br><span class="line">    Person p1;  </span><br><span class="line">    Person p2 = <span class="literal">null</span>; <span class="comment">//等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以在类中声明一个和自己相同类型的成员变量，但<strong>不能对类内部它进行实例化</strong></li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">person</span></span><br><span class="line">&#123;</span><br><span class="line">    Person girlfriend;</span><br><span class="line">    Person girlfriend = <span class="keyword">new</span> Person(); <span class="comment">//error!</span></span><br><span class="line">    </span><br><span class="line">    Person[] boyfriend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员变量的默认初始值<ul>
<li>值类型，数字类型默认为 0，bool 类型默认为 false</li>
<li>引用类型，默认为 null</li>
<li><code>default（类型）</code> 得到该类型的默认值</li>
</ul>
</li>
</ul>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>内部类，类中的类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body = <span class="keyword">new</span> Person.Body(); <span class="comment">// 实例化时指出外部类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//身体</span></span><br><span class="line">        Arm leftArm;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Arm</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//手臂</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分部类-partial"><a href="#分部类-partial" class="headerlink" title="分部类 partial"></a>分部类 partial</h3><p>把一个类分成几部分申明</p>
<p><strong>关键字</strong>：<code>partial</code></p>
<p><strong>作用</strong></p>
<ol>
<li>分部描述一个类</li>
<li>增加程序的拓展性</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>分部类可以写在多个脚本文件中，数据共享</li>
<li>分部类的访问修饰符要一致</li>
<li>分部类中不能有重复成员</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:分布类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以理解为将Person类分开，两部分共同组成Person类，数据共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span>  <span class="title">Person</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span>  <span class="title">Person</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>分部方法</strong>：将方法的声明和实现分离</p>
<p><strong>特点</strong></p>
<ol>
<li>不能加访问修饰符，默认private</li>
<li>只能在分部类中声明</li>
<li>返回值只能是 void</li>
<li>可以有参数但不用 out 关键字<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span>  <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>; <span class="comment">// 声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">//实现</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="密封类-sealed"><a href="#密封类-sealed" class="headerlink" title="密封类 sealed"></a>密封类 sealed</h3><p><strong>关键字</strong>：<code>sealed </code></p>
<p>密封类不能被继承，但可以继承其他父类</p>
<p>加强面向对象程序设计的规范性、结构性、安全性</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Test</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h4><p><strong>概念</strong>：用密封关键字 <code>sealed</code> 修饰的重写函数<br><strong>作用</strong>：让虚方法或者抽象方法之后不能再被子类重写<br><strong>特点</strong>：和 <code>override</code> 一起出现</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> overide <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-访问修饰符"><a href="#2-访问修饰符" class="headerlink" title="2 访问修饰符"></a>2 访问修饰符</h2><ol>
<li>不显式声明访问修饰符，则默认为 private</li>
<li>分类：<br><code>public</code>：公开的，可被类的内部外部访问（<strong>可访问</strong>可以理解为<strong>可读写</strong>）</li>
</ol>
<p><code>private</code>：私有的，只能在当前类的内部访问</p>
<p><code>protected</code>：受保护的，只能在当前类的内部以及该类的子类中访问</p>
<p><code>internal</code>：只能在当前项目中访问，在本项目中和 public 权限一样</p>
<p><code>protected internal</code>：protected+internal</p>
<ul>
<li>能够修饰类的访问修饰符：public，internal</li>
<li>子类的访问权限不能高于父类的访问权限，会暴露父类的成员</li>
</ul>
<h2 id="3-成员属性-get-set"><a href="#3-成员属性-get-set" class="headerlink" title="3 成员属性 get set"></a>3 成员属性 get set</h2><p>#get #set</p>
<ol>
<li><strong>用于保护成员变量</strong>  </li>
<li><strong>为成员属性的获取和赋值添加逻辑处理</strong>  </li>
<li><strong>解决访问修饰符的局限性</strong><ul>
<li>访问修饰符只能同时控制读写，不能单独控制</li>
<li>通过令属性的 get 或 set 为 private，可以让成员变量<strong>在外部只能读不能写</strong>或<strong>只能写不能读</strong></li>
</ul>
</li>
<li><strong>get 和 set 可以只有一个</strong><ul>
<li>既有 get ()也有 set ()我们诚之为可读可写属性。</li>
<li>只有 get ()没有 set ()我们称之为只读属性</li>
<li>没有 get ()只有 set ()我们称之为只写属性<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set（）源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_Name</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get（）源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> get_Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age; <span class="comment">//字段在类中必须是私有的，如果想访问只能通过成员属性！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//属性必须是公有的，可以外部访问 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出属性的值的时候，会执行get方法</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _age; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给属性赋值的时候，首先会执行set方法</span></span><br><span class="line">        <span class="comment">//value关键字用于表示外部传入的值</span></span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//添加额外条件起到限定作用</span></span><br><span class="line">            <span class="keyword">if</span>（<span class="keyword">value</span> &lt; <span class="number">0</span> || <span class="keyword">value</span> &gt; <span class="number">100</span>）</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//默认功能</span></span><br><span class="line">            _age = <span class="keyword">value</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CHLSS</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       	<span class="comment">//调用属性this.Age，执行get方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我今年<span class="subst">&#123;<span class="keyword">this</span>.Age&#125;</span>岁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对类调用：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Person sunQuan = <span class="keyword">new</span> Person();</span><br><span class="line">    sunQuan.Age = <span class="string">&quot;10&quot;</span>;   <span class="comment">//调用属性sunQuan.Age，执行Set（）方法</span></span><br><span class="line">    sunQuan.CHLSS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:新写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span> =&gt; _age; <span class="keyword">set</span> =&gt; _age = <span class="keyword">value</span>; &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>get 和 set 可以加访问修饰符</strong></li>
</ol>
<ul>
<li>默认不加，会使用属性声明时的访问权限</li>
<li>加的访问修饰符要低于属性的访问权限</li>
<li>不能让 get 和 set 的访问权限都低于属性的权限<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> _age &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span> &#123; _age = <span class="keyword">value</span> &#125;  <span class="comment">// 给set加private，那么该属性只能读不能写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong>自动属性</strong><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>没有在 get 和 set 中写逻辑的需求时，可以使用自动属性。</li>
<li>get set 仍可以添加 private。一般用于外部能读不能写的情况</li>
</ul>
<h2 id="4-静态-static"><a href="#4-静态-static" class="headerlink" title="4 静态 static"></a>4 静态 static</h2><p>#static</p>
<ol>
<li>在非静态类中，既可以有实例成员（非静态），也可以有静态成员。</li>
<li>在调用实例成员的时候，需要使用<strong>对象名. 实例成员</strong>;</li>
<li>在调用静态成员的时候，需要使用<strong>类名. 静态成员名</strong>;</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">M1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;非静态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;静态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用实例成员</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.M1(); <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p.M2();  报错</span></span><br><span class="line">Person.M2();  <span class="comment">//静态方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li><strong>静态函数中，只能访问静态成员，不允许访问实例成员。</strong></li>
<li>实例函数中，既可以使用静态成员，也可以使用实例成员。</li>
<li><strong>静态类</strong>中只允许有静态成员，不能被实例化（适合作为工具类）。</li>
<li><strong>静态构造函数</strong>，用于初始化静态变量<ul>
<li>静态类和普通类中都可以有静态构造函数</li>
<li>不能使用访问修饰符</li>
<li>不能有参数</li>
<li>只会自动调用一次<figure class="highlight cs"><figcaption><span>title:静态构造函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 静态构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">200</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>什么时候使用：</strong><br>1)、如果你想要你的类当做一个”工具类”去使用，这个时候可以考虑将类写成静态的。<br>2)、静态类在整个项目中资源共享。静态类存放在<strong>堆栈静态存储区域</strong>，只有在程序全部结束之后，静态类才会释放资源。</p>
<p><strong>const (常量)可以理解为特殊的 static (静态)</strong></p>
<ul>
<li><strong>相同点</strong><br>他们都可以通过类名点出使用</li>
<li><strong>不同点</strong><ol>
<li>const 必须初始化，不能修改， static 没有这个规则</li>
<li>const 只能修饰变量、static 可以修饰很多</li>
<li>const 一定是写在访问修饰符后面的，static 没有这个要求</li>
</ol>
</li>
</ul>
<h2 id="5-拓展方法"><a href="#5-拓展方法" class="headerlink" title="5 拓展方法"></a>5 拓展方法</h2><p>概念：为现有<strong>非静态变量类型</strong>添加新方法</p>
<p><strong>作用</strong></p>
<ol>
<li>提升程序拓展性</li>
<li>不需要再对象中重新写方法</li>
<li>不需要继承来添加方法</li>
<li>为别人封装的类型写额外的方法</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>一定是写在静态类中</li>
<li>一定是个静态函数</li>
<li>第一个参数为拓展目标</li>
<li>第一个参数用 this 修饰</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名，参数类型 参数名,参数类型 参数名....)</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i =<span class="number">10</span>;</span><br><span class="line">i.SpeakValue(); <span class="comment">//int类型的拓展方法,i作为value值传入函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拓展方法写在静态类中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法的逻辑</span></span><br><span class="line">        Console.WriteLine( <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以为类类型添加拓展方法，当拓展方法名和类成员函数重名时，只会调用类成员函数。</p>
<p>例：Unity 拓展 Transfrom 类判断朝向</p>
<figure class="highlight cs"><figcaption><span>h:8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtensionMethod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> s_DotThreshold = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">//this是要扩展的类，</span></span><br><span class="line">    <span class="comment">//逗号之后，第二个参数是扩展方法的参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//夹角小于60°，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFacingTarget</span>(<span class="params"><span class="keyword">this</span> Transform transform, Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 direction = (target.position - transform.position).normalized;</span><br><span class="line">        <span class="built_in">float</span> dot = Vector3.Dot(direction, transform.forward);  </span><br><span class="line">        <span class="keyword">return</span> dot&gt;s_DotThreshold; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">transform.IsFacingTarget(m_attackTarget.transform)</span><br></pre></td></tr></table></figure>
<h2 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6 构造函数"></a>6 构造函数</h2><p><strong>作用</strong>：在实例化对象时（new 时），会调用用于初始化的函数，如果不写默认存在一个无参构造函数。</p>
<p><strong>构造函数是一个特殊的方法：</strong><br>1)、构造函数没有返回值，连 void 也不能写。<br>2)、构造函数的名称必须跟类名一样。<br>3)、没有特殊需求时，修饰符一般是 public</p>
<ul>
<li><strong>构造函数是可以有重载的。</strong></li>
<li>重载之后会失去默认的无参构造函数，如果需要可以显式声明以下</li>
<li>特殊写法 （构造函数的继承）较少使用  <ul>
<li>在构造函数后添加 : <code>this (指定的重载参数)  </code></li>
<li>可以实现<strong>执行该构造函数前执行 this 指定的构造函数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Age = age; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">string</span> gender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Age = age; </span><br><span class="line">        <span class="keyword">this</span>.Gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">string</span> gender</span>):<span class="title">this</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Age = age; </span><br><span class="line">        <span class="keyword">this</span>.Gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="comment">//当引用类型的堆内存被回收时，会调用该函数  </span></span><br><span class="line">    <span class="comment">//c#中有自动垃圾回收机制GC，所以几乎不使用析构函数  </span></span><br><span class="line">    ~Person（）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//手动回收内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;        </span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _age; &#125;   </span><br><span class="line">        <span class="keyword">set</span> &#123; _age = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Gender</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _gender; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _gender = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;孙权&quot;</span>,<span class="number">10</span>,<span class="string">&quot;男&quot;</span>); <span class="comment">//初始化</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;孙尚香&quot;</span>,<span class="number">10</span>); <span class="comment">//重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类当中会有一个默认的无参数的构造函数</strong>，当你写一个新的构造函数之后，不管是有参数的还是无参数的，那个默认的无参数的构造函数都被干掉了。</p>
<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p><code>Person p=new Person ();</code><br>new 帮助我们做了 3 件事儿：<br>1)、在内存中开辟一块空间<br>2)、在开辟的空间中创建对象<br>3)、调用对象的构造函数进行初始化对象</p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>1)、代表当前类的对象<br>2)、在类当中显示的调用本类的构造函数  : this </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">string</span> gender</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Name = name;</span><br><span class="line">    <span class="keyword">this</span>.Age = age; </span><br><span class="line">    <span class="keyword">this</span>.Gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//：this（name,age,&quot;&quot;）再次调用构造函数，可以省区该函数中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age</span>)：<span class="keyword">this</span>（name,age,&quot;&quot;）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this.Name = name;</span></span><br><span class="line">    <span class="comment">//this.Age = age; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-索引器"><a href="#7-索引器" class="headerlink" title="7 索引器"></a>7 索引器</h2><p><strong>作用：</strong> 让对象可以像数组一样通过索引访问其中元素，使程序看起来更直观，更容易编写。<br><strong>语法：</strong> </p>
<figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值 <span class="keyword">this</span>[参数类型 参数名, 参数类型 参数名, ......] <span class="comment">// 注意这里是中括号[]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//内部的写法和规则和索引器相同</span></span><br><span class="line">    <span class="keyword">get</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">private</span> Person[] _friend; <span class="comment">// 类数组，也可以是用二维数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index] <span class="comment">//索引器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _friend[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">             _friend[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引器</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();  </span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();  </span><br><span class="line">p[<span class="number">1</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>索引器 this 函数中的 get 和 set 可以写逻辑，this 函数支持重载</p>
<h2 id="8-继承"><a href="#8-继承" class="headerlink" title="8 继承"></a>8 继承</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类（基类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类（派生类）：</span></span><br><span class="line"><span class="title">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>子类继承了父类的属性和方法，<strong>不能继承父类 <code>private</code> 字段和构造函数。</strong></p>
</li>
<li><p><strong>单根性</strong>（子类只能有一个父类）和<strong>传递性</strong> (子类可以间接继承父类的父类))</p>
</li>
<li><p>子类成员函数和父类的<strong>同名</strong>时，会把父类的隐藏掉。（不建议写同名成员）</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027437.png" alt="image-20220623161508887"></p>
<p>加 new 之后不再警告</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。</li>
<li>当申明一个子类对象时，<strong>先执行父类的构造函数，再执行子类的构造函数</strong><ul>
<li>父类的无参构造很重要，子类实例化时默认自动调用的是父类的无参构造，所以如果父类无参构造被顶掉，会报错！</li>
<li>子类可以通过 <code>base</code> 关键字代表父类调用父类构造</li>
</ul>
</li>
</ol>
<h3 id="base-关键字"><a href="#base-关键字" class="headerlink" title="base 关键字"></a>base 关键字</h3><p>#base<br>子类写的成员函数和父类的<strong>同名</strong>时，会把父类的隐藏掉。</p>
<p><strong><code>base</code> 关键字用于从派生类中访问基类的成员：</strong></p>
<ul>
<li>调用基类上已被 overide的方法。</li>
<li>指定创建派生类实例时应调用的基类构造函数。</li>
<li>基类访问只能在<strong>构造函数、实例方法或实例属性访问器</strong>中进行。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在派生类中调用基类方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> _className = <span class="string">&quot;BaseClass&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class Name: &#123;0&#125;&quot;</span>, _className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _className = <span class="string">&quot;DerivedClass&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrintName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;The BaseClass Name is &#123;0&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//调用基类方法</span></span><br><span class="line">        <span class="keyword">base</span>.PrintName();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This DerivedClass is &#123;0&#125;&quot;</span>, _className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在派生类中调用基类构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;in BaseClass()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = i;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;in BaseClass(int &#123;0&#125;)&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 该构造器调用  BaseClass.BaseClass()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该构造器调用 BaseClass.BaseClass(int i)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p><strong>概念：</strong><br>任何父类出现的地方，子类都可以替代</p>
<p><strong>语法表现</strong>：父类容器装子类对象, 因为子类对象包含了父类的所有内容</p>
<p><strong>作用：</strong><br>方便进行对象存储和管理</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Student类是Person类的子类</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//里氏替换，父类容器装子类对象</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果父类中装的是子类对象，那么可以将这个父类强转为子类对象</span></span><br><span class="line">    Student ss = (Student)p;</span><br><span class="line">    ss.StudentSayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="is-as-关键字"><a href="#is-as-关键字" class="headerlink" title="is as 关键字"></a>is as 关键字</h3><p>#is #as<br><code>is</code>：判断一个对象是否是指定的类对象，如果能够转换，则返回一个 true，否则返回一个 false<br><code>as</code>：将一个对象转换为指定的类对象，如果能够转换则转换为指定的类对象，否则返回一个 null</p>
<figure class="highlight cs"><figcaption><span>title:is和as的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Student类是Person类的子类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Student();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//is的用法</span></span><br><span class="line">    <span class="keyword">if</span> (p <span class="keyword">is</span> Teacher)</span><br><span class="line">    &#123;</span><br><span class="line">        Student ss = (Student)p;</span><br><span class="line">        ss.StudentSayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//as的用法</span></span><br><span class="line">    Student ss = ss <span class="keyword">as</span> Student;  </span><br><span class="line">    ss.StudentSayHello();</span><br><span class="line">    </span><br><span class="line">    (ss <span class="keyword">as</span> Student).StudentSayHello(); <span class="comment">//等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:游戏中的应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Gameobject是其他游戏类的基类，里氏替换如下：</span></span><br><span class="line">Gameobject player = <span class="keyword">new</span> Player();  </span><br><span class="line">Gameobject monster = <span class="keyword">new</span> Monster();  </span><br><span class="line">Gameobject boss = <span class="keyword">new</span> Boss();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用父类数组来管理子类</span></span><br><span class="line">Gameobject[] objects = <span class="keyword">new</span> Gameobject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Monster(), <span class="keyword">new</span> Boss() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断各自使用的逻辑</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; objects.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( objects[i] <span class="keyword">is</span> Player )</span><br><span class="line">    &#123;</span><br><span class="line">        (objects[i] <span class="keyword">as</span> Player) . PlayerAtk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( objects[i] <span class="keyword">is</span> Monster )</span><br><span class="line">    &#123;</span><br><span class="line">        (objects[i] <span class="keyword">as</span> Monster). MonsterAtk() ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects[i] <span class="keyword">is</span> Boss)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-多态"><a href="#10-多态" class="headerlink" title="10 多态"></a>10 多态</h2><p>多态按字面的意思就是“多种状态”<br>让继承同一父类的子类们在执行相同方法时有不同的表现 (状态)</p>
<p><strong>主要目的</strong><br>同一父类的对象执行相同行为 (方法)有不同的表现</p>
<p><strong>解决的问题</strong><br>让同一个对象有唯一行为的特征</p>
<p><strong>多态有两种：</strong></p>
<ul>
<li>编译时多态（函数重载，开始就写好的）</li>
<li>运行时多态（重写父类虚函数、抽象函数、接口）</li>
</ul>
<h3 id="虚函数-virtual"><a href="#虚函数-virtual" class="headerlink" title="虚函数 virtual"></a>虚函数 virtual</h3><p><strong>当父类中的方法需要实现, 将父类的方法标记为虚方法，使用关键字 <code>virtual</code><strong>，这个函数</strong>可以</strong>被子类重写。<br>**子类的方法使用关键字 <code>override</code>**。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//真的鸭子嘎嘎叫，木头鸭子吱吱叫，橡皮鸭子唧唧叫</span></span><br><span class="line">           ReadDuck rd = <span class="keyword">new</span> ReadDuck();</span><br><span class="line">           WoodDuck wd = <span class="keyword">new</span> WoodDuck();</span><br><span class="line">           XPDuck xd = <span class="keyword">new</span> XPDuck();</span><br><span class="line"></span><br><span class="line">           ReadDuck[] ducks = &#123; rd, wd, xd &#125;;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; ducks.Length;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               ducks[i].jiao();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//父类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadDuck</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;真的鸭子嘎嘎叫&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//子类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WoodDuck</span> : <span class="title">ReadDuck</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;木头鸭子吱吱叫&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XPDuck</span> : <span class="title">ReadDuck</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;橡皮鸭子唧唧叫&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h3><p>被抽象关键字 <code>abstract</code> 修饰的类<br><strong>当父类中的方法不知道如何去实现的时候，可以考虑将父类写成抽象类，将方法写成抽象方法。</strong></p>
<p><strong>特点:</strong></p>
<ol>
<li>不能被实例化，其他封装特性都有</li>
<li>可以包含抽象方法（即纯虚函数）</li>
<li>继承抽象类必须重写其抽象方法</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//狗会叫，猫也会叫</span></span><br><span class="line">    <span class="comment">//Animal a = new Animal();  抽象类或接口无法创建对象</span></span><br><span class="line">    Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    dog.jiao();</span><br><span class="line">    Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat.jiao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加abstract</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span>;  <span class="comment">//抽象方法不写方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	Console.WriteLine(<span class="string">&quot;狗会叫&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">jiao</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">   	 	Console.WriteLine(<span class="string">&quot;猫也会叫&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>抽象成员必须标记为 <code>abstract</code>, 并且不能有任何实现。</li>
<li>抽象成员必须在抽象类中。</li>
<li>抽象类不能被实例化</li>
<li>子类继承抽象类后，必须把父类中的所有抽象成员都重写。（除非子类也是一个抽象类，则可以不重写）</li>
<li>抽象成员的访问修饰符不能是 <code>private</code></li>
<li>在抽象类中可以包含实例成员。并且抽象类的实例成员可以不被子类实现</li>
<li>抽象类是有构造函数的。虽然不能被实例化。</li>
<li>如果父类的抽象方法中有参数，那么。继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数。</li>
<li>如果抽象父类的抽象方法中有返回值，那么子类在重写这个抽象方法的时候也必须要传入返回值。</li>
</ol>
<p><strong>使用时机：</strong></p>
<ol>
<li>如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑将父类定义成一个普通类，用虚方法来实现多态。</li>
<li>如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类。</li>
</ol>
<blockquote>
<p>[!summary] 抽象类和接口<br>相同点：</p>
<ol>
<li>都可以被继承</li>
<li>都不能直接实例化</li>
<li>都可以包含方法申明</li>
<li>子类必须实现未实现的方法</li>
<li>都遵循里氏替换原则</li>
</ol>
<p>不同点：</p>
<ol>
<li>抽象类中可以有构造函数; 接口中不能</li>
<li>抽象类只能被单一继承; 接口可以被继承多个</li>
<li>抽象类中可以有成员变量; 接口中不能</li>
<li>抽象类中可以申明成员方法，虚方法，抽象方法，静态方法; 接口中只能声明没有实现的抽象方法</li>
<li>抽象类方法可以使用访问修饰符; 接口中建议不写，默认 public</li>
</ol>
</blockquote>
<blockquote>
<p>[!summary] 如何选择抽象类和接口</p>
<ol>
<li>表示对象的用抽象类，表示行为拓展的用接口</li>
<li>不同对象拥有的共同行为，我们往往可以使用接口来实现</li>
</ol>
</blockquote>
<h2 id="11-面向对象七大原则"><a href="#11-面向对象七大原则" class="headerlink" title="11 面向对象七大原则"></a>11 面向对象七大原则</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027440.png" alt="6be61eb7b87ada15753dc35768da4317_MD5"></p>
<p>七大原则总体要实现的目标是: <strong>高内聚、低耦合</strong>，使程序模块的可重用性、移植性增强</p>
<ul>
<li><strong>高内聚低耦合：</strong><ul>
<li>从类角度来看，高内聚低耦合要求减少类内部对其他类的调用</li>
<li>从功能块来看，高内聚低耦合要求减少模块之间的交互复杂度</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>单一职责原则 SRP (Single Responsibility Principle)</strong><br>类被修改的几率很大，因此应该专注于单一的功能。如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另个功能。举例: 假设程序、策划、美术三个工种是三个类，他们应该各司其职，在程序世界中只应该做自己应该做的事情。</p>
</li>
<li><p><strong>开闭原则 OCP (Open-Closed Principle)</strong><br>对拓展开放，对修改关闭<br>拓展开放: 模块的行为可以被拓展从而满足新的需求<br>修改关闭: 不允许修改模块的源代码（或者尽量使修改最小化)<br>举例: 继承就是最典型的开闭原则的体现，可以通过添加新的子类和重写父类的方法来实现</p>
</li>
<li><p><strong>里氏替换原则 LSP (Liskov Substitution Principle)</strong><br>任何父类出现的地方，子类都可以替代<br>举例: 用父类容器装载子类对象，因为子类对象包含了父类的所有内容</p>
</li>
<li><p><strong>依赖倒转原则 DIP (Dependence Inversion Principle)</strong><br>要依赖于抽象，不要依赖于具体的实现<br> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027441.png" alt="756ed87732dfe143814d6c3bc38a8766_MD5"></p>
</li>
</ol>
<blockquote>
<p>玩家对象的开枪不依赖于具体种类的开枪，而是依赖于抽象的接口</p>
</blockquote>
<ol start="5">
<li><p><strong>迪米特法则 LoP (Law of Demeter)又称最少知识原则</strong><br>一个对象应当对其它对象尽可能少的了解不要和陌生人说话<br>举例: 一个对象中的成员，要尽可能少的直接和其它类建立关系，目的是降低耦合性</p>
</li>
<li><p><strong>接口分离原则 ISP (Interface Segregation Principle)</strong><br>不应该强迫别人依赖他们不需要使用的方法。<br>一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有的行为都封装到一个接口当中<br>举例: 飞行接口、走路接口、跑步接口等等虽然都是移动的行为但是我们应该把他们分为一个一个单独的接口，让别人去选择使用</p>
</li>
<li><p><strong>合成复用原则 CRP (Composite Reuse Principle)</strong><br>尽量使用对象组合，而不是继承来达到复用的目的。<br><strong>继承关系是强耦合，组合关系是低耦合</strong><br>举例: 脸应该是眼镜、鼻子、嘴巴、耳朵的组合，而不是依次的继承，角色和装备也应该是组合，而不是继承<br>注意: 不能盲目的使用合成复用原则，要在遵循迪米特原则的前提下</p>
</li>
</ol>
<p><strong>如何使用这些原则</strong><br>在开始做项目之前，整理 UML 类图时先按自己的想法把需要的类整理出来再把七大原则截图放在旁边，基于七大原则去，优化整理自己的设计<br>整体目标就是: 高内聚，低耦合</p>
<h1 id="六、接口-interface"><a href="#六、接口-interface" class="headerlink" title="六、接口 interface"></a>六、接口 interface</h1><p>接口是行为的抽象规范</p>
<p><strong>关键字</strong>：<code>interface</code></p>
<p><strong>接口声明的规范</strong></p>
<ol>
<li>不包含成员变量</li>
<li>只包含方法、属性索引器、事件</li>
<li>成员不能被实现</li>
<li>成员可以不用写访问修饰符，不能是私有的</li>
<li>接口不能继承类，但是可以继承另一个接口</li>
</ol>
<p><strong>接口的使用规范</strong></p>
<ol>
<li>类可以继承多个接口</li>
<li>类继承接口后，必须实现接口中所有成员</li>
</ol>
<p><strong>特点:</strong></p>
<ol>
<li>它和类的声明类似</li>
<li>接口是用来继承的</li>
<li>接口不能被实例化，但是可以作为容器存储对象</li>
</ol>
<figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> 接口名称（通常以<span class="title">I</span>开头，如<span class="title">ICompute</span>）</span><br><span class="line">&#123;</span><br><span class="line">    接口成员；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><p>类可以继承 1 个类，多个接口<br>继承了接口后，必须实现其中的内容，并且必须是 public 的</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">event</span> Action doSomthing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承父类和接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span>, <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action doSomthing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现的接口函数，可以作为虚函数继承</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口存储子类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//IFly f = new IFly();  //error</span></span><br><span class="line">    IFly f = <span class="keyword">new</span> Person();  <span class="comment">// 里氏替换原则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027442.svg" alt="f52e612d29b16288c18c4f4639d55bc5_MD5"></p>
<ul>
<li>并不是所有动物都会飞，所以 Fly 放在动物父类中不合适，可以单独作为一个接口。</li>
<li>接口可以作为容器存储所以继承 Fly 的子类</li>
</ul>
<h3 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h3><p>相当于将接口行为合并  </p>
<ul>
<li>接口继承接口时，不需要实现</li>
<li>待类继承接口后，类自己去实现所有内容</li>
</ul>
<h3 id="隐式实现接口"><a href="#隐式实现接口" class="headerlink" title="隐式实现接口"></a>隐式实现接口</h3><p><strong>隐式实现接口成员是将接口的所有成员以 public 访问修饰符修饰。</strong></p>
<p>使用隐式方式来实现接口 ICompute 的成员，以计算机专业的学生类 (ComputerMajor) 实现 ICompute 接口，为其添加英语 (English)、编程 (Programming)、数据库 (Database) 学科成绩属性，代码如下。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ComputerMajor</span> : <span class="title">ICompute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;     <span class="comment">//隐式的实现接口中的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">//隐式实现接口中的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> English &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Programming &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Database &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Avg</span>()       <span class="comment">//隐式实现接口中的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> avg = (English + Programming + Database) / <span class="number">3</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;平均分：&quot;</span> + avg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Total</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> sum = English + Programming + Database;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总分为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Main 方法中调用该实现类的成员，代码如下。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ComputerMajor computerMajor = <span class="keyword">new</span> ComputerMajor();</span><br><span class="line">        computerMajor.Id = <span class="number">1</span>;</span><br><span class="line">        computerMajor.Name = <span class="string">&quot;李明&quot;</span>;</span><br><span class="line">        computerMajor.English = <span class="number">80</span>;</span><br><span class="line">        computerMajor.Programming = <span class="number">90</span>;</span><br><span class="line">        computerMajor.Database = <span class="number">85</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;学号：&quot;</span> + computerMajor.Id);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;姓名：&quot;</span> + computerMajor.Name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;成绩信息如下：&quot;</span>);</span><br><span class="line">        computerMajor.Total();</span><br><span class="line">        computerMajor.Avg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，效果如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027438.gif" alt="使用隐式方式实现接口成员"></p>
<h3 id="显式实现接口"><a href="#显式实现接口" class="headerlink" title="显式实现接口"></a>显式实现接口</h3><p><strong>显式实现接口是指在实现接口时所实现的成员名称前含有接口名称作为前缀。</strong></p>
<p>主要用于实现不同接口中的同名函数的不同表现</p>
<p><strong>使用显式实现接口的成员不能再使用修饰符修饰</strong>，即 public、abstract、virtual、 override 等。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ComputerMajor</span> : <span class="title">ICompute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> English &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Programming &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Database &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="built_in">int</span> ICompute.Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;           <span class="comment">//显示实现接口中的属性</span></span><br><span class="line">    <span class="built_in">string</span> ICompute.Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;      <span class="comment">//显示实现接口中的属性</span></span><br><span class="line">    <span class="keyword">void</span> ICompute.Total()                   <span class="comment">//显示实现接口中的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> sum = English + Programming + Database;</span><br><span class="line">        Console.WriteLine (<span class="string">&quot;总分数：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> ICompute.Avg ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> avg = (English + Programming + Database) / <span class="number">3</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;平均分为：&quot;</span> + avg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，在使用显式方式实现接口中的成员时，所有成员都会加上接口名称 ICompute 作为前缀，并且不加任何修饰符。</p>
<p>在 Main 方法中调用实现类中的成员, 代码如下</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ComputerMajor computerMajor = <span class="keyword">new</span> ComputerMajor();</span><br><span class="line">        ICompute compute = computerMajor;       <span class="comment">//创建接口的实例</span></span><br><span class="line">        compute.Id = <span class="number">1</span>;</span><br><span class="line">        compute.Name = <span class="string">&quot;李明&quot;</span>;</span><br><span class="line">        computerMajor.English = <span class="number">80</span>;</span><br><span class="line">        computerMajor.Programming = <span class="number">90</span>;</span><br><span class="line">        computerMajor.Database = <span class="number">85</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;学号：&quot;</span> + compute.Id);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;姓名：&quot;</span> + compute.Name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;成绩信息如下：&quot;</span>);</span><br><span class="line">        compute.Total();</span><br><span class="line">        compute.Avg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，效果与上图一致。从调用的代码可以看出，在调用显式方式实现接口的成员时，必须使用接口的实例来调用，而不能使用实现类的实例来调用。</p>
<h1 id="七、泛型-generic"><a href="#七、泛型-generic" class="headerlink" title="七、泛型 generic"></a>七、泛型 generic</h1><ul>
<li>泛型实现了类型参数化，达到代码重用目的</li>
<li>通过类型参数化来实现同一份代码上操作多种类型</li>
<li>泛型相当于类型占位符</li>
<li>定义类或方法时使用替代符代表变量类型&#x2F;当真正使用类或者方法时再具体指定类型</li>
</ul>
<ol>
<li>不同类型对象的相同逻辑处理就可以选择泛型</li>
<li>使用泛型可以一定程度避免装箱拆箱<figure class="highlight cs"><figcaption><span>title:举例:优化ArrayList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个可指定类型的ArrayList,这样可以避免使用Object类型的装箱拆箱操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-泛型类和泛型接口"><a href="#1-泛型类和泛型接口" class="headerlink" title="1 泛型类和泛型接口"></a>1 泛型类和泛型接口</h2><figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&lt;泛型占位字母&gt;</span><br><span class="line"><span class="title">interface</span> 接口名&lt;泛型占位字母&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:泛型类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> TestClass&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        t1.<span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line">        TestClass&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        t2.<span class="keyword">value</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span>, <span class="title">T4</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 valu1;</span><br><span class="line">    <span class="keyword">public</span> T2 valu2;</span><br><span class="line">    <span class="keyword">public</span> T3 valu3;</span><br><span class="line">    <span class="keyword">public</span> T4 valu4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:泛型接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IInterface</span>&lt;<span class="title">T</span>&gt;  </span><br><span class="line">&#123;  </span><br><span class="line">    T <span class="keyword">value</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">IInterface</span>&lt;<span class="title">int</span>&gt;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-泛型方法（函数）"><a href="#2-泛型方法（函数）" class="headerlink" title="2 泛型方法（函数）"></a>2 泛型方法（函数）</h2><figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名&lt;泛型占位字母&gt;(参数列表)</span><br></pre></td></tr></table></figure>

<h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><figure class="highlight cs"><figcaption><span>title:普通类中的泛型方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>  <span class="comment">//注意这是普通类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//传值</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func2</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用泛型类型做逻辑处理</span></span><br><span class="line">        T t = <span class="literal">default</span>(T);  <span class="comment">//不确定泛型类型时获取默认值可以使用 default(占位字符)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func3</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以作为返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func3</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">T3</span>&gt;(<span class="params">T1 value1,T2 value2,T3 value3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.Func1&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><figure class="highlight cs"><figcaption><span>title:泛型类中的泛型方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="comment">//注意这是泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里传入的T是Test类指定的,而不是该函数的泛型,所以这个函数不是泛型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func1</span>(<span class="params">T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">value</span> = t;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的K是泛型函数的泛型，所以Func2是泛型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func2</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test&lt;<span class="built_in">int</span>&gt; t = <span class="keyword">new</span> Test&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        t.Func1(<span class="number">1</span>);  <span class="comment">//由于Func1不是泛型,所以这里的形参必须是int类型</span></span><br><span class="line">        t.Func2&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;test&quot;</span>); <span class="comment">//Func2是泛型，所以可以指定类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-泛型约束"><a href="#3-泛型约束" class="headerlink" title="3 泛型约束"></a>3 泛型约束</h2><p>#where<br><strong>让泛型的类型有一定的限制</strong><br>关键字:<code>where</code></p>
<p><strong>泛型约束一共有 6 种</strong></p>
<ol>
<li>值类型<br><code>where 泛型占位字母:struct</code></li>
<li>引用类型<br><code>where 泛型占位字母:class</code></li>
<li>存在无参公共构造函数<br><code>where 泛型占位字母: new ()</code></li>
<li>某个类本身或者其派生类<br><code>where 泛型占位字母: 类名</code></li>
<li>某个接口的派生类型<br><code>where 泛型占位字母: 接口名</code></li>
<li>另一个泛型类型本身或者派生类型<br><code>where 泛型占位字母: 另一个泛型字母</code></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027443.png" alt="Pasted image 20230530224846|500"></p>
<blockquote>
<p>这里泛型约束使用了值类型，当泛型使用 string（引用类型）时报错</p>
</blockquote>
<figure class="highlight cs"><figcaption><span>title:可以同时指定多个约束，使用逗号</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:多个泛型同时指定约束</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span> <span class="keyword">where</span> <span class="title">K</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="八、委托-delegate"><a href="#八、委托-delegate" class="headerlink" title="八、委托 delegate"></a>八、委托 delegate</h1><ul>
<li><strong>委托是函数的容器</strong></li>
<li>可以理解为表示函数的变量类型</li>
<li>用来存储、传递函数</li>
<li>委托的本质是一个类，用来定义函数 (方法)的类型 (返回值和参数的类型)</li>
<li>不同的函数必须对应和各自”格式”—致的委托</li>
<li>支持泛型</li>
</ul>
<p>关键字 <code>delegate</code></p>
<p>写在哪里?<br>可以申明在 namespace 和 class 语句块中，更多的写在 namespace 中</p>
<figure class="highlight cs"><figcaption><span>title:语法:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单记忆委托语法就是函数申明语法前面加一个 delegate 关键字</span></span><br><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名 (参数列表);</span><br></pre></td></tr></table></figure>

<h2 id="1-委托的使用"><a href="#1-委托的使用" class="headerlink" title="1 委托的使用"></a>1 委托的使用</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个委托，用来存储无返回值，函数参数为string类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实例化一个委托对象（只传入函数名）</span></span><br><span class="line">        MyDelegate del = <span class="keyword">new</span> MyDelegate(DelegateMethod);</span><br><span class="line">        MyDelegate del = DelegateMethod; <span class="comment">//等价的简化写法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用委托对象，这里会调用DelegateMethod函数</span></span><br><span class="line">        del.Invoke(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        del(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//等价的简化写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelegateMethod</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-委托作为类的成员-函数参数"><a href="#2-委托作为类的成员-函数参数" class="headerlink" title="2 委托作为类的成员&#x2F;函数参数"></a>2 委托作为类的成员&#x2F;函数参数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>; <span class="comment">//声明一个委托类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//作为类的成员</span></span><br><span class="line">    <span class="keyword">public</span> MyDelegate del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunc</span>(<span class="params">MyDelegate del</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        del(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DelegateClass dc = <span class="keyword">new</span> DelegateClass();  <span class="comment">//先实例化DelegateClass</span></span><br><span class="line">        dc.del = DelegateMethod; <span class="comment">//再实例化委托del</span></span><br><span class="line">        </span><br><span class="line">        dc.del.Invoke(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">//调用委托对象，这里会调用DelegateMethod函数</span></span><br><span class="line">        dc.del(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//等价的简化写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelegateMethod</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-多播委托"><a href="#3-多播委托" class="headerlink" title="3 多播委托"></a>3 多播委托</h2><p>多播的意思是<strong>委托变量可以存储多个函数</strong></p>
<p><code>+=</code> 追加委托<br><code>-=</code> 移除委托<br><code>= null</code> 清空委托</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>; <span class="comment">//声明一个委托类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegate del = <span class="literal">null</span>;  <span class="comment">//声明一个委托变量</span></span><br><span class="line">        del += DelegateMethod1; <span class="comment">// += 追加委托</span></span><br><span class="line">        del += DelegateMethod2; <span class="comment">// += 追加委托</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//del -= DelegateMethod1; // -= 移除委托</span></span><br><span class="line">        <span class="comment">//del = null;             // = null 清空委托</span></span><br><span class="line">        <span class="comment">//del = DelegateMethod1;  //🚨弊端：这样会清空之前追加的委托，只保留=后的委托</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (del != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            del(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//调用委托</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelegateMethod1</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第一个&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelegateMethod2</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第二个&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//第一个Hello World</span></span><br><span class="line"><span class="comment">//第二个Hello World</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="4-内置委托类型"><a href="#4-内置委托类型" class="headerlink" title="4 内置委托类型"></a>4 内置委托类型</h2><p>Action 和 Func 的区别是有无返回值<br>Action 无返回值<br>Func 有返回值</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>Action</code>：无参<strong>无返回值。</strong><br><code>Action&lt;&gt;</code>：有参<strong>无返回值</strong>，支持 0~16 个参数</p>
<figure class="highlight cs"><figcaption><span>title:源码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action action1 = TestFunc1;</span><br><span class="line">        Action&lt;<span class="built_in">string</span>&gt; action2 = TestFunc2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFunc1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFunc2</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h3><p><code>Func&lt;&gt;</code>：无参<strong>有返回值</strong><br><code>Func&lt;，&gt;</code>：有参<strong>有返回值</strong>，支持 0~16 个参数</p>
<figure class="highlight cs"><figcaption><span>title:源码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;()</span>; <span class="comment">//无参有返回值，TResult为返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T arg</span>)</span>; <span class="comment">//可以传入多个参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Func&lt;<span class="built_in">int</span>&gt; func1 = TestFunc1;</span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; func2 = TestFunc2;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(func1());</span><br><span class="line">        Console.WriteLine(func2(<span class="number">100</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无参有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">TestFunc1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">TestFunc2</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5 案例"></a>5 案例</h2><p>一家三口，妈妈做饭，爸爸妈妈和孩子都要吃饭<br>用委托模拟做饭—&gt;开饭—&gt;吃饭的过程</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mother</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action beginEat;  <span class="comment">//Action委托</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;妈妈吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cook</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;妈妈做饭&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;饭做好了&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (beginEat != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beginEat();   <span class="comment">//调用委托</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Father</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;孩子吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        mother.beginEat += father.Eat;</span><br><span class="line">        mother.beginEat += child.Eat;</span><br><span class="line">        mother.beginEat += mother.Eat;</span><br><span class="line">        </span><br><span class="line">        mother.Cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//妈妈做饭</span></span><br><span class="line"><span class="comment">//饭做好了</span></span><br><span class="line"><span class="comment">//爸爸吃饭</span></span><br><span class="line"><span class="comment">//孩子吃饭</span></span><br><span class="line"><span class="comment">//妈妈吃饭</span></span><br></pre></td></tr></table></figure>

<h2 id="6-协变逆变（不常用）"><a href="#6-协变逆变（不常用）" class="headerlink" title="6 协变逆变（不常用）"></a>6 协变逆变（不常用）</h2><p><strong>协变 <code>out</code>:</strong> 遵循里氏替换原则，父类的泛型委托可以装子类的泛型委托<br>**逆变 <code>in</code>**：逆着来，子类的泛型委托可以装父类的泛型委托</p>
<ul>
<li><strong>协变和逆变是用来修饰泛型的</strong></li>
<li><strong>用于在泛型中修饰泛型字母的，只能在泛型接口和泛型委托中使用</strong></li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用 <code>out</code> 修饰的泛型<strong>只能作为返回值</strong><br>用 <code>in</code> 修饰的泛型<strong>只能作为参数</strong> &#96;</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">MyDelegate1</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate2</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//协变 父类总是能被子类替换</span></span><br><span class="line">        <span class="comment">//父类的泛型委托可以装子类的泛型委托</span></span><br><span class="line">        MyDelegate1&lt;Son&gt; son1 = () =&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> Son(); &#125;;</span><br><span class="line"></span><br><span class="line">        MyDelegate1&lt;Father&gt; fathrer1 = son1;</span><br><span class="line">        </span><br><span class="line">        Father f = fathrer1(); <span class="comment">//实际上返回的是son1里面装的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逆变 父类总是能被子类替换</span></span><br><span class="line">        <span class="comment">//子类的泛型委托可以装父类的泛型委托</span></span><br><span class="line">        MyDelegate2&lt;Father&gt; fathrer2 = (<span class="keyword">value</span>) =&gt; &#123;  &#125;;</span><br><span class="line">        </span><br><span class="line">        MyDelegate2&lt;Son&gt; son2 = fathrer2;</span><br><span class="line">        </span><br><span class="line">        Son s = <span class="keyword">new</span> Son(); <span class="comment">//实际上返回的是father2里面装的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="九、事件-event"><a href="#九、事件-event" class="headerlink" title="九、事件 event"></a>九、事件 event</h1><h2 id="使用事件将逻辑和视觉代码分离"><a href="#使用事件将逻辑和视觉代码分离" class="headerlink" title="使用事件将逻辑和视觉代码分离"></a>使用事件将逻辑和视觉代码分离</h2><p>使用事件意味着说我可以让一件事发生而不关心是谁订阅了它，事件模型中有 publishers 和 subscribers，其中 publishers 触发事件，所有的 subscribers 都会收到事件被触发的通知。因为 <strong>publishers 并不关心是谁订阅了它，之后又发生了什么，所以使用事件模型可以使我们的代码解耦</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027444.png" alt="6bd258fb8a085e4a5f7e2bb56aadef7a_MD5|500"></p>
<p>通常我们不希望逻辑代码与视觉代码耦合在一起，<strong>我们希望不管有没有视觉组件，逻辑都能够单独运行，而视觉组件只关心逻辑代码运行时造成的具体的视觉变化</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027445.png" alt="e6f02ebd69b652045c9266b8df4813c1_MD5|500"></p>
<h2 id="事件的使用"><a href="#事件的使用" class="headerlink" title="事件的使用"></a>事件的使用</h2><ul>
<li>事件是基于委托的存在</li>
<li>事件是委托的安全包裹</li>
<li>让委托的使用更具有安全性</li>
<li>事件是一种特殊的变量类型</li>
</ul>
<p><strong>语法:</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 事件名;</span><br></pre></td></tr></table></figure>

<p><strong>事件的使用:</strong></p>
<ol>
<li>事件是作为成员变量存在于类中</li>
<li>委托怎么用，事件就怎么用</li>
</ol>
<p><strong>事件相对于委托的区别:</strong></p>
<ol>
<li><strong>不能在<mark style="background: #FF5582A6;">类外部</mark>使用 <code>=</code>  赋值，但可以在类外追加减少 <code>+=</code>   <code>-=</code> 委托</strong></li>
<li>不能在类外部调用</li>
<li>事件只能作为成员存在于类和接口以及结构体中，而委托可以作为临时变量在函数中使用。</li>
</ol>
<blockquote>
<p>[!question] 为什么使用事件？</p>
<ol>
<li>防止外部随意置空委托</li>
<li>防止外部随意调用委托</li>
<li>事件相当于对委托进行了一次封装让其更加安全</li>
</ol>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;  <span class="comment">//声明一个事件，事件的类型是委托类型，这里是Action</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件的使用方法和委托一样</span></span><br><span class="line">        myEvent = <span class="literal">null</span>;</span><br><span class="line">        myEvent += TestFunc1;</span><br><span class="line">        myEvent += TestFunc2;</span><br><span class="line">        </span><br><span class="line">        myEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunc1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestFunc1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunc2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestFunc2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line">        t.myEvent = <span class="literal">null</span>; <span class="comment">//error！事件不能在类外赋值</span></span><br><span class="line">        t.myEvent += t.TestFunc1; <span class="comment">//正确, 可以追加减少委托</span></span><br><span class="line">        </span><br><span class="line">        t.myEvent(); <span class="comment">//error！事件不能在类外调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//TestFunc1</span></span><br><span class="line"><span class="comment">//TestFunc2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h2><p>是一个多播委托类型</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义：</span></span><br><span class="line"><span class="comment">//@sender: 引发事件的对象</span></span><br><span class="line"><span class="comment">//@e: 传递的参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler m_event;  <span class="comment">//修改自定义委托类型为EventHandler</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestingEvents</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnSpacePressed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnSpacePressed += Testing_OnSpacePressed; <span class="comment">//订阅事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Testing_OnSpacePressed</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Space Pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若没有订阅，OnSpacePressed 的值是 null</span></span><br><span class="line">            <span class="comment">//EventArgs 我们这里不需要传参数，所以使用 EventArgs.Empty</span></span><br><span class="line">            OnSpacePressed?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行游戏，按下空格，我们就可以看到该事件触发的函数。</p>
<p>现在我们都是在同一个脚本、同一个类中去触发和监听事件，但<strong>使用事件模型的好处是我们可以从其他地方去监听</strong>，所以接下来我们新创建一个脚本 TestingEventSubscriber. cs，将上面的监听事件的过程放到这个脚本中</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestingEventSubscriber.cs中</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestingEventSubscriber</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestingEvents testingEvents = GetComponent&lt;TestingEvents&gt;();</span><br><span class="line">        testingEvents.OnSpacePressed += TestingEvents_OnSpacePressed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestingEvents_OnSpacePressed</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Space Pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TestingEvents.cs中</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestingEvents</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnSpacePressed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            OnSpacePressed?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将脚本挂载到同一个物体上，运行游戏，按下空格，和之前的效果相同</p>
<h3 id="参数-EventArgs-e"><a href="#参数-EventArgs-e" class="headerlink" title="参数 EventArgs e"></a>参数 <code>EventArgs e</code></h3><p>EventHandler 的另一个参数 EventArgs e 可以通过事件传递更多信息，<strong>要使用 EventArgs，我们首先需要使用泛型，然后定义一个派生自 EventArgs 的类</strong>，比如这里我们想要传递一个 int 类型的 spaceCount 记录按下空格的次数，在调整了 EventArgs 之后两个脚本如下</p>
<figure class="highlight cs"><figcaption><span>h:25-30,41</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestingEventSubscriber.cs中</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestingEventSubscriber</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestingEvents testingEvents = GetComponent&lt;TestingEvents&gt;();</span><br><span class="line">        testingEvents.OnSpacePressed += TestingEvents_OnSpacePressed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestingEvents_OnSpacePressed</span>(<span class="params"><span class="built_in">object</span> sender, TestingEvents.OnSpacePressEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Space Pressed&quot;</span> + e.spaceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestingEvents.cs中</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestingEvents</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OnSpacePressEventArgs&gt; OnSpacePressed;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnSpacePressEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> spaceCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _spaceCount;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            spaceCount++;</span><br><span class="line">            OnSpacePressed?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> OnSpacePressEventArgs &#123; spaceCount = _spaceCount &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行游戏，可以看到控制台显示出了按下空格的次数</p>
<h1 id="十、匿名函数"><a href="#十、匿名函数" class="headerlink" title="十、匿名函数"></a>十、匿名函数</h1><ul>
<li>顾名思义，就是没有名字的函数</li>
<li>匿名函数的使用主要是配合委托和事件进行使用</li>
<li><strong>脱离委托和事件是不会使用匿名函数的</strong></li>
</ul>
<figure class="highlight cs"><figcaption><span>title:语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种方法等价：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delegate 委托匿名方法</span></span><br><span class="line"><span class="built_in">delegate</span>(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda 表达式</span></span><br><span class="line">(参数列表)=&gt;&#123; 函数逻辑 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>何时使用?</strong></p>
<ol>
<li>函数中传递委托参数时</li>
<li>作为函数返回值</li>
<li>委托或事件赋值时</li>
</ol>
<p><strong>匿名函数的缺点：</strong><br>添加到委托或事件容器中后不记录，无法使用 <code>-=</code> 指定移除</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Action无参数无返回值</span></span><br><span class="line">Action action1 = <span class="built_in">delegate</span>() &#123; Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>); &#125;;   <span class="comment">//这里的匿名函数只是声明</span></span><br><span class="line">Action action1 = () =&gt; &#123; Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>); &#125;;  <span class="comment">//Lambda 表达式</span></span><br><span class="line">action1(); <span class="comment">//这里才是调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Action有参数无返回值</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; action2 = <span class="built_in">delegate</span>(<span class="built_in">string</span> name) &#123; Console.WriteLine(<span class="string">&quot;Hello &quot;</span> + name); &#125;;</span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; action2 = (<span class="built_in">string</span> name) =&gt; &#123; Console.WriteLine(<span class="string">&quot;Hello &quot;</span> + name); &#125;;  <span class="comment">//Lambda 表达式</span></span><br><span class="line">action2(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Func无参数有返回值</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; func1 = <span class="built_in">delegate</span>() &#123; <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>; &#125;;</span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; func1 = ()=&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>; &#125;; <span class="comment">//Lambda 表达式</span></span><br><span class="line">Console.WriteLine(func1());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Func有参数有返回值</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; func2 = <span class="built_in">delegate</span>(<span class="built_in">string</span> name) &#123; <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name; &#125;;</span><br><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; func2 = (<span class="built_in">string</span> name) =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name; &#125;;<span class="comment">//Lambda 表达式</span></span><br><span class="line">Console.WriteLine(func2(<span class="string">&quot;World!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:作为参数传递\作为函数返回值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//作为参数传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomething</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//作为函数返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> &#123; Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//作为参数传递</span></span><br><span class="line">        t.Dosomething(<span class="number">100</span>,<span class="built_in">delegate</span> &#123; Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//作为函数返回值</span></span><br><span class="line">        Action ac = t.GetFun();</span><br><span class="line">        ac();</span><br><span class="line">        t.GetFun()();  <span class="comment">//等价于上面两行代码，一步到位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包：<strong>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止</strong></p>
<p>注意：<strong>该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        action = () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);  <span class="comment">//形成了闭包，改变了value的生命周期，直到action为null时value才会被释放。</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            action += () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i); <span class="comment">//形成了闭包，i最终值为10，所以会打印10个10</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomthing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.DoSomthing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、反射和特性"><a href="#十一、反射和特性" class="headerlink" title="十一、反射和特性"></a>十一、反射和特性</h1><h2 id="程序集和元数据"><a href="#程序集和元数据" class="headerlink" title="程序集和元数据"></a>程序集和元数据</h2><p><strong>程序集</strong>是经由编译器编译得到的，供进一步编译执行的那个中间产物，在 windows 系统中，它一般表现为<strong>后缀为 <code>.dll</code> (库文件）或者是 <code>.exe</code> (可执行文件)</strong> 的格式<br>程序集就是我们写的一个代码集合，我们现在写的所有代码最终都会被编译器翻译为一个程序集供别人使用，比如一个代码库文件 (d11)或者一个可执行文件 (exe)</p>
<p><strong>元数据（metadata）</strong> 就是用来描述数据的数据，这个概念不仅仅用于程序上，在别的领域也有元数据。<br><strong>程序中的类，类中的函数、变量等等信息就是程序的元数据</strong>，有关程序以及类型的数据被称为元数据，它们<strong>保存在程序集中</strong>。</p>
<h2 id="反射-Type"><a href="#反射-Type" class="headerlink" title="反射 Type"></a>反射 Type</h2><p>程序正在运行时，可以查看其它程序集或者自身的元数据。<strong>一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射</strong><br>在程序运行时，通过反射可以得到其它程序集或者自己程序集代码的各种信息&#x2F;类，函数，变量，对象等等，实例化它们，执行它们，操作它们</p>
<p><strong>反射的作用</strong><br>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性</p>
<ol>
<li>程序运行时得到所有元数据，包括元数据的特性</li>
<li>程序运行时，实例化对象，操作对象</li>
<li>程序运行时创建新对象，用这些对象执行任务</li>
</ol>
<p>  <strong>Type （类的信息类）</strong></p>
<ul>
<li>它是反射功能的基础!  </li>
<li>它是访问元数据的主要方式。  </li>
<li>使用 Type 的成员获取有关类型声明的信息  </li>
<li>有关类型的成员（如构造函数、方法、<strong>字段</strong>、属性和类的事件)</li>
</ul>
<blockquote>
<p>[!question] 字段<br>字段 (Field) 就是类的成员变量!</p>
</blockquote>
<blockquote>
<p>[!info] Title<br>反射常用于跨文件获取数据，此案例只是为了演示功能，所以将所有代码放在一个文件中</p>
</blockquote>
<figure class="highlight cs"><figcaption><span>title: 获取Type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">        <span class="comment">//⭐获取Type的三种方法，三种方法都指向堆中的同一个对象</span></span><br><span class="line">        <span class="comment">//1.Object类中的GetType方法</span></span><br><span class="line">        Type t1 = a.GetType();</span><br><span class="line">        <span class="comment">//2.通过typeof关键字</span></span><br><span class="line">        Type t2 = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">        <span class="comment">//3. 通过类的名字，类名必须包含命名空间</span></span><br><span class="line">        Type t3 = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⭐得到类的程序集信息</span></span><br><span class="line">        Console.WriteLine(t1.Assembly);</span><br><span class="line">        Console.WriteLine(t2.Assembly);</span><br><span class="line">        Console.WriteLine(t3.Assembly);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>@ 以下代码都在 Main 函数中</li>
</ul>
<h3 id="获取类中的所有成员"><a href="#获取类中的所有成员" class="headerlink" title="获取类中的所有成员"></a>获取类中的所有成员</h3><figure class="highlight cs"><figcaption><span>title:获取类中的所有公共成员</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Type t4 = <span class="keyword">typeof</span>(Test); <span class="comment">//获取Test类的Type对象</span></span><br><span class="line">MemberInfo[] members = t4.GetMembers();  <span class="comment">//获取Test类中的所有成员,需要引用命名空间using System.Reflection;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; members.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(members[i]);</span><br><span class="line">    <span class="comment">//输出如下：</span></span><br><span class="line">    <span class="comment">//Void Speak()                     //Test类中的方法</span></span><br><span class="line">    <span class="comment">//System.Type GetType()            //Object类中的方法</span></span><br><span class="line">    <span class="comment">//System.String ToString()         //Object类中的方法</span></span><br><span class="line">    <span class="comment">//Boolean Equals(System.Object)    //Object类中的方法</span></span><br><span class="line">    <span class="comment">//Int32 GetHashCode()              //Object类中的方法</span></span><br><span class="line">    <span class="comment">//Void .ctor()                     //Test类构造函数</span></span><br><span class="line">    <span class="comment">//Void .ctor(Int32)                //Test类构造函数</span></span><br><span class="line">    <span class="comment">//Void .ctor(Int32, System.String) //Test类构造函数</span></span><br><span class="line">    <span class="comment">//Int32 j                          //Test类中的成员变量</span></span><br><span class="line">    <span class="comment">//System.String str                //Test类中的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><figure class="highlight cs"><figcaption><span>title:获取类的公共构造函数并调用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取所有构造函数</span></span><br><span class="line">ConstructorInfo[] ctors = t4.GetConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ctors.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(ctors[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取其中一个构造函数并执行</span></span><br><span class="line"><span class="comment">//得构造函数传入Type数组，数组中内容按顺序是参数类型</span></span><br><span class="line"><span class="comment">//执行构造函数传入object数组，表示按顺序传入的参数</span></span><br><span class="line"><span class="comment">//2.1 得到无参构造</span></span><br><span class="line">ConstructorInfo info1 = t4.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//执行无参构造函数</span></span><br><span class="line">Test obj = info1.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;<span class="comment">//获得Test类的对象obj，无参构造函数传null</span></span><br><span class="line">Console.WriteLine(obj.j);  <span class="comment">//通过obj即可访问到Test类中的成员变量</span></span><br><span class="line"><span class="comment">//2.2 得到有参构造</span></span><br><span class="line">ConstructorInfo info2 = t4.GetConstructor(<span class="keyword">new</span> Type[] &#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;);</span><br><span class="line">obj = info2.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">2</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.str);</span><br><span class="line"></span><br><span class="line">ConstructorInfo info3 = t4.GetConstructor(<span class="keyword">new</span> Type[] &#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>)&#125;);</span><br><span class="line">obj = info3.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">3</span>, <span class="string">&quot;456&quot;</span> &#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure>

<h3 id="获取类的公共成员变量"><a href="#获取类的公共成员变量" class="headerlink" title="获取类的公共成员变量"></a>获取类的公共成员变量</h3><figure class="highlight cs"><figcaption><span>title:获取类的公共成员变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取所有成员变量</span></span><br><span class="line">FieldInfo[] fields = t4.GetFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; fields.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fields[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取指定成员变量</span></span><br><span class="line">FieldInfo infoJ = t4.GetField(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">Console.WriteLine(infoJ); <span class="comment">//返回Int32 J</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过反射获取和设置对象的值</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line">test.str = <span class="string">&quot;222&quot;</span>;</span><br><span class="line"><span class="comment">//3.1 通过反射 获取对象的某个变量的值</span></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test)); <span class="comment">//返回99 </span></span><br><span class="line"><span class="comment">//3.2 通过反射 设置指定对象的某个变量的值</span></span><br><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(test.j); <span class="comment">//返回100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h3><figure class="highlight cs"><figcaption><span>title:获取类的成员方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Type类中的GetMethod方法</span></span><br><span class="line"><span class="comment">//GetMethod方法传入方法名，返回MethodInfo(方法的反射信息)对象</span></span><br><span class="line">Type strType = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="comment">//如果存在方法重载，用Type数组表示参数类型</span></span><br><span class="line"><span class="comment">//1. 获取string类的所有方法</span></span><br><span class="line">MethodInfo[] methods = strType.GetMethods();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>; i &lt; methods.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(methods[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取String类的Substring方法，调用该方法</span></span><br><span class="line">MethodInfo subStr = strType.GetMethod</span><br><span class="line">    (<span class="string">&quot;Substring&quot;</span>,<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;); </span><br><span class="line"><span class="comment">//注意：如果是静态方法，Invoke的第一个参数传null即可</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">//第一个参数相当于，是哪个对象要执行这个成员方法</span></span><br><span class="line"><span class="built_in">object</span> result = subStr.Invoke(str, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">0</span>, <span class="number">5</span> &#125;); <span class="comment">//调用Substring方法</span></span><br><span class="line">Console.WriteLine(result); <span class="comment">//输出Hello</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>得枚举<br><code>GetEnumName</code><br><code>GetEnumNames</code></p>
<p>得事件<br><code>GetEvent</code><br><code>GetEvents</code></p>
<p>得接口<br><code>GetInterface</code><br><code>GetInterfaces</code></p>
<p>得属性<br><code>GetProperty</code><br><code>GetPropertys</code></p>
<h3 id="判断一个类型的对象是否可以让另一个类型为自己分配空间"><a href="#判断一个类型的对象是否可以让另一个类型为自己分配空间" class="headerlink" title="判断一个类型的对象是否可以让另一个类型为自己分配空间"></a>判断一个类型的对象是否可以让另一个类型为自己分配空间</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类装子类</span></span><br><span class="line"><span class="comment">//是否可以从某一个类型的对象为自己分配空间</span></span><br><span class="line">Type fatherType = <span class="keyword">typeof</span>(Father);</span><br><span class="line">Type sonType = <span class="keyword">typeof</span>(Son);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fatherType.IsAssignableFrom(sonType))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;可以装&quot;</span>);</span><br><span class="line">    Father f = Activator.CreateInstance(sonType) <span class="keyword">as</span> Father;</span><br><span class="line">    print(f);  <span class="comment">//输出Son</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;不可以装&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取泛型类型"><a href="#通过反射获取泛型类型" class="headerlink" title="通过反射获取泛型类型"></a>通过反射获取泛型类型</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">Type listType = list.GetType();</span><br><span class="line"></span><br><span class="line">Type[] types = listType.GetGenericArguments(); <span class="comment">//GetGenericArguments()方法</span></span><br><span class="line">print(types[<span class="number">0</span>]);  <span class="comment">//返回string </span></span><br><span class="line"></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">float</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">float</span>&gt;();</span><br><span class="line">Type dicType = dic.GetType();</span><br><span class="line">types = dicType.GetGenericArguments();</span><br><span class="line">print(types[<span class="number">0</span>]); <span class="comment">//0对应第一个泛型类型，返回string</span></span><br><span class="line">print(types[<span class="number">1</span>]); <span class="comment">//1对应第二个泛型类型，返回float</span></span><br></pre></td></tr></table></figure>

<h2 id="Activator-动态实例化"><a href="#Activator-动态实例化" class="headerlink" title="Activator 动态实例化"></a>Activator 动态实例化</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获得要创建实例的类的类名</span></span><br><span class="line"><span class="keyword">var</span> className = <span class="string">&quot; (命名空间 namespace).ClassName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.得到当前类的类型</span></span><br><span class="line"><span class="keyword">var</span> classType = Type.GetType (className);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> classType = <span class="keyword">typeof</span> (className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建实例化类的参数数组</span></span><br><span class="line"><span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; object1, object2, object3...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 使用 Activator 实例化类</span></span><br><span class="line"><span class="keyword">var</span> classInstance = Activator.CreateInstance (classType, args);</span><br></pre></td></tr></table></figure>

<p><code>Activator.CreateInstance</code> 方法的第一个参数是要创建的类型，第二个参数是可选的，用于指定构造函数的参数。如果要创建的类型没有默认构造函数，那么必须传递构造函数所需的参数。如果要创建的类型有默认构造函数，那么第二个参数可以为空。<br>此外，<code>Activator.CreateInstance</code> 方法返回的是 <code>object</code> 类型，需要进行强制类型转换。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.使用 Activator 实例化类</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> classInstance = classType.InvokeMember (<span class="string">&quot;&quot;</span>, BindingFlags. CreateInstance, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><code>InvokeMember</code> 方法的第一个参数是空字符串，因为我们要调用的是构造函数，而不是方法、属性或字段。<br>第二个参数是 <code>BindingFlags. CreateInstance</code> 标志，表示创建对象实例；<br>第三个参数是绑定器，用于指定成员查找的方式；第四个参数是目标对象，因为我们要创建的是对象实例，所以目标对象为 null；第五个参数是构造函数参数，用于传递给构造函数的参数</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.得到要执行的方法</span></span><br><span class="line"><span class="keyword">var</span> method = classType.GetMethod (<span class="string">&quot;MathodName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.执行方法</span></span><br><span class="line"><span class="keyword">return</span> method.Invoke (classInstance, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">return</span>  classType .InvokeMember (<span class="string">&quot;MathodName&quot;</span>, BindingFlags. InvokeMethod | BindingFlags. Public | BindingFlags. Instance, <span class="literal">null</span>, classInstance , <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><code>Invoke</code> 和 <code>InvokeMember</code> 都是反射中用于调用方法的方法，但它们有一些区别：</p>
<ul>
<li>参数列表不同：<code>Invoke</code> 方法的第二个参数是 <code>object[]</code> 类型的数组，用于传递方法的参数；而 <code>InvokeMember</code> 方法的第三个参数是 <code>BindingFlags</code> 枚举类型，用于指定方法的访问权限、搜索方式等信息。</li>
<li>访问权限不同：<code>Invoke</code> 方法可以调用 public、protected、private 等所有访问权限的方法，而 <code>InvokeMember</code> 方法需要指定对应的 <code>BindingFlags</code>，才能调用对应访问权限的方法。</li>
<li>安全性不同：<code>Invoke</code> 方法可以执行非托管代码，因此需要受到安全性限制；而 <code>InvokeMember</code> 方法只能执行托管代码，因此相对更安全。</li>
</ul>
<h2 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性 Attribute"></a>特性 Attribute</h2><ol>
<li>特性是一种<strong>允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类</strong></li>
<li>特性提供功能强大的方法以将声明信息与代码 （类型、方法、属性等）相关联。特性与程序实体关联后，即可<strong>在运行时使用反射查询特性信息</strong></li>
<li>特性的目的是<strong>告诉编译器把程序结构的某组元数据嵌入程序集中</strong>，它可以放置在几乎所有的声明中 (类、变量、函数等等申明)</li>
</ol>
<p>说人话:</p>
<ul>
<li>特性本质是个类</li>
<li>我们可以<strong>利用特性类为元数据添加额外信息</strong>，比如一个类、成员变量、成员方法等等为他们添加更多的额外信息</li>
<li>之后可以通过反射来获取这些额外信息</li>
</ul>
<p><strong>基本语法:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[特性名(参数列表)]</span><br></pre></td></tr></table></figure>
<ul>
<li>本质上就是在调用特性类的构造函数</li>
<li>可以写在类、函数、变量、函数参数前，表示为他们添加了额外的信息</li>
</ul>
<h3 id="自定义特性和使用"><a href="#自定义特性和使用" class="headerlink" title="自定义特性和使用"></a>自定义特性和使用</h3><figure class="highlight cs"><figcaption><span>h:1,20,49</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 自定义特性</span></span><br><span class="line"><span class="comment">//继承特征基类Attribute</span></span><br><span class="line"><span class="comment">//类名的末尾必须带Attribute</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特性中的成员，一般根据需求来写，这些作为元数据的额外信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;特性的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用特性，注意这里去掉了自定义特性末尾的Attribute</span></span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;用于计算的类&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;成员函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">[MyCustom(<span class="string">&quot;函数参数&quot;</span></span>)]<span class="built_in">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Type t = mc.GetType();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否使用了某个特性</span></span><br><span class="line">        <span class="comment">//参数一：特性的类型</span></span><br><span class="line">        <span class="comment">//参数二：是否搜索继承链（属性和特性忽略此参数）</span></span><br><span class="line">        <span class="keyword">if</span>(t.IsDefined(<span class="keyword">typeof</span>(MyCustomAttribute),<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;该类型应用了MyCustom特性&quot;</span>); <span class="comment">//输出：该类型应用了MyCustom特性</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 通过反射来获取这些额外信息</span></span><br><span class="line">        <span class="built_in">object</span>[] array = t.GetCustomAttributes(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;array.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MyCustomAttribute mca = array[i] <span class="keyword">as</span> MyCustomAttribute;</span><br><span class="line">            <span class="keyword">if</span>(mca!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(mca.info);  <span class="comment">//输出：用于计算的类</span></span><br><span class="line">                mca.TestFun(); <span class="comment">//输出：特性的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制自定义特性的使用范围"><a href="#限制自定义特性的使用范围" class="headerlink" title="限制自定义特性的使用范围"></a>限制自定义特性的使用范围</h3><p>通过<strong>为特性类加特性</strong>限制其使用范围</p>
<p>参数一: <code>AttributeTargets</code> 特性能用在哪些地方<br>参数二: <code>AllowMultiple</code> 是否允许多个特性实例用在同一个目标上<br>参数三: <code>Inherited</code> 特性是否能被派生类和重写成员继承</p>
<figure class="highlight cs"><figcaption><span>h:3 e:21,24,26,27</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：指明MyCutom特性类只能用在类和结构体上，故后面用于成员变量，成员函数，函数参数的特性都会报错</span></span><br><span class="line"><span class="comment">//第二个参数：不允许多个实例用在同一目标</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple = true,Inherited = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特性中的成员，一般根据需求来写，这些作为元数据的额外信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;特性的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;用于计算的类1&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;用于计算的类2&quot;</span>)</span>] <span class="comment">//error!不允许多个实例用在同一目标！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;成员变量&quot;</span>)</span>] <span class="comment">//error！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;成员函数&quot;</span>)</span>]  <span class="comment">//error！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">[MyCustom(<span class="string">&quot;函数参数&quot;</span></span>)]<span class="built_in">int</span> a) <span class="comment">//error！</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置特性"><a href="#内置特性" class="headerlink" title="内置特性"></a>内置特性</h3><h4 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h4><p>关键字：  <code>Obsolete</code></p>
<ul>
<li>用于提示用户使用的方法等成员已经过时，建议使用新方法</li>
<li><strong>一般加在函数前</strong>的特性</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数一:调用过时方法时提示的内容</span></span><br><span class="line">    <span class="comment">//参数二:true-使用该方法时会报错 false-使用该方法时直接警告</span></span><br><span class="line">    [<span class="meta">Obsolete(<span class="string">&quot;该方法已经过时，请使用Speak方法&quot;</span>,false)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldSpeak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OldSpeak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Speak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用过时方法会报错或者警告：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027446.png" alt="Pasted image 20230602202716|650"></p>
<h4 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h4><p><strong>哪个文件调用?</strong><br><code>CallerFilePath</code> 特性</p>
<p><strong>哪一行调用?</strong><br><code>CallerLineNumber</code> 特性</p>
<p><strong>哪个函数调用?</strong><br><code>CallerMemberName</code> 特性</p>
<p>需要引用命名空间 <code>using System. Runtime. CompilerServices;</code><br><strong>一般作为函数参数的特性</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCall</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="params"><span class="function">        [CallerFilePath]<span class="built_in">string</span> filePath =<span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        [CallerLineNumber]<span class="built_in">int</span> linNumber = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        [CallerMemberName]<span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">        Console.WriteLine(filePath);</span><br><span class="line">        Console.WriteLine(linNumber);</span><br><span class="line">        Console.WriteLine(memberName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">        testClass.SpeakCall(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//hello world</span></span><br><span class="line"><span class="comment">//C:\Users\LiuKe\RiderProjects\ConsoleApp1\ConsoleApp1\Program.cs</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//Main</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h4><p>关键字： <code>Conditional</code><br>它会和预处理指令  <code>#define</code> 配合使用<br>需要引用命名空同 <code>using System. Diagnostics</code>; </p>
<p>主要可以用在一些调试代码上<br>有时想执行有时不想执行的代码</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Func  //没有这个宏定义，Func()函数不会被编译</span></span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="string">&quot;Func&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Func(); <span class="comment">//若没有宏定义，则不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外部-DLL-包函数特性"><a href="#外部-DLL-包函数特性" class="headerlink" title="外部 DLL 包函数特性"></a>外部 DLL 包函数特性</h4><p>关键字： <code>DllImport</code><br>用来标话非.Net (C#)的函数，表明该函数在一个外部的 DLL 中定义.<br>一般用来调用 c 或者 c++的 DLL 包写好的方法<br>需要引用命名空间 &#96;using System. Runtime. InteropServices</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;  <span class="comment">//使用Test.dll包里的方法</span></span><br></pre></td></tr></table></figure>

<h1 id="十二、枚举器和迭代器"><a href="#十二、枚举器和迭代器" class="headerlink" title="十二、枚举器和迭代器"></a>十二、枚举器和迭代器</h1><ul>
<li>迭代器 (iterator）有时又称光标（cursor)是程序设计的软件设计模式</li>
<li>迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标识</li>
<li>在表现效果上看<ul>
<li>是可以在容器对象 (例如链表或数组)上遍历访问的接口</li>
<li>设计人员无需关心容器对象的内存分配的实现细节</li>
<li>可以用 foreach 遍历的类，都是实现了迭代器的</li>
</ul>
</li>
</ul>
<h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p>关键接口: <code>IEnumerator</code> , <code>IEnumerable</code><br>命名空间:<code> using system. collections;</code><br>可以通过同时继承 <code>IEnumerable</code> 和 <code>IEnumerator</code> 实现其中的方法</p>
<p><code>foreach</code> 本质：</p>
<figure class="highlight cs"><figcaption><span>title:使用迭代器实现List数据结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>,<span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从-1开始的光标，用于表示当前遍历到的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> position = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动光标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先将光标向后移动一位</span></span><br><span class="line">        ++position;</span><br><span class="line">        <span class="comment">//如果position的值大于等于数组的长度，说明已经遍历完了</span></span><br><span class="line">        <span class="keyword">return</span> position &lt; list.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reset是重置光标位置一般写在获取IEnumerator对象这个函数中//用于第一次重置光标位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前光标所在位置的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list[position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CustomList list = <span class="keyword">new</span> CustomList();</span><br><span class="line">        <span class="comment">//foreach本质</span></span><br><span class="line">        <span class="comment">//1.先获取in后面list对象的 IEnumerator(通过GetEnumerator方法来获取IEnumerator对象)</span></span><br><span class="line">        <span class="comment">//2.执行得到这个IEnumerator对象中的 MoveNext方法</span></span><br><span class="line">        <span class="comment">//3.只要MoveNext方法的返回值时true就会去得到current, 然后赋值给item</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><p><code> yield return</code> 是 cs 提供的一个<strong>语法糖</strong>，也称<strong>糖衣语法</strong><br>语法糖主要作用就是将复杂逻辑简单化，可以增加程序的可读性从而减少程序代码出错的机会<br>关键接口: <code>IEnumerable</code><br>命名空间: <code>using System. collections;</code></p>
<p>让想要通过 <code>foreach</code> 遍历的自定义类实现接口中的方法 <code>GetEnumerator</code> 即可</p>
<p><strong>使用 yield return 实现和上一节相同的功能：</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//yield关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">//可以理解为暂时返回，保留当前的状态，一会还会再回来</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="comment">//yield return list[0];</span></span><br><span class="line">        <span class="comment">//yield return list[1];</span></span><br><span class="line">        <span class="comment">//yield return list[2];</span></span><br><span class="line">        <span class="comment">//yield return list[3];</span></span><br><span class="line">        <span class="comment">//yield return list[4];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CustomList list = <span class="keyword">new</span> CustomList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"><span class="keyword">params</span> T[] list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//yield关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">//可以理解为暂时返回，保留当前的状态，一会还会再回来</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="comment">//yield return list[0];</span></span><br><span class="line">        <span class="comment">//yield return list[1];</span></span><br><span class="line">        <span class="comment">//yield return list[2];</span></span><br><span class="line">        <span class="comment">//yield return list[3];</span></span><br><span class="line">        <span class="comment">//yield return list[4];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CustomList&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> CustomList&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十三、特殊语法"><a href="#十三、特殊语法" class="headerlink" title="十三、特殊语法"></a>十三、特殊语法</h1><h2 id="1-var-隐式类型"><a href="#1-var-隐式类型" class="headerlink" title="1 var 隐式类型"></a>1 var 隐式类型</h2><p>var 是一种特殊的变量类型，它可以用<strong>来表示任意类型的变量</strong></p>
<p>注意:</p>
<ol>
<li>var 不能作为类的成员，<strong>只能用于临时变量声明</strong>，也就是<strong>一般写在函数语句块</strong>中</li>
<li>var 必须初始化</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="2-匿名类型"><a href="#2-匿名类型" class="headerlink" title="2 匿名类型"></a>2 匿名类型</h2><p><strong>匿名类型</strong>：<br>var 变量可以声明为自定义的匿名类型</p>
<figure class="highlight cs"><figcaption><span>title:匿名类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span>&#123;age =<span class="number">10</span>,name=<span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line">Console.WriteLine(v.age);</span><br><span class="line">Console.WriteLine(v.name);</span><br></pre></td></tr></table></figure>
<h2 id="3-设置对象初始值"><a href="#3-设置对象初始值" class="headerlink" title="3 设置对象初始值"></a>3 设置对象初始值</h2><p>声明对象时，可以通过直接写**大括号 <code>&#123;&#125;</code> 的形式初始化公共成员变量和属性</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person &#123; money = <span class="number">100</span>, Age = <span class="number">10</span>, Name = <span class="string">&quot;Tom&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-设置集合初始值"><a href="#4-设置集合初始值" class="headerlink" title="4 设置集合初始值"></a>4 设置集合初始值</h2><p>申明集合对象时，也可以通过<strong>大括号</strong>直接初始化内部属性</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] array2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        </span><br><span class="line">        List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Person&#123;Age = <span class="number">100</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Person&#123;Age = <span class="number">200</span>,Name = <span class="string">&quot;Test&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Person &#123; money = <span class="number">100</span>, Age = <span class="number">10</span>, Name = <span class="string">&quot;Tom&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-可空类型"><a href="#5-可空类型" class="headerlink" title="5 可空类型"></a>5 可空类型</h2><ol>
<li><p>值类型是不能赋值为空 （null）的</p>
</li>
<li><p>声明时在值类型后面加 <code>?</code> 可以赋值为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int？ c = null</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否为空 <code>.HasValue</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">    Console.WriteLine(c.Value);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全获取可空类型值</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? d = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//如果为空，默认返回值类型的默认值</span></span><br><span class="line">Console.WriteLine(d.GetValueOrDefault());</span><br><span class="line"><span class="comment">//也可以指定一个默认值</span></span><br><span class="line">Console.WriteLine(d.GetValueOrDefault(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>语法糖：自动判断是否为<code>null</code></strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(o!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(o.ToString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法糖：自动判断是否为空,如果为空则不执行，如果不为空则执行</span></span><br><span class="line">Console.WriteLine(o?.ToString()); <span class="comment">//等价</span></span><br></pre></td></tr></table></figure>

<h2 id="6-空合并操作符"><a href="#6-空合并操作符" class="headerlink" title="6 空合并操作符 ??"></a>6 空合并操作符 ??</h2><p>左边值 ?? 右边值</p>
<ul>
<li>如果左边值为 null 就返回右边值，否则返回左边值</li>
<li>只要是可以为 null 的类型都能用<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? b = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = b ?? <span class="number">100</span>; <span class="comment">//空合并操作符</span></span><br><span class="line"><span class="built_in">int</span> a = b == <span class="literal">null</span> ? <span class="number">100</span> : b.<span class="keyword">value</span>; <span class="comment">//等价</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-内插字符串"><a href="#7-内插字符串" class="headerlink" title="7 内插字符串 $"></a>7 内插字符串 $</h2><p>关键符号: <code>$</code><br>用 <code>$</code> 来构造字符串，让字符串中可以拼接变量</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;好好学习，<span class="subst">&#123;name&#125;</span>&quot;</span>); </span><br></pre></td></tr></table></figure>

<h1 id="十四、多线程"><a href="#十四、多线程" class="headerlink" title="十四、多线程"></a>十四、多线程</h1><p><strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027447.png" alt="Pasted image 20230611103909"><br><strong>进程 (Process）</strong>是计算机中的程序关于某数据集合上的一次运行活动<br>是系统进行资源分配和调度的基本单位，是操作系统结构的基础</p>
<p>说人话: </p>
<ul>
<li>打开一个应用程序就是在操作系统上开启了一个进程</li>
<li>进程之间可以相互独立运行，互不干扰</li>
<li>进程之间也可以相互访问、操作</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190027448.png" alt="Pasted image 20230611103916|311"><br><strong>线程</strong>是操作系统能够进行CPU运算调度的最小单位。</p>
<ul>
<li>它被包含在进程之中，是进程中的实际运作单位</li>
<li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程</li>
<li>我们目前写的程序都在主线程中</li>
</ul>
<p>简单理解线程:<br>就是代码从上到下运行的一条“管道”</p>
<p><strong>什么是多线程？</strong><br>我们可以通过代码开启新的线程<br>可以以同时运行代码的多条“管道”就叫多线程</p>
<h2 id="线程类-Thread"><a href="#线程类-Thread" class="headerlink" title="线程类 Thread"></a>线程类 Thread</h2><p>需要引用命名空间 <code>using System.Threading;</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.声明一个子线程</span></span><br><span class="line"><span class="comment">//注意线程执行的代码需要封装到一个函数中(执行委托)</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(TestFunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.启动线程</span></span><br><span class="line">t.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设置为后台线程</span></span><br><span class="line"><span class="comment">//当前台线程都结束了的时候,整个程序也就结束了,即使还有后台线程正在运行</span></span><br><span class="line"><span class="comment">//后台线程不会防止应用程序的进程被终止掉</span></span><br><span class="line"><span class="comment">//如果不设置为后台线程可能导致进程无法正常关闭</span></span><br><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭释放一个线程</span></span><br><span class="line"><span class="comment">//如果开启的线程中不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>/如果是死循环想要中止这个线程有两种方式</span></span><br><span class="line"><span class="comment">//4.1-死循环中bool标识，让while(true)改为while(false)</span></span><br><span class="line"><span class="comment">//4.2-通过线程提供的方法(注意在.Net core版本中无法中止会报错)</span></span><br><span class="line">t.Abort();</span><br><span class="line">t = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.线程休眠，单位ms</span></span><br><span class="line"><span class="comment">//在哪个线程里执行，就让哪个线程休眠</span></span><br><span class="line">Thread.Sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>多个线程使用的内存是共享的，都属于该应用程序 (进程)<br>所以要注意，当多线程同时操作同一片内存区域时可能会出问题，可以通过<strong>加锁</strong>的形式避免问题</p>
<p>当我们在多个线程当中想要访问同样的东西进行逻辑处理时，为了避免不必要的逻辑顺序执行的差错<br><code>lock (引用类型对象)</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">object</span> obj = <span class="keyword">new</span> <span class="built_in">object</span>(); <span class="comment">//引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逻辑1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逻辑2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多线程对于我们的意义</strong><br>可以用多线程专门处理一些复杂耗时，影响主线成流畅度的逻辑，比如寻路、网络通信等等，副线程算完再拿到主线程使用</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/23284.html">http://liuke101.github.io/post/23284.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/62114.html" title="Unity数据持久化"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190020794.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity数据持久化</div></div></a></div><div class="next-post pull-right"><a href="/post/64623.html" title="Unity GUI"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity GUI</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">零、特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">1 预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2 控制台方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Path-%E7%B1%BB"><span class="toc-text">3 Path 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-GC"><span class="toc-text">4 垃圾回收 GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">5 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%EF%BC%88%E5%BC%BA%E5%88%B6%EF%BC%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">显式（强制）类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%BC%BA%E8%BD%AC"><span class="toc-text">括号强转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Convert-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">Convert 类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parse-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">.Parse 类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TryParse-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">.TryParse 类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">6 命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、变量和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-struct"><span class="toc-text">结构体 struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81"><span class="toc-text">具有值类型特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">字符串类型拼接方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE"><span class="toc-text">查找字符位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%AD%97%E7%AC%A6"><span class="toc-text">移除字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6"><span class="toc-text">替换字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-text">字符串截取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2"><span class="toc-text">字符串切割</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder"><span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6-Object-%E7%B1%BB"><span class="toc-text">万物之父 Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-text">装箱拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">object 的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">虚方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-text">交错数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%88Collection%EF%BC%89"><span class="toc-text">集合类（Collection）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%EF%BC%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">ArrayList （动态数组）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-text">Hashtable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-text">泛型数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List&lt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">List 的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">自定义类的排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E5%87%BD%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">通过委托函数排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dictionary"><span class="toc-text">Dictionary&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList-%E5%92%8C-LinkedListNode"><span class="toc-text">LinkedList&lt;&gt; 和 LinkedListNode&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-1"><span class="toc-text">Stack&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-1"><span class="toc-text">Queue&lt;&gt;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">二、函数（方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ref-%E5%92%8C-out-%E5%8F%82%E6%95%B0"><span class="toc-text">ref 和 out 参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#params-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">params 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三、表达式和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%89"><span class="toc-text">四、语句（控制流）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-text">异常捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-text">foreach 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BB%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-text">表达式主体成员 &#x3D;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#return-%E5%8D%95%E5%8F%A5%E6%97%B6%E5%8F%AF%E4%BB%A5%E7%94%A8-%E4%BB%A3%E6%9B%BF"><span class="toc-text">return 单句时可以用 &#x3D;&gt; 代替</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP"><span class="toc-text">五、面向对象 OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB-class"><span class="toc-text">1 类 class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E7%B1%BB-partial"><span class="toc-text">分部类 partial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB-sealed"><span class="toc-text">密封类 sealed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-text">密封方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2 访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7-get-set"><span class="toc-text">3 成员属性 get set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81-static"><span class="toc-text">4 静态 static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-text">5 拓展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">6 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">new 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">this 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-text">7 索引器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BB%A7%E6%89%BF"><span class="toc-text">8 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#base-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">base 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-as-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">is as 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A4%9A%E6%80%81"><span class="toc-text">10 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-virtual"><span class="toc-text">虚函数 virtual</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-abstract"><span class="toc-text">抽象类 abstract</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">11 面向对象七大原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A5%E5%8F%A3-interface"><span class="toc-text">六、接口 interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">接口的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口可以继承接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">隐式实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">显式实现接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B3%9B%E5%9E%8B-generic"><span class="toc-text">七、泛型 generic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">1 泛型类和泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">2 泛型方法（函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">普通类中的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">泛型类中的泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">3 泛型约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%A7%94%E6%89%98-delegate"><span class="toc-text">八、委托 delegate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1 委托的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A7%94%E6%89%98%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">2 委托作为类的成员&#x2F;函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98"><span class="toc-text">3 多播委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E7%BD%AE%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">4 内置委托类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Action"><span class="toc-text">Action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Func"><span class="toc-text">Func</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A1%88%E4%BE%8B"><span class="toc-text">5 案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">6 协变逆变（不常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BA%8B%E4%BB%B6-event"><span class="toc-text">九、事件 event</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%B0%86%E9%80%BB%E8%BE%91%E5%92%8C%E8%A7%86%E8%A7%89%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB"><span class="toc-text">使用事件将逻辑和视觉代码分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">事件的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventHandler"><span class="toc-text">EventHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-EventArgs-e"><span class="toc-text">参数 EventArgs e</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">十、匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-text">十一、反射和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">程序集和元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-Type"><span class="toc-text">反射 Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">获取类中的所有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">获取构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">获取类的公共成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">获取类的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%AE%A9%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">判断一个类型的对象是否可以让另一个类型为自己分配空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-text">通过反射获取泛型类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activator-%E5%8A%A8%E6%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">Activator 动态实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-Attribute"><span class="toc-text">特性 Attribute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">自定义特性和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">限制自定义特性的使用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7"><span class="toc-text">内置特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%97%B6%E7%89%B9%E6%80%A7"><span class="toc-text">过时特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E7%89%B9%E6%80%A7"><span class="toc-text">调用者信息特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%89%B9%E6%80%A7"><span class="toc-text">条件编译特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8-DLL-%E5%8C%85%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-text">外部 DLL 包函数特性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%9E%9A%E4%B8%BE%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">十二、枚举器和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">标准迭代器的实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">用 yield return 语法糖实现迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95"><span class="toc-text">十三、特殊语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-var-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">1 var 隐式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">2 匿名类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">3 设置对象初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">4 设置集合初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">5 可空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%A9%BA%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">6 空合并操作符 ??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%86%85%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">7 内插字符串 $</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">十四、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB-Thread"><span class="toc-text">线程类 Thread</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/42467.html" title="HLSL ShaderLab">HLSL ShaderLab</a><time datetime="2024-05-18T16:49:50.000Z" title="发表于 2024-05-19 00:49:50">2024-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/42466.html" title="CG ShaderLab">CG ShaderLab</a><time datetime="2024-05-18T16:48:56.000Z" title="发表于 2024-05-19 00:48:56">2024-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/21838.html" title="冯乐乐入门精要笔记">冯乐乐入门精要笔记</a><time datetime="2024-05-18T16:45:45.000Z" title="发表于 2024-05-19 00:45:45">2024-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/21879.html" title="Unity Primer"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Primer"/></a><div class="content"><a class="title" href="/post/21879.html" title="Unity Primer">Unity Primer</a><time datetime="2024-05-18T16:36:03.000Z" title="发表于 2024-05-19 00:36:03">2024-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/64623.html" title="Unity GUI"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity GUI"/></a><div class="content"><a class="title" href="/post/64623.html" title="Unity GUI">Unity GUI</a><time datetime="2024-05-18T16:32:22.000Z" title="发表于 2024-05-19 00:32:22">2024-05-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>