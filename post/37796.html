<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STL标准库 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、通用容器操作以下操作基本适用于所有容器   size ()的返回值为 size_type 类型，比如 string. size ()返回值为 string:: size_type 类型，值得一提的是 string[x]的下标 x 也为 string:: size_type 类型。  容器定义和初始化 将一个容器初始化为另一个容器的拷贝将一个容器初始化为另一个容器的拷贝的方法有两种：  直接拷贝">
<meta property="og:type" content="article">
<meta property="og:title" content="STL标准库">
<meta property="og:url" content="http://liuke101.github.io/post/37796.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="一、通用容器操作以下操作基本适用于所有容器   size ()的返回值为 size_type 类型，比如 string. size ()返回值为 string:: size_type 类型，值得一提的是 string[x]的下标 x 也为 string:: size_type 类型。  容器定义和初始化 将一个容器初始化为另一个容器的拷贝将一个容器初始化为另一个容器的拷贝的方法有两种：  直接拷贝">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2024-04-28T11:06:25.000Z">
<meta property="article:modified_time" content="2024-04-28T11:07:13.139Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/37796.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STL标准库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-28 12:07:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STL标准库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-28T11:06:25.000Z" title="发表于 2024-04-28 12:06:25">2024-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-28T11:07:13.139Z" title="更新于 2024-04-28 12:07:13">2024-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>97分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STL标准库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/37796.html#post-comment"><span class="waline-comment-count" data-path="/post/37796.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、通用容器操作"><a href="#一、通用容器操作" class="headerlink" title="一、通用容器操作"></a>一、通用容器操作</h1><p>以下操作基本适用于所有容器</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018508.png" alt="Pasted image 20230211213826"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018509.png" alt="Pasted image 20230211214254"></p>
<blockquote>
<p>size ()的返回值为 size_type 类型，比如 string. size ()返回值为 string:: size_type 类型，值得一提的是 string[x]的下标 x 也为 string:: size_type 类型。</p>
</blockquote>
<h2 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018510.png" alt="Pasted image 20230211220558|650"></p>
<h4 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h4><p>将一个容器初始化为另一个容器的拷贝的方法有两种：</p>
<ol>
<li>直接拷贝整个容器（两容器类型及元素类型必须相同）</li>
<li>拷贝迭代器指定的元素范围（不要求类型相同，只要能进行类型转换即可，我们称之为<strong>相容</strong>）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个容器有三个元素，用给定的初始化器进行初始化</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span> , <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles= &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接拷贝</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span> </span>;<span class="comment">//正确:类型匹配</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>; <span class="comment">//错误:容器类型不匹配</span></span><br><span class="line"><span class="comment">//迭代器指定</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>; <span class="comment">//正确:可以将const char*元素转换为string</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="特别的-array"><a href="#特别的-array" class="headerlink" title="特别的 array"></a><strong>特别的 <code>array</code></strong></h4><ul>
<li>定义一个 array 时，除了指定元素类型，还要指定容器大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt;</span><br></pre></td></tr></table></figure></li>
<li>此外，其他容器默认构造都是空容器，而 array 默认构造是非空的：它包含了与其大小一样多的默认初始化元素。</li>
<li>无法对内置数组类型进行拷贝或对象赋值，但 array 可以</li>
</ul>
<blockquote>
<p>[!NOTE] 关键概念：容器元素是拷贝<br>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。<br>容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>
</blockquote>
<h2 id="swap-和-assign"><a href="#swap-和-assign" class="headerlink" title="swap 和 assign"></a>swap 和 assign</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018511.png" alt="Pasted image 20230211221941"><br>assign 允许我们从一个<strong>不同但相容</strong>的类型赋值，或者从容器的一个子序列赋值。assign 操作用参数指定的元素的拷贝替换左边容器的所有元素。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器实现了<strong>智能指针</strong>功能，它们用于指向容器中的元素，对容器中的元素进行访问和遍历。</p>
<p>在 STL 中，迭代器是作为类模板来实现的（在头文件 <code>iterator</code> 中定义），它们可分为以下几种类型：</p>
<h3 id="根据访问修改权限分类"><a href="#根据访问修改权限分类" class="headerlink" title="根据访问修改权限分类"></a>根据访问修改权限分类</h3><ul>
<li>输出迭代器（output iterator，记为：<strong>OutIt</strong>）<ul>
<li>可以修改它所指向的容器元素</li>
<li>间接访问操作（<code>*</code>）</li>
<li><code>++</code> 操作</li>
</ul>
</li>
<li>输入迭代器（input iterator，记为：<strong>InIt</strong>）<ul>
<li>只能读取它所指向的容器元素</li>
<li>间接访问操作（<code>*</code>）和元素成员间接访问（<code>-&gt;</code>）</li>
<li><code>++</code>、<code>==</code>、<code>!=</code> 操作。</li>
</ul>
</li>
</ul>
<h3 id="根据迭代方式分类"><a href="#根据迭代方式分类" class="headerlink" title="根据迭代方式分类"></a>根据迭代方式分类</h3><ul>
<li>前向迭代器（forward iterator，记为：<strong>FwdIt</strong>）<ul>
<li>可以读取&#x2F;修改它所指向的容器元素</li>
<li>元素间接访问操作（<code>*</code>）和元素成员间接访问操作（<code>-&gt;</code>）</li>
<li><code>++</code>、<code>==</code>、<code>!=</code> 操作</li>
</ul>
</li>
<li>双向迭代器（bidirectional iterator，记为：<strong>BidIt</strong>）<ul>
<li>可以读取&#x2F;修改它所指向的容器元素</li>
<li>元素间接访问操作（<code>*</code>）和元素成员间接访问操作（<code>-&gt;</code>）</li>
<li><code>++</code>、<code>--</code>、<code>==</code>、<code>!=</code> 操作</li>
</ul>
</li>
<li>随机访问迭代器（random-access iterator，记为：<strong>RanIt</strong>）<ul>
<li>可以读取&#x2F;修改它所指向的容器元素</li>
<li>元素间接访问操作（<code>*</code>）、元素成员间接访问操作（<code>-&gt;</code>）和下标访问元素操作（<code>[]</code>）</li>
<li><code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>、<code>+=</code>、<code>-=</code>、<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 操作</li>
</ul>
</li>
</ul>
<p>除了这些基本迭代器外，STL 还提供了一些<strong>迭代器适配器</strong>，可以生成对应的迭代器 [[#泛型迭代器]]，用于一些特殊的操作。</p>
<ul>
<li>插入迭代器</li>
<li>反向迭代器</li>
<li>流迭代器</li>
</ul>
<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p><strong>迭代器正序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;T&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 迭代器的声明方式:  容器类型::迭代器类型</span></span><br><span class="line"><span class="comment"> * 2. 顺序首尾迭代器由begin()和end()方法生成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11后支持范围for循环</span></span><br><span class="line"><span class="comment">//等价写法如下：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : v)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器逆序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;T&gt;::reverse_iterator it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. 逆向迭代器不再是iterator，而是reverse_iterator</span></span><br><span class="line"><span class="comment">  * 2. 逆序首位迭代器由rbegin()和rend()方法生成</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="各容器的迭代器类型"><a href="#各容器的迭代器类型" class="headerlink" title="各容器的迭代器类型"></a>各容器的迭代器类型</h3><ul>
<li>对于 <code>vector</code>、<code>deque</code> 以及 <code>basic_string</code> 容器类，与它们关联的迭代器类型为<strong>随机访问迭代器（RanIt）</strong></li>
<li>对于 <code>list</code>、<code>map/multimap</code> 以及 <code>set/multiset</code> 容器类，与它们关联的迭代器类型为<strong>双向迭代器（BidIt）</strong></li>
</ul>
<p><code>queue</code>、<code>stack</code> 和 <code>priority_queue</code> 容器类，不支持迭代器！</p>
<p><strong>判断迭代器是否能随机访问的方法</strong><br>用多了自然就背上了，下面给出一种现场测试的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iterator++；</span><br><span class="line">iterator--；</span><br><span class="line"><span class="comment">//通过编译，至少是双向迭代器</span></span><br><span class="line">  </span><br><span class="line">iterator = iterator + <span class="number">1</span>；</span><br><span class="line"><span class="comment">//通过编译，则是随机访问迭代器</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器之间的相融关系"><a href="#迭代器之间的相融关系" class="headerlink" title="迭代器之间的相融关系"></a>迭代器之间的相融关系</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018512.png" alt="cefca8bcc1571137315093623ec613f2_MD5"></p>
<p>迭代器之间的相融关系<br><strong>在需要箭头左边迭代器的地方可以用箭头右边的迭代器去替代。</strong></p>
<h1 id="二、顺序容器"><a href="#二、顺序容器" class="headerlink" title="二、顺序容器"></a>二、顺序容器</h1><p><strong>容器</strong>用于表示由同类型元素构成的、长度可变的元素序列。<br>容器是由类模板来实现的，模板的参数是容器中元素的类型。</p>
<ul>
<li><code>vector</code>：<strong>可变大小数组</strong>。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</li>
<li><code>array</code>：<strong>固定大小数组</strong>。支持快速随机访问。不能添加或删除元素</li>
<li><code>string</code>：与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入&#x2F;删除速度快</li>
<li><code>deque</code>：<strong>双端队列</strong>。支持快速随机访问。在头尾位置插入删除速度很快</li>
<li><code>list</code>：<strong>双向链表</strong>。只支持双向顺序访问。在 list 中任何位置进行插入&#x2F;删除操作速度都很快</li>
<li><code>forward_list</code>：<strong>单向链表</strong>。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p>顺序容器特有的操作</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>这些操作会改变容器的大小; array 不支持这些操作。</li>
<li>forward_list 有自己专有版本的 insert 和 emplace;</li>
<li>forward_list 不支持 push_back 和 emplace_back。</li>
<li>vector 和 string 不支持 push_front 和 emplace_front。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span> (t)       <span class="comment">//在c的尾部创建一个值为t或由args 创建的元素。返回void</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(args)</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">push_front</span>(t)       <span class="comment">//在c的头部创建一个值为t或由args创建的元素。返回void</span></span><br><span class="line">c.<span class="built_in">emplace_front</span> (args)</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span> (p,t)        <span class="comment">//在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器</span></span><br><span class="line">c.<span class="built_in">emplace</span>(p, args)</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(p,n,t)       <span class="comment">//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器;若n为0，则返回p</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span> (p,b,e)      <span class="comment">//将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第-个元素的迭代器;若范围为空，则返回p</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(p,il)        <span class="comment">//il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器;若列表为空，则返回p</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>向一个 vector ，string 或 deque 插入元素会使所有指向容器的迭代器、引用和指针失效。</p>
</blockquote>
<p>【C++11】<strong>接受元素个数或范围的 insert 版本</strong>返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，insert 操作会将第一个参数返回。</p>
<p>【C++11】**<code>emplace_back_front / emplace / emplace_back</code>**</p>
<ul>
<li>和 insert 效果相同，但 emplace 操作不是拷贝而是<strong>构造元素</strong>（调用元素类型的构造函数）, 性能更好。</li>
<li>传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。</li>
</ul>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><ul>
<li><p>at 和下标操作只适用于 string、vector、 deque 和 array</p>
</li>
<li><p>back 不适用于 forward list。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">back</span> ()  <span class="comment">//返回c中尾元素的引用。若c为空，函数行为未定义</span></span><br><span class="line">c.<span class="built_in">front</span> () <span class="comment">//返回c中首元素的引用。若c为空，函数行为未定义</span></span><br><span class="line">c[n]       <span class="comment">//返回c中下标为n的元素的引用,n是一个无符号整数。若n&gt;=c.size(),则函数行为未定义</span></span><br><span class="line">c.<span class="built_in">at</span> (n)   <span class="comment">//返回下标为n的元素的引用。如果下标越界，则抛出一 out_of_range异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在容器中<strong>访问成员函数返回的都是引用</strong>，如果容器是一个 const 对象，则返回值是 const 引用。</p>
</li>
<li><p>对一个空容器调用 front 和 back，就像使用一个越界的下标一样，是一种严重的程序设计错误。</p>
</li>
<li><p><code>at</code> 能够检测下标是否合法，防止越界。如果下标越界，at 方法内部会抛出异常（<code>exception</code>），可以使用 <code>try-catch</code> 捕获并处理该异常。示例如下：</p>
<figure class="highlight c++"><figcaption><span>fold title:捕获异常</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexception&gt;</span>  <span class="comment">//标准异常头文件</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//s[100]不会抛出异常，程序会直接挂掉</span></span><br><span class="line">        s.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (out_of_range&amp; e) </span><br><span class="line">        <span class="comment">//如果不熟悉异常类型，可以使用多态特性， catch(exception&amp; e)。</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; </span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>这些操作会改变容器的大小，所以不适用于 array。</li>
<li>forward_list 有特殊版本的 erase</li>
<li>forward_list 不支持 pop_back;</li>
<li>vector 和 string 不支持 pop_front。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">pop_back</span> ( ) <span class="comment">//删除c中尾元素。若c为空，则函数行为未定义。函数返回void</span></span><br><span class="line">c.<span class="built_in">pop_front</span> () <span class="comment">//删除c中首元素。若c为空，则函数行为未定义。函数返回void</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span> (p)    <span class="comment">//删除迭代器 p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后（off-the-end）迭代器。若p是尾后迭代器，则函数行为未定义</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span> (b,e)  <span class="comment">//删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">clear</span> ( )    <span class="comment">//删除c中的所有元素。返回void</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning] Title<br>删除 deque 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向 vector 或 string 中删除点之后位置的迭代器、引用和指针都会失效。</p>
</blockquote>
<h3 id="改变容器的大小"><a href="#改变容器的大小" class="headerlink" title="改变容器的大小"></a>改变容器的大小</h3><ul>
<li><code>resize</code> 不适用于 array</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">resize</span>(n)      <span class="comment">//调整 c 的大小为 n 个元素。若 n&lt;c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</span></span><br><span class="line">c.<span class="built_in">resize</span>(n, t)  <span class="comment">//调整 c 的大小为 n 个元素。任何新添加的元素都初始化为值 t</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>如果 resize 缩小容器，则指向被删除元素的迭代器、引用和指针都会失效; 对 vector、string 或 deque 进行 resize 可能导致迭代器、指针和引用失效。</p>
</blockquote>
<h3 id="容器容量管理"><a href="#容器容量管理" class="headerlink" title="容器容量管理"></a>容器容量管理</h3><blockquote>
<p>[!NOTE] size 和 capacity 的区别</p>
<ul>
<li><code>size</code> 是指容器已经保存的元素的数目；</li>
<li><code>capacity</code> 则是在不分配新的内存空间的前提下它最多可以保存多少元素。即容器的容量</li>
<li><code>resize</code> 成员函数只改变容器中元素的数目，而不是容器的容量。</li>
</ul>
</blockquote>
<ul>
<li><code>shrink_to_fit</code> 只适用于 vector、 string 和 deque。</li>
<li><code>capacity</code> 和 <code>reserve</code> 只适用于 vector 和 string。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">shrink_to_fit</span>() <span class="comment">//请将capacity ()减少为与size ()相同大小</span></span><br><span class="line">c.<span class="built_in">capacity</span>()      <span class="comment">//不重新分配内存空间的话，c可以保存多少元素</span></span><br><span class="line">c.<span class="built_in">reserve</span>(n)      <span class="comment">//分配至少能容纳n个元素的内存空间</span></span><br></pre></td></tr></table></figure>

<p>只有当需要的内存空间超过当前容量时，<code>reserve</code> 调用才会改变 vector 的容量。如果需求大小大于当前容量，<code>reserve</code> 至少分配与需求一样大的内存空间（可能更大）。</p>
<p>如果需求大小小于或等于当前容量，<code>reserve</code> 什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用 <code>reserve</code> 之后，capacity 将会大于或等于传递给 <code>reserve</code> 的参数。</p>
<p>调用 <code>reserve</code> 永远也不会减少容器占用的内存空间。类似的，**<code>resize</code> 成员函数（参见 9.3.5 节，第 314 页）只改变容器中元素的数目，而不是容器的容量**。我们同样不能使用 resize 来减少容器预留的内存空间。</p>
<p><strong>巧用 swap 来收缩空间：</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41929943/article/details/103190891">C++ vector容器的swap方法（容器互换）_vector的swap_对的时间点的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"><span class="comment">// vector&lt;int&gt;(v): 利用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="comment">// swap(v): 交换的本质其实只是互换指向内存的指针</span></span><br><span class="line"><span class="comment">// 匿名对象指针指向的内存会由系统自动释放</span></span><br></pre></td></tr></table></figure>

<h2 id="顺序容器迭代器"><a href="#顺序容器迭代器" class="headerlink" title="顺序容器迭代器"></a>顺序容器迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通常使用auto简写迭代器类型</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(); <span class="comment">// begin()返回指向第一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> c = v.<span class="built_in">end</span>(); <span class="comment">// end()返回指向尾元素的下一位置的迭代器（尾后迭代器）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>特殊的，如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。</p>
</blockquote>
<p>迭代器主要有 iterator（本质是 <code>T*</code>）和 const_iterator（本质是常量指针 <code>const T*</code>）两种类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;  <span class="comment">//it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it; <span class="comment">//只能读元素，不能写元素</span></span><br><span class="line"></span><br><span class="line">string&lt;<span class="type">int</span>&gt;::iterator it;  <span class="comment">//it能读写vector&lt;string&gt;的元素</span></span><br><span class="line">string&lt;<span class="type">int</span>&gt;::const_iterator it; <span class="comment">//只能读元素，不能写元素</span></span><br></pre></td></tr></table></figure>

<p><strong>如果 vector 对象或 string 对象是一个常量，那么只能使用 const_iterator；<br>如果不是常量，那么两种迭代器都可以使用。</strong></p>
<h3 id="begin-和-end-成员"><a href="#begin-和-end-成员" class="headerlink" title="begin 和 end 成员"></a>begin 和 end 成员</h3><p>begin 和 end 有多个版本<br>rbegin：返回反向迭代器 (reverse_iterator)<br>cbegin：返回 const 迭代器（const_iterator）</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018513.png" alt="Pasted image 20230209204934"><br>forward_list 的迭代器不支持递减运算符<code>--</code></p>
<p><strong>以下运算只能应用于 string、vector、deque 和 array 的迭代器</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018514.png" alt="Pasted image 20230209205951"><br><strong>迭代器相减的结果是两个迭代器的距离</strong>，类型是名为 <code>difference_type</code> 的<strong>带符号整型数</strong>。</p>
<h3 id="容器操作导致的迭代器失效"><a href="#容器操作导致的迭代器失效" class="headerlink" title="容器操作导致的迭代器失效"></a>容器操作导致的迭代器失效</h3><p><strong>在向容器添加元素后：</strong></p>
<ol>
<li>如果容器是 vector 或 string, 且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li>
<li>对于 deque, 插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于 list 和 forward_list, 指向容器的迭代器（包括尾后迭代器和首前迭代器)、指针和引用仍有效。</li>
</ol>
<p>当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。</p>
<p><strong>当我们删除一个元素后：</strong></p>
<ol>
<li>对于 vector 和 string, 指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li>
<li>对于 deque, 如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响：如果是删除首元素，这些也不会受影响。</li>
<li>对于 list 和 forward_list, 指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器)、引用和指针仍有效。</li>
</ol>
<blockquote>
<p>[!command] 建议：管理迭代器<br>当你使用迭代器（或指向容器元素的引用或指针）时，<strong>最小化要求迭代器必须保持有效</strong>的程序片段是一个好的方法。由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。<br>这个建议对 vector、string 和 deque 尤为重要。</p>
</blockquote>
<blockquote>
<p>[!Warning] warning<br>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p>
<p>如果在一个循环中插入&#x2F;删除 deque、string 或 vector 中的元素，不要缓存 end 返回的迭代器。</p>
</blockquote>
<h2 id="【array】-固定数组"><a href="#【array】-固定数组" class="headerlink" title="【array】 固定数组"></a>【array】 固定数组</h2><ul>
<li>当<strong>创建 array</strong> 时就要<strong>初始化其大小</strong>，不可再改变。</li>
<li>array 和原生数组都是<strong>创建在栈上</strong>的（vector 是在堆上创建底层数据储存的）</li>
<li>原生数组越界的时候不会报错，而 <strong>array 会有越界检查</strong>，会报错提醒。</li>
<li>使用 std:: array 的好处是可以<strong>访问它的大小</strong>（通过 s<strong>ize ()</strong> 函数），它是一个<strong>类</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArray</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&amp; data)</span>  <span class="comment">//显式指定了大小 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; data.<span class="built_in">size</span>();i++)  <span class="comment">//访问数组大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; data[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; data; <span class="comment">//定义，有两个参数，一个指定类型，一个指定大小</span></span><br><span class="line">    data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    data[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    data[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    data[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    data[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">PrintArray</span>(data);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【vector】-可变数组"><a href="#【vector】-可变数组" class="headerlink" title="【vector】 可变数组"></a>【vector】 可变数组</h2><p>vector 提供的是<strong>随机访问迭代器（Random Access Iterator）</strong>，其内部用普通指针实现。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018515.png" alt="Pasted image 20230209195935"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018516.png" alt="Pasted image 20230209200056"></p>
<blockquote>
<p>[!bug] 下标操作<br>vector 对象的下标类型仍是对应的 size_type，和 string 一样，只能对已存在的元素执行下标操作，否则会造成缓冲区溢出，在运行时产生一个不可预估的值。</p>
<p><strong>确保下标合法的一种有效手段就是尽可能使用范围 for 语句。</strong></p>
</blockquote>
<h3 id="内存空间增长策略"><a href="#内存空间增长策略" class="headerlink" title="内存空间增长策略"></a>内存空间增长策略</h3><p>vector 本质上是一个动态数组, 内存连续存储。</p>
<p><strong>Vector 对象是如何增长的？</strong><br>假定容器中元素是连续存储的，且容器的大小是可变的，考虑向 vector 或 string 中添加元素会发生什么：如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置，因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。<br>如果我们每添加一个新元素，vector 就执行一次这样的内存分配和释放操作，性能会慢到不可接受。<br>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。<strong>当不得不获取新的内存空间时，vector 和 string 的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。</strong></p>
<p>vs 编辑器每次扩容 1.5 倍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44918090/article/details/120583540">C++vector的动态扩容，为何是1.5倍或者是2倍</a></p>
<h3 id="vector-使用优化"><a href="#vector-使用优化" class="headerlink" title="vector 使用优化"></a>vector 使用优化</h3><p>vecctor 的优化策略：</p>
<p><strong>问题 1：</strong> 当向 vector 数组中<strong>添加新元素</strong>时，为了扩充容量，<strong>当前的 vector 的内容会从内存中的旧位置复制到内存中的新位置</strong> (产生一次复制)，然后删除旧位置的内存。简单说，push_back 时，容量不够，会自动调整大小，重新分配内存。这就是将代码拖慢的原因之一。<br><strong>解决办法：</strong> vertices.reserve (n) ，直接指定容量大小，避免重复分配产生的复制浪费。  </p>
<p><strong>问题 2：</strong> 在非 vector 内存中创建对象进行初始化时，即 push_back () 向容器尾部添加元素时，首先会创建一个临时容器对象（不在已经分配好内存的 vector 中）并对其追加元素，然后再将这个对象拷贝或者移动到【我们真正想添加元素的容器】中。这其中，就造成了一次复制浪费。<br><strong>解决办法：</strong> <strong>emplace_back</strong>，直接在容器尾部创建元素，即直接在已经分配好内存的那个容器中直接构造元素，不创建临时对象。</p>
<p>简单的说：<br><strong><code>reserve </code>提前申请内存</strong>，避免动态申请开销 <strong><code>emplace_back</code> 直接在容器尾部构造元素</strong>，省略拷贝或移动过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex)</span><br><span class="line">        : <span class="built_in">x</span>(vertex.x), <span class="built_in">y</span>(vertex.y), <span class="built_in">z</span>(vertex.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )); <span class="comment">//同vertices.push_back(&#123; 1, 2, 3 &#125;);</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ));</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ));</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure>

<p><strong>发生六次复制的原因：</strong></p>
<p>理解一：</p>
<p>环境: VS2019，x64，C++17 标准，经过我自己的测试，vector 扩容因子为 1.5，初始的 capacity 为 0.<br>第一次 push_back，capacity 扩容到 1，临时对象拷贝到真正的 vertices 所占内存中，第一次 Copied；第二次 push_back，发生扩容，capacity 扩容到 2，vertices 发生内存搬移发生的拷贝为第二次 Copied，然后再是临时对象的搬移，为第三次 Copied；接着第三次 push_back，capacity 扩容到 3（2 * 1.5 &#x3D; 3，3 之后是 4，4 之后是 6…），vertices 发生内存搬移发生的拷贝为第四和第五个 Copied，然后再是临时对象的搬移为第六个 Copied；</p>
<p>理解二：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Entity&gt; e;</span><br><span class="line">    Entity data1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; </span><br><span class="line">    e.<span class="built_in">push_back</span>( data1); <span class="comment">// data1-&gt;新vector内存</span></span><br><span class="line">    Entity data2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; </span><br><span class="line">    e.<span class="built_in">push_back</span>( data2 ); <span class="comment">//data1-&gt;新vector内存   data2-&gt;vector新vector内存  删除旧vector内存</span></span><br><span class="line">    Entity data3 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    e.<span class="built_in">push_back</span>(data3);  <span class="comment">// data1-&gt;新vector内存  data2-&gt;vector新vector内存  data3-&gt;vector新vector内存  删除旧vector内存</span></span><br><span class="line">所以他的输出的次数分别是<span class="number">1</span>，<span class="number">3</span>，<span class="number">6</span></span><br><span class="line">他的复制次数你可以这样理解递增。 <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+....</span><br></pre></td></tr></table></figure>

<p>解决:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="comment">//ver 1 : copy 6 times</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ver 2 : copy 3 times</span></span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ver 3 : copy 0 times</span></span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【string】-字符串"><a href="#【string】-字符串" class="headerlink" title="【string】 字符串"></a>【string】 字符串</h2><p>标准库类型 String 表示可变长的字符序列</p>
<ul>
<li><code>char*</code> 是一个指针，<code>string</code> 是一个类<br>  <code>string</code> 封装了 <code>char*</code>，管理这个字符串，是一个 <code>char*</code> 型的容器。</li>
</ul>
<blockquote>
<p><code>string</code> 本质上是一个动态的 char 数组。</p>
</blockquote>
<ul>
<li>不用考虑内存释放和越界<br>  <code>string</code> 管理 <code>char*</code> 所分配的内存，每一次 <code>string</code> 的复制&#x2F;赋值，取值都由 <code>string</code> 类负责维护，不用担心复制越界和取值越界等。</li>
</ul>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018517.png" alt="Pasted image 20230209190416"></p>
<p><strong>除了顺序容器通用的操作外，string 类型还提供了一些额外的操作。</strong></p>
<ul>
<li>提供 string 类和 C 风格字符串之间的相互转换</li>
<li>增加了允许我们用下标代替迭代器的版本</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018518.png" alt="Pasted image 20230212153613"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 const char*</span></span><br><span class="line">string str = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//const char* 转 string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(cstr)</span></span>; <span class="comment">// 本质上其实是一个有参构造</span></span><br></pre></td></tr></table></figure>


<h3 id="2-substr-子串"><a href="#2-substr-子串" class="headerlink" title="2 substr 子串"></a>2 substr 子串</h3><p>返回一个 string，他是原始 string 的一部分或全部的拷贝，可以传递给 substr 一个可选的开始位置和计数值（从开始位置算起共有几个字符）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//substr(开始位置，计数值)</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);  <span class="comment">//s2=he11o</span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span>(<span class="number">6</span>);  <span class="comment">//s3=world</span></span><br><span class="line">string s4 = s.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">11</span>);  <span class="comment">//s3=world</span></span><br><span class="line">string s5 = s.<span class="built_in">substr</span>(<span class="number">12</span>);  <span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> string str&#123;<span class="string">&quot;HelloWorld!&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> left = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(left,right-left+<span class="number">1</span>) &lt;&lt; endl; </span><br><span class="line"><span class="comment">//为什么+1，因为右边表示的是数量，所以 4-2+1=3 表示从索引2开始的3个字符串</span></span><br><span class="line"><span class="comment">//右边范围的公式可以总结为(right-left+1)</span></span><br><span class="line"><span class="comment">//返回llo</span></span><br></pre></td></tr></table></figure>
<h3 id="3-修改"><a href="#3-修改" class="headerlink" title="3 修改"></a>3 修改</h3><ul>
<li><code>insert</code> 和 <code>erase</code> 有多个版本：<ul>
<li>接收迭代器</li>
<li><strong>接收下标</strong></li>
<li><strong>接受 C 风格字符数组</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 在pos位置插入C风格字符数组</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">// 在pos位置插入字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 在pos位置插入n个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>; <span class="comment">// 删除从pos位置开始的n个字符，默认一直删除到末尾。</span></span><br></pre></td></tr></table></figure>

<p>string 类定义了两个额外的成员函数： <code>append</code> 和 <code>repalce</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>; </span><br><span class="line"><span class="comment">// 把C风格字符数组s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> n)</span></span>; </span><br><span class="line"><span class="comment">// 把C风格字符数组s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>; </span><br><span class="line"><span class="comment">// 将字符串s追加到当前字符串末尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string&amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>; </span><br><span class="line"><span class="comment">// 把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>; </span><br><span class="line"><span class="comment">// 在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; </span><br><span class="line"><span class="comment">// 替换从pos开始n个字符为字符串s</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="comment">// 替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018519.png" alt="Pasted image 20230212154457"> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018520.png" alt="Pasted image 20230212154543"></p>
<h3 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4 搜索"></a>4 搜索</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018521.png" alt="Pasted image 20230212154657"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018522.png" alt="Pasted image 20230212154705"></p>
<p><strong><code>find</code></strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 查找str在当前字符串中第一次出现的位置，从pos开始查找，pos默认为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> n = <span class="number">0</span>)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 查找C风格字符串s在当前字符串中第一次出现的位置，从pos开始查找，pos默认为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 从pos位置查找s的前n个字符在当前字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 查找字符c第一次出现的位置，从pos开始查找，pos默认为0</span></span><br></pre></td></tr></table></figure>
<p>当查找失败时，find 方法会返回-1，-1 已经被封装为 string 的静态成员常量 <code>string::npos</code>。<br><code>static const size_t nops = -1;</code></p>
<p><strong><code>rfind</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 从pos开始向左查找最后一次出现的位置，pos默认为npos</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 查找s最后一次出现的位置，从pos开始向左查找，pos默认为npos</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 从pos开始向左查找s的前n个字符最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 查找字符c最后一次出现的位置</span></span><br></pre></td></tr></table></figure>
<p>find 方法通常查找字串第一次出现的位置，而 rfind 方法通常<strong>查找字串最后一次出现的位置。</strong><br>rfind (str, pos)的实际的开始位置是 pos + str. size ()，即从该位置开始（不包括该位置字符）向前寻找匹配项，如果有则返回字符串位置，如果没有返回 string:: npos。<br>-1 其实是 size_t 类的最大值（学过补码的同学应该不难理解），所以 string:: npos 还可以表示“直到字符串结束”，这样的话 rfind 中 pos 的默认参数是不是就不难理解啦？</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018523.png" alt="Pasted image 20230209190604"></p>
<h3 id="5-compare-比较"><a href="#5-compare-比较" class="headerlink" title="5 compare 比较"></a>5 compare 比较</h3><blockquote>
<p>[!NOTE] Title<br><code>compare()</code>和<code>&lt;</code>比较运算符都可以用来比较字母序</p>
</blockquote>
<p><strong>比较规则：</strong><br>如果两个 string 对象在某些写对应的位置上不一致，则 string 对象比较的结果其实是 string 对象中第一对相异字符比较的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string b = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">string c = <span class="string">&quot;Hiya&quot;</span></span><br></pre></td></tr></table></figure>
<p>a &lt; b<br>c &gt; a 且 c &gt; b</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018524.png" alt="Pasted image 20230212155018"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp; s)</span> <span class="type">const</span></span>; <span class="comment">// 与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span></span>; <span class="comment">// 与C风格字符数组比较</span></span><br></pre></td></tr></table></figure>
<p>compare 函数<strong>依据字典序比较</strong>，在当前字符串比给定字符串小时返回-1，在当前字符串比给定字符串大时返回 1，相等时返回 0。</p>
<h4 id="字母序比较"><a href="#字母序比较" class="headerlink" title="字母序比较"></a>字母序比较</h4><h5 id="s1-compare-s2"><a href="#s1-compare-s2" class="headerlink" title="s1.compare (s2)"></a>s1.compare (s2)</h5><p>在 C++ 中，我们可以使用 <code>compare()</code> 函数比较 <code>char*</code> 类型和 <code>string</code> 类型字符串的字典序。在当前字符串比给定字符串小时返回-1，在当前字符串比给定字符串大时返回 1，相等时返回 0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">compare</span>(s2) &lt;&lt; endl;	<span class="comment">//-1</span></span><br><span class="line">	cout &lt;&lt; s2.<span class="built_in">compare</span>(s1) &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">compare</span>(s1) &lt;&lt; endl;	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="&lt; 比较运算符"></a>&lt; 比较运算符</h5><p>此外，在 C++ 中，我们还可以使用比较运算符比较 <code>char*</code> 类型和 <code>string</code> 类型字符串的字典序，注意使用比较运算符比较 <code>char*</code> 类型字符串时，需要将 <code>char*</code> 类型强制转换为 <code>string</code> 类型，否则比较的则是字符串的起始地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> s1[<span class="number">2</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">	<span class="type">char</span> s2[<span class="number">2</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">	cout &lt;&lt; (s1 &lt; s2) &lt;&lt; endl;	<span class="comment">//0</span></span><br><span class="line">	cout &lt;&lt; &amp;s1 &lt;&lt; endl;		<span class="comment">//00BDFE74</span></span><br><span class="line">	cout &lt;&lt; &amp;s2 &lt;&lt; endl;		<span class="comment">//00BDFE68</span></span><br><span class="line">	cout &lt;&lt; (<span class="built_in">string</span>(s1) &lt; <span class="built_in">string</span>(s2)) &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	cout &lt;&lt; (<span class="built_in">string</span>(s2) &lt; <span class="built_in">string</span>(s1)) &lt;&lt; endl;	<span class="comment">//0</span></span><br><span class="line">	cout &lt;&lt; (<span class="built_in">string</span>(s1) == <span class="built_in">string</span>(s1)) &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-cin-和-getline-函数"><a href="#6-cin-和-getline-函数" class="headerlink" title="6 cin 和 getline 函数"></a>6 cin 和 getline 函数</h3><blockquote>
<p>[!NOTE] Title</p>
<ul>
<li><code>cin</code>：忽略前导空格字符（空格、制表符或换行符），从第一个非空格字符开始阅读，当读取到下一个空白字符时停止读取</li>
<li><code>getline</code>：读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。</li>
</ul>
</blockquote>
<p>虽然可以使用 cin 和 &gt;&gt; 运算符来输入字符串，但它可能会导致一些需要注意的问题。</p>
<p>当 cin 读取数据时，它会传递并忽略任何前导空格字符（空格、制表符或换行符）。一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。以下面的语句为例：</p>
<p> cin &gt;&gt; name;</p>
<p>可以输入 “Liu” 或 “Ke”，但不能输入 “Liu Ke”，因为 cin 不能输入包含嵌入空格的字符串。下面程序演示了这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     string name;  </span><br><span class="line">     string city;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Please enter your name: &quot;</span>;  </span><br><span class="line">     cin &gt;&gt; name;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Enter the city you live in: &quot;</span>;  </span><br><span class="line">     cin &gt;&gt; city;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; endl;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;You live in &quot;</span> &lt;&lt; city &lt;&lt; endl;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//若输入不带空格  </span></span><br><span class="line"> Please enter your name： Liu  </span><br><span class="line"> Enter the city you live in: Shandong  </span><br><span class="line"> <span class="comment">//前两行 信息分别手动输入  </span></span><br><span class="line"> Hello,Liu  </span><br><span class="line"> You live in Shandong  </span><br><span class="line">       </span><br><span class="line"> <span class="comment">//若输入带空格  </span></span><br><span class="line"> Please enter your name: Liu Ke  </span><br><span class="line"> <span class="comment">//输入Liu Ke后直接输出结果，没有机会输入城市名  </span></span><br><span class="line"> Enter the city you live in: Hello, Liu  </span><br><span class="line"> You live in Ke  </span><br></pre></td></tr></table></figure>

<p> 因为在第一个输入语句中，当 cin 读取到 Liu 和 Ke 之间的空格时，它就会停止阅读，只存储 Liu 作为 name 的值。在第二个输入语句中， cin 使用键盘缓冲区中找到的剩余字符，并存储 Ke 作为 city 的值。</p>
<p><strong>为了解决带空格字符串的输入问题，使用getline函数，该函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">getline</span>(cin, inputLine);  </span><br><span class="line"> <span class="comment">//cin 是正在读取的输入流  </span></span><br><span class="line"> <span class="comment">//inputLine 是接收输入字符串的 string 变量的名称</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     string name;  </span><br><span class="line">     string city;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Please enter your name: &quot;</span>;  </span><br><span class="line">     <span class="built_in">getline</span>(cin, name);  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Enter the city you live in: &quot;</span>;  </span><br><span class="line">     <span class="built_in">getline</span>(cin, city);  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; endl;  </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;You live in &quot;</span> &lt;&lt; city &lt;&lt; endl;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line"> Please enter your name: Liu Ke  </span><br><span class="line"> Enter the city you live in: Shandong  </span><br><span class="line"> <span class="comment">//可正常输入带空格字符串  </span></span><br><span class="line"> Hello, Liu Ke  </span><br><span class="line"> You live in Shandong</span><br></pre></td></tr></table></figure>
<h3 id="8-字面值和-string-相加"><a href="#8-字面值和-string-相加" class="headerlink" title="8 字面值和 string 相加"></a>8 字面值和 string 相加</h3><p>当 string 对象和字符字面值以及字符串字面值混在一条语句中使用时，要确保每个+运算符两侧的运算对象至少有一个是 string：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">string s2 = s1 + <span class="string">&quot;World&quot;</span>; <span class="comment">//正确，string+字面值 </span></span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>; <span class="comment">//错误，两个运算对象都不是string </span></span><br><span class="line">string s4 =  <span class="string">&quot;world&quot;</span> + <span class="string">&quot;!&quot;</span> + s1; <span class="comment">//错误，不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>
<h3 id="9-类型转换"><a href="#9-类型转换" class="headerlink" title="9 类型转换"></a>9 类型转换</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018525.png" alt="Pasted image 20230212155134"></p>
<h4 id="【C-11】to-string"><a href="#【C-11】to-string" class="headerlink" title="【C++11】to_string"></a>【C++11】to_string</h4><p>c++11 标准新增了全局函数 <code>std::to_string</code>，十分强大，可以将<strong>任何算术类型</strong>变成 string 类型。</p>
<blockquote>
<p>[!note] 算术类型<br>即 int，char，bool … 这些类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 带符号整数转换成字符串 */</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 无符号整数转换成字符串 */</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实数转换成字符串 */</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">float</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">double</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="stoX"><a href="#stoX" class="headerlink" title="stoX"></a>stoX</h4><p>将 string 转换为其他类型X</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 字符串转带符号整数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stoi</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">stol</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. idx返回字符串中第一个非数字的位置，即数值部分的结束位置</span></span><br><span class="line"><span class="comment">  * 2. base为进制</span></span><br><span class="line"><span class="comment">  * 3. 该组函数会自动保留负号和自动去掉前导0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 字符串转无符号整数 */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">stoul</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">stoull</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 字符串转实数 */</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">stof</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">stod</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">stold</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//与之类似的在同一个库里的还有一组基于字符数组的函数如下。</span></span><br><span class="line"><span class="comment">// &#x27;a&#x27; means array, since it is array-based. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>; <span class="comment">// &#x27;i&#x27; means  int</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>; <span class="comment">// &#x27;l&#x27; means long</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">atoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>; <span class="comment">// &#x27;ll&#x27; means long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>; <span class="comment">// &#x27;f&#x27; means double</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>如果 string 不能转换为一个数值，这些函数抛出一个 invalid_argument 异常（参见 5.6 节，第 173 页）。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。</p>
</blockquote>
<h3 id="10-处理字符"><a href="#10-处理字符" class="headerlink" title="10 处理字符"></a>10 处理字符</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018526.png" alt="Pasted image 20230209193035"></p>
<p><strong>大小写转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> c)</span></span>; <span class="comment">// 如果字符c是大写字母，则返回其小写形式，否则返回本身</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> c)</span></span>; <span class="comment">// 如果字符c是小写字母，则返回其大写形式，否则返回本身</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!comment] 建议<br>建议：使用 C++版本的 C 标准库头文件</p>
<p>C++标准库中除了定义 C+语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name. h, C++则将这些文件命名为 cname。也就是去掉了. h 后缀，而在文件名 name 之前添加了字母 c, 这里的 c 表示这是一个属于 C 语言标准库的头文件。</p>
<p>因此，cctype 头文件和 ctype. h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++语言的要求。特别的，在名为 cname 的头文件中定义的名字从属于命名空间 std, 而定义在名为. h 的头文件中的则不然。</p>
<p>一般来说，C++程序应该使用名为 cname 的头文件而不使用 name. h 的形式。</p>
</blockquote>
<h2 id="【list】-双向链表"><a href="#【list】-双向链表" class="headerlink" title="【list】 双向链表"></a>【list】 双向链表</h2><p><strong>list 不仅仅是一个双向链表，而且是一个循环的双向链表。</strong></p>
<p><strong>list 有一个重要的性质，插入和删除操作都不会造成原有 list 迭代器的失效</strong>。这在 vector 是不成立的，因为 vector 的插入操作可能会造成内存的重新配置，导致原有的迭代器全部失效<br><strong>而 list 元素的删除只会使得被删除元素的迭代器失效</strong></p>
<blockquote>
<p>[!NOTE]<br>对于 list 和 forward_list，应该<strong>优先使用成员函数版本</strong>的算法而不是通用算法。</p>
</blockquote>
<p>链表特有的操作会改变底层的容器</p>
<p>链表是一种物理存储单元上非连、续非顺序的储存结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<ul>
<li>链表由一系列结点（链表中每一个元素称为结点）组成</li>
<li>结点可以在运行时动态生成</li>
<li>每个结点包括两个部分<ul>
<li>储存数据元素的数据域</li>
<li>储存下一个结点地址的指针域</li>
</ul>
</li>
<li>链表灵活，但是空间和时间的额外消耗会比较大。</li>
</ul>
<p>相较于 vector 的连续线性空间，list 就显得复杂许多。</p>
<ul>
<li>它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间</li>
<li>因此，list 对于空间的运用有绝对的精准，一点也不浪费</li>
<li>而且，list 对于任何位置插入或删除元素都是常数项时间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018527.jpg" alt="Pasted image 20230825104451"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018528.png" alt="Pasted image 20230212235051"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018529.png" alt="Pasted image 20230212235106"></p>
<p>特有的 <code>splice</code> 成员函数<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018530.png" alt="Pasted image 20230212235202"></p>
<h2 id="【forward-list】单向链表"><a href="#【forward-list】单向链表" class="headerlink" title="【forward_list】单向链表"></a>【forward_list】单向链表</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018532.png" alt="Pasted image 20230211232259"></p>
<h2 id="【deque】双端队列"><a href="#【deque】双端队列" class="headerlink" title="【deque】双端队列"></a>【deque】双端队列</h2><p>vector 容器是单向开口的连续内存空间，deque 则是一种双向开口的连续线性空间。<br>所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作<br>vector 虽然也能在头尾插入元素，但是在头部插入元素的效率很低，需要大量进行移位操作<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018533.jpg" alt="Pasted image 20230825103846"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018534.jpg" alt="Pasted image 20230825103917"><br>deque <strong>允许使用 O(1) 复杂度在头部插入或删除元素</strong><br>deque 没有容量的概念，因为它是由动态的分段连续空间组合而成，随时可以增加一块新的空间并链接起来<br>虽然 deque 也提供了 Random Access Iterator，但其实现相比于 vector 要复杂得多，所以<strong>需要随机访问的时候最好还是用 vector</strong>。</p>
<h3 id="双端插入删除"><a href="#双端插入删除" class="headerlink" title="双端插入删除"></a>双端插入删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(T elem); <span class="comment">// 在容器尾部添加一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(T elem); <span class="comment">// 在容器头部插入一个元素</span></span><br><span class="line">​</span><br><span class="line"><span class="built_in">pop_back</span>(); <span class="comment">// 删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>(); <span class="comment">// 删除容器第一个数据</span></span><br></pre></td></tr></table></figure>


<h2 id="顺序容器适配器"><a href="#顺序容器适配器" class="headerlink" title="顺序容器适配器"></a>顺序容器适配器</h2><p>#适配器 </p>
<p>容器、迭代器和函数都有<strong>适配器（adaptor）</strong>，标准库定义了三个顺序容器适配器：<br><strong><code>stack</code></strong> 栈适配器<br><strong><code>queue</code></strong> 队列适配器<br><strong><code>priority_queue</code></strong></p>
<blockquote>
<p>[!NOTE] 适配器</p>
<p><strong>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种己有的容器类型，使其行为看起来像一种不同的类型。</strong></p>
<p>例如，stack 适配器接受一个顺序容器（除 array 或 forward_list 外），并使其操作起来像一个 stack 一样。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018535.png" alt="Pasted image 20230212163058"></p>
<h3 id="定义适配器"><a href="#定义适配器" class="headerlink" title="定义适配器"></a>定义适配器</h3><p>每个适配器定义两个构造函数：</p>
<ol>
<li>默认构造函数创建空对象</li>
<li>接收一个容器的构造函数拷贝该容器来初始化适配器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; intStack; <span class="comment">//空栈</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">intStack</span><span class="params">(deq)</span></span>; <span class="comment">//接受一个容器的构造函数，拷贝该容器来初始化适配器，假设deq是一个deque&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>默认情况</strong>下，stack 和 queue 是基于 deque 实现的，priority_queue 是在 vector 之上实现的。<br>我们可以在创建一个适配器时<strong>将一个命名的顺序容器作为第二个类型参数</strong>，来<strong>重载默认容器类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vector上实现的空栈</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">//str stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>

<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，<strong>我们只能使用适配器操作，而不能使用底层容器类型的操作！</strong></p>
<blockquote>
<p>[!warning] 重载类型限制<br>所有适配器都要求容器具有添加和删除元素的能力。<strong>因此，适配器不能构造在 array 之上。</strong></p>
</blockquote>
<p>类似的，我们<strong>也不能用 forward_list 来构造适配器</strong>，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。</p>
<blockquote>
<ul>
<li><p><strong><code>stack</code></strong> 只要求 push_back、pop_back 和 back 操作，因此<strong>可以使用除 array 和 forward list 之外的任何容器类型来构造 stack。默认基于 deque 实现</strong></p>
</li>
<li><p><strong><code>queue</code> 适配器</strong>要求 back、push_back、front 和 push_front, 因此它可以构造于 list 或 deque 之上，但<strong>不能基于 vector 构造</strong>。<strong>默认基于 deque 实现</strong></p>
</li>
<li><p><strong><code>priority_queue</code></strong> 除了 front、push_back 和 pop_back 操作之外还要求随机访问能力，因此它<strong>可以构造于 vector 或 deque 之上，但不能基于 list 构造。</strong>默认基于 vector 实现。</p>
</li>
</ul>
</blockquote>
<h2 id="【stack】-栈适配器"><a href="#【stack】-栈适配器" class="headerlink" title="【stack】 栈适配器"></a>【stack】 栈适配器</h2><ul>
<li>先进后出</li>
<li>没有迭代器，不能遍历</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018536.jpg" alt="Pasted image 20230825104239|300"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span> () <span class="comment">//删除栈顶元素，但不返回该元素值</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push</span> (item) <span class="comment">//创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造</span></span><br><span class="line">s.<span class="built_in">emplace</span>(args)</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">top</span> () <span class="comment">//返回栈顶元素，但不将元素弹出栈</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; intStack; <span class="comment">//空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">        intStack.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//intStack保存0到9十个数</span></span><br><span class="line">    <span class="keyword">while</span> (!intStack.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> value = intStack.<span class="built_in">top</span>(); <span class="comment">//使用栈顶值的代码</span></span><br><span class="line">        intStack.<span class="built_in">pop</span>(); <span class="comment">//出栈，弹出栈顶元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【queue-priority-queue】-队列适配器"><a href="#【queue-priority-queue】-队列适配器" class="headerlink" title="【queue&#x2F;priority_queue】 队列适配器"></a>【queue&#x2F;priority_queue】 队列适配器</h2><ul>
<li>先进先出</li>
<li>没有迭代器，不能遍历</li>
<li><code>priority_queue</code> 允许我们为队列中的元素建立<strong>优先级</strong>，新加入的元素会排在所有优先级比他低的已有元素之前。标准库在元素类型上使用<code>&lt;</code>运算符来确定相对优先级。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018537.jpg" alt="Pasted image 20230825104341"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span> ()   <span class="comment">//返回【queue的首元素】或【priority_queue的最高优先级的元素】,并删除此元素</span></span><br><span class="line">q.<span class="built_in">front</span> () <span class="comment">//返回首元素，但不删除此元素</span></span><br><span class="line">q.<span class="built_in">back</span> ()  <span class="comment">//返回尾元素【只适用于queue】</span></span><br><span class="line">q.<span class="built_in">top</span> ()   <span class="comment">//返回最高优先级元素，但不删除该元素【只适用于priority_queue】</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span> (item)     <span class="comment">//在queue末尾或priority_queue 中恰当的位置创建一个元素，其值为item，或者由 args构造</span></span><br><span class="line">q.<span class="built_in">emplace</span> (args ) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>priority_queue</code> 默认利用<strong>大根堆</strong>完成对元素的排序，这个大顶堆是以 <code>vector</code> 为表现形式的完全二叉树。</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p><strong>所以大家经常说的大根堆（堆头是最大元素），小根堆（堆头是最小元素），如果懒得自己实现的话，就直接用 priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</strong></p>
<p><code>priority_queue</code> 和 <code>queue</code> 基本操作相同，只是在队列的基础上添加了内部的一个排序规则</p>
<ul>
<li>top 访问队头元素</li>
<li>empty 队列是否为空</li>
<li>size 返回队列内元素个数</li>
<li>push 插入元素到队尾 (并排序)</li>
<li>emplace 原地构造一个元素并插入队列</li>
<li>pop 弹出队头元素</li>
<li>swap 交换内容</li>
</ul>
<h3 id="优先队列（自定义比较函数）"><a href="#优先队列（自定义比较函数）" class="headerlink" title="优先队列（自定义比较函数）"></a>优先队列（自定义比较函数）</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018538.png" alt="ba77e24a77fa6a6c96e31cbe72243434_MD5"></p>
<p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code><br><code>Type</code> 就是数据类型，<code>Container</code> 就是容器类型（Container 必须是用数组实现的容器，比如 vector, deque 等等，但<strong>不能用 list</strong>。STL 里面默认用的是 vector），<code>Functional</code> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，<strong>默认是大顶堆</strong><br><code>Functional</code>传入的可以是函数指针或者函数对象（类对操作符 () 进行了重载，）</p>
<p>可以使用现成的<br><code>less&lt;T&gt;</code> 来定义大顶堆<br><code>greater&lt;T&gt;</code> 来定义小顶堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列（默认大顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="comment">//降序队列（小顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>


<h4 id="方式一：struct-重载运算符"><a href="#方式一：struct-重载运算符" class="headerlink" title="方式一：struct 重载运算符 ()"></a>方式一：struct 重载运算符 ()</h4><p>通过 struct 重载 () 操作符，定义了一个函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>]; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,cmp&gt; q;<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>

<p><strong>这是属于传入函数对象的方式</strong></p>
<h4 id="方式二：class-重载运算符"><a href="#方式二：class-重载运算符" class="headerlink" title="方式二：class 重载运算符 ()"></a>方式二：class 重载运算符 ()</h4><p>通过 class 重载 () 操作符，定义了一个函数对象<br><em>注意要加 public</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,cmp&gt; q;<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>

<p><strong>这是属于传入函数对象的方式</strong></p>
<h4 id="方式三：定义函数"><a href="#方式三：定义函数" class="headerlink" title="方式三：定义函数"></a>方式三：定义函数</h4><p>首先定义一个比较函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype () 是用于获得函数指针的类型的。在模板中也要传入它们的类型。<br>decltype () 要传入的是一个对象的地址，因此需要对 cmp 加取值符，&amp;cmp 为对象的地址  </p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018539.png" alt="75d4bf0a872043996feeb6c563ae2fa3_MD5"></p>
<p>因此可以由函数地址 <code>cmp</code> 转为函数指针类型 <code>decltype(&amp;cmp)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">q</span>(cmp);<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>

<p><strong>写法一：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018540.png" alt="aff14818217969af08a78142ed222570_MD5"></p>
<p><strong>写法二：</strong><br>如果作为类成员函数，一定要声明 <code>static</code>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018541.png" alt="f821ce7c06901f2da6e6d4427b372e4d_MD5"></p>
<p><strong>这是属于传入函数指针的方式。</strong></p>
<h4 id="方式四：lambda-表达式"><a href="#方式四：lambda-表达式" class="headerlink" title="方式四：lambda 表达式"></a>方式四：lambda 表达式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp=[](vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>

<p><strong>这是属于传入函数指针的方式。</strong></p>
<h4 id="方式五：function-包装-lambda-表达式"><a href="#方式五：function-包装-lambda-表达式" class="headerlink" title="方式五：function 包装 lambda 表达式"></a>方式五：function 包装 lambda 表达式</h4><p>要加入头文件 <code>#include&lt;functional&gt;</code></p>
<p>由于 function 对 lambda 函数进行了包装 ,cmp 本身就是一个对象地址。（function 对象）<br>直接 decltype (cmp) 获得函数指针的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">bool</span>(vector&lt;<span class="type">int</span>&gt;&amp;,vector&lt;<span class="type">int</span>&gt;&amp;)&gt; cmp=[](vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>

<p><strong>这是属于传入函数指针的方式。</strong></p>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp=[](vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);<span class="comment">//小顶堆</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec=q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;vec[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;vec[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果  </p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018542.png" alt="d121fa94a435ecc14315d838d2ddeb89_MD5"></p>
<h1 id="三、关联容器"><a href="#三、关联容器" class="headerlink" title="三、关联容器"></a>三、关联容器</h1><ul>
<li>关联容器中的元素是按关键字来保存和访问的</li>
<li>关联容器的<strong>迭代器都是双向</strong>的<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018543.png" alt="Pasted image 20230213162157"></li>
<li>有序关联容器使用比较运算符 <code>&lt;</code> 来组织元素，按 Key 值字典排序从小到大 </li>
<li><strong>无序关联容器使用哈希函数</strong>（hash function）和关键字类型 <code>==</code> 运算符来组织元素</li>
</ul>
<h2 id="1-map-映射"><a href="#1-map-映射" class="headerlink" title="1 map 映射"></a>1 map 映射</h2><p>map 的特性是，所有的元素都会根据元素的键值自动排序；<br>map 的所有元素都是 <code>pair</code>，同时拥有实值和键值。</p>
<ul>
<li>pair 的第一元素被视为键值，第二元素被视为实值；</li>
<li><strong>map 不允许两个元素有相同的键值；如果尝试插入两个具有相同键值的元素，新的元素将会覆盖旧的元素。</strong></li>
<li><strong>和 set 类似的原因，我们不能通过迭代器改变 map 的键值，但我们可以任意修改实值。</strong><br>map 和 list 在增删元素的时候具有相似的性质。<br>map 和 multimap 的操作类似，唯一的区别是 multimap 键值可重复。<br>map 和 multimap 都是以<strong>红黑树</strong>作为底层实现机制。<br>map 和 multimap 包含在同一个头文件中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count; <span class="comment">//空容器</span></span><br><span class="line">map&lt;string,string&gt; m = &#123; &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">							&#123;<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>&#125;,</span><br><span class="line">							&#123;<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>使用 map：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">//string到size_t的空map</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word]; <span class="comment">//提取word的计数器并加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)  </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;出现&quot;</span> &lt;&lt; w.second &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018544.png" alt="Pasted image 20230213163856"></p>
<h2 id="2-set-集合"><a href="#2-set-集合" class="headerlink" title="2 set 集合"></a>2 set 集合</h2><p>set 的特性是，所有的容器都会根据元素自身的键值进行自动被排序。</p>
<p>set 的元素不像 map 那样可以同时拥有实值和键值，<strong>set 的元素既是实值又是键值</strong>。</p>
<ul>
<li><strong>set 不允许两个元素有相同的键值</strong>，如果插入两个相同的键值，那么第二个键值插入操作将会被忽略。</li>
<li>我们不可以通过 set 的迭代器改变 set 元素的值。因为其元素值就是键值，任意改变会严重破坏 set 的组织</li>
<li>换句话说，set 的 iterator 是一种 const_iterator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">set&lt;string&gt; s = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>使用 set：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数，并忽略指定的单词</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">//string到size_t的空map</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;I&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;You&quot;</span>,<span class="string">&quot;you&quot;</span> &#125;; <span class="comment">//忽略单词集合</span></span><br><span class="line"></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//只统计不在exclude中的单词</span></span><br><span class="line">    <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>())</span><br><span class="line">        ++word_count[word]; <span class="comment">//提取word的计数器并加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)  </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;出现&quot;</span> &lt;&lt; w.second &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018545.png" alt="Pasted image 20230213170315"><br>find 调用返回一个迭代器，如果给定关键字在 set 中，迭代器指向该关键字，否则，find 返回尾后迭代器。</p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><ul>
<li>multiset 特性及用法和 set 完全相同，唯一的差别在于它允许键值重复。</li>
<li>set 和 multiset 的底层实现是<strong>红黑树</strong>，红黑树为平衡二叉树的一种</li>
</ul>
<blockquote>
<p>注意，multiset 和 set 共用一个头文件。</p>
</blockquote>
<h2 id="3-pair-类型"><a href="#3-pair-类型" class="headerlink" title="3 pair 类型"></a>3 pair 类型</h2><p>定义在头文件 utility 中</p>
<ul>
<li>一个 pair 保存两个数据成员，必须提供两个类型名</li>
<li>pair 的数据成员是 public 的，两个成员分别命名为 first，second<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">pair&lt;string,<span class="type">size_t</span>&gt; p; <span class="comment">//pair的默认构造函数对数据成员进行值初始化，一个是空string，一个是0</span></span><br><span class="line">pair&lt;string,<span class="type">size_t</span>&gt; p&#123;<span class="string">&quot;a&quot;</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p</span><span class="params">(k, v)</span></span>;</span><br><span class="line"></span><br><span class="line">pair&lt;T1, T2&gt; p = <span class="built_in">make_pair</span>(k, v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; p.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018546.png" alt="Pasted image 20230213172051"></p>
<p>【C++11】**可以对返回值进行列表初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理v</span></span><br><span class="line">    <span class="comment">//若v不为空，我们返回一个由v中最后一个string及其大小组成的pair。</span></span><br><span class="line">    <span class="comment">//否则，隐式构造一个空pair,并返回它。</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span> ()</span><br><span class="line">        <span class="keyword">return</span>&#123; v.<span class="built_in">back</span>(),v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;<span class="comment">//列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;();<span class="comment">//隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在较早的 C++版本中，不允许用花括号包围的初始化器来返回 pair 这种类型的对象，<br>必须显式构造返回值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span> ()</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(v.<span class="built_in">back</span>(),v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p><strong>我们还可以用 <code>make_pair</code> 来生成 pair 对象</strong>，pair 的两个类型来自于 make pair 的<br>参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span> ()</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make_pair</span>(v.<span class="built_in">back</span>(),v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-关联容器操作"><a href="#4-关联容器操作" class="headerlink" title="4 关联容器操作"></a>4 关联容器操作</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018547.png" alt="Pasted image 20230213172656"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;  <span class="comment">//v1是一个string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;  <span class="comment">//v2是一个string</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;:value_type v3;  <span class="comment">//v3是一个pair&lt;const string,int&gt;</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;:key_type v4;  <span class="comment">//v4是一个string</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;:mapped_type v5;  <span class="comment">//v5是一个int</span></span><br></pre></td></tr></table></figure>

<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用关联容器迭代器，得到类型为 value_type，<strong>value_type 是一个 pair 类型，其 first 成员保存 const 关键字（const key_type），second 保存值（maped_type）</strong></p>
<blockquote>
<p>[!NOTE]<br>一个 map 的 value_type 是一个 pair，可以改变 pair 的值，不能改变 pair 的关键字。<br>同样，set 的关键字也不能改变</p>
</blockquote>
<p><strong>map 的 value_type 就是 pair 类型</strong>，所以支持 first，second 操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;</span><br><span class="line"><span class="comment">//获得指向word_count中一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it =  word_count.<span class="built_in">begin</span> ()  <span class="comment">//*map_it是指向一个pair&lt;const string,size t&gt;对象的引用</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;  <span class="comment">//打印此元素的关键字</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;second;  <span class="comment">//打印此元素的值</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;  <span class="comment">//错误：关键字是const的</span></span><br><span class="line">++map_it-&gt;second;  <span class="comment">//正确：我们可以通过迭代器改变元素</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line">*set_it = <span class="number">42</span>;  <span class="comment">//错误，set关键字是const的</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h3><p>支持 begin 和 end</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得一个指向首元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">cbegin</span>();</span><br><span class="line"><span class="comment">//比较当前迭代器和尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.<span class="built_in">cend</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解引用迭代器，打印关键字-值对</span></span><br><span class="line">    cout &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">&quot;出现&quot;</span> &lt; &lt;map_it-&gt;second &lt;&lt; <span class="string">&quot;次&quot;</span>&lt;&lt; endl;</span><br><span class="line">    ++map_it;<span class="comment">//递增迭代器，移动到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;T1, T2&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insert-添加元素"><a href="#insert-添加元素" class="headerlink" title="insert 添加元素"></a>insert 添加元素</h3><p>insert 向容器中添加一个元素或一个元素范围（begin，end）<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018548.png" alt="Pasted image 20230213180409"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map添加</span></span><br><span class="line"><span class="comment">//向word_count插入word的4种方法</span></span><br><span class="line">word_count.<span class="built_in">insert</span> (&#123;word,<span class="number">1</span>&#125;);  <span class="comment">//最方便</span></span><br><span class="line">word_count.<span class="built_in">insert</span> (<span class="built_in">make_pair</span> (word,<span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span> (<span class="built_in">pair</span>&lt;string,size t&gt; (word,<span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span> (map&lt;string,size t&gt;::<span class="built_in">value_type</span> (word,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set添加</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;:  <span class="comment">//ivec有8个元素</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; set2;  <span class="comment">//空集合</span></span><br><span class="line">set2.<span class="built_in">insert</span> (ivec.<span class="built_in">cbegin</span>(), ivec.<span class="built_in">cend</span>());  <span class="comment">//set2有4个元素</span></span><br><span class="line">set2.<span class="built_in">insert</span>((<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;):  <span class="comment">//set2现在有8个元素，重复的不会加入</span></span><br></pre></td></tr></table></figure>

<h3 id="erase-删除元素"><a href="#erase-删除元素" class="headerlink" title="erase 删除元素"></a>erase 删除元素</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018549.png" alt="Pasted image 20230213195217"></p>
<h3 id="map-的下标操作"><a href="#map-的下标操作" class="headerlink" title="map 的下标操作"></a>map 的下标操作</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018550.png" alt="Pasted image 20230213195731"><br>map 下标运算符接受一个关键字，获取此关键字相关联的值，如果关键字不在 map 中就会创建一个元素插入到 map 中，值进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map &lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">//空map</span></span><br><span class="line"><span class="comment">// 插入一个关键字为“Anna”的元素，值初始化为0；</span></span><br><span class="line"><span class="comment">// 然后将1赋给值，值变为1</span></span><br><span class="line">word_count[”Anna“] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们指向查找值，不想改变map，那就不能使用下标操作，可以用find代替</span></span><br><span class="line"><span class="comment">//find查找失败返回尾后迭代器，即end迭代器</span></span><br><span class="line"><span class="keyword">if</span>(word_count.<span class="built_in">find</span>(<span class="string">&quot;foobar&quot;</span>) == word_count.<span class="built_in">end</span>())</span><br><span class="line">		cout&lt;&lt; <span class="string">&quot;foobar is not in the map&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>vector, string 解引用迭代器返回的类型与下标运算符返回的类型一样，但是 map 不一样。<br><strong>map 下标操作获得 mapped_type 对象，解引用获得 value_type 对象</strong></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>find：查找<br>count：统计数量<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018551.png" alt="Pasted image 20230213200150"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018552.png" alt="Pasted image 20230213200158"></p>
<blockquote>
<p>[!NOTE] Title<br>lower bound 返回的迭代器可能指向一个具有给定关键字的元素，但也可能<br>不指向。</p>
</blockquote>
<p><strong>如果关键字不在容器中，lower_bound 和 upper_bound 返回相同的迭代器</strong>（返回关键字的第一个安全插入点）一一不影响容器中元素顺序的插入位置</p>
<h4 id="multimap-或-multiset-中查找"><a href="#multimap-或-multiset-中查找" class="headerlink" title="multimap 或 multiset 中查找"></a>multimap 或 multiset 中查找</h4><p>Multimap 和 multiset 允许关键字重复，这些元素再容器中相邻存储</p>
<p>给定一个作者到著作题目的映射，我们想打印一个特定作者的所有著作<br>方法一：使用 find 和 count：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">search_iter</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;  <span class="comment">//要查找的作者</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_iter);  <span class="comment">//元素的数量</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_iter);  <span class="comment">//作者的第一本书</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个循环查找此作者的所有著作</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; iter-&gt; second &lt;&lt;endl;</span><br><span class="line">    ++iter;</span><br><span class="line">    --entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h4><p>lower_bound ( )和 upper_bound ( )都是利用二分查找的方法在一个排好序的数组中进行查找的。</p>
<p><strong>在从小到大的排序数组中，</strong><br><code>lower_bound ( begin, end, num)</code>：从数组的 begin 位置到 end-1 位置二分查找<strong>第一个大于等于</strong> num 的数字，找到返回该数字的地址，<strong>不存在则返回 end</strong>。<strong>通过返回的地址减去起始地址 begin, 得到找到数字在数组中的下标。</strong></p>
<p><code>upper_bound ( begin, end, num)</code>：从数组的 begin 位置到 end-1 位置二分查找<strong>第一个大于</strong> num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin, 得到找到数字在数组中的下标。</p>
<p><strong>在从大到小的排序数组中</strong>，重载 lower_bound ()和 upper_bound()<br><code>lower_bound ( begin, end, num, greater&lt;type&gt;() )</code>: 从数组的 begin 位置到 end-1 位置二分查找<strong>第一个小于等于</strong> num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin, 得到找到数字在数组中的下标。</p>
<p><code>upper_bound ( begin, end, num, greater&lt;type&gt;())</code>: 从数组的 begin 位置到 end-1 位置二分查找<strong>第一个小于</strong> num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin, 得到找到数字在数组中的下标。</p>
<h4 id="equal-range-函数"><a href="#equal-range-函数" class="headerlink" title="equal_range 函数"></a>equal_range 函数</h4><p>equal_range 函数 s 接受一个关键字，返回一个迭代器 pair。<br>若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置<br>若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置</p>
<p>相当于 lower_bound 和 upper_bound 的结合体。</p>
<p>方法三：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authors 和 search_item的定义，与前面的程序一样</span></span><br><span class="line"><span class="comment">// pos保存迭代器对，表示与关键字匹配的元素范围</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);pos.first != pos.second; ++pos.first)</span><br><span class="line">&#123;</span><br><span class="line">		cout&lt;&lt; pos.first-&gt;second &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-无序关联容器"><a href="#5-无序关联容器" class="headerlink" title="5 无序关联容器"></a>5 无序关联容器</h2><p>unorderd：不按关键字顺序，使用<strong>哈希函数（hash function）</strong> 和关键字类型 <code>==</code> 运算符来组织元素<br><strong>使用有序容器相同的操作，只是不排序</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Peealy/article/details/116895964">一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数-CSDN博客</a></p>
<blockquote>
<p>[!Tip]<br>如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。<br>使用无序容器通常性能更好</p>
</blockquote>
<h3 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h3><ul>
<li>无序容器在存储上组织为一组<strong>桶（bucket）</strong>，每个桶保存零个或多个元素。</li>
<li>使用一个哈希函数将元素映射到桶。</li>
<li><strong>为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶</strong>。</li>
<li>容器<strong>将具有一个特定哈希值的所有元素都保存在相同的桶</strong>中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</li>
</ul>
<p>无序容器提供了一组管理桶的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018553.png" alt="Pasted image 20230213213719"></p>
<h3 id="对关键字类型的要求"><a href="#对关键字类型的要求" class="headerlink" title="对关键字类型的要求"></a>对关键字类型的要求</h3><p>默认情况下，无序容器使用关键字类型的 <code>==</code> 运算符来比较元素，它们还使用一个 <code>hash&lt;key_type&gt;</code> 类型的对象来生成每个元素的哈希值。标准库为内置类型〈包括指针)提供了 hash 模板。还为一些标准库类型，包括 string 和我们将要在第 12 章介绍的智能指针类型定义了 hash。因此，<strong>我们可以直接定义关键字是内置类型（包括指针类型)、string 还是智能指针类型的无序容器</strong>。<br><strong>但是，我们不能直接定义关键字类型为自定义类类型的无序容器。</strong> 与容器不同，不能直接使用哈希模板，而<strong>必须提供我们自己的 hash 模板版本</strong>。我们将在 16.5 节 (第 626 页)中介绍如何做到这一点。</p>
<h2 id="6-自定义排序"><a href="#6-自定义排序" class="headerlink" title="6 自定义排序"></a>6 自定义排序</h2><p>有序关联容器，默认按照 Key 值升序排列插入数据，我们可以自定义排序规则<br>下面以 map 为例，map 没有函数对象和函数指针均可以作为算法的谓词传递，但函数对象还能自适应，并增加 C++ 标准库的作用域、灵活性和效率。随机迭代器，只有顺序迭代器,所以不能用 <code>sort</code> 排序。</p>
<p><strong>自定义按 Key 排序：</strong><br>map 的构造函数： <code>map&lt;int,int,comp&gt;</code></p>
<ul>
<li>comp 可以是函数指针或函数对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="type">char</span> lhs, <span class="type">char</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">classcomp</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; lhs, <span class="type">const</span> <span class="type">char</span>&amp; rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>,classcomp&gt; fourth;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt; &gt; mp; <span class="comment">//注意&lt;int&gt;后空一格</span></span><br><span class="line"><span class="comment">//当然lambda也可以</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>自定义按 Value 值排序</strong>：无法直接对 map 本身操作，可以先将 map 压入 vector，再对 vector 排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//map统计出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Num_To_Count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++Num_To_Count[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无法直接对map排序，所以将map值复制到vector中进行排序</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(Num_To_Count.<span class="built_in">begin</span>(),Num_To_Count.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据出现次数降序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">        [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; A,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; B)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.second &gt; B.second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出前k个元素</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;++i)</span><br><span class="line">         &#123;</span><br><span class="line">             res.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、定制操作"><a href="#四、定制操作" class="headerlink" title="四、定制操作"></a>四、定制操作</h1><h3 id="谓词：向算法传递函数"><a href="#谓词：向算法传递函数" class="headerlink" title="谓词：向算法传递函数"></a>谓词：向算法传递函数</h3><blockquote>
<p>[!NOTE] 谓词<br><strong>谓词是一个可调用的表达式，是返回值为 <code>bool</code> 的函数、函数指针、函数对象、lambda 表达式。</strong></p>
<p>标准库算法所使用的谓词分为两类：<br>一元谓词 (unary predicate, 意味着它们只接受单一参数)<br>二元谓词 (binary predicate, 意味着它们有两个参数)。</p>
<p>接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。</p>
</blockquote>
<h4 id="1-使用函数"><a href="#1-使用函数" class="headerlink" title="1. 使用函数"></a>1. 使用函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数，作为传入参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bigthan3</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算容器vec中大于3的元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> CountNum = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),bigthan3);   <span class="comment">//传入的是bigthan3谓词，返回的是bool类型，其中自动将vec容器中的元素值传给bigthan3函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CountNum = &quot;</span>&lt;&lt;CountNum &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：CountNum = 3；</span></span><br></pre></td></tr></table></figure>

<h4 id="2-使用函数指针"><a href="#2-使用函数指针" class="headerlink" title="2. 使用函数指针"></a>2. 使用函数指针</h4><p>与上述函数做谓词基本一致，只是使用函数指针中转了一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数，作为传入参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bigthan3</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算容器vec中大于3的元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">bool</span> (*p_bigthan3)(<span class="type">int</span>);	<span class="comment">//定义函数指针指向bigthan3函数</span></span><br><span class="line">	p_bigthan3 = bigthan3;</span><br><span class="line">	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> CountNum = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),p_bigthan3);   <span class="comment">//传入的是p_bigthan3函数指针做谓词，返回的是bool类型，其中自动将vec容器中的元素值传给bigthan3函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CountNum = &quot;</span>&lt;&lt;CountNum &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：CountNum = 3；</span></span><br></pre></td></tr></table></figure>

<h4 id="3-使用函数对象"><a href="#3-使用函数对象" class="headerlink" title="3. 使用函数对象"></a>3. 使用函数对象</h4><p>函数对象使用的本质就是对 () 进行运算符重载，并且返回类型为 bool 型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义仿函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bigthan3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span><span class="type">const</span>  <span class="comment">//对()实现重载，注意一定要加const修饰 &#123;</span></span></span><br><span class="line"><span class="function">		<span class="keyword">return</span> val &gt; 3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//计算容器vec中大于3的元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> CountNum = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">bigthan3</span>());   <span class="comment">//传入的是bigthan3仿函数，返回的是bool类型，其中自动将vec容器中的元素值传给bigthan3函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CountNum = &quot;</span>&lt;&lt;CountNum &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：CountNum = 3；</span></span><br></pre></td></tr></table></figure>


<h4 id="4-使用-lambda-表达式"><a href="#4-使用-lambda-表达式" class="headerlink" title="4. 使用 lambda 表达式"></a>4. 使用 lambda 表达式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span>      <span class="comment">//bind2nd函数需使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算容器vec中大于3的元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> CountNum = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> val)&#123;<span class="keyword">return</span> val&gt;<span class="number">3</span>;&#125;);   <span class="comment">//传入的是lambda表达式，返回的是bool类型，其中val为遍历vec容器传入的元素值</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CountNum = &quot;</span>&lt;&lt;CountNum &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：CountNum = 3；</span></span><br></pre></td></tr></table></figure>


<h4 id="一元谓词举例"><a href="#一元谓词举例" class="headerlink" title="一元谓词举例"></a>一元谓词举例</h4><p>例如，对于下面的“<strong>统计</strong>”算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count_if</span><span class="params">(InIt first, InIt last, Pred cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以有如下使用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    ...... <span class="comment">// 往容器中放了元素</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), f); <span class="comment">// 统计v中正数的个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二元谓词举例"><a href="#二元谓词举例" class="headerlink" title="二元谓词举例"></a>二元谓词举例</h4><p>例如，对于下面的“<strong>排序</strong>”算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt first, RanIt last)</span></span>; <span class="comment">// 按“&lt;”排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt first, RanIt last, BinPred comp)</span></span>; <span class="comment">// 按comp返回true规定的次序</span></span><br></pre></td></tr></table></figure>

<p>可以有如下用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> </span>&#123; <span class="keyword">return</span> x1 &gt; x2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    ...... <span class="comment">// 往容器中放了元素</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater); <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 greater 函数使得排序变为从大到小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater</span> <span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> </span>&#123; <span class="keyword">return</span> x1 &gt; x2; &#125;</span><br></pre></td></tr></table></figure>
<p>可以把 <code>x1</code>，<code>x2</code> 看作 <code>vector&lt;int&gt;</code> 两个元素，x1 在左边，x2 在右边。<br>当 <code>x1 &gt; x2</code> 为、ture 时，说明数组左边元素大于右边元素，该数组为降序排列。<br>相反，当 <code>x1&lt;x2</code> 为 true 时，为升序排列。</p>
<h2 id="泛型迭代器"><a href="#泛型迭代器" class="headerlink" title="泛型迭代器"></a>泛型迭代器</h2><p>除了为每个容器定义的迭代器之外，标准库在头文件 <code>iterator</code> 中还定义了额外几种迭代器。</p>
<ol>
<li>**插入迭代器 (insert iterator)**：绑定到一个容器上，可用来向容器插入元素。</li>
<li>**流迭代器 (stream iterator)**：绑定到输入或输出流上，可用来遍历所关联的 IO 流。</li>
<li>**反向迭代器 (reverse iterator)**：向后而不是向前移动。除了 forward_list 之外的标准库容器都有反向迭代器。</li>
<li>**移动迭代器 (move iterator)**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li>
</ol>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p><strong>插入迭代器适配器：接受一个容器，生成一个迭代器</strong></p>
<ul>
<li><code>back_inserter</code></li>
<li><code>front_inserter</code> </li>
<li><code>inserter</code></li>
</ul>
<p><strong>插入迭代器：用于在容器中指定位置插入元素</strong></p>
<ul>
<li><code>back_insert_iterator</code>（用于在尾部插入元素）</li>
<li><code>front_insert_iterator</code>（用于在首部插入元素）</li>
<li><code>insert_iterator</code>（用于在任意指定位置插入元素）</li>
</ul>
<p>当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。<br>通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018554.png" alt="Pasted image 20230212223317"></p>
<h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><ul>
<li><code>back_inserter</code> 创建一个使用 <code>push_back</code> 的迭代器。<code>back_inserter</code> 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 <code>push_back</code> 将一个具有给定值的元素添加到容器中：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;<span class="comment">//空向量</span></span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">back_inserter</span>(vec);<span class="comment">//通过它赋值会将元素添加到vec中</span></span><br><span class="line">*it=<span class="number">42</span>;<span class="comment">//vec中现在有一个元素，值为42</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>我们常常使用 <code>back_inserter</code> 来创建一个迭代器，作为算法的目的位置来使用。</strong>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;<span class="comment">//空向量</span></span><br><span class="line"><span class="comment">//正确：back_inserter创建一个插入迭代器，可用来向vec添加元素</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">0</span>);<span class="comment">//添加10个元素到vec</span></span><br></pre></td></tr></table></figure>

<h4 id="front-inserter"><a href="#front-inserter" class="headerlink" title="front_inserter"></a>front_inserter</h4><ul>
<li><code>front_inserter</code> 创建一个使用 <code>push_front</code> 的迭代器。元素总是插入到容器第一个元素之前。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2,list3; <span class="comment">//空list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝完成之后，lst2包含4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">//拷贝完成之后，lst2包含1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">inserter</span>(lst3,lst3.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><ul>
<li><code>inserter</code> 创建一个使用 <code>insert</code> 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">inserter</span>(c,iter);</span><br><span class="line">*it = val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it,val);</span><br><span class="line">++it <span class="comment">//递增it使他指向原来的元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>[!NOTE]<br>只有在容器支持 push front 的情况下，我们才可以使用 front_inserter。类似的，只有在容器支持 push_back 的情况下，我们才能使用 back_inserter。</p>
</blockquote>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素; 递减一个迭代器 (—-it）会移动到下一个元素。<br>除了 <code>forward_list</code> 之外, 其他容器都支持反向迭代器。我们可以通过调用 rbegin、rend、crbegin 和 crend 成员函数来获得反向迭代器。<strong>这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器</strong>。与普通迭代器一样，反向迭代器也有 const 和非 const 版本。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018555.png" alt="Pasted image 20230824095050"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//从尾元素到首元素的反向迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> r_iter = vec.<span class="built_in">crbegin</span>( );  <span class="comment">//将r_iter绑定到尾元素</span></span><br><span class="line">    r_iter != vec.<span class="built_in">crend</span> ( ) ; <span class="comment">//crend指向首元素之前的位置</span></span><br><span class="line">    ++r_iter) <span class="comment">//实际是递减，移动到前一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt;*r_iter&lt;&lt; endl; <span class="comment">//打印9,8，7， ... 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过向 sort 传递一对反向迭代器来将 vector 整理为递减序列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> (vec.<span class="built_in">begin</span> () , vec.<span class="built_in">end</span> ()); <span class="comment">//按“正常序”排序vec</span></span><br><span class="line"><span class="built_in">sort</span> (vec.<span class="built_in">rbegin</span> () , vec.<span class="built_in">rend</span> ( )); <span class="comment">//按逆序排序:将最小元素放在vec的末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="iostream-流迭代器"><a href="#iostream-流迭代器" class="headerlink" title="iostream 流迭代器"></a>iostream 流迭代器</h3><p>iostream 类型不是容器，但是标准库也定义了用于这些 IO 对象的迭代器。<strong>迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器，<strong>可以用泛型算法</strong>从流对象读取数据以及写入数据。</p>
<p>创建流迭代器，必须指定迭代器要读写的类型。</p>
<h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p><strong>可以为任何具有输入运算符（&gt;&gt;）的类型定义 ostream iterator 对象</strong>。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018556.png" alt="Pasted image 20230212231129"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;  <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; int_eof;  <span class="comment">//默认初始化迭代器，可以组为尾后值使用</span></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_it</span><span class="params">(ifs)</span></span>;  <span class="comment">//从&quot;afile&quot;读取字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：从标准输入读取数据，存入vector</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;  <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;  <span class="comment">//尾后迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有数据可供读取时</span></span><br><span class="line"><span class="keyword">while</span>(in_iter != eof)  </span><br><span class="line">		<span class="comment">//后置递增运算读取流，返回迭代器的旧值</span></span><br><span class="line">		<span class="comment">//解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">		vec.<span class="built_in">push_back</span>(*in_iter++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">//从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure>

<h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p><strong>可以为任何具有输出运算符（&lt;&lt;）的类型定义 ostream iterator 对象</strong>。</p>
<p>创建 ostream_iterator 时，我们可以<strong>提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串</strong>。此字符串必须是一个 C 风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针)。<br>必须将 ostream_iterator 绑定到一个指定的流，不允许空的或表示尾后位置的 ostream_iterator。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018557.png" alt="Pasted image 20230212231331"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出值的序列</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">		*out_ite++ = e; <span class="comment">//赋值语句实际将元素写到cout</span></span><br><span class="line">cout&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用copy来打印vec中的元素，比循环更简单</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018558.png" alt="Pasted image 20230212233213"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alg</span> (beg, end, other args);</span><br><span class="line"><span class="built_in">alg</span> (beg, end, dest, other args);</span><br><span class="line"><span class="built_in">alg</span> (beg, end, beg2, other args);</span><br><span class="line"><span class="built_in">alg</span> (beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>

<p>beg、end、dest 都是迭代器参数。除了这些参数，一些算法还接受额外的、非迭代器的特定参数。</p>
<p><strong>接受单个目标迭代器的算法</strong><br>dest 参数是一个表示算法可以写入的目的位置的迭代器。<br>算法假定 (assume)：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<blockquote>
<p>[!NOTE]<br>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。</p>
</blockquote>
<p><strong>接受第二个输入序列的算法</strong><br>如果一个算法接受 beg2 和 end2, 这两个迭代器表示第二个范围。这类算法接受两个完整指定的范围：[ beg, end ) 表示的范围和 [ beg2end2 ) 表示的第二个范围。</p>
<p>只接受单独的 beg2 ( 不接受 end2 ) 的算法将 beg2 作为第二个输入范围中的首元素。此范围的结束位置未指定，这些算法假定从 beg2 开始的范围与 beg 和 end 所表示的范围至少一样大。</p>
<blockquote>
<p>[!NOTE]<br>接受单独 beg2 的算法假定从 beg2 开始的序列与 beg 和 end 所表示的范围至少一样大。</p>
</blockquote>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载形式传递一个谓词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg, end);  <span class="comment">//使用==运算符比较元素</span></span><br><span class="line"><span class="built_in">unique</span>(beg, end, comp)  <span class="comment">//使用comp比较元素</span></span><br></pre></td></tr></table></figure>

<p>_ if 版本的算法<br>接受一个元素值得算法通常都有一个接受谓词的版本 (不是重载)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);   </span><br><span class="line"><span class="built_in">find_if</span>(beg,end,lambada);</span><br></pre></td></tr></table></figure>

<h1 id="五、泛型算法"><a href="#五、泛型算法" class="headerlink" title="五、泛型算法"></a>五、泛型算法</h1><blockquote>
<p>[!Tip]<br>标准库容器定义的操作集合很小。标准库并未给每个容器添加大量功能，而是提<br>供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些<strong>算法是通用的<br>(generic, 或称泛型的)：它们可用于不同类型的容器和不同类型的元素。</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//包含除数值泛型算法以外的所有算法</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//数值泛型算法</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 关键概念：算法永远不会执行容器的操作</p>
</blockquote>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。这使得算法不依赖于具体的容器，提高了算法的通用性。</p>
<blockquote>
<p><strong>算法永远不会改变底层容器的大小。</strong> 算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
</blockquote>
<p>当一个算法操作<strong>插入迭代器</strong>时，插入迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。</p>
<ul>
<li><strong><code>beg</code> 和 <code>end</code> 是表示元素范围的迭代器。</strong> 几乎所有算法都对一个由 beg 和 end 表示的序列进行操作。</li>
<li><strong><code>beg2</code> 是表示第二个输入序列开始位置的迭代器。<code>end2</code> 表示第二个序列的末尾位置（如果有的话）。</strong><ul>
<li>如果没有 end2, 则假定 beg2 表示的序列与 beg 和 end 表示的序列一样大。</li>
<li>beg 和 beg2 的类型不必匹配，但是，必须保证对两个序列中的元素都可以执行特定操作或调用给定的可调用对象。</li>
</ul>
</li>
<li><strong><code>dest</code> 是表示目的序列的迭代器。</strong> 对于给定输入序列，算法需要生成多少元素，目的序列必须保证能保存同样多的元素。</li>
<li><strong><code>unaryPred</code> 和 <code>binaryPred</code> 是一元和二元谓词</strong>，分别接受一个和两个参数，都是来自输入序列的元素，两个谓词都返回可用作条件的类型。</li>
<li><strong><code>comp</code> 是一个二元谓词</strong>，满足关联容器中对关键字序的要求。</li>
<li><strong><code>unaryOp</code> 和 <code>binaryOp</code> 是可调用对象</strong>，可分别使用来自输入序列的一个和两个实参来调用。<br>![[1 C++ Primer#^snr6wf]]</li>
</ul>
<h2 id="1-查找算法"><a href="#1-查找算法" class="headerlink" title="1 查找算法"></a>1 查找算法</h2><p>这些算法在一个输入序列中搜索一个指定值或一个值的序列。</p>
<p>每个算法都提供两个重载的版本：</p>
<ul>
<li>第一个版本使用底层类型的相等运算符 <code>==</code> 来比较元素;</li>
<li>第二个版本使用用户给定的 <code>unaryPred</code> 和 <code>binaryPred</code> 比较元素。</li>
</ul>
<h3 id="查找指定值"><a href="#查找指定值" class="headerlink" title="查找指定值"></a>查找指定值</h3><p>这些算法查找指定值，要求输入迭代器 ( input iterator)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val)</span><br><span class="line"><span class="built_in">find_if</span>(beg, end, unaryPred) </span><br><span class="line"><span class="built_in">find_if_not</span>(beg, end, unaryPred) </span><br><span class="line"><span class="built_in">count</span>(beg, end, val)</span><br><span class="line"><span class="built_in">count_if</span>(beg, end, unaryPred)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>find</code></strong> 返回一个迭代器，指向输入序列中<strong>第一个</strong>等于 <code>val</code> 的元素。</p>
</li>
<li><p><strong><code>find_if</code></strong> 返回一个迭代器，指向<strong>第一个</strong>满足 <code>unaryPred</code> 的元素。</p>
</li>
<li><p><strong><code>find_if_not</code><strong>返回一个迭代器，指向</strong>第一个</strong>令 <code>unaryPred</code> 为 false 的元素。<br><strong>上述三个算法在未找到元素时都返回 end。</strong></p>
</li>
<li><p><strong><code>count</code></strong> 返回一个计数器，指出 val 出现了多少次; </p>
</li>
<li><p><strong><code>count_if</code></strong> 统计有多少个元素满足 <code>unaryPred</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all_of</span>(beg, end, unaryPred) </span><br><span class="line"><span class="built_in">any_of</span>(beg, end, unaryPred) </span><br><span class="line"><span class="built_in">none_of</span>(beg, end, unaryPred)</span><br></pre></td></tr></table></figure>
<p>这些算法都返回一个 bool 值，分别指出 <code>unaryPred</code> 是否对所有元素都成功、对任意一个元素成功以及对所有元素都不成功。<br>如果序列为空：<br><strong><code>any_of</code></strong> 返回 false<br><strong><code>all_of</code></strong> 和 <strong><code>none_of</code></strong> 返回 true。</p>
<h3 id="查找重复值"><a href="#查找重复值" class="headerlink" title="查找重复值"></a>查找重复值</h3><p>下面这些算法要求<strong>前向迭代器</strong> ( forward iterator )，在输入序列中查找重复元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">adjacent_find</span> (beg, end)</span><br><span class="line"><span class="built_in">adjacent_find</span> (beg, end, binaryPred)</span><br></pre></td></tr></table></figure>
<p><strong><code>adjacent_find</code><strong>：返回指向</strong>第一对</strong>相邻重复元素的迭代器。如果序列中无相邻重复元素，则返回 end。</p>
<blockquote>
<p>adjacent：邻近的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">search_n</span>(beg, end, count, val)</span><br><span class="line"><span class="built_in">search_n</span>(beg, end, count, val, binaryPred)</span><br></pre></td></tr></table></figure>
<p>**<code>search_n</code>**：返回一个迭代器，从此位置开始有 count 个相等元素。如果序列中不存在这样的子序列，则返回 end。</p>
<h3 id="查找子序列"><a href="#查找子序列" class="headerlink" title="查找子序列"></a>查找子序列</h3><p>在下面的算法中，除了 <code>find_first_of</code> 之外，都要求两个前向迭代器。<code>find_first_of</code> 用输入迭代器表示第一个序列，用前向迭代器表示第二个序列。这些算法搜索子序列而不是单个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">search</span> (beg1, end1 , beg2 , end2)</span><br><span class="line"><span class="built_in">search</span> (beg1, end1 , beg2, end2, binaryPred)</span><br></pre></td></tr></table></figure>
<p><strong><code>search</code><strong>：返回第二个输入范围（子序列)在第一个输入范围中</strong>第一次</strong>出现的位置。如果未找到子序列，则返回 end1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_first_of</span> (beg1, end1, beg2, end2)</span><br><span class="line"><span class="built_in">find_first_of</span> (beg1, end1, beg2, end2, binaryPred)</span><br></pre></td></tr></table></figure>
<p><strong><code>find_first_of</code><strong>：返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中</strong>首次</strong>出现的位置。如果未找到匹配元素，则返回 end1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_end</span>(beg1, end1, beg2 , end2)</span><br><span class="line"><span class="built_in">find_end</span>(beg1, end1 , beg2 , end2, binaryPred)</span><br></pre></td></tr></table></figure>
<p><strong><code>find_end</code><strong>：类似 search，但返回的是</strong>最后一次</strong>出现的位置。如果第二个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1。</p>
<h2 id="2-其他只读算法"><a href="#2-其他只读算法" class="headerlink" title="2 其他只读算法"></a>2 其他只读算法</h2><p>这些算法要求前两个实参都是输入迭代器。<br><code>equal</code> 和 <code>mismatch</code> 算法还接受一个额外的输入迭代器，表示第二个范围的开始位置。<br>这两个算法都提供两个重载的版本：</p>
<ul>
<li>第一个版本使用底层类型的相等运算符 <code>==</code> 比较元素</li>
<li>第二个版本则用用户指定的 <code>unaryPred</code> 或 <code>binaryPred</code> 比较元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(beg, end, unaryop)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>for_each</code><strong>：</strong>对输入序列中的每个元素应用可调用对象 <code>unaryOp</code></strong>, <ul>
<li><code>unaryOp</code> 的返回值被忽略。</li>
<li>如果迭代器允许通过解引用运算符向序列中的元素写入值，则 <code>unaryOp</code> 可能修改元素。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mismatch</span> (beg1, end1, beg2)</span><br><span class="line"><span class="built_in">mismatch</span> (beg1, end1, beg2, binaryPred)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>mismatch</code><strong>：比较两个序列中的元素。返回一个迭代器的 <code>pair</code>，表示两个序列中</strong>第一个不匹配的元素</strong>。</li>
<li>如果所有元素都匹配，则返回的 pair 中第一个迭代器为 end1，第二个迭代器指向 beg2 中偏移量等于第一个序列长度的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span> (beg1, end1, beg2)</span><br><span class="line"><span class="built_in">equal</span> (beg1, end1 , beg2, binaryPred)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>equal</code>**：确定两个序列是否相等。如果输入序列中每个元素都与从 beg2 开始的序列中对应元素相等，则返回 true。</li>
</ul>
<p><strong>equal 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</strong></p>
<blockquote>
<p>[!NOTE]  关键概念：迭代器参数<br><strong>一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器，两个序列中元素的类型也不要求严格匹配。</strong> 算法要求的只是能够比较两个序列中的元素。例如，对 equal 算法，元素类型不要求相同，但是我们必须能使用 <code>==</code> 来比较来自两个序列中的元素。</p>
</blockquote>
<p><strong>用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。</strong></p>
<h2 id="3-二分搜索算法"><a href="#3-二分搜索算法" class="headerlink" title="3 二分搜索算法"></a>3 二分搜索算法</h2><p>这些算法都要求前向迭代器，但这些算法都经过了优化，如果我们提供<strong>随机访问迭代器 (random-access iterator)</strong> 的话，它们的性能会好得多。<br>从技术上讲，无论我们提供什么类型的迭代器，这些算法都会执行对数次的比较操作。但是，当使用前向迭代器时，这些算法必须花费线性次数的迭代器操作来移动到序列中要比较的元素。<br><strong>这些算法要求序列中的元素已经是有序的。</strong> 它们的行为类似关联容器的同名成员（参见 11.3.5 节，第 389 页)。<code>equal_range</code>、<code>lower_bound</code> 和 <code>upper_bound</code> 算法返回迭代器，指向给定元素在序列中的正确插入位置——插入后还能保持有序。如果给定元素比序列中的所有元素都大，则会返回尾后迭代器。</p>
<p>每个算法都提供两个版本: </p>
<ul>
<li>第一个版本用元素类型的小于运算符（<code>&lt;</code>）来检测元素; </li>
<li>第二个版本则使用给定的比较操作。在下列算法中，“x 小于 y”表示 <code>x&lt;y</code> 或 <code>comp (x,y)</code> 成功。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span> (beg, end, val)</span><br><span class="line"><span class="built_in">lower_bound</span> (beg, end, val, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>lower_bound</code><strong>：返回一个迭代器，表示</strong>第一个小于等于 val 的元素</strong>, 如果不存在这样的元素，则返回 end。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span> (beg, end, val)</span><br><span class="line"><span class="built_in">upper_bound</span> (beg, end, val, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>upper_bound</code><strong>：返回一个迭代器，表示</strong>第一个大于 val 的元素</strong>，如果不存在这样的元素，则返回 end。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal_range</span> (beg, end, val)</span><br><span class="line"><span class="built_in">equal_range</span> (beg, end, val, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>equal_range</code>**：返回一个 pair ，其 first 成员是 lower_bound 返回的迭代器，second 成员是 upper_bound 返回的迭代器。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">binary_search</span> (beg, end, val)</span><br><span class="line"><span class="built_in">binary_search</span> (beg, end, val, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>binary_search</code><strong>：返回一个 bool 值，指出序列中</strong>是否包含等于 val 的元素</strong>。</li>
</ul>
<h2 id="4-写容器元素的算法"><a href="#4-写容器元素的算法" class="headerlink" title="4 写容器元素的算法"></a>4 写容器元素的算法</h2><p>很多算法向给定序列中的元素写入新值。这些算法可以从不同角度加以区分: </p>
<ul>
<li>通过表示输入序列的迭代器类型来区分; </li>
<li>通过是写入输入序列中元素还是写入给定目的位置来区分。</li>
</ul>
<h3 id="只写不读元素"><a href="#只写不读元素" class="headerlink" title="只写不读元素"></a>只写不读元素</h3><p>这些算法要求一个**输出迭代器 (output iterator)**，表示目的位置。<code>_n</code> 结尾的版本接受第二个实参，表示写入的元素数目，并将给定数目的元素写入到目的位置中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span> (beg, end, val)</span><br><span class="line"><span class="built_in">fill_n</span> (dest, cnt, va1) </span><br><span class="line"><span class="built_in">generate</span> (beg, end, Gen) </span><br><span class="line"><span class="built_in">generate_n</span> (dest, cnt, Gen)</span><br></pre></td></tr></table></figure>

<p><strong>给输入序列中每个元素赋予一个新值。</strong></p>
<ul>
<li><strong><code>fill</code></strong> ：将值 val 赋予元素; </li>
<li>**<code>generate</code>**： 执行生成器对象 <code>Gen ()</code> 生成新值。生成器是一个可调用对象，每次调用会生成一个不同的返回值。</li>
</ul>
<p><code>fill</code> 和 <code>generate</code> 都返回 void。<br><code>_n</code> 版本返回一个迭代器，指向写入到输出序列的最后一个元素之后的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fi1l</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);<span class="comment">//将每个元素重置为0</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">// 将所有元素重置为0</span></span><br></pre></td></tr></table></figure>
<h3 id="使用输入迭代器"><a href="#使用输入迭代器" class="headerlink" title="使用输入迭代器"></a>使用输入迭代器</h3><p>这些算法读取一个输入序列，将值写入到一个输出序列中。它们要求一个名为 <code>dest</code> 的输出迭代器，而表示输入范围的迭代器必须是输入迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> (beg, end, dest)</span><br><span class="line"><span class="built_in">copy_if</span> (beg, end, dest, unaryPred) <span class="built_in">copy_n</span> (beg, n, dest)</span><br></pre></td></tr></table></figure>
<p><strong>从输入范围将元素拷贝到 <code>dest</code> 指定的目的序列。</strong></p>
<ul>
<li>**<code>copy</code>**： 拷贝所有元素，</li>
<li>**<code>copy_if</code>**： 拷贝满足 <code>unaryPred</code> 的元素</li>
<li><strong><code>copy_n</code></strong> ：拷贝前 n 个元素。输入序列必须有至少 n 个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span> (beg, end, dest)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>move</code>**： 对输入序列中的每个元素调用 <code>std: : move</code>，将其移动到迭代器 dest 开始的序列中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span> (beg, end, dest, unaryop)</span><br><span class="line"><span class="built_in">transform</span> (beg, end, beg2, dest, binaryop)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>transform</code><strong>：</strong>调用给定操作，并将结果写到 dest 中</strong>。<ul>
<li>第一个版本对输入范围中每个元素应用一元操作。</li>
<li>第二个版本对两个输入序列中的元素应用二元操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">replace_copy</span> (beg, end, dest, old_val, new_val)</span><br><span class="line"><span class="built_in">replace_copy_if</span> (beg, end, dest, unaryPred, new_val)</span><br></pre></td></tr></table></figure>
<p><strong>将每个元素拷贝到 dest，将指定的元素替换为 new_val。</strong></p>
<ul>
<li>**<code>replace_copy</code>**：替换那些 <code>==old_val</code> 的元素。</li>
<li>**<code>replace_copy_if</code>**：替换那些满足 <code>unaryPred</code> 的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span> (beg1, end1, beg2, end2, dest)</span><br><span class="line"><span class="built_in">merge</span> (beg1, end1, beg2, end2, dest, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>merge</code><strong>：两个输入序列必须都是</strong>有序</strong>的。<strong>将合并后的序列写入到 dest 中</strong>。<ul>
<li>第一个版本用 <code>&lt;</code> 运算符比较元素;</li>
<li>第二个版本则使用给定比较操作。</li>
</ul>
</li>
</ul>
<h3 id="使用前向迭代器"><a href="#使用前向迭代器" class="headerlink" title="使用前向迭代器"></a>使用前向迭代器</h3><p><strong>这些算法要求前向迭代器，由于它们是向输入序列写入元素，迭代器必须具有写入元素的权限。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter_swap</span> (iter1, iter2)</span><br><span class="line"><span class="built_in">swap_ranges</span> (beg1, end1 ,beg2)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>iter_swap</code></strong> 交换 <code>iter1</code> 和 <code>iter2</code> 所表示的元素，返回 void</li>
<li><strong><code>swap_ranges</code></strong> 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。两个范围不能有重叠。<ul>
<li>返回递增后的 beg2，指向最后一个交换元素之后的位置。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">replace</span> (beg, end, old_val, new_val)</span><br><span class="line"><span class="built_in">replace_if</span> (beg, end, unaryPred, new_val)</span><br></pre></td></tr></table></figure>
<p>用 <code>new_val</code> 替换每个匹配元素。</p>
<ul>
<li>**<code>replace</code>**：使用 <code>==</code> 比较元素与 <code>old_val</code></li>
<li>**<code>replace_if</code>**：替换那些满足 <code>unaryPred</code> 的元素。</li>
</ul>
<h3 id="使用双向迭代器的写算法"><a href="#使用双向迭代器的写算法" class="headerlink" title="使用双向迭代器的写算法"></a>使用双向迭代器的写算法</h3><p>这些算法需要在序列中有反向移动的能力，因此它们要求双向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy_backward</span> (beg, end, dest)</span><br><span class="line"><span class="built_in">move_backward</span> (beg, end, dest)</span><br></pre></td></tr></table></figure>
<p><strong>从后往前，从输入范围中拷贝或移动元素到指定目的位置。</strong><br>与其他算法不同，**<code>dest</code> 是输出序列的尾后迭代器**（即，目的序列恰在 dest 之前结束)。<br>输入范围中的尾元素被拷贝或移动到目的序列的尾元素，然后是倒数第二个元素被拷贝&#x2F;移动，依此类推。元素在目的序列中的顺序与在输入序列中相同。<br>如果范围为空，则返回值为 dest; 否则，返回值表示从<code>*beg</code> 中拷贝或移动的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">inplace_merge</span> (beg, mid, end)</span><br><span class="line"><span class="built_in">inplace_merge</span> (beg, mid, end, comp)</span><br></pre></td></tr></table></figure>
<p><strong>将同一个序列中的两个有序子序列合并为单一的有序序列。</strong> beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。</p>
<ul>
<li>第一个版本使用 <code>&lt;</code> 比较元素</li>
<li>第二个版本使用给定的比较操作，返回 void。</li>
</ul>
<h2 id="5-划分和排序算法"><a href="#5-划分和排序算法" class="headerlink" title="5 划分和排序算法"></a>5 划分和排序算法</h2><p>每个排序和划分算法都提供<strong>稳定（<code>stable_</code> 标记）和不稳定版本</strong>（参见 10.3.1 节，第 345 页)。<br><strong>稳定算法保证保持相等元素的相对顺序</strong>。由于稳定算法会做更多工作，可能比不稳定版本慢得多并消耗更多内存。</p>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><p><strong>一个划分算法将输入范围中的元素划分为两组:</strong></p>
<ul>
<li>第一组包含那些<strong>满足给定谓词</strong>的元素</li>
<li>第二组则包含<strong>不满足谓词</strong>的元素。</li>
</ul>
<p>例如，对于一个序列中的元素，我们可以根据元素是否是奇数或者单词是否以大写字母开头等来划分它们。<strong>这些算法都要求双向迭代器。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is_partitioned</span> (beg, end, unaryPred)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>is_partitioned</code>**：如果所有满足谓词 <code>unaryPred</code> 的元素都在不满足 <code>unaryPred</code> 的元素之前，则返回 true。若序列为空，也返回 true。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partition_copy</span> (beg, end, dest1, dest2, unaryPred)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>partition_copy</code>**：将满足 <code>unaryPred</code> 的元素拷贝到 dest1, 并将不满足 <code>unaryPred</code> 的元素拷贝到 dest2。<ul>
<li>返回一个迭代器 <code>pair</code> ，其 first 成员表示拷贝到 dest1 的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</li>
<li>输入序列与两个目的序列都不能重叠。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partition_point</span> (beg, end,unaryPred)</span><br></pre></td></tr></table></figure>
<p><code>partition_point</code>：输入序列必须是已经用 <code>unaryPred</code> 划分过的。返回满足 <code>unaryPred</code> 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stable_partition</span> (beg, end, unaryPred) <span class="built_in">partition</span> (beg, end, unaryPred)</span><br></pre></td></tr></table></figure>
<p>**<code>stable_partition</code>**：使用 <code>unaryPred</code> 划分输入序列。满足 <code>unaryPred</code> 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置，如果所有元素都不满足 unaryPred，则返回 beg。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>这些算法要求<strong>随机访问迭代器</strong>。</p>
<p>每个排序算法都提供两个重载的版本。</p>
<ul>
<li>一个版本用元素的 <code>&lt;</code> 运算符来比较元素，</li>
<li>另一个版本接受一个额外参数来指定排序关系。</li>
</ul>
<p><code>partial_sort_copy</code> 返回一个指向目的位置的迭代器，其他排序算法都返回 void。<br><code>partial_sort</code> 和 <code>nth_element</code> 算法都只进行部分排序工作，它们常用于不需要排序整个序列的场合。由于这些算法工作量更少, 它们通常比排序整个输入序列的算法更快。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> (beg, end)</span><br><span class="line"><span class="built_in">stable_sort</span> (beg, end) </span><br><span class="line"><span class="built_in">sort</span> (beg, end, comp)</span><br><span class="line"><span class="built_in">stable_sort</span> (beg, end, comp)</span><br></pre></td></tr></table></figure>
<p><strong><code>sort</code><strong>：</strong>排序整个范围</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is_sorted</span> (beg, end)</span><br><span class="line"><span class="built_in">is_sorted</span> (beg, end, comp) </span><br><span class="line"><span class="built_in">is_sorted_until</span> (beg, end)</span><br><span class="line"><span class="built_in">is_sorted_until</span> (beg, end, comp)</span><br></pre></td></tr></table></figure>
<p><strong><code>is_sorted</code><strong>：返回一个 bool 值，指出整个输入序列是否有序。<br><strong><code>is_sorted_until</code></strong> ：在输入序列中</strong>查找最长初始有序子序列</strong>，并返回子序列的尾后迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span> (beg, mid, end)</span><br><span class="line"><span class="built_in">partial_sort</span> (beg, mid, end, comp)</span><br></pre></td></tr></table></figure>
<p><strong><code>partial_sort</code><strong>：排序 <code>mid-beg</code> 个</strong>最小元素</strong>。即，如果 mid-beg 等于 42，则此函数<strong>将值最小</strong>的 42 个元素有序放在序列前 42 个位置。当 partial_sort 完成后，从 beg 开始直至 mid 之前的范围中的元素就都已排好序了。<strong>已排序范围中的元素都不会比 mid 后的元素更大。未排序区域中元素的顺序是未指定的。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort_copy</span> (beg, end, destBeg, destEnd)</span><br><span class="line"><span class="built_in">partial_sort_copy</span> (beg, end, destBeg, destEnd, comp)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>partial_sort_copy</code>**：排序输入范围中的元素，并将足够多的已排序元素放到 <code>destBeg</code> 和 <code>destEnd</code> 所指示的序列中。<ul>
<li>如果目的范围的大小<code>&gt;=</code>输入范围，则排序整个输入序列并存入从 <code>destBeg</code> 开始的范围。</li>
<li>如果目的范围大小<code>&lt;</code>输入范围，则只拷贝输入序列中与目的范围一样多的元素。</li>
<li>算法返回一个迭代器，指向目的范围中已排序部分的尾后迭代器。如果目的序列的大小小于或等于输入范围，则返回 <code>destEnd</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span> (beg, nth, end)</span><br><span class="line"><span class="built_in">nth_element</span> (beg, nth, end, comp)</span><br></pre></td></tr></table></figure>
<p><strong><code>nth_element</code><strong>：参数 nth 必须是一个迭代器，指向输入序列中的一个元素。执行 <code>nth_element</code> 后，此</strong>迭代器指向的元素恰好是整个序列排好序后此位置上的值。序列中的元素会围绕 nth 进行划分: nth 之前的元素都小于等于它，而之后的元素都大于等于它。</strong></p>
<h2 id="6-重排顺序算法"><a href="#6-重排顺序算法" class="headerlink" title="6 重排顺序算法"></a>6 重排顺序算法</h2><p><strong>重排输入序列中元素的顺序</strong>。</p>
<p>前两个算法 <code>remove</code> 和 <code>unique</code>，会重排序列, 使得排在序列第一部分的元素满足某种标准。它们返回一个迭代器，标记子序列的末尾。<br>其他算法，如 <code>reverse</code>、<code>rotate</code> 和 <code>random_shuffle</code> 都重排整个序列。</p>
<p><strong>这些算法的基本版本都进行“原址”操作，即，在输入序列自身内部重排元素</strong>。三个重排算法提供 <code>_copy</code> 版本。这些 <strong><code>_copy</code> 版本完成相同的重排工作，但将重排后的元素写入到一个指定目的序列中</strong>，而不是改变输入序列。这些算法要求输出迭代器来表示目的序列。</p>
<h3 id="使用前向迭代器的重排算法"><a href="#使用前向迭代器的重排算法" class="headerlink" title="使用前向迭代器的重排算法"></a>使用前向迭代器的重排算法</h3><p>这些算法重排输入序列。它们要求迭代器至少是前向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span> (beg, end, val)</span><br><span class="line"><span class="built_in">remove_if</span> (beg, end, unaryPred) </span><br><span class="line"><span class="built_in">remove_copy</span> (beg, end, dest, va1)</span><br><span class="line"><span class="built_in">remove_copy_if</span> (beg, end, dest, unaryPred)</span><br></pre></td></tr></table></figure>
<p>**<code>remove</code>**： <strong>从序列中“删除”元素，采用的办法是用保留的元素覆盖要删除的元素。</strong> 被删除的是那些 <code>==val</code> 或满足 <code>unaryPred</code> 的元素。算法返回一个迭代器，指向最后一个删除元素的尾后位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span> (beg, end)</span><br><span class="line"><span class="built_in">unique</span> (beg, end, binaryPred) </span><br><span class="line"><span class="built_in">unique_copy</span> (beg, end, dest)</span><br><span class="line"><span class="built_in">unique_copy_if</span> (beg, end, dest, binaryPred)</span><br></pre></td></tr></table></figure>
<p><strong><code>unique</code><strong>：</strong>重排序列，对相邻的重复元素，通过覆盖它们来进行“删除”</strong>。返回一个迭代器，指向不重复元素的尾后位置。第一个版本用 <code>==</code> 确定两个元素是否相同，第二个版本使用谓词检测相邻元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rotate</span> (beg, mid, end)</span><br><span class="line"><span class="built_in">rotate_copy</span> (beg, mid, end, dest)</span><br></pre></td></tr></table></figure>
<p><strong><code>rotate</code><strong>：</strong>围绕 mid 指向的元素进行元素转动。</strong> 元素 mid 成为首元素，随后是 mid+1 到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素。</p>
<h3 id="使用双向迭代器的重排算法"><a href="#使用双向迭代器的重排算法" class="headerlink" title="使用双向迭代器的重排算法"></a>使用双向迭代器的重排算法</h3><p>由于这些算法要反向处理输入序列，它们要求双向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span> (beg, end)</span><br><span class="line"><span class="built_in">reverse_copy</span> (beg, end, dest)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>reverse</code><strong>：</strong>翻转序列中的元素。</strong><ul>
<li><code>reverse</code> 返回 void</li>
<li><code>reverse_copy</code> 返回一个迭代器，指向拷贝到目的序列的元素的尾后位置。</li>
</ul>
</li>
</ul>
<h3 id="使用随机访问迭代器的重排算法"><a href="#使用随机访问迭代器的重排算法" class="headerlink" title="使用随机访问迭代器的重排算法"></a>使用随机访问迭代器的重排算法</h3><p>由于这些算法要随机重排元素，它们要求随机访问迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random_shuff1e</span> (beg, end)</span><br><span class="line"><span class="built_in">random_shuffle</span> (beg, end, rand) </span><br><span class="line"><span class="built_in">shuffle</span> (beg, end, Uniform_rand)</span><br></pre></td></tr></table></figure>

<p><strong>洗牌算法，混洗输入序列中的元素。</strong><br>第二个版本接受一个可调用对象参数，该对象必须接受一个正整数值，并生成 0到此值的包含区间内的一个服从均匀分布的随机整数。shuffle 的第三个参数必须满足均匀分布随机数生成器的要求 (参见 17.4 节，第 659 页)。所有版本都返回 void。</p>
<h2 id="7-排列算法"><a href="#7-排列算法" class="headerlink" title="7 排列算法"></a>7 排列算法</h2><p>排列算法生成序列的<strong>字典序排列</strong>。对于一个给定序列，这些算法通过重排它的一个排列来生成字典序中下一个或前一个排列。<strong>算法返回一个 bool 值，指出是否还有下一个或前一个排列。</strong><br>为了理解什么是下一个或前一个排列，考虑下面这个三字符的序列: abc。它有六种可能的排列: abc、acb、bac、bca、cab 及 cba。这些排列是按字典序递增序列出的。即，abc 是第一个排列，这是因为它的第一个元素小于或等于任何其他排列的首元素，并且它的第二个元素小于任何其他首元素相同的排列。类似的，acb 排在下一位，原因是它以 a 开头，小于任何剩余排列的首元素。同理，以 b 开头的排列也都排在以 c 开头的排列之前。<br><strong>对于任意给定的排列，基于单个元素的一个特定的序，我们可以获得它的前一个和下一个排列。给定排列 bca，我们知道其前一个排列为 bac，下一个排列为 cab。序列 abc 没有前一个排列，而 cba 没有下一个排列。</strong><br><strong>这些算法假定序列中的元素都是唯一的</strong>，即，没有两个元素的值是一样的。为了生成排列，必须既向前又向后处理序列，因此算法<strong>要求双向迭代器。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is_permutation</span> (beg1, end1 , beg2)</span><br><span class="line"><span class="built_in">is_permutation</span> (beg1, end1, beg2, binaryPred)</span><br></pre></td></tr></table></figure>
<p>**<code>is_permutation</code>**：如果第二个序列的某个排列和第一个序列具有相同数目的元素，且元素都相等，则返回 true。第一个版本用 <code>==</code> 比较元素，第二个版本使用给定的 binaryPred。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span> (beg, end)</span><br><span class="line"><span class="built_in">next_permutation</span> (beg, end, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>next_permutation</code>**： 如果序列已经是最后一个排列，则将序列重排为最小的排列，并返回 false。否则，它将输入序列转换为字典序中下一个排列，并返回 true。第一个版本使用元素的 <code>&lt;</code> 运算符比较元素，第二个版本使用给定的比较操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">prev_permutation</span> (beg, end)</span><br><span class="line"><span class="built_in">prev_permutation</span> (beg, end, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>prev_permutation</code>**：类似 <code>next_premutation</code>，但将序列转换为前一个排列。如果序列已经是最小的排列，则将其重排为最大的排列，并返回 false。</p>
<h2 id="8-有序序列的集合算法"><a href="#8-有序序列的集合算法" class="headerlink" title="8 有序序列的集合算法"></a>8 有序序列的集合算法</h2><p>集合算法实现了有序序列上的一般集合操作。<br><strong>这些算法提供了普通顺序容器 (vector、list 等）或其他序列（如输入流）上的类集合行为。</strong></p>
<blockquote>
<p>[!warning]<br>这些算法与标准库 set 容器不同，不要与 set 上的操作相混淆。</p>
</blockquote>
<p>这些算法顺序处理元素，因此<strong>要求输入迭代器</strong>。他们还接受一个表示目的序列的输出迭代器，唯一的例外是 <code>includes</code>。这些算法返回递增后的 dest 迭代器，表示写入 dest 的最后一个元素之后的位置。<br>每种算法都有重载版本</p>
<ul>
<li>第一个使用元素类型的 <code>&lt;</code> 运算符</li>
<li>第二个使用给定的比较操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span> (beg, end, beg2, end2)</span><br><span class="line"><span class="built_in">includes</span> (beg,end,beg2, end2, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>includes</code>**：如果第二个序列中每个元素都包含在输入序列中，则返回 true。否则返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_union</span> (beg, end, beg2, end2, dest)</span><br><span class="line"><span class="built_in">set_union</span> (beg, end, beg2, end2, dest, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>set_union并集</code>**：对两个序列中的所有元素，创建它们的有序序列。两个序列都包含的元素在输出序列中只出现一次。输出序列保存在 dest 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_intersection</span> (beg, end, beg2, end2, dest)</span><br><span class="line"><span class="built_in">set_intersection</span> (beg, end, beg2, end2, dest, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>set_intersection交集</code>**：对两个序列都包含的元素创建一个有序序列。结果序列保存在 dest 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_difference</span> (beg, end, beg2, end2, dest)</span><br><span class="line"><span class="built_in">set_difference</span> (beg, end, beg2, end2, dest, comp)</span><br></pre></td></tr></table></figure>
<p><strong><code>set_difference差集</code></strong>:对出现在第一个序列中，但不在第二个序列中的元素，创建一个有序序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_symmetric_difference</span> (beg, end，beg2, end2, dest)</span><br><span class="line"><span class="built_in">set_symmetric_difference</span> (beg, end，beg2, end2，dest, comp)</span><br></pre></td></tr></table></figure>
<p>**<code>set_symmetric_difference</code>**：对只出现在一个序列中的元素，创建一个有序序列。</p>
<h2 id="9-最大值最小值"><a href="#9-最大值最小值" class="headerlink" title="9 最大值最小值"></a>9 最大值最小值</h2><p>这些算法使用元素类型的<code>&lt;</code>运算符或给定的比较操作。第一组算法对值而非序列进行操作。第二组算法接受一个序列，它们要求输入迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span> (val1, val2)</span><br><span class="line"><span class="built_in">min</span> (val1, val2, comp) </span><br><span class="line"><span class="built_in">min</span> (init_list)</span><br><span class="line"><span class="built_in">min</span> (init_list, comp) </span><br><span class="line"><span class="built_in">max</span> (val1, val2)</span><br><span class="line"><span class="built_in">max</span> (val1, val2, comp) </span><br><span class="line"><span class="built_in">max</span> (init_list)</span><br><span class="line"><span class="built_in">max</span> (init_list, comp)</span><br></pre></td></tr></table></figure>
<p>返回 val1 和 val2 中的最小值&#x2F;最大值，或 <code>initializer_list</code> 中的最小值&#x2F;最大值。</p>
<ul>
<li>两个实参的类型必须完全一致。</li>
<li>参数和返回类型都是 const 的引用，意味着对象不会被拷贝。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minmax</span> (val1, val2)</span><br><span class="line"><span class="built_in">minmax</span> (va11, va12, comp) <span class="built_in">minmax</span> (init_list)</span><br><span class="line"><span class="built_in">minmax</span> (init_list, comp)</span><br></pre></td></tr></table></figure>
<p>返回一个 <code>pair </code>, 其 first 成员为提供的值中的较小者, second 成员为较大者。<code>initializer_list</code> 版本返回一个 pair，其 first 成员为 list 中的最小值，second 为最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min_element</span> (beg, end)</span><br><span class="line"><span class="built_in">min_element</span> (beg, end, comp) </span><br><span class="line"><span class="built_in">max_element</span> (beg, end)</span><br><span class="line"><span class="built_in">max_element</span> (beg, end, comp) </span><br><span class="line"><span class="built_in">minmax_element</span> (beg, end)</span><br><span class="line"><span class="built_in">minmax_element</span> (beg, end, comp)</span><br></pre></td></tr></table></figure>
<p><code>min_element</code> 和 <code>max_element</code> 分别返回指向输入序列中最小和最大元素的迭代器。<br><code>minmax_element</code> 返回一个 pair，其 first 成员为最小元素，second 成员为最大元素。</p>
<p><strong>字典序比较</strong><br><strong>此算法比较两个序列，根据第一对不相等的元素的相对大小来返回结果。</strong> 算法使用元素类型的 <code>&lt;</code> 运算符或给定的比较操作。两个序列都要求用输入迭代器给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lexicographical_compare</span> (beg1, end1, beg2, end2)</span><br><span class="line"><span class="built_in">lexicographical_compare</span> (beg1, end1，beg2, end2, comp)</span><br></pre></td></tr></table></figure>
<p><strong>如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 false。</strong> 如果一个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</p>
<h2 id="10-数值算法"><a href="#10-数值算法" class="headerlink" title="10 数值算法"></a>10 数值算法</h2><p>数值算法定义在头文件 <code>numeric</code> 中。这些算法要求输入迭代器; 如果算法输出数据，则使用输出迭代器表示目的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span> (beg, end, init)</span><br><span class="line"><span class="built_in">accumulate</span> (beg, end, init, binaryop)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>accumulate</code><strong>：返回输入序列中</strong>所有值的和</strong>。和的初值从 init 指定的值开始。返回类型与 init 的类型相同。<ul>
<li>第一个版本使用元素类型的<code>+</code>运算符</li>
<li>第二个版本使用指定的二元操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">inner_product</span> (beg1, end1, beg2, init)</span><br><span class="line"><span class="built_in">inner_product</span> (beg1, end1, beg2, init, binop1, binop2)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>inner_product</code><strong>：返回两个序列的</strong>内积</strong>，即，对应元素的积的和。两个序列一起处理，来自两个序列的元素相乘，乘积被累加起来。和的初值由 <code>init</code> 指定，<code>init</code> 的类型确定了返回类型。<ul>
<li>第一个版本使用元素类型的乘法 (<code>*</code>）和加法 (<code>+</code>）运算符。</li>
<li>第二个版本使用给定的二元操作，使用第一个操作代替加法，第二个操作代替乘法。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sum</span> (beg, end, dest)</span><br><span class="line"><span class="built_in">partial_sum</span> (beg, end, dest, binaryop)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>partial_sum</code><strong>：</strong>将新序列写入 dest，每个新元素的值都等于输入范围中当前位置和之前位置上所有元素之和</strong>。<ul>
<li>第一个版本使用元素类型的+运算符;</li>
<li>第二个版本使用指定的二元操作。算法返回递增后的 dest 迭代器，指向最后一个写入元素之后的位置。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">adjacent_difference</span> (beg, end, dest)</span><br><span class="line"><span class="built_in">adjacent_difference</span> (beg, end, dest, binaryop)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>adjacent_difference</code> 邻差</strong>：将新序列写入 dest，<strong>每个新元素（除了首元素之外）的值都等于输入范围中当前位置和前一个位置元素之差。</strong><ul>
<li>第一个版本使用元素类型的-运算符，</li>
<li>第二个版本使用指定的二元操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iota</span> (beg, end, val)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>iota</code>**：将 val 赋予首元素并递增 val。将递增后的值赋予下一个元素，继续递增 val，然后将递增后的值赋予序列中的下一个元素。继续递增 val 并将其新值赋予输入序列中的后续元素。</li>
</ul>
<h1 id="六、标准库特殊设施"><a href="#六、标准库特殊设施" class="headerlink" title="六、标准库特殊设施"></a>六、标准库特殊设施</h1><h2 id="【C-11】tuple-元组"><a href="#【C-11】tuple-元组" class="headerlink" title="【C++11】tuple 元组"></a>【C++11】tuple 元组</h2><p>#tuple</p>
<blockquote>
<p>[!NOTE]<br>“快速而随意”的数据结构，当我们希望将一些不同类型的数据组合成单一对象，又不想麻烦的定义一个数据结构来表示这些数据时，tuple 非常有用。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018559.png" alt="Pasted image 20230226231649"></p>
<ul>
<li>tuple 是类似 pair 的类型，可以简单地<strong>保存类型不同的任意数量的对象</strong>。</li>
<li>tuple 也可以进行比较运算，但是必须元素数量相同时才能比较</li>
<li>tuple 的<strong>常见用途是从一个函数返回多个值</strong>，类似于在外部定义一个 struct，但是更加方便且低耦合</li>
</ul>
<h3 id="定义和初始化-tuple"><a href="#定义和初始化-tuple" class="headerlink" title="定义和初始化 tuple"></a>定义和初始化 tuple</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们定义一个tuple时，需要指出每个成员的类型：</span></span><br><span class="line">tuple&lt;<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">size_t</span>&gt; threeD; <span class="comment">//默认初始化，三个成员都设置为0</span></span><br><span class="line"></span><br><span class="line">tuple&lt;string, vector&lt;<span class="type">double</span>&gt;, <span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; </span><br><span class="line"><span class="built_in">someVal</span>(<span class="string">&quot;constants&quot;</span>,&#123;<span class="number">3.14</span>,<span class="number">2.718</span>&#125;,<span class="number">42</span>,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) <span class="comment">//提供初始值</span></span><br></pre></td></tr></table></figure>

<p><strong>tuple 的构造函数是 explicit 的</strong>，因此必须使用直接初始化语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">size_t</span>&gt; threeD = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//错误</span></span><br><span class="line">tuple&lt;<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似 make_pair 函数，标准库定义了 make_tuple 函数，我们还可以用它来生成 tuple 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示书店交易记录的tuple,包含：ISBN、数量和每册书的价格</span></span><br><span class="line"><span class="keyword">auto</span> item = <span class="built_in">make_tup1e</span>(<span class="string">&quot;0-999-78345-X&quot;</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<p>make_tuple 函数使用初始值的类型来推断 tuple 的类型。在本例中，item 是一个 tuple, 类型为 <code>tuple&lt;const char*,int,double&gt;</code>。</p>
<h3 id="访问-tuple-的成员"><a href="#访问-tuple-的成员" class="headerlink" title="访问 tuple 的成员"></a>访问 tuple 的成员</h3><p>tuple 的成员都是未命名的（没有 first、second），访问时需要使用 <code>get</code> 标准库函数模板。</p>
<ul>
<li>使用 get 时, 我们必须<strong>指定一个显式模板实参</strong>，它指出我们想要访问第几个成员。<code>&lt;  &gt;</code> 内的值必须是整形常量表达式，从 0 开始计数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递给get一个tuple对象，它返回指定成员的引用：</span></span><br><span class="line"><span class="keyword">auto</span> book = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item);  <span class="comment">//返回item的第一个成员</span></span><br><span class="line"><span class="keyword">auto</span> cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item);  <span class="comment">//返回item的第二个成员</span></span><br><span class="line"><span class="keyword">auto</span> price = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item)/cnt;  <span class="comment">//返回item的最后一个成员</span></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item) *= <span class="number">0.8</span>;  <span class="comment">//打折20号</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果不知道一个 tuple 准确的类型细节信息，可以用两个辅助类模板来查询 tuple 成员的数量和类型：</p>
<ul>
<li><code>&lt; &gt;</code> 括号内是 tuple 对象的类型，可以使用 decltype 获取。</li>
<li><code>tuple_size&lt; &gt;</code> ：有一个 <code>value</code> 数据成员，表示给定 tuple 的成员数量</li>
<li><code>tuple_element&lt; &gt;</code>：额外接受一个索引值&gt;有一个 <code>type</code> 成员，表示给定 tuple 类型中指定成员的类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 trans 类型对象中成员的数量</span></span><br><span class="line"><span class="type">size_t</span> sz = tuple_size&lt;<span class="keyword">decltype</span>(item)&gt;::value;  <span class="comment">// 返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnt的类型与item中第二个成员相同</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>,<span class="keyword">decltype</span>(item)&gt;::type cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item); <span class="comment">//cnt是一个int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-tuple-返回多个值"><a href="#使用-tuple-返回多个值" class="headerlink" title="使用 tuple 返回多个值"></a>使用 tuple 返回多个值</h3><p>tuple 的<strong>常见用途是从一个函数返回多个值</strong>，例子 P638</p>
<h2 id="bitset-类型"><a href="#bitset-类型" class="headerlink" title="bitset 类型"></a>bitset 类型</h2><p>#bitset</p>
<ul>
<li>bitset 类型可以很好地处理位运算问题，比直接使用位操作符清晰方便很多</li>
<li>bitset 类似 array，定义的时候模板参数是这个 bitset 的位数<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018560.png" alt="Pasted image 20230226231850"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018561.png" alt="Pasted image 20230226231958"></li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>略</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>旧版 c 和 C++使用<strong>rand 函数</strong>生成随机数，此函数生成均匀分布的伪随机数，每个随机数的范围在 0 和一个系统相关最大值（至少为 32767之间）。<br>有很多程序需要不同范围的随机数，对 rand 进行定制会有很多问题，对此 C++11 引入了<strong>随机数引擎类 (random-number engines)和随机数分布类 (random-number distribution)。</strong><br>一个引擎类可以生成 unsigned 随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018562.png" alt="Pasted image 20230226232655"></p>
<blockquote>
<p>[!tip]<br>C++程序不应该使用库函数 rand, 而应使用 default_random_engine 类和恰当的分布类对象。</p>
</blockquote>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>标准库定义了多个随机数引擎类 P783，这里只介绍最常用的 <code>default_random_engine</code> 类。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404281018563.png" alt="Pasted image 20230226234230"><br>随机数引擎是函数对象类（参见 14.8 节，第 506 页），它们定义了一个调用运算符，该运算符不接受参数并返回一个随机 unsigned 整数。我们可以通过调用一个随机数引擎对象来生成原始随机数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;  <span class="comment">//生成随机无符号数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">		<span class="comment">//e()“调用”对象来生成下一个随机数</span></span><br><span class="line">		cout &lt;&lt; <span class="built_in">e</span>() &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>为了得到一个指定范围内的数，我们使用一个<strong>分布</strong>类型的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成0到9之间（包含）均匀分布的随机数</span></span><br><span class="line"><span class="function">uniform <span class="type">int</span> distribution&lt;<span class="type">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e;<span class="comment">//生成无符号随机整数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i = <span class="number">10</span>; ++i)</span><br><span class="line">		<span class="comment">//将u作为随机数源</span></span><br><span class="line">		<span class="comment">//每个调用返回在指定范围内并服从均匀分布的值</span></span><br><span class="line">		cout&lt;&lt;<span class="built_in">u</span>(e)&lt;&lt;<span class="string">&quot;&quot;</span>; <span class="comment">//得到0到9之间（包含）的数</span></span><br></pre></td></tr></table></figure>
<p>此处我们将 u 定义为 <code>uniform int distribution&lt;unsigned&gt;</code>。此类型生成均匀分布的 unsigned 值。当我们定义一个这种类型的对象时，可以提供想要的最小值和最大值。<br>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>
<blockquote>
<p>[!NOTE] </p>
<ol>
<li>当我们说<strong>随机数发生器</strong>时，是指分布对象和引擎对象的组合。</li>
<li>一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为 static 的。否则，每次调用函数都会生成相同的序列。</li>
</ol>
</blockquote>
<h3 id="随机种子"><a href="#随机种子" class="headerlink" title="随机种子"></a>随机种子</h3><p>随机数发生器会生成相同的随机数序列，我们可以提供一个<strong>随机种子</strong>来生成不同的随即结果。种子就是一个数值，引擎可以利用它从序列中一个新位置重新生成随机数。<br>为引擎设置种子有两种方式：在创建引擎对象时提供种子，或者调用引擎的 seed 成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine el;  <span class="comment">// 使用默认种子</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">2147483646</span>)</span></span>;  <span class="comment">// 使用给定的种子值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e3和e4将生成相同的序列，因为它们使用了相同的种子</span></span><br><span class="line">default_random_engine e3;  <span class="comment">//使用默认种子值</span></span><br><span class="line">e3.<span class="built_in">seed</span>(<span class="number">32767</span>);  <span class="comment">//调用seed设置一个新种子值</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e4</span><span class="params">(<span class="number">32767</span>)</span></span>;  <span class="comment">//将种子值设置为32767</span></span><br><span class="line"><span class="keyword">for</span>(size t i=<span class="number">0</span>;i!=<span class="number">100</span>;++<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">e1</span>()==<span class="built_in">e2</span>())</span><br><span class="line">			cout &lt;<span class="string">&quot;unseeded match at iteration:&quot;</span>&lt;i&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">e3</span>()！=<span class="built_in">e4</span>())</span><br><span class="line">			cout &lt;<span class="string">&quot;seeded differs at iteration:&quot;</span>&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常调用系统函数 time 作为种子。由于 time 返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">el</span><span class="params">(time(<span class="number">0</span>))</span></span>;<span class="comment">//稍微随机些的种子</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>如果程序作为一个自动过程的一部分反复运行，将 time 的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。</p>
</blockquote>
<h3 id="其他随机数分布"><a href="#其他随机数分布" class="headerlink" title="其他随机数分布"></a>其他随机数分布</h3><p>P665</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/37796.html">http://liuke101.github.io/post/37796.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/60549.html" title="C++精粹"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++精粹</div></div></a></div><div class="next-post pull-right"><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">模板与泛型编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/60549.html" title="C++精粹"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">C++精粹</div></div></a></div><div><a href="/post/60457.html" title="Effective C++"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">Effective C++</div></div></a></div><div><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">模板与泛型编程</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">一、通用容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">容器定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">将一个容器初始化为另一个容器的拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84-array"><span class="toc-text">特别的 array</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap-%E5%92%8C-assign"><span class="toc-text">swap 和 assign</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E5%88%86%E7%B1%BB"><span class="toc-text">根据访问修改权限分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-text">根据迭代方式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="toc-text">迭代器遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">各容器的迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E8%9E%8D%E5%85%B3%E7%B3%BB"><span class="toc-text">迭代器之间的相融关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">二、顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">顺序容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">改变容器的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F%E7%AE%A1%E7%90%86"><span class="toc-text">容器容量管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">顺序容器迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#begin-%E5%92%8C-end-%E6%88%90%E5%91%98"><span class="toc-text">begin 和 end 成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-text">运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">容器操作导致的迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90array%E3%80%91-%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%BB%84"><span class="toc-text">【array】 固定数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90vector%E3%80%91-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84"><span class="toc-text">【vector】 可变数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E7%AD%96%E7%95%A5"><span class="toc-text">内存空间增长策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">vector 使用优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90string%E3%80%91-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">【string】 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-substr-%E5%AD%90%E4%B8%B2"><span class="toc-text">2 substr 子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9"><span class="toc-text">3 修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%90%9C%E7%B4%A2"><span class="toc-text">4 搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-compare-%E6%AF%94%E8%BE%83"><span class="toc-text">5 compare 比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E5%BA%8F%E6%AF%94%E8%BE%83"><span class="toc-text">字母序比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#s1-compare-s2"><span class="toc-text">s1.compare (s2)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">&lt; 比较运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-cin-%E5%92%8C-getline-%E5%87%BD%E6%95%B0"><span class="toc-text">6 cin 和 getline 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8C-string-%E7%9B%B8%E5%8A%A0"><span class="toc-text">8 字面值和 string 相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">9 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91to-string"><span class="toc-text">【C++11】to_string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stoX"><span class="toc-text">stoX</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6"><span class="toc-text">10 处理字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90list%E3%80%91-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">【list】 双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90forward-list%E3%80%91%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">【forward_list】单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90deque%E3%80%91%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-text">【deque】双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-text">双端插入删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">顺序容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">定义适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90stack%E3%80%91-%E6%A0%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">【stack】 栈适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90queue-priority-queue%E3%80%91-%E9%98%9F%E5%88%97%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">【queue&#x2F;priority_queue】 队列适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">优先队列（自定义比较函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Astruct-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">方式一：struct 重载运算符 ()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aclass-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">方式二：class 重载运算符 ()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">方式三：定义函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9Alambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">方式四：lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%94%EF%BC%9Afunction-%E5%8C%85%E8%A3%85-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">方式五：function 包装 lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-text">测试用例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">三、关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-map-%E6%98%A0%E5%B0%84"><span class="toc-text">1 map 映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-set-%E9%9B%86%E5%90%88"><span class="toc-text">2 set 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multiset"><span class="toc-text">multiset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-pair-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3 pair 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">4 关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">关联容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">遍历关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">insert 添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#erase-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">erase 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="toc-text">map 的下标操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="toc-text">访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#multimap-%E6%88%96-multiset-%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">multimap 或 multiset 中查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lower-bound"><span class="toc-text">lower_bound</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equal-range-%E5%87%BD%E6%95%B0"><span class="toc-text">equal_range 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">5 无序关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%A1%B6"><span class="toc-text">管理桶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-text">对关键字类型的要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F"><span class="toc-text">6 自定义排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">四、定制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D%EF%BC%9A%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-text">谓词：向算法传递函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">1. 使用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">2. 使用函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 使用函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4. 使用 lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D%E4%B8%BE%E4%BE%8B"><span class="toc-text">一元谓词举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D%E4%B8%BE%E4%BE%8B"><span class="toc-text">二元谓词举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">泛型迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">插入迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#back-inserter"><span class="toc-text">back_inserter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#front-inserter"><span class="toc-text">front_inserter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inserter"><span class="toc-text">inserter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">反向迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream-%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">iostream 流迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#istream-iterator"><span class="toc-text">istream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ostream-iterator"><span class="toc-text">ostream_iterator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">泛型算法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">迭代器类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">算法形参模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">算法命名规范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-text">五、泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">1 查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%80%BC"><span class="toc-text">查找指定值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-text">查找重复值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">查找子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B6%E4%BB%96%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="toc-text">2 其他只读算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-text">3 二分搜索算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">4 写容器元素的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%86%99%E4%B8%8D%E8%AF%BB%E5%85%83%E7%B4%A0"><span class="toc-text">只写不读元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">使用输入迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">使用前向迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%86%99%E7%AE%97%E6%B3%95"><span class="toc-text">使用双向迭代器的写算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%92%E5%88%86%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">5 划分和排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-text">划分算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">排序算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%87%8D%E6%8E%92%E9%A1%BA%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">6 重排顺序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E7%AE%97%E6%B3%95"><span class="toc-text">使用前向迭代器的重排算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E7%AE%97%E6%B3%95"><span class="toc-text">使用双向迭代器的重排算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E9%87%8D%E6%8E%92%E7%AE%97%E6%B3%95"><span class="toc-text">使用随机访问迭代器的重排算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-text">7 排列算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-text">8 有序序列的集合算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">9 最大值最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-text">10 数值算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD"><span class="toc-text">六、标准库特殊设施</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90C-11%E3%80%91tuple-%E5%85%83%E7%BB%84"><span class="toc-text">【C++11】tuple 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-tuple"><span class="toc-text">定义和初始化 tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-tuple-%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">访问 tuple 的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-tuple-%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-text">使用 tuple 返回多个值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bitset-%E7%B1%BB%E5%9E%8B"><span class="toc-text">bitset 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">随机数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E%E5%92%8C%E5%88%86%E5%B8%83"><span class="toc-text">随机数引擎和分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90"><span class="toc-text">随机种子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-text">其他随机数分布</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/64863.html" title="全局光照GI"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300005318.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全局光照GI"/></a><div class="content"><a class="title" href="/post/64863.html" title="全局光照GI">全局光照GI</a><time datetime="2024-04-29T23:06:00.000Z" title="发表于 2024-04-30 00:06:00">2024-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/55802.html" title="环境光照IBL"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300003151.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="环境光照IBL"/></a><div class="content"><a class="title" href="/post/55802.html" title="环境光照IBL">环境光照IBL</a><time datetime="2024-04-29T23:03:00.000Z" title="发表于 2024-04-30 00:03:00">2024-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/49886.html" title="光线追踪理论"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292358872.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="光线追踪理论"/></a><div class="content"><a class="title" href="/post/49886.html" title="光线追踪理论">光线追踪理论</a><time datetime="2024-04-29T22:59:00.000Z" title="发表于 2024-04-29 23:59:00">2024-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/38389.html" title="路径追踪"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300000048.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="路径追踪"/></a><div class="content"><a class="title" href="/post/38389.html" title="路径追踪">路径追踪</a><time datetime="2024-04-29T22:59:00.000Z" title="发表于 2024-04-29 23:59:00">2024-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/19081.html" title="PBR理论"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292357277.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PBR理论"/></a><div class="content"><a class="title" href="/post/19081.html" title="PBR理论">PBR理论</a><time datetime="2024-04-29T22:57:00.000Z" title="发表于 2024-04-29 23:57:00">2024-04-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>