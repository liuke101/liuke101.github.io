<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GAS精粹 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="项目地址： https:&#x2F;&#x2F;github.com&#x2F;liuke101&#x2F;ProjectGASRPG GAS 插件 GAS 由多个组件构成：  **Ability System Component**：核心组件，由 C++ 编写，维持所属 Actor 拥有的所有技能的列表，并处理激活。 Gameplay Ability ，表示角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和 UI">
<meta property="og:type" content="article">
<meta property="og:title" content="GAS精粹">
<meta property="og:url" content="http://liuke101.github.io/post/46645.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="项目地址： https:&#x2F;&#x2F;github.com&#x2F;liuke101&#x2F;ProjectGASRPG GAS 插件 GAS 由多个组件构成：  **Ability System Component**：核心组件，由 C++ 编写，维持所属 Actor 拥有的所有技能的列表，并处理激活。 Gameplay Ability ，表示角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和 UI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-10-15T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.275Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="GAS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/46645.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GAS精粹',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GAS精粹</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.275Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/">虚幻引擎</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">43.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>158分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GAS精粹"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/46645.html#post-comment"><span class="waline-comment-count" data-path="/post/46645.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>项目地址： <a target="_blank" rel="noopener" href="https://github.com/liuke101/ProjectGASRPG">https://github.com/liuke101/ProjectGASRPG</a></p>
<h1 id="GAS-插件"><a href="#GAS-插件" class="headerlink" title="GAS 插件"></a>GAS 插件</h1><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016328.png"></p>
<p>GAS 由多个组件构成：</p>
<ul>
<li>**<code>Ability System Component</code>**：核心组件，由 C++ 编写，维持所属 Actor 拥有的所有技能的列表，并处理激活。</li>
<li><strong><code>Gameplay Ability</code></strong> ，表示角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但<strong>不包括基础移动和 UI</strong><ul>
<li>由 <code>Gameplay Ability Tasks</code> 以及其他函数构成。</li>
</ul>
</li>
<li><strong><code>Attribute Set</code></strong> ，附加到 ASC。<ul>
<li>包含 <code>GameplayAttribute</code> ，用于驱动计算或表示资源。</li>
</ul>
</li>
<li><strong><code>Gameplay Effects</code></strong> ，处理 Actor 因使用技能而发生的属性更改。<ul>
<li><code>Gameplay Effect Calculations</code> ，提供模块化、可复用的方法来计算效果。</li>
<li><code>GameplayCue</code> ，与 GE 关联，并提供数据驱动的方法来处理特效、音效。</li>
</ul>
</li>
</ul>
<p>GAS 指在处理所有这些用例，方法是<strong>将技能建模为负责自身执行的完全独立的实体</strong>。</p>
<ul>
<li>谁可以释放技能？ 持有 ASC 组件的 Actor</li>
<li>如何编写技能逻辑？ 使用 GameAbility </li>
<li>如何技能效果？ 使用 GameEffect (属性修改、增减 Buff, 并不是特效)</li>
<li>技能改变的什么属性？ 使用 GamePlayAttribute 属性系统</li>
<li>技能释放的条件？ 使用 GameplayTag 进行条件判断</li>
<li>技能的视角表现效果？ 使用 GameplayCue</li>
<li>技能的长时行动？ 使用 GameplayTask </li>
<li>技能消息事件？ 使用 GameplayEvent</li>
</ul>
<p>在多人游戏中, GAS提供<strong>客户端预测</strong>支持:  </p>
<ul>
<li>Ability 激活</li>
<li>播放蒙太奇</li>
<li>对<code>Attribute</code>的修改</li>
<li>应用<code>GameplayTag</code></li>
<li>生成<code>GameplayCue</code></li>
<li>通过连接于<code>CharacterMovementComponent</code>的<code>RootMotionSource</code>函数形成的移动</li>
</ul>
<h1 id="0-开启-GAS"><a href="#0-开启-GAS" class="headerlink" title="0 开启 GAS"></a>0 开启 GAS</h1><p>使用GAS建立一个项目的基本步骤:  </p>
<ol>
<li>在编辑器中启用 GameplayAbilitySystem 插件.。</li>
<li>编辑<code>YourProjectName.Build.cs</code>, 添加<code>&quot;GameplayAbilities&quot;</code>, <code>&quot;GameplayTags&quot;</code>, <code>&quot;GameplayTasks&quot;</code>到你的<code>PrivateDependencyModuleNames</code>.</li>
<li>刷新&#x2F;重新生成Visual Studio项目文件.</li>
<li>从4.24开始, 需要强制调用 <code>UAbilitySystemGlobals::InitGlobalData()</code> 来使用 <code>TargetData</code>, 样例项目在 <code>UEngineSubsystem::Initialize()</code> 中调用该函数. 参阅 <code>InitGlobalData()</code> 获取更多信息.</li>
</ol>
<p>这就是你启用GAS所需做的全部了. 从这里开始, 添加一个<code>ASC</code>和<code>AttributeSet</code>到你的<code>Character</code>或<code>PlayerState</code>, 并开始着手<code>GameplayAbility</code>和<code>GameplayEffect</code>!</p>
<h1 id="1-Ability-System-Component"><a href="#1-Ability-System-Component" class="headerlink" title="1 Ability System Component"></a>1 Ability System Component</h1><p>ASC 是 GAS 的核心组件（是一个 UActorComponent），用于处理整个框架下的交互逻辑，交互对象包括：</p>
<ul>
<li>GameAbility</li>
<li>GameplayEffect</li>
<li>GameplayAttribute</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016329.png"></p>
<blockquote>
<p>从上图的继承关系可以发现, ASC 继承自 <code>UGameplayTasksComponent</code>, 所以它具有执行 Task 的能力; 同时实现了多个接口</p>
</blockquote>
<p><strong>所有期望使用 GA, 包含 Attribute, 或者接受 GE 的 Actor 都必须附加 <code>ASC</code></strong>. 这些对象都存于 <code>ASC</code> 并由其管理和复制(除了由 <code>AttributeSet</code> 复制的 <code>Attribute</code>)</p>
<ul>
<li><code>ASC</code> 附加的 <code>Actor</code> 被引用作为该 <code>ASC</code> 的 **<code>OwnerActor</code>**（逻辑上拥有这个 ASC 的 Actor）</li>
<li>该 <code>ASC</code> 的物理代表 <code>Actor</code> 被称为 **<code>AvatarActor</code>**（通常是 Pawn，但也可以是塔楼、建筑、炮塔等）.</li>
<li><code>OwnerActor</code> 和 <code>AvatarActor</code> 可以是同一个 <code>Actor</code>, 比如 AIController 控制的敌人。</li>
<li>它们也可以是不同的 <code>Actor</code>, 比如玩家控制的 Character, 其中 <code>OwnerActor</code> 是 <code>PlayerState</code>, <code>AvatarActor</code> 是 <code>Character</code> 类。</li>
<li>**绝大多数 Actor 的 <code>ASC</code> 都附加在其自身, 如果你的 Actor 会重生并且重生时需要持久化 <code>Attribute</code> 或 <code>GameplayEffect</code> , 那么 <code>ASC</code> 理想的位置就是 <code>PlayerState</code>*。</li>
<li>技能间的互相作用其实就是一个 Actor 上的 ASC 作用到另一个 Actor 上的 ASC</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016331.png" alt="Pasted image 20231006202320"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016332.png" alt="Pasted image 20231006202726"></p>
<blockquote>
<p>Pawn 被销毁时，身上的 ASC 和属性集也会被销毁。重生后 ASC 和属性集也是新创建的，为默认值。如果使用 PlayState 则可以保存数据！<br>比如怪物不需要持久化数据，我们可以直接在怪物自身的 Actor 上使用 ASC。而玩家角色需要持久化数据，我们就要使用 PlayState。</p>
</blockquote>
<h2 id="IAbilitySystemInterface"><a href="#IAbilitySystemInterface" class="headerlink" title="IAbilitySystemInterface"></a>IAbilitySystemInterface</h2><p><code>OwnerActor</code> 需要继承并实现 **<code>IAbilitySystemInterface</code>**（如果 AvatarActor 和 OwnerActor 是不同的 Actor, 那么 AvatarActor 也应该继承并实现 <code>IAbilitySystemInterface</code>）。</p>
<ul>
<li>该接口只有一个必须重写的 Getter 函数： <code>UAbilitySystemComponent* GetAbilitySystemComponent() const</code>, 其返回一个指向 <code>ASC</code> 的指针, <code>ASC</code> 通过寻找该接口函数来和系统内部进行交互.  </li>
<li><code>UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(AActor *Actor)</code> 方法也可以获取实现了该接口函数的 Actor 的 ASC<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规方法：获取实现了接口函数的 Actor 的 ASC</span></span><br><span class="line"><span class="keyword">if</span> (IAbilitySystemInterface* ASInterface = <span class="built_in">Cast</span>&lt;IAbilitySystemInterface&gt;(TestActor))  </span><br><span class="line">&#123;  </span><br><span class="line">    UAbilitySystemComponent* ASC = ASInterface-&gt;<span class="built_in">GetAbilitySystemComponent</span>()  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐使用ASC蓝图库：更方便，若TestActor本身没有实现接口，还会遍历组件</span></span><br><span class="line"> UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(TestActor); </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OwnerActor-与-AvatarActor-实现接口"><a href="#OwnerActor-与-AvatarActor-实现接口" class="headerlink" title="OwnerActor 与 AvatarActor 实现接口"></a>OwnerActor 与 AvatarActor 实现接口</h3><p>项目中角色相关的类有三个，抽象基类 <code>MageCharacterBase</code> ，该基类由两个子类：</p>
<ul>
<li><p>由 PlayerController 控制的 <code>MageCharacter</code> （后文<strong>简称玩家角色</strong>）</p>
</li>
<li><p>由 AIController 控制的 <code>MageEnemy</code>。（后文<strong>简称敌人角色</strong>）</p>
</li>
<li><p><code>MageCharacter</code> 类需要持久化 Attribute 和 GE 数据，故采用 OwnerActor 和 AvatarActor <strong>分离</strong>的方式： <code>MagePlayerState</code> 为 OwnerActor，<code>MageCharacter</code> 为 AvatarActor  </p>
</li>
<li><p><code>MageEnemy</code> 类采用 OwnerActor 和 AvatarActor <strong>合一</strong>的方式，OwnerActor, AvatarActor 都是自身</p>
</li>
</ul>
<p>**OwnerActor 和 AvatarActor 都需要继承并实现 <code>IAbilitySystemInterface</code>**，我们在角色基类中继承了 <code>IAbilitySystemInterface</code>（这样子类 MageCharacter，MageEnemy 也完成了继承）, 我们只需要再在 MagePlayerState 中继承即可。继承后需要实现 <code>GetAbilitySystemComponent ()</code> 方法</p>
<figure class="highlight c++"><figcaption><span>title:MageCharacterBase</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后文的 AMageCharacter、AMageEnemy 都继承自该基类 AMageCharacterBase</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> AMageCharacterBase : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">AMageCharacterBase</span>();  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region GAS</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> AbilitySystemComponent; &#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MagePlayerState</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> AMagePlayerState : <span class="keyword">public</span> APlayerState, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//在构造函数中</span></span><br><span class="line">	<span class="built_in">AMagePlayerState</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region GAS</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//实现接口的抽象Getter函数</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> AbilitySystemComponent;&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 声明ASC</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Mage_GAS&quot;</span>)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p><code>ASC</code> 一般<strong>在 <code>OwnerActor</code> 的构造函数中创建</strong>并且多人游戏需要明确标记为 <code>Replicated</code>. <strong>必须在 C++中完成.</strong>  </p>
<p>对于玩家角色，OwnerActor 为 PlayerState，即在 PlayerState 中创建 ASC：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AMagePlayerState::<span class="built_in">AMagePlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须提高网络更新率，后文会讲原因</span></span><br><span class="line">	NetUpdateFrequency = <span class="number">100.0f</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ASC组件</span></span><br><span class="line">	AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UMageAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//多人游戏需要设置复制</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>); </span><br><span class="line">	AbilitySystemComponent</span><br><span class="line">	-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Mixed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于敌人角色，OwnerActor 为自身：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMageEnemy::<span class="built_in">AMageEnemy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UMageAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line">    AbilitySystemComponent</span><br><span class="line">    -&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Minimal);<span class="comment">// 注意复制模式和玩家角色类是不同的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>OwnerActor</code> 和 <code>AvatarActor</code> 的 <code>ASC</code> 在服务端和客户端上均需初始化，你<strong>应该在 <code>Pawn</code> 的 <code>Controller</code> 设置之后(Possess 之后)进行初始化</strong>,  单人游戏只需参考服务端的做法。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016333.png" alt="Pasted image 20231006222111"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016334.png" alt="Pasted image 20231006224827"></p>
<ul>
<li>对于玩家角色且 <code>ASC</code> 位于自身（项目采用的是分离方案）：<ul>
<li>在服务端 <code>Pawn</code> 的 <code>PossessedBy()</code> 函数中初始化, </li>
<li>在客户端 <code>PlayerController</code> 的 <code>AcknowledgePossession()</code> 函数中初始化.  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCharacterBase::PossessedBy</span><span class="params">(AController * NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ASC MixedMode replication requires that the ASC Owner&#x27;s Owner be the Controller.</span></span><br><span class="line">	<span class="built_in">SetOwner</span>(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPlayerControllerBase::AcknowledgePossession</span><span class="params">(APawn* P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">AcknowledgePossession</span>(P);</span><br><span class="line"></span><br><span class="line">	MyCharacterBase* CharacterBase = <span class="built_in">Cast</span>&lt;MyCharacterBase&gt;(P);</span><br><span class="line">	<span class="keyword">if</span> (CharacterBase)</span><br><span class="line">	&#123;</span><br><span class="line">		CharacterBase-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(CharacterBase, CharacterBase);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@ ⭐对于玩家角色且 <code>ASC</code> 位于 <code>PlayerState</code><ul>
<li>在服务端 <code>Pawn</code> 的 <code>PossessedBy()</code> 函数中初始化, </li>
<li>在客户端 PlayerController 的 <code>OnRep_PlayerState()</code> 函数中初始化 （在 Pawn 的 <code>OnRep_PlayerState()</code> 也可以）, 这将确保 <code>PlayerState</code> 成功从服务器复制到客户端</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><figcaption><span>title:MageCharacter.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 服务器初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">InitASC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 客户端初始化, 在 PlayerState 复制到客户端时进行回调 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::OnRep_PlayerState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnRep_PlayerState</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">InitASC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::InitASC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 该函数被 PossessedBy() 和 OnRep_PlayerState()调用 </span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * PossessedBy(): 在服务器上设置 ASC</span></span><br><span class="line"><span class="comment">	 * - AI 没有 PlayerController，因此我们可以在这里再次 init 以确保万无一失。</span></span><br><span class="line"><span class="comment">	 * - 对于拥有 PlayerController 的 Character，init两次也无妨。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * OnRep_PlayerState():为客户端设置 ASC</span></span><br><span class="line"><span class="comment">	 * - 为客户端init AbilityActorInfo</span></span><br><span class="line"><span class="comment">	 * - 当服务器 possess 一个新的 Actor 时，它将init自己的 ASC。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取PlayerState</span></span><br><span class="line">	AMagePlayerState* MagePlayerState = <span class="built_in">GetMagePlayerState</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将AvatarActor的ASC设置为和OwnerActor创建的的ASC</span></span><br><span class="line">	AbilitySystemComponent = MagePlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化AbilityActorInfo, 保存ASC的AvatarActor和OwnerActor</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(MagePlayerState, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你遇到了错误消息 <code>LogAbilitySystem: Warning: Can&#39;t activate LocalOnly or LocalPredicted Ability %s when not local!</code>， 那么就表明 <code>ASC</code> 没有在客户端中初始化.  </p>
<ul>
<li>@ ⭐对于敌人角色 ASC 位于自身，只需要在 <code>BeginPlay()</code> 中初始化 &#96;<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDEnemy::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">InitASC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageEnemy::InitASC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(AbilitySystemComponent == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/** 初始化ASC */</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="FGameplayAbilityActorInfo"><a href="#FGameplayAbilityActorInfo" class="headerlink" title="FGameplayAbilityActorInfo"></a>FGameplayAbilityActorInfo</h3><p>用于缓存 Ability 需要经常访问的 owning Actor 数据（Movement Component, Mesh Component, Anim Instance 等）。</p>
<p>Abilities 使用它来了解要对哪个 actor 进行操作，而不是与特定的 actor 类耦合。<br>项目可以重载 <code>UAbilitySystemGlobals::AllocAbilityActorInfo</code> 来创建的默认结构类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存的所有数据类型：</span></span><br><span class="line">TWeakObjectPtr&lt;AActor&gt;	OwnerActor;</span><br><span class="line">TWeakObjectPtr&lt;AActor&gt;	AvatarActor;</span><br><span class="line"></span><br><span class="line">TWeakObjectPtr&lt;APlayerController&gt;	PlayerController;</span><br><span class="line">TWeakObjectPtr&lt;UAbilitySystemComponent&gt;	AbilitySystemComponent;</span><br><span class="line">TWeakObjectPtr&lt;USkeletalMeshComponent&gt;	SkeletalMeshComponent; <span class="comment">//avatar </span></span><br><span class="line">TWeakObjectPtr&lt;UAnimInstance&gt;	AnimInstance; <span class="comment">//avatar</span></span><br><span class="line">TWeakObjectPtr&lt;UMovementComponent&gt;	MovementComponent; <span class="comment">//avatar</span></span><br><span class="line">	</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;ActorInfo&quot;</span>)</span><br><span class="line">FName AffectedAnimInstanceTag; </span><br><span class="line"><span class="function">UAnimInstance* <span class="title">GetAnimInstance</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="两个容器"><a href="#两个容器" class="headerlink" title="两个容器"></a>两个容器</h2><p><strong>ASC 维护两个容器：</strong></p>
<ol>
<li>在 <code>FActiveGameplayEffectContainer ActiveGameplayEffect</code> 中<strong>保存其当前已经 Apply 的 <code>GE</code></strong></li>
<li>在 <code>FGameplayAbilitySpecContainer ActivatableAbility</code> 中<strong>保存其已经授予的（GiveAbility） <code>GA</code></strong></li>
</ol>
<h3 id="ABILITYLIST-SCOPE-LOCK"><a href="#ABILITYLIST-SCOPE-LOCK" class="headerlink" title="ABILITYLIST_SCOPE_LOCK"></a>ABILITYLIST_SCOPE_LOCK</h3><p><strong>当你想遍历 <code>ActivatableAbility</code> 时, 确保在循环体之上添加 <code>ABILITYLIST_SCOPE_LOCK();</code> 来锁定列表以防其改变 (比如移除一个 Ability).</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GameplayAbilitySpec.h中的一个宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABILITYLIST_SCOPE_LOCK()	FScopedAbilityListLock ActiveScopeLock(*this);</span></span><br></pre></td></tr></table></figure>

<p><code>FScopedAbilityListLock</code> 用于阻止我们在迭代 Ability 时从 ASC 中移除 Ability</p>
<ul>
<li>每个域中的 <code>ABILITYLIST_SCOPE_LOCK()</code> 会增加 <code>AbilityScopeLockCount</code>, 之后出域时会减量. </li>
<li>不要尝试在 <code>ABILITYLIST_SCOPE_LOCK()</code> 域中移除某个 Ability (Ability 删除函数会在内部检查 <code>AbilityScopeLockCount</code> 以防在列表锁定时移除 Ability).</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAbilitySystemComponent::ForEachAbility</span><span class="params">(<span class="type">const</span> FForEachAbilityDelegate&amp; AbilityDelegate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/** 遍历 ActivatableAbilities 时, 锁定列表 */</span></span><br><span class="line">	<span class="built_in">ABILITYLIST_SCOPE_LOCK</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> FGameplayAbilitySpec&amp; AbilitySpec : <span class="built_in">GetActivatableAbilities</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h2><ul>
<li><code>ASC</code> 定义了三种不同的复制模式用于复制 <code>GameplayEffect</code> 到客户端, <code>GameplayTag</code> 和 <code>GameplayCue</code> ： <code>Full</code>, <code>Mixed</code> 和 <code>Minimal</code>.</li>
<li><code>Attribute</code> 由其 <code>AttributeSet</code> 复制。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">复制模式</th>
<th align="center">何时使用</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Full</code></td>
<td align="center">单人</td>
<td align="center"><code>GameplayEffect</code>复制到所有客户端</td>
</tr>
<tr>
<td align="center"><code>Mixed</code></td>
<td align="center">多人, PlayerController控制的Actor</td>
<td align="center"><code>GameplayEffect</code>只复制到其所属（owning）客户端； <code>GameplayTag</code>和<code>GameplayCue</code>复制到所有客户端</td>
</tr>
<tr>
<td align="center"><code>Minimal</code></td>
<td align="center">多人, AIController控制的Actor</td>
<td align="center"><code>GameplayEffect</code>不复制；<code>GameplayTag</code>和<code>GameplayCue</code>复制到所有客户端.</td>
</tr>
</tbody></table>
<blockquote>
<p>2023.10.6 根据 GAS 视频教程修正描述</p>
</blockquote>
<ul>
<li><code>Mixed</code> 模式要求 <code>OwnerActor</code> 的 <code>Owner</code> 必须是 <code>Controller</code>。</li>
<li><strong><code>Pawn</code> 在 <code>PossessedBy()</code> 中自动设置，<code>PlayerState</code> 的 <code>Owner</code> 默认是 <code>Controller</code> ，但是 <code>Character</code> 不是。</strong></li>
<li>如果 <code>OwnerActor</code> 不是 <code>PlayerState</code> 时使用 <code>Mixed</code> 模式, 那么需要<strong>使用 <code>PossessedBy()</code> 设置新的 <code>Controller</code> 为 <code>Pawn</code> 的 Owner。</strong><blockquote>
<p> <code>PossessedBy()</code> ：当该 Pawn 被 possess 时调用。仅在服务器（或单机）上调用。</p>
</blockquote>
</li>
</ul>
<h2 id="NetUpdateFrequency"><a href="#NetUpdateFrequency" class="headerlink" title="NetUpdateFrequency"></a>NetUpdateFrequency</h2><p>如果 <code>ASC</code> 位于 PlayerState, 那么你需要提高 PlayerState 的 <code>NetUpdateFrequency</code>, 其默认是一个很低的值（在 PlayerState 构造函数中设为 100.0f 即可）, 因此在客户端上发生 <code>Attribute</code> 和 <code>GameplayTag</code> 改变时会造成延迟或卡顿. 确保启用 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/Properties/index.html#adaptivenetworkupdatefrequency">Adaptive Network Update Frequency</a>, Fortnite 就启用了该项.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在PlayerState构造函数中设置</span></span><br><span class="line">AMagePlayerState::<span class="built_in">AMagePlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line">	NetUpdateFrequency = <span class="number">100.0f</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Gameplay-Tags"><a href="#2-Gameplay-Tags" class="headerlink" title="2 Gameplay Tags"></a>2 Gameplay Tags</h1><p>Gameplay Tags 有助于确定玩法技能之间的交互方式。每种技能都拥有一组标记，以可影响其行为的方式识别和分类技能，还有玩法标记容器和游戏标记查询，用于支持与其他技能进行交互。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016335.png" alt="Pasted image 20231009222739"></p>
<p><code>FGameplayTag</code> 是由 <code>GameplayTagManager</code> 注册的形似 <code>Parent.Child.Grandchild...</code> 的层级 <code>FName</code>,  这些标签对于分类和描述对象的状态非常有用, 例如, 如果某个 Character 处于眩晕状态, 我们可以给一个 <code>State.Debuff.Stun</code> 的 <code>GameplayTag</code>.  </p>
<p>你会发现自己使用 <code>GameplayTag</code><strong>替换了过去使用布尔值或枚举值</strong>来编程, 并且需要对对象有无特定的 <code>GameplayTag</code> 做布尔逻辑判断.   比如 AI 在行为树的 Decorator 节点中，通过玩家拥有的 Gameplay Tag 来判断玩家是否处于无敌帧、喝药。</p>
<p><strong>当给某个对象设置标签时, 如果它有 <code>ASC</code> 的话, 我们一般添加标签到 <code>ASC</code> 以与其交互。</strong> <code>UAbilitySystemComponent</code> 继承 <strong><code>IGameplayTagAssetInterface</code> 接口</strong>的函数来访问其拥有的 <code>GameplayTag</code>.   </p>
<h2 id="IGameplayTagAssetInterface"><a href="#IGameplayTagAssetInterface" class="headerlink" title="IGameplayTagAssetInterface"></a>IGameplayTagAssetInterface</h2><p>如果 Actor 想要使用 FGameplayTagContainer 来保存 GameplayTag，需要继承 <code>IGameplayTagAssetInterface</code> 接口。</p>
<ul>
<li>该 Actor 必须重载 Getter 函数 <code>GetOwnedGameplayTags</code> ，返回 Actor 中的 <code>FGameplayTagContainer</code></li>
<li>同时 Actor 会继承三个标签匹配函数，用于对 TagContainer 存储的标签进行匹配</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 必须重载该Getter函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetOwnedGameplayTags</span><span class="params">(FGameplayTagContainer&amp; TagContainer)</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时Actor会继承三个函数，用于对TagContainer存储的标签进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasMatchingGameplayTag</span><span class="params">(FGameplayTag TagToCheck)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasAllMatchingGameplayTags</span><span class="params">(<span class="type">const</span> FGameplayTagContainer&amp; TagContainer)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasAnyMatchingGameplayTags</span><span class="params">(<span class="type">const</span> FGameplayTagContainer&amp; TagContainer)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="FGameplayTagContainer"><a href="#FGameplayTagContainer" class="headerlink" title="FGameplayTagContainer"></a>FGameplayTagContainer</h2><blockquote>
<p>[!quote] </p>
<ul>
<li>跟踪 Tag 应用的数量（次数）结构体。明确跟踪添加或删除的 Tag, 同时跟踪 Parent Tag 的数量。  </li>
<li>每当任何 Tag（或其 Parent Tag）的标签计数被修改时，都会触发事件&#x2F;委托。</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016336.png" alt="Pasted image 20231130205052"></p>
<p><strong>多个 <code>GameplayTag</code> 可被保存于一个 <code>FGameplayTagContainer</code> 中</strong>, 内部封装了 <code>TArray&lt;FGameplayTag&gt;</code> 。不建议自定义 TArray 来保存 Tag, 因为 <code>GameplayTagContainer</code> 做了一些很有效率的优化，并且为我们实现了很多标签匹配相关的功能函数。</p>
<ul>
<li><code>GameplayTagContainer</code> 或 ASC 可以使用 <code>GetGameplayTagArray</code> 函数返回指定 <code>FGameplayTag</code> 的 TArray 用于遍历。</li>
<li><code>GameplayTagContainer</code> <strong>使用 <code>GameplayTagCountMap</code> 保存了每个 <code>GameplayTag</code> 和其实例数量的映射</strong>，可以通过 <code>GetTagCount</code> 访问实例数量。（或 ASC 得 <code>GetGameplayTagCount</code> 函数）</li>
<li>因为标签是标准的 <code>FName</code>, 所以当在项目设置中启用 <code>Fast Replication</code> 后, 它们可以高效地打包进 <code>FGameplayTagContainer</code> 以用于复制。 <code>Fast Replication</code> 要求服务端和客户端有相同的 <code>GameplayTag</code> 列表, 这通常不是问题, 因此你应该启用该选项。</li>
<li>除了 <code>Fast Replication</code>, <code>GameplayTag</code> 编辑器可以选择填充普遍需要复制的 <code>GameplayTag</code> 以对其深度优化.</li>
</ul>
<h3 id="Tag-变化委托"><a href="#Tag-变化委托" class="headerlink" title="Tag 变化委托"></a>Tag 变化委托</h3><p><code>FGameplayTagContainer</code> 实现了两个委托返回函数，可以绑定这两个委托监听 Tag 变化（<strong>ASC 对其进行了封装，可以通过 ASC 调用</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听指定Tag的变化</span></span><br><span class="line"><span class="function">FOnGameplayEffectTagCountChanged&amp; <span class="title">RegisterGameplayTagEvent</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; Tag, EGameplayTagEventType::Type EventType=EGameplayTagEventType::NewOrRemoved)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//监听全部Tag的变化</span></span><br><span class="line"><span class="function">FOnGameplayEffectTagCountChanged&amp; <span class="title">RegisterGenericGameplayEvent</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>ASC 使用该委托监听 Tag 变化的例子：</strong><br>监听 <code>Effects_HitReact</code> Tag 的变化，来决定是否应用受击反馈</p>
<figure class="highlight c++"><figcaption><span>title:ASC</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 受击反馈, 当角色被GE授予 Tag 时触发 */</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span></span><br><span class="line">(FMageGameplayTags::<span class="built_in">Get</span>().Effects_HitReact,EGameplayTagEventType::NewOrRemoved).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AMageEnemy::HitReactTagChanged);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:回调函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageEnemy::HitReactTagChanged</span><span class="params">(<span class="type">const</span> FGameplayTag CallbackTag, <span class="type">const</span> int32 NewCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NewCount即Tag的数量，大于0说明该Tag被授予给了敌人</span></span><br><span class="line">	bHitReacting = NewCount &gt; <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// 如果受击，则禁止移动</span></span><br><span class="line">	<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bHitReacting ? <span class="number">0.0f</span> : DefaultMaxWalkSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-Tag"><a href="#获取-Tag" class="headerlink" title="获取 Tag"></a>获取 Tag</h2><p><strong>C++中获取 <code>GameplayTag</code> 引用:</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Your.GameplayTag.Name&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>对于像获取父或子 <code>GameplayTag</code> 的高阶操作, 请查看 <code>GameplayTagManager</code> 提供的函数. </p>
<h2 id="网络复制与-LooseGameplayTag"><a href="#网络复制与-LooseGameplayTag" class="headerlink" title="网络复制与 LooseGameplayTag"></a>网络复制与 LooseGameplayTag</h2><p>Loose：松散，意思就是这个 Tag 不是通过 GE 授予得 Tag，而是直接添加到 ASC 的。</p>
<p><strong>如果 <code>GameplayTag</code> 由 <code>GameplayEffect</code> 添加, 那么其就是可复制的。</strong> </p>
<p><code>ASC</code> 允许你添加<strong>不可复制</strong>的 <code>LooseGameplayTag</code> 且<strong>必须手动管理 TagCount</strong> 。ASC 为我们提供了一些函数来更新 LooseGameplayTag 数量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddLooseGameplayTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; GameplayTag, int32 Count=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveLooseGameplayTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; GameplayTag, int32 Count = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>



<h2 id="过滤Tag"><a href="#过滤Tag" class="headerlink" title="过滤Tag"></a>过滤Tag</h2><p><code>GameplayTag</code> 和 <code>GameplayTagContainer</code> 有可选 UPROPERTY 元数据标签 <code>Meta = (Categories = &quot;GameplayCue&quot;)</code> 用于在蓝图中过滤标签而只显示父标签为 <code>GameplayCue</code> 的 <code>GameplayTag</code>, 当你知道 <code>GameplayTag</code> 或 <code>GameplayTagContainer</code> 变量应该只用于 <code>GameplayCue</code> 时, 这将是非常有用的.<br>作为选择, 有一单独的<code>FGameplayCueTag</code>结构体可以包裹<code>FGameplayTag</code>并且可以在蓝图中自动过滤<code>GameplayTag</code>而只显示父标签为<code>GameplayCue</code>的标签.  </p>
<h2 id="通过-C-创建和管理-Tag"><a href="#通过-C-创建和管理-Tag" class="headerlink" title="通过 C++ 创建和管理 Tag"></a>通过 C++ 创建和管理 Tag</h2><p>使用 C++来创建和管理 Tag 可以使得代码更加灵活，这是除了使用 ini 或数据表配置 Tag 的另外一种方式。重要的是，我们可以在 C++中访问这些 Tag!</p>
<p>实现步骤如下：</p>
<ol>
<li>创建饿汉式单例 C++ 类 <code>FMageGameplayTags</code></li>
</ol>
<figure class="highlight c++"><figcaption><span>title:MageGameplayTags.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameplayTagContainer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 饿汉式单例模式</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 访问GameplayTag的方法：</span></span><br><span class="line"><span class="comment">  * 1. 获取单例：const FMageGameplayTags&amp; GameplayTagsInstance = FMageGameplayTags::Instance();</span></span><br><span class="line"><span class="comment">  * 2. 通过单例访问FGameplayTag成员变量：GameplayTagsInstance.Character_Player</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FMageGameplayTags</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> FMageGameplayTags&amp; <span class="title">Instance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TagsInstance; &#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加C++Native(原生) GameplayTag, 不再使用ini或数据表配置Tag */</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitNativeGameplayTags</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 示例Tag</span></span><br><span class="line">	FGameplayTag Character_Player;</span><br><span class="line">	FGameplayTag Character_Enemy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">static</span> FMageGameplayTags TagsInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MageGameplayTags.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 全局变量,但是由于TagsInstance是private成员,其他类访问不到。所以这里只起到初始化静态成员变量的作用（创建实例） */</span></span><br><span class="line">FMageGameplayTags FMageGameplayTags::TagsInstance; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMageGameplayTags::InitNativeGameplayTags</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">/** AddNativeGameplayTag() 将Tag注册到引擎， GameplayTagsInstance则将Tag存储一份，放便读取 */</span></span><br><span class="line">    TagsInstance.Character_Player = UGameplayTagsManager::<span class="built_in">Instance</span>().<span class="built_in">AddNativeGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Character.Player&quot;</span>),<span class="built_in">FString</span>(<span class="string">&quot;玩家&quot;</span>));</span><br><span class="line"></span><br><span class="line">    TagsInstance.Character_Enemy = UGameplayTagsManager::<span class="built_in">Instance</span>().<span class="built_in">AddNativeGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Character.Enemy&quot;</span>),<span class="built_in">FString</span>(<span class="string">&quot;敌人&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 <code>UMageAssetManager</code> 类继承 <code>UAssetManager</code>，调用 <code>InitNativeGameplayTags()</code>;</li>
</ol>
<figure class="highlight c++"><figcaption><span>title:MageAssetManager.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/AssetManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MageAssetManager.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMageAssetManager : <span class="keyword">public</span> UAssetManager</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> UMageAssetManager&amp; <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartInitialLoading</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MageAssetManager.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UMageAssetManager&amp; <span class="title">UMageAssetManager::Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(GEngine);</span><br><span class="line">	UMageAssetManager* MageAssetManager = <span class="built_in">Cast</span>&lt;UMageAssetManager&gt;(GEngine-&gt;AssetManager);</span><br><span class="line">	<span class="keyword">return</span> *MageAssetManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAssetManager::StartInitialLoading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">StartInitialLoading</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用InitNativeGameplayTags();</span></span><br><span class="line">	FMageGameplayTags::<span class="built_in">InitNativeGameplayTags</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** TargetData必须执行该操作，否则造成ScriptStructCache错误 */</span></span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">InitGlobalData</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置引擎的资产管理器类<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016337.png" alt="Pasted image 20231130221216"><br>或通过 ini 设置：<figure class="highlight c++"><figcaption><span>title:DefaultEngine.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[/Script/Engine.Engine]</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 = /Script/项目名/资产管理类名</span></span><br><span class="line">AssetManagerClassName = /Script/ProjectGASRPG.MageAssetManager</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成后，就可以在项目设置的 GameplayTagList 中查看到添加的 GameplayTag。</p>
<h1 id="3-Attribute"><a href="#3-Attribute" class="headerlink" title="3 Attribute"></a>3 Attribute</h1><h2 id="01-定义"><a href="#01-定义" class="headerlink" title="01 定义"></a>01 定义</h2><p><code>Attribute</code> 是由 <code>FGameplayAttributeData</code> 结构体定义的<strong>浮点值</strong>，其可以表示生命值、等级、药水回复量等, <strong>如果某项数值是属于某个 Actor 且游戏相关的, 你就应该考虑使用 <code>Attribute</code>。</strong></p>
<p><strong><code>Attribute</code> 一般应该只能由 <code>GE</code> 修改, 这样 <code>ASC</code> 才能<mark style="background: #ADCCFFA6;">预测(Predict)</mark>其改变.</strong>  [[#与 Gameplay Effects 互动]]<br>![[GAS精粹#^nwhtjz]]<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016338.png" alt="Pasted image 20231007152129|600"></p>
<p><code>Attribute</code> 也可以由 <code>AttributeSet</code> 定义并存于其中.。**<code>AttributeSet</code> 用于复制那些标记为 Replication 的 <code>Attribute</code>**</p>
<blockquote>
<p>[!tip]<br> 如果你不想某个 <code>Attribute</code> 显示在编辑器的 <code>Attribute</code> 列表, 可以使用 <code>Meta = (HideInDetailsView)</code> 元属性  </p>
</blockquote>
<h2 id="02-BaseValue-与-CurrentValue"><a href="#02-BaseValue-与-CurrentValue" class="headerlink" title="02 BaseValue 与 CurrentValue"></a>02 BaseValue 与 CurrentValue</h2><p><code>FGameplayAttributeData</code> 定义了 BaseValue 和 CurrentValue 。并提供获取他们的函数。</p>
<p>一个 <code>Attribute</code> 是由两个值 ： <code>BaseValue</code> 和 <code>CurrentValue</code> 组成的。</p>
<ul>
<li><code>BaseValue</code> 是 <code>Attribute</code> 的永久值</li>
<li><code>CurrentValue</code> 是 <code>BaseValue</code> 加上 <code>GameplayEffect</code> 给的临时修改值后得到的。 <blockquote>
<p>例如, 你的 Character 可能有一个 <code>BaseValue</code> 为600的移动速度 <code>Attribute</code>,  <code>BaseValue</code> 和 <code>CurrentValue</code> 为600。如果 Character 通过 <code>GE</code> 获得了一个50 的移动速度加成, 那么 <code>BaseValue</code> 仍然是600 ，而 <code>CurrentValue</code> 是600+50&#x3D;650, 当该移动速度加成消失后, <code>CurrentValue</code> 就会变回 <code>BaseValue</code> 的600。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>[!bug]<br>不能将 <code>BaseValue</code> 作为 <code>Attribute</code> 的最大值使用！<strong>可以修改或引用的 Ability&#x2F;UI 中的 <code>Attribute</code> 最大值应该是另外单独的一个 <code>Attribute</code>。</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016339.png" alt="Pasted image 20231007152931"></p>
</blockquote>
<p><strong>对于硬编码的最大值和最小值, 有一种方法是使用可以设置最大值和最小值的 <code>FAttributeMetaData</code> 定义一个 DataTable</strong> [[#使用数据表初始化(不推荐)]], 但是 Epic 在该结构体上的注释称之为”work in progress”, 详见 <code>AttributeSet.h</code>. </p>
<p>为了避免这种疑惑, <strong>我建议引用在 Ability 或 UI 中的最大值应该单独定义 <code>Attribute</code>, 只用于限制(Clamp) <code>Attribute</code> 大小的硬编码最大值和最小值应该在 <code>AttributeSet</code> 中定义为硬编码浮点值。</strong></p>
<blockquote>
<p>关于 Clamp <code>Attribute</code> 值的问题在 [[#06 <code>PreAttributeChange()</code>]] 中讨论了 CurrentValue 的修改, 在 [[#07 <code>PostGameplayEffectExecute()</code>]] 中讨论了 <code>GameplayEffect</code> 对 <code>BaseValue</code> 的修改。**</p>
</blockquote>
<p><strong>DurationType 与 Value 的关系：</strong></p>
<ul>
<li><code>(Instant)GE</code> 可以永久性的修改 <code>BaseValue</code></li>
<li><code>(Periodic)GE </code> 被视为  <code>(Instant)GE</code> 并且可以修改 <code>BaseValue</code>。</li>
<li><code>(Duration)GE</code> 和 <code>(Infinite)GE</code> 可以修改 <code>CurrentValue</code>.</li>
</ul>
<h2 id="03-MetaAttribute"><a href="#03-MetaAttribute" class="headerlink" title="03 MetaAttribute"></a>03 MetaAttribute</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016340.png" alt="Pasted image 20231021201741"></p>
<p>首先说明，MetaAttribute 并没有对应的类，而只是一种特殊的 <code>Attribute</code>，和其他属性一样都是 <code>FGameplayAttributeData</code> 。</p>
<p>我们通常定义伤害值为 <code>MetaAttribute</code>, 项目中称为 <code>MetaDamage</code> 。使用 <code>MetaDamage</code> 作为临时占位符（可以理解为中间值，temp 值） , 而不是使用 <code>GE</code> 直接修改生命值属性, <strong>使用这种方法，允许我们在造成伤害之前执行所有的数学运算（在 Execution Calculation 中计算，在属性集中处理）。处理结束后 MetaAttribute 归零。</strong></p>
<blockquote>
<p>伤害值就可以在 <code>Execution(GameplayEffectExecutionCalculation)</code> 中由 buff 和 debuff 修改, 并且可以在 <code>AttributeSet</code> 中进一步操作, 例如, 在最终将生命值减去伤害值之前, 要将伤害值减去当前的护盾值. </p>
</blockquote>
<ul>
<li>伤害值 <code>MetaAttribute</code> 在 <code>GE</code> 之间不是持久化的, 并且可以被任何一方重写。</li>
<li><code>MetaAttribute</code> 是<strong>不可复制</strong>的.  </li>
<li><code>MetaAttribute</code> 对于在”我们应该造成多少伤害?”和”我们该如何处理伤害值?”这种问题之中的伤害值和治疗值做了很好的解构, 这种解构意味着 <code>GE</code> 和 <code>Execution Calculation</code> 无需了解目标是如何处理伤害值的。</li>
</ul>
<p><strong>尽管 <code>MetaAttribute</code> 是一个很好的设计模式, 但其并不是强制使用的</strong>。如果你只有一个用于所有伤害实例的 <code>Execution Calculation</code> 和一个所有 Character 共用的 <code>AttributeSet</code> 类, 那么你就可以在 <code>Exeuction Calculation</code> 中分配伤害到生命, 护盾等等, 并直接修改那些 <code>Attribute</code>, 这种方式你只会丢失灵活性, 但总体上并无大碍.  </p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>项目中使用元属性计算伤害值和获得的经验值，下面以伤害值元属性 <code>MetaDamage</code> 为例：</p>
<ol>
<li><p>在 AttributeSet 中创建 MetaAttribute（不需要设置复制）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMageAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** Meta Attributes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region <span class="string">&quot;伤害值元属性 MetaDamage&quot;</span></span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Mage_Attributes|Meta&quot;</span>)</span><br><span class="line">	FGameplayAttributeData MetaDamage;</span><br><span class="line">	<span class="built_in">ATTRIBUTE_ACCESSORS</span>(UMageAttributeSet, MetaDamage)</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们需要使用 GE 修改 MetaDamage 的值。首先建立一个 GE 蓝图，项目中命名为 <code>GE_ExecCalc_Damage</code> 。从名字也可以看出来，我们使用了 Execution Calculation 的方法计算伤害值。详细用法可见： [[#12 Execution Calculation]]</p>
<ul>
<li>GE 设置如下：<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016341.png" alt="Pasted image 20231201203631"><ul>
<li>其中 Calculation Class 指定我们创建的 C++类 <code>ExecCalc_Damage</code></li>
<li>使用 Execution Calculation 方法允许我们捕获 GE 源对象和目标对象的 Attribute，从而我们可以知道玩家角色的攻击力和敌人角色的防御力等信息，完成伤害值的数学运算。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UExecCalc_Damage::Execute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams,</span></span></span><br><span class="line"><span class="params"><span class="function">	FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** 执行数学运算，计算最终的伤害值FinalDamage */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** 修改MetaDamage属性 */</span></span><br><span class="line">	<span class="function"><span class="type">const</span> FGameplayModifierEvaluatedData <span class="title">EvaluatedData</span><span class="params">(UMageAttributeSet::GetMetaDamageAttribute(), EGameplayModOp::Additive, FinalDamage)</span></span>;</span><br><span class="line">	OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(EvaluatedData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>完成伤害计算后，我们可以在属性集 <code>PostGameplayEffectExecute</code> 函数中 <code>GetMetaDamage()</code>，进而判断角色是否受伤，是否死亡。</li>
<li>最后记得将元属性清零，防止干扰下一次伤害计算。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::PostGameplayEffectExecute</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** 伤害计算, MetaAttribute不会被复制，所以以下只在服务器中进行 */</span></span><br><span class="line">	<span class="keyword">if</span>(Data.EvaluatedData.Attribute == <span class="built_in">GetMetaDamageAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CalcMetaDamage</span>(Property);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::CalcMetaDamage</span><span class="params">(<span class="type">const</span> FEffectProperty&amp; Property)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取元属性</span></span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> TempMetaDamage = <span class="built_in">GetMetaDamage</span>();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(TempMetaDamage &gt; <span class="number">0.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> NewHealth = <span class="built_in">GetHealth</span>() - TempMetaDamage;</span><br><span class="line">		<span class="built_in">SetHealth</span>(FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(NewHealth, <span class="number">0.0f</span>, <span class="built_in">GetMaxHealth</span>()));</span><br><span class="line">			</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bIsDead = NewHealth &lt;= <span class="number">0.0f</span>; <span class="comment">// 用来判断死亡</span></span><br><span class="line">		<span class="keyword">if</span>(bIsDead)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/** 死亡反馈 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/** 受击反馈 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/** 显示伤害浮动数字 */</span></span><br><span class="line">		<span class="comment">/** Debuff */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//伤害为0仍显示伤害浮动数字</span></span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">SetMetaDamage</span>(<span class="number">0.0f</span>); <span class="comment">//元属性清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="04-派生属性-Derived-Attribute"><a href="#04-派生属性-Derived-Attribute" class="headerlink" title="04 派生属性 Derived Attribute"></a>04 派生属性 Derived Attribute</h2><p>**要使 <code>Attribute</code> 的部分或全部值派生于（继承）一个或多个其他 <code>Attribute</code>, 可以使用基于一个或多个 <code>Attribute</code> 或 MMC Modifiers 的 <code>(Infinite)GE</code>**。当 <code>Derived Attribute</code> 依赖的 <code>Attribute</code> 更新时它也会自动更新。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016342.png" alt="Pasted image 20231012110400"></p>
<p>在  <code>Derived Attribute</code> 上的所有 <code>Modifier</code> 形成的最终公式和 <code>Modifier Aggregators</code> 的公式是一样的。 如果您需要按特定顺序进行计算，请在 <code>MMC</code> 内完成所有操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((CurrentValue + Additive) * Multiplicitive) / Division</span><br></pre></td></tr></table></figure>

<hr>
<p>Backing : 备份的意思</p>
<p><strong>一个关于对派生属性应用 <code>(Infinite)GE</code> 的 BUG（此 BUG 只影响 PIE，打包后正常）：</strong><br>本项目应用名为 <code>GE_Secondary_Attributes</code> 的 <code>(Infinite)GE</code>，基于主属性来改变副属性。当主属性发生变化时，该 GE 会将其 Modifiers 应用到副属性中。这在单人游戏中有效。  </p>
<p><strong>但在多人游戏中，使用派生属性的 <code>(Infinite)GE</code>  只对最后进入游戏的客户端应用其 Modifiers。</strong> 无论  <code>(Infinite)GE</code>  是否应用于所有玩家，也无论是否应用于服务器，这种情况都会发生。由于 <code>(Infinite)GE</code> 无法应用于所有玩家，因此这对多人游戏来说并不理想，您需要以不同的方式实现派生属性。  </p>
<p><strong>最简单的解决方法是在 <code>PostGameplayEffectExecute</code> 中检查 Primary Attributes 的变化，并在此应用您对 Secondary Attributes 的自定义修改(本项目就采用这种方法更新副属性，舍弃了 MMC 方案, MMC 方案也会有派生属性的这个 BUG???)</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根据 Primary Attribute 的变化更新 Secondary Attributes */</span></span><br><span class="line"><span class="keyword">if</span>(Data.EvaluatedData.Attribute == <span class="built_in">GetStrengthAttribute</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 更新相关的属性 */</span></span><br><span class="line">    <span class="built_in">UpdateMaxHealth</span>(PSourceCharacterLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::UpdateMaxHealth</span><span class="params">(<span class="type">float</span> CharacterLevel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> NewMaxHealth = <span class="built_in">GetStrength</span>() * <span class="number">2.0f</span> + <span class="built_in">GetStamina</span>() * <span class="number">19.4f</span> + CharacterLevel * <span class="number">10.0f</span>;</span><br><span class="line">	<span class="built_in">SetMaxHealth</span>(NewMaxHealth);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这里，由于您可以访问 owning player 的相关类（包括 PlayerState），您可以在这里考虑任何值，例如玩家的等级等。这在多人游戏中适用于所有客户端和服务器上的 hosting player。实际上，这比创建 Infinite Duration Gameplay 和相应的 MMC 要省事得多。  </p>
<blockquote>
<p>[!BUG]<br>如果在 PIE 中打开多个窗口, 你需要在编辑器首选项中禁用 <code>Run Under One Process</code>, 否则当自动推导 <code>Attribute</code> 所依赖的 <code>Attribute</code> 更新时, 除了第一个窗口外其不会更新.  <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016343.png" alt="Pasted image 20231027115004"></p>
</blockquote>
<h1 id="4-AttributeSet"><a href="#4-AttributeSet" class="headerlink" title="4 AttributeSet"></a>4 AttributeSet</h1><blockquote>
<p>[!NOTE]<br>只能用 C++ 中创建属性和属性集</p>
</blockquote>
<p>GAS 主要通过 <strong>属性集（AttributeSet）</strong> 与 Actor 交互，其中包含 <strong>Gameplay Attribute。</strong></p>
<p>使用 Attribute 可带来多项<strong>优势</strong>：</p>
<ul>
<li>属性集提供了一组一致、可复用的属性，可用于构建系统。</li>
<li>GA 可以通过反射访问 GameplayAttribute，以便可以直接在蓝图编辑器中创建简单的计算和效果。</li>
<li>GameplayAttribute 会<strong>单独</strong>追踪 Base Value 和 Current Value，这样就更容易创建临时修改（增益和减益）以及持久效果。</li>
<li>GameplayAttribute 还<strong>会将其值复制到所有客户端</strong>，适合直观地显示敌方血条等本地 UI。</li>
</ul>
<p>使用多个属性集是完全可能的应用场景，比如玩家和敌人都拥有同一个属性集，包含 Health, Mana, Attack Damage, Defense。而玩家拥有一个额外的属性集包含常见的 RPG 属性，比如 Strength, Intelligence, Constitution 等等。很棒的一点是系统让你能够混用这些属性集，因为属性集注册到 ASC 后，系统可以自动识别属性集属于哪个ASC。</p>
<blockquote>
<p>[!bug]<br>在某些情况下，GameplayAttribute 可以在没有属性集的情况下存在。这通常表明，某个 GameplayAttribute 被保存在一个 ASC 上，而这个组件没有一个包含适当类型 GameplayAttribute 的属性集。这种方法并<strong>不推荐</strong>，因为这种 GameplayAttribute 除了作为浮点值保存外，不会与 GAS 的任何部分交互。</p>
</blockquote>
<h2 id="01-注册-AttributeSet-到-ASC"><a href="#01-注册-AttributeSet-到-ASC" class="headerlink" title="01 注册 AttributeSet 到 ASC"></a>01 注册 AttributeSet 到 ASC</h2><p><code>AttributeSet</code> 继承自 <code>UAttributeSet</code>，用于定义, 保存以及管理对 <code>Attribute</code> 的修改。<strong>在 <code>OwnerActor</code> 的构造函数中创建的 <code>AttributeSet</code> 将会自动注册到 <code>ASC</code>。在此之后，<code>ASC</code> 可以访问你分配给 <code>AttributeSet</code> 的属性。</strong></p>
<p>必须在 C++中注册：</p>
<ol>
<li><p>继承属性集类 <code>UAttributeSet</code>，重载两个重要的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMageAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UMageAttributeSet</span>();</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PreAttributeChange</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, <span class="type">float</span>&amp; NewValue)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostGameplayEffectExecute</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 OwnerActor 和 AvatarActor 上创建属性集</strong>，Getter 函数使用 <strong><code>const</code> 关键字</strong> 来确保代码不能直接修改属性集：</p>
</li>
</ol>
<ul>
<li>对于玩家角色类，在 PlayerState 构造函数中创建属性集<figure class="highlight c++"><figcaption><span>title:在OwnerActor中创建属性集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> AMagePlayerState : <span class="keyword">public</span> APlayerState, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMagePlayerState</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了方便获取属性集，创建一个Getter函数</span></span><br><span class="line">    <span class="function">FORCEINLINE <span class="keyword">virtual</span> UAttributeSet* <span class="title">GetAttributeSet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> AttributeSet; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly)</span><br><span class="line">    TObjectPtr&lt;UAttributeSet&gt; AttributeSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AMagePlayerState::<span class="built_in">AMagePlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line">	AttributeSet = <span class="built_in">CreateDefaultSubobject</span>&lt;UMageAttributeSet&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AttributeSet&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 AvatarActor 上拷贝 MagePlayerState 中的属性集，即 OwnerActor 和 AvatarActor 的属性集是相同的。前文 ASC 的创建也是这样实现。</p>
<figure class="highlight c++"><figcaption><span>title:在AvatarActor中复制属性集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> AMageCharacterBase : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">virtual</span> UAttributeSet* <span class="title">GetAttributeSet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> AttributeSet; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TObjectPtr&lt;UAttributeSet&gt; AttributeSet;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 初始化ASC，前面介绍ASC的时候已经讲过,我们在这里复制属性集，这样就可以随着ASC一起被初始化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitASC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::InitASC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AttributeSet = MagePlayerState-&gt;<span class="built_in">GetAttributeSet</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于敌人角色类，直接在自身构造函数中创建<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMageEnemy::<span class="built_in">AMageEnemy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AttributeSet = <span class="built_in">CreateDefaultSubobject</span>&lt;UMageAttributeSet&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AttributeSet&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>[!warning] 注意</p>
<ul>
<li>一个 <code>ASC</code> 可以有多个属性集，但每个属性集必须与所有其它属性集的<strong>类</strong>不同。</li>
<li>如果使用 <code>GE</code>  来修改 <code>ASC</code> <strong>没有的 <code>GamplayAttribute</code></strong> ，这样做会使技能系统组件为自己创建一个匹配的游戏玩法属性。然而，这个方法并不会创建一个属性集，也不会将游戏玩法属性添加到任何现有的属性集中。</li>
</ul>
</blockquote>
<h2 id="02-定义-Attribute"><a href="#02-定义-Attribute" class="headerlink" title="02 定义 Attribute"></a>02 定义 Attribute</h2><p><strong>Attribute 只能使用 C++ 在 AttributeSet 头文件中定义.</strong> </p>
<p>建议把下面这个 <strong><code>ATTRIBUTE_ACCESSORS</code>宏</strong>添加到每个 <code>AttributeSet</code> 头文件的顶部, 可以很方便的定义每个属性的 Getter、Setter、Init 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该宏复制自AttributeSet.h，使用时将该宏复制到自定义的属性集头文件中，项目中在MageAttributeSet.h中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 自动为每个Attribute生成以下函数：（以Health为例）</span></span><br><span class="line"><span class="comment"> * static FGameplayAttribute UMyHealthSet::GetHealthAttribute(); </span></span><br><span class="line"><span class="comment"> * FORCEINLINE float UMyHealthSet::GetHealth() const; ==&gt; GetCurrentValue</span></span><br><span class="line"><span class="comment"> * FORCEINLINE void UMyHealthSet::SetHealth(float NewVal); ==&gt;  SetBaseValue</span></span><br><span class="line"><span class="comment"> * FORCEINLINE void UMyHealthSet::InitHealth(float NewVal); ==&gt; SetBaseValue / SetCurrentValue</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> * 用法：ATTRIBUTE_ACCESSORS(UMyHealthSet, Health)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">		GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">		GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">		GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">		GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>宏（带参数）</th>
<th>生成函数的签名</th>
<th>行为&#x2F;用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>GAMEPLAYATTRIBUTE_PROPERTY_GETTER(UMyAttributeSet, Health)</code></td>
<td><code>static FGameplayAttribute GetHealth()</code></td>
<td><strong>静态函数</strong>从虚幻引擎的反射系统中返回 <code>FGameplayAttribute</code> 结构</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_GETTER(Health)</code></td>
<td><code>float GetHealth() const</code></td>
<td>返回 CurrentValue</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_SETTER(Health)</code></td>
<td><code>void SetHealth(float NewVal)</code></td>
<td>设置 BaseValue</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_INITTER(Health)</code></td>
<td><code>void InitHealth(float NewVal)</code></td>
<td>初始化 BaseValue 和 CurrentVale</td>
</tr>
</tbody></table>
<p>添加完这些之后，你的属性集类定义应该是如下所示（以 Health 属性为例）：</p>
<figure class="highlight c++"><figcaption><span>title:MageAttributeSet.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMageAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UMageAttributeSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 项目为了添加属性格式统一，将属性声明和宏声明放在了一起，建议实际项目中将属性声明设为protected或private</span></span><br><span class="line"><span class="comment">// 多人游戏需要考虑属性复制</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region <span class="string">&quot;生命值 Health&quot;</span></span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Health)</span><br><span class="line">	FGameplayAttributeData Health;</span><br><span class="line">	<span class="built_in">ATTRIBUTE_ACCESSORS</span>(UMageAttributeSet, Health)</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldData)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AttributeSet</code> 的. cpp 文件应该用<strong>预测系统使用的 <code>GAMEPLAYATTRIBUTE_REPNOTIFY</code> 宏</strong>填充 OnRep 函数。<br>该辅助宏用于 RepNotify 函数，以处理将被客户端预测修改的属性。</p>
<figure class="highlight c++"><figcaption><span>title:MageAttributeSet.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldData)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UMageAttributeSet, Health, OldData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后, <code>Attribute</code>需要添加到<code>GetLifetimeReplicatedProps</code>:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这里列出我们想要复制的属性</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * COND_None：此属性没有条件，并将在其发生变化时随时发送（服务器）</span></span><br><span class="line"><span class="comment">	 * REPNOTIFY_Always：RepNotify函数在客户端值已经与服务端复制的值相同的情况下也会触发(因为有预测)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UMageAttributeSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>REPTNOTIFY_Always</code></strong> 用于设置 OnRep 函数在客户端值已经与服务端复制的值相同的情况下触发(因为有预测), 默认设置下, 客户端值与服务端复制的值相同时, OnRep 函数是不会触发的。</p>
<p>如果 <code>Attribute</code> 无需复制（比如 <code>MetaAttribute</code> ）, 那么 <code>OnRep</code> 和 <code>GetLifetimeReplicatedProps</code> 步骤可以跳过。</p>
<h2 id="03-初始化-Attribute"><a href="#03-初始化-Attribute" class="headerlink" title="03 初始化 Attribute"></a>03 初始化 Attribute</h2><p>有多种方法可以初始化 <code>Attribute</code> (将 BaseValue 和 CurrentValue 设置为某初始值).</p>
<h3 id="通过-GE（推荐）"><a href="#通过-GE（推荐）" class="headerlink" title="通过 GE（推荐）"></a>通过 GE（推荐）</h3><p>建议使用 <code>(Instant)GE</code>修改属性，这种方法可以支持预测, 这也是项目使用的方法。</p>
<p>创建 GE 并设置 Modifier 指定要修改的属性，然后将 GE 应用到角色类的 ASC 即可。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016344.png" alt="Pasted image 20231201165337"><br>详情可查看角色类的 <code>InitDefaultAttributes()</code> 函数</p>
<h3 id="通过-ATTRIBUTE-ACCESSORS-宏的-Init-方法"><a href="#通过-ATTRIBUTE-ACCESSORS-宏的-Init-方法" class="headerlink" title="通过 ATTRIBUTE_ACCESSORS 宏的 Init 方法"></a>通过 ATTRIBUTE_ACCESSORS 宏的 Init 方法</h3><p>如果在定义<code>Attribute</code>时使用了<code>ATTRIBUTE_ACCESSORS</code>宏, 那么在<code>AttributeSet</code>中会自动为每个<code>Attribute</code>生成一个初始化函数.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitHealth(float InitialValue) 是一个自动生成的函数，用于使用 &quot;ATTRIBUTE_ACCESSORS &quot;宏定义的属性 &quot;Health&quot;。</span></span><br><span class="line">AttributeSet-&gt;<span class="built_in">InitHealth</span>(<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>查看<code>AttributeSet.h</code>获取更多初始化<code>Attribute</code>的方法.  </p>
<h3 id="使用数据表初始化-不推荐"><a href="#使用数据表初始化-不推荐" class="headerlink" title="使用数据表初始化(不推荐)"></a>使用数据表初始化(不推荐)</h3><p>如果你选择不通过调用有硬编码值的初始化函数来初始化你的属性集和游戏玩法属性，你可以使用一个<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/data-driven-gameplay-elements-in-unreal-engine">数据表</a>来初始化，使用 <code>AttributeMetaData</code> 类。你可以从外部文件导入数据，或者在编辑器中手动填充数据表。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016345.jpg" alt="c07f187fdff9a045b5651ee5e1a2bd1c_MD5"></p>
<blockquote>
<p>注意命名，必须是已经在C++定义的属性</p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016346.png" alt="Pasted image 20231011204857"></p>
<blockquote>
<p>Character 的 ASC 组件中查看</p>
</blockquote>
<h4 id="导入数据表"><a href="#导入数据表" class="headerlink" title="导入数据表"></a>导入数据表</h4><p>开发者通常会从. csv 文件中导入数据表，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---,BaseValue,MinValue,MaxValue,DerivedAttributeInfo,bCanStack</span><br><span class="line">MyAttributeSet.Health,<span class="string">&quot;100.000000&quot;</span>,<span class="string">&quot;0.000000&quot;</span>,<span class="string">&quot;150.000000&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;False&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>“MinValue”和”MaxValue”栏不会在默认的 GAS 插件中执行，这些值不会有任何影响。</p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016347.jpg" alt="8bea5f5b7314d6e5c82d55d5ec8d6868_MD5"></p>
<p>将. csv 文件导入为数据表资产时，请选择”AttributeMetaData”行类型。</p>
<h4 id="手动填充数据表"><a href="#手动填充数据表" class="headerlink" title="手动填充数据表"></a>手动填充数据表</h4><p>如果你喜欢在虚幻编辑器中编辑数值，而不是在外部电子表格或文本编辑程序中编辑数值，你可以创建表格，然后像其它蓝图资产一样打开它来编辑数值。使用窗口顶部的”添加”按键为每个游戏玩法属性添加一行。请记住，命名惯例是”<code>AttributeSetName.AttributeName</code>“，也就是”属性集名称. 属性名称”，而且是区分大小写的。</p>
<h3 id="多属性集-FAttributeSetInitter"><a href="#多属性集-FAttributeSetInitter" class="headerlink" title="多属性集  FAttributeSetInitter"></a>多属性集  FAttributeSetInitter</h3><p><strong><code>FAttributeSetInitter</code> 是定义在 <code>AttributeSet.h</code> 中的Helper struct，有助于从电子表格（UCurveTable）初始化属性集默认值。</strong>  </p>
<p><strong>可以读取不同的属性集，适合多个属性集的项目</strong></p>
<p>基本思想是在这种形式的电子表格中：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016348.png" alt="Pasted image 20231201161630"></p>
<ul>
<li>表格中行的形式为：[GroupName].[AttributeSetName].[Attribute]  <ul>
<li><code>GroupName</code>：用于标识 “组 “的任意名称  </li>
<li><code>AttributeSetName</code> ：该属性属于哪个 UAttributeSet。(请注意，这只是 UClass 名称的简单部分匹配。”Health”匹配 “UMyGameHealthSet”）。  </li>
<li><code>Attribute</code>： 实际属性的名称（与全名匹配）。</li>
</ul>
</li>
<li>列表示 “Level “。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将把 CurveTable 转换为更有效的格式，以便在运行时读取。例如，应从 UAbilitySystemGlobals 中调用。  </span></span><br><span class="line">FAttributeSetInitter::<span class="built_in">PreloadAttributeSetData</span>(UCurveTable*)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的 GroupName 和 Level 初始化给定 ASC 的属性集。游戏代码会在 Spawn新的Actor 或 Actor升级 等情况下调用此功能。  </span></span><br><span class="line">FAttributeSetInitter::<span class="built_in">InitAttributeSetDefaults</span>(UAbilitySystemComponent* AbilitySystemComponent, FName GroupName, int32 Level) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IGameplayAbilitiesModule::<span class="built_in">Get</span>().<span class="built_in">GetAbilitySystemGlobals</span>()-&gt;<span class="built_in">GetAttributeSetInitter</span>()-&gt;<span class="built_in">InitAttributeSetDefaults</span>(MyCharacter-&gt;AbilitySystemComponent, <span class="string">&quot;Hero1&quot;</span>, MyLevel);</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，系统设计人员就可以为属性指定任意值。它们可以基于任何他们想要的公式。  </li>
<li>等级上限非常高的项目可能希望采用更简单的 “每级获得属性 “方法。  </li>
<li>在此方法中初始化的任何东西都不应该被 GE 直接修改。例如，如果 MaxMoveSpeed 随等级变化，那么其他任何修改 MaxMoveSpeed 的行为都应使用non-instant 的GE  </li>
<li>“Default”目前是硬编码的后备组名。如果调用 InitAttributeSetDefaults 时没有有效的组名，我们将回退到默认组名。</li>
</ul>
<h2 id="04-使用-GE-修改-Attribute"><a href="#04-使用-GE-修改-Attribute" class="headerlink" title="04 使用 GE 修改 Attribute"></a>04 使用 GE 修改 Attribute</h2><ul>
<li>! 我们可以直接修改 Attribute ，方法是使用 <code>const_cast</code> 移除 const。但不推荐在 GAS 框架中这样使用 ^nwhtjz<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(IAbilitySystemInterface* ASInterface = <span class="built_in">Cast</span>&lt;IAbilitySystemInterface&gt;(OtherActor))</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="type">const</span> UMageAttributeSet* MageAttributeSet = <span class="built_in">Cast</span>&lt;UMageAttributeSet&gt;(ASInterface-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">GetAttributeSet</span>(UMageAttributeSet::<span class="built_in">StaticClass</span>())))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//使用const_cast移除 const，进而以一种Hack的方式修改Attribute，危险！</span></span><br><span class="line">			UMageAttributeSet* MutableMageAttributeSet = <span class="built_in">const_cast</span>&lt;UMageAttributeSet*&gt;(MageAttributeSet);</span><br><span class="line">			MutableMageAttributeSet-&gt;<span class="built_in">SetHealth</span>(MageAttributeSet-&gt;<span class="built_in">GetHealth</span>() + <span class="number">10.0f</span>);</span><br><span class="line">			<span class="built_in">Destroy</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>为了实现网络预测，必须通过与之相关的 <code>GE</code> 来修改</strong>。</p>
<h2 id="05-生命周期函数"><a href="#05-生命周期函数" class="headerlink" title="05 生命周期函数"></a>05 生命周期函数</h2><p>属性集提供了多个生命周期函数方法：</p>
<ul>
<li><strong><code>PreAttributeBaseChange ()</code></strong><ul>
<li>当属性的聚合器存在时，当<strong>属性 BaseValue 修改之前</strong>调用。  </li>
<li>此函数应强制执行 Clamp</li>
<li>此函数不应调用与游戏相关的事件或回调。</li>
</ul>
</li>
<li><strong>&#96;PostAttributeBaseChange()</strong><ul>
<li>当属性的聚合器存在时，当<strong>属性的 BaseValue 修改之后</strong>调用</li>
</ul>
</li>
<li><strong><code>PreAttributeChange()</code></strong><ul>
<li>属性的 CurrentValue 修改之前调用</li>
</ul>
</li>
<li><strong><code>PostAttributeChange()</code></strong><ul>
<li>属性的 CurrentValue 修改之后调用</li>
</ul>
</li>
<li><strong><code>PreGameplayEffectExecute()</code></strong><ul>
<li><strong>在 GE 通过 ExecutionCalculation 修改属性集之前调用</strong></li>
<li>带有一个 <code>FGameplayEffectModCallbackData</code> 参数，由 <code>GameplayEffectExecutionCalculation</code> 提供(包含它要修改那个状态，值为多少)。</li>
<li>通过返回一个 bool 值决定是否允许 <code>GameplayEffectExecutionCalculation</code> 影响属性集，默认为true</li>
</ul>
</li>
<li><strong><code>PostGameplayEffectExecute()</code></strong><ul>
<li><strong>在 <code>PreGameplayEffectExecute</code> 返回 true 之后，允许 GE 通过 ExecutionCalculation 修改属性集。该函数发生在 GE 执行之后，Base Value 被修改之前调用。</strong></li>
<li>可以利用被 ExecutionCalculation 修改过的属性来编写逻辑，比如项目中的伤害值元属性 <code>MetaDamage</code> 由 ExecutionCalculation 修改，可以使用 <code>MetaDamage</code> 在这里判断角色是否死亡。</li>
</ul>
</li>
</ul>
<p><strong>以下两个函数是最常用的</strong></p>
<h3 id="06-PreAttributeChange"><a href="#06-PreAttributeChange" class="headerlink" title="06 PreAttributeChange()"></a>06 <code>PreAttributeChange()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PreAttributeChange</span>(<span class="type">const</span> FGameplayAttribute&amp; Attribute, <span class="type">float</span>&amp; NewValue)</span><br></pre></td></tr></table></figure>
<ul>
<li>**在 <code>Attribute</code> 的 <code>CurrentValue</code> 被修改前触发。<ul>
<li><code>(Duration)GE</code> 和 <code>(Infinite)GE</code> 可以修改 <code>CurrentValue</code>.</li>
</ul>
</li>
<li><strong>Clamp 属性值的理想位置。</strong></li>
</ul>
<p>例如项目中 Clamp 生命值属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::PreAttributeChange</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, <span class="type">float</span>&amp; NewValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PreAttributeChange</span>(Attribute, NewValue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 只负责Clamp，不要再这写游戏逻辑 */</span></span><br><span class="line">	<span class="comment">/* 可以响应 Setter 函数和 GameplayEffect 对 CurrentValue 的修改 */</span></span><br><span class="line">	<span class="comment">/* 预修改属性获取Clamp后的NewValue值，但这只发生在属性修改前，不会影响最后NewValue值（即NewValue值最终仍没有被Clamp） */</span></span><br><span class="line">	<span class="keyword">if</span> (Attribute == <span class="built_in">GetHealthAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		NewValue = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(NewValue, <span class="number">0.0f</span>, <span class="built_in">GetMaxHealth</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里做的任何 Clamp 都不会永久性地修改 <code>ASC</code> 中的 <code>Modifier</code>, 只会修改查询 <code>Modifier</code> 的返回值。<br>这意味着属性<strong>修改之后</strong>的操作，像 <code>ExecutionCalculations</code> 和 <code>MMC</code> 这种根据所有 <code>Modifier</code> 重新计算 <code>CurrentValue</code> 的函数需要再次执行限制 (Clamp)操作。执行的位置是 <code>PostGameplayEffectExecute()</code></p>
<blockquote>
<p>[!bug]<br>源码对于 <code>PreAttributeChange()</code>的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做 Clamp 操作. 对于修改 <code>Attribute</code> 的游戏逻辑事件的建议位置是 <code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code> [[#04 监听 Attribute 变化委托]].  </p>
</blockquote>
<h3 id="07-PostGameplayEffectExecute"><a href="#07-PostGameplayEffectExecute" class="headerlink" title="07  PostGameplayEffectExecute()"></a>07  <code>PostGameplayEffectExecute()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PostGameplayEffectExecute</span>(<span class="type">const</span> FGameplayEffectModCallbackData &amp; Data)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在 <code>PreGameplayEffectExecute</code> 返回 true 之后，允许 GE 通过 ExecutionCalculation 修改属性集。该函数发生在 GE 执行之后，<code>Base Value</code> 被修改之前调用。</strong></li>
<li>可以利用被 ExecutionCalculation 修改过的属性来编写逻辑，比如项目中的伤害值元属性 <code>MetaDamage</code> 由 ExecutionCalculation 修改，可以使用 <code>MetaDamage</code> 在这里判断角色是否死亡。</li>
</ul>
<p><strong>项目中在这里进行如下操作：</strong></p>
<ol>
<li>对由 <code>(Instant)GE</code> 进行<strong>初始化的主属性</strong>再次 Clamp（只由 <code>(Instant)GE</code> 修改 BaseValue 的 <code>Attribute</code> 都可以在这里Clamp）</li>
<li>根据主属性的变化更新副属性（使用 Attribute 的 Getter，Setter 函数）</li>
<li>使用 <code>MetaAttribute</code> 进行了伤害计算和经验值计算</li>
</ol>
<blockquote>
<p>[!NOTE]<br>当 <code>PostGameplayEffectExecute()</code> 被调用时, 对 <code>Attribute</code> 的修改已经发生, 但是还没有被复制回客户端, 因此在这里限制值不会造成对客户端的二次复制, 客户端只会接收到限制后的值。</p>
</blockquote>
<h2 id="06-监听-Attribute-变化委托"><a href="#06-监听-Attribute-变化委托" class="headerlink" title="06 监听 Attribute 变化委托"></a>06 监听 Attribute 变化委托</h2><p>[[#06 生命周期函数]] 该小节中的生命周期函数虽然可以感知属性的变化，但是不允许我们在其中执行游戏逻辑。比如执行诸如”生命值属性变化时，让血条 UI 更新”的操作。</p>
<p>为了监听 <code>Attribute</code> 何时变化以便更新 UI 和其他游戏逻辑, ASC 提供了一个委托和对应的 Getter 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Attribute 改变时广播 */</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FOnGameplayAttributeValueChange, <span class="type">const</span> FOnAttributeChangeData&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Getter函数，返回上述委托 */</span>  </span><br><span class="line"><span class="function">FOnGameplayAttributeValueChange&amp; <span class="title">GetGameplayAttributeValueChangeDelegate</span><span class="params">(FGameplayAttribute Attribute)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们只需要调用这个 Getter 函数将其绑定一个当 <code>Attribute</code> 变化时需要调用的回调函数，在回调函数中实现游戏逻辑。</p>
<p>项目中 OverlayWidgetController 中使用该委托绑定<strong>生命值属性</strong>变化回调（没有使用回调函数，而是用的 Lambda 表达式），通过回调再次广播 OnHealthChanged 委托，将新的生命值属性值广播到控件蓝图 <code>WBP_HealthBar</code> 中以更新血条。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BindCallbacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** 绑定ASC属性变化回调，接收属性变化 */</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(<span class="built_in">GetMageAttributeSet</span>()-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddLambda</span>([<span class="keyword">this</span>](<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span><br><span class="line">	&#123;</span><br><span class="line">		OnHealthChanged.<span class="built_in">Broadcast</span>(Data.NewValue);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WBP_HealthBar</code> 中绑定了 OnHealthChanged 委托：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016349.png" alt="Pasted image 20231201214824"><br>还可以通过创建蓝图异步节点 <code>UBlueprintAsyncActionBase</code> [[异步节点#示例]]，或 GAS 内置的 <code>AbilityAsync</code> 类 <code>AbilityAsync_WaitAttributeChanged</code> 实现上述功能。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016350.png" alt="Pasted image 20231202222100"></p>
<h2 id="07-聚合器-Aggregator"><a href="#07-聚合器-Aggregator" class="headerlink" title="07 聚合器 Aggregator"></a>07 聚合器 Aggregator</h2><p><strong>聚合器 “聚” 的是什么？</strong><br>聚的是<strong>属性相关的修改信息</strong>。</p>
<p>从下图可知，一个 ASC 有一个 <code>FActiveGameplayEffectsContainer</code> 实例，一个  <code>FActiveGameplayEffectsContainer</code> 有一个 “属性 -&gt; 聚合器”的映射。</p>
<p>也就是说，<strong>一个聚合器实例</strong>聚合了，针对<strong>一个 ASC 实例</strong>的<strong>一个属性</strong>的**所有修改信息。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016351.jpg" alt="0c442f5ae2a60debd4ef709c0555fb18_MD5"></p>
<p><strong>聚合器的作用：</strong></p>
<ul>
<li><p>属性的计算<br>属性的计算方法，即 Modifier（代码中的 Mod）都在聚合器中，所以属性的计算都在 Aggregator 的一系列数据类型中完成。</p>
</li>
<li><p>属性推导<br>属性之间可以建立相关性，例如，属性 A&#x3D;f (属性 B)。在 B 发生变化后，A 的值也会自动变化。也就是说，我们只需要驱动 B 的变化，然后不需要再调用任何函数，就可以期待 A 的变化发生。</p>
</li>
</ul>
<p>源码解析：[[ 03-1 GameplayEffect 标签面面观 - 属性与聚合器]]</p>
<h3 id="OnAttributeAggregatorCreated"><a href="#OnAttributeAggregatorCreated" class="headerlink" title="OnAttributeAggregatorCreated()"></a><code>OnAttributeAggregatorCreated()</code></h3><p><code>OnAttributeAggregatorCreated()</code> 会在 Aggregator 为集合中的某个 <code>Attribute</code> 创建时触发, 它允许 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/FAggregatorEvaluateMetaData/index.html">FAggregatorEvaluateMetaData</a> 的自定义设置, <code>AggregatorEvaluateMetaData</code> 是 Aggregator 基于所有应用的 <code>Modifier(Modifier)</code> 评估 <code>Attribute</code> 的 CurrentValue 的。</p>
<p>默认情况下, AggregatorEvaluateMetaData 只由 Aggregator 用于确定哪些 <a href="#concepts-ge-mods">Modifier</a> 是满足条件的, 以 MostNegativeMod_AllPositiveMods 为例, 其允许所有正(Positive) <code>Modifier</code> 但是限制负(Negative) <code>Modifier</code> (仅最负的那一个), <strong>这在 Paragon 中只允许将最负移动速度减速效果应用到玩家, 而不用管应用所有正移动速度 buff 时有多少负移动效果</strong>. 不满足条件的 <code>Modifier</code> 仍存于 <code>ASC</code> 中, 只是不被总合进最终的 CurrentValue, 一旦条件改变, 它们之后就可能满足条件, 就像如果最负 <code>Modifier</code> 过期后, 下一个最负 <code>Modifier</code> (如果存在的话)就是满足条件的.   </p>
<p>为了在只允许最负<code>Modifier</code>和所有正<code>Modifier</code>的例子中使用<code>AggregatorEvaluateMetaData</code>:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttributeAggregatorCreated</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGSAttributeSetBase::OnAttributeAggregatorCreated</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnAttributeAggregatorCreated</span>(Attribute, NewAggregator);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!NewAggregator)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Attribute == <span class="built_in">GetMoveSpeedAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		NewAggregator-&gt;EvaluationMetaData = &amp;FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的自定义<code>AggregatorEvaluateMetaData</code>应该作为静态变量添加到<code>FAggregatorEvaluateMetaDataLibrary</code>.  </p>
<h1 id="5-Gameplay-Effect"><a href="#5-Gameplay-Effect" class="headerlink" title="5 Gameplay Effect"></a>5 Gameplay Effect</h1><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016352.png" alt="Pasted image 20231008201140"></p>
<h2 id="01-定义-1"><a href="#01-定义-1" class="headerlink" title="01 定义"></a>01 定义</h2><p><code>GE</code> 可以改变 <code>Attribute</code> 和 <code>GameplayTag</code> ，其可以立即修改 <code>Attribute</code> （例如伤害或治疗）或应用持续状态（buff&#x2F;debuff）。 </p>
<ol>
<li><code>UGameplayEffect</code> 只是一个定义单一游戏效果的<strong>数据类</strong>, 不应该在其中添加额外的逻辑（没有 blueprint graph）。</li>
<li><code>GE</code> 通常不重载基类 <code>UGameplayEffect</code>，被设计成完全通过变量来配置</li>
<li><code>GE</code> 通过 <code>Modifier</code> 和 <code>ExecutionCalculation</code> 修改 <code>Attribute</code>.</li>
</ol>
<h2 id="02-配置项"><a href="#02-配置项" class="headerlink" title="02 配置项"></a>02 配置项</h2><h3 id="（1）Gameplay-Effect"><a href="#（1）Gameplay-Effect" class="headerlink" title="（1）Gameplay Effect"></a>（1）Gameplay Effect</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016353.png" alt="Pasted image 20231203091101"></p>
<ul>
<li>Modifier 和 Executions 后面会讲</li>
<li><code>Conditional Gameplay Effects</code>：当 GE 成功应用时，可以应用其他 GE，<strong>嵌套调用 GE 的方法之一。</strong></li>
</ul>
<h4 id="持续策略-Duration-Policy"><a href="#持续策略-Duration-Policy" class="headerlink" title="持续策略 Duration Policy"></a>持续策略 Duration Policy</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016354.png" alt="Pasted image 20231008232717"><br><code>GE</code> 有三种<strong>持续策略</strong>: <code>(Instant)</code>, <code>(Duration)</code> 和 <code>(Infinite)</code>。</p>
<p><strong>Duration Policy 与 Value 的关系：</strong></p>
<ul>
<li><code>(Instant)GE</code> ：立即永久性修改 <code>BaseValue</code></li>
<li><code>(Periodic)GE</code> ：周期性应用  <code>(Instant)GE</code>  修改 <code>BaseValue</code>。</li>
<li><code>(Duration)GE</code> ：在指定时间内修改 <code>CurrentValue</code>，时间结束后移除该 <code>GE</code>，CurrentValue 值恢复为与 BaseValue 相等。</li>
<li><code>(Infinite)GE</code>：在无限时间内修改 <code>CurrentValue</code>，直到手动移除该 <code>GE</code>，CurrentValue 值恢复为与 BaseValue 相等。</li>
</ul>
<h3 id="（2）Period-周期"><a href="#（2）Period-周期" class="headerlink" title="（2）Period 周期"></a>（2）Period 周期</h3><blockquote>
<p>[!warning]<br><code>(Periodic) GE</code> 不能被预测</p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016355.png" alt="Pasted image 20231008233014"></p>
<p><code>(Duration)GE</code> 和 <code>(Infinite)GE</code> 可以通过设置 Period 转变为 <code>(Periodic)GE</code> , 其每过 X 秒(由周期定义)就应用一次 Modifier 和 EExecution</p>
<ul>
<li>如果由 <code>Duration</code> 转变为 <code>Periodic</code>，则在持续时间内按周期执行</li>
<li>如果由 <code>Infinite</code> 转变为 <code>Periodic</code>，则一直按周期执行，直到手动移除。</li>
</ul>
<p><strong>周期性抑制策略 Periodic Inhibition Policy</strong>：GE 中断并恢复后的处理方式。</p>
<ul>
<li>Never Reset：从被打断时的位置开始计算周期，相当于暂停再播放。</li>
<li>Reset Period：从 0 开始计算周期。</li>
<li>Execute and Reset Period：打断时立即执行一次，下次从 0 开始计算周期。</li>
</ul>
<h3 id="（3）Application-设置-Apply-概率和条件"><a href="#（3）Application-设置-Apply-概率和条件" class="headerlink" title="（3）Application  设置 Apply 概率和条件"></a>（3）Application  设置 Apply 概率和条件</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016356.png" alt="Pasted image 20231203091309"><br>设置 GE 的应用概率和条件。</p>
<p>条件可以简单地用 Tag 去限制，也可以用 <code>Application Requirement</code> 进行更复杂的逻辑判断。</p>
<p>使用 <code>Application Requirement</code> 需要用 C++或蓝图实现 <code>Gameplay Effect Custom Application Requirement</code>（简称 <code>GECAR</code>）类，重载里面的唯一方法，用于<strong>判断是否可以应用 GE。</strong></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016357.png" alt="Pasted image 20231203091555"></p>
<p>官方文档推荐在以下情况使用<code>GECAR</code> </p>
<ul>
<li>目标需要有一定数量的 <code>Attribute</code>.</li>
<li>目标需要有一定数量的 <code>GameplayEffect</code> 堆栈.</li>
<li>除此之外 <code>GECAR</code> 还能够做更多事情，比如检查 <code>Target</code> 是否应用了一个 <code>GE</code> 的实例，在应用一个新实例时如果同类型的实例已存在则只改变其持续时间而（<code>CanApplyGameplayEffect()</code> 要返回 false）。</li>
</ul>
<h3 id="（4）Stacking-堆叠"><a href="#（4）Stacking-堆叠" class="headerlink" title="（4）Stacking 堆叠"></a>（4）Stacking 堆叠</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016358.png" alt="Pasted image 20231203092108"></p>
<p>堆叠处理<strong>对已具有 buff 或 debuff（GE）的目标再次应用 buff 或 debuff ，以及处理”Overflow 溢出”的策略</strong>，溢出是指在原 Gameplay 效果的影响下已完全饱和的目标被应用了新的游戏性效果（例如，不断累积的毒药计时条只有在溢出后才会产生持续伤害效果）。</p>
<ul>
<li><code>GE</code> 默认会应用新的 <code>GE Spec</code> 实例, 而不关心之前已经应用过的尚且存在的 <code>GE Spec</code> 实例。**&#96;</li>
<li><code>GE</code> 可以设置到的堆栈中, 新的 <code>GE Spec</code> 实例不会添加到堆栈中, 而是修改当前已经存在的 <code>GE Spec</code> 堆栈数. </li>
<li>只适用于 <code>(Duration)GE</code> 和 <code>(Infinite)GE</code></li>
</ul>
<h4 id="堆叠类型"><a href="#堆叠类型" class="headerlink" title="堆叠类型"></a>堆叠类型</h4><p><code>Stacking Type</code>:<code>Aggregate（总计） by Source</code> 和 <code>Aggregate by Target</code>.<br>即叠加栈在目标身上 or 施法者身上。</p>
<table>
<thead>
<tr>
<th align="center">堆栈类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Aggregate by Source</td>
<td align="center">Target上的每个<code>SourceASC</code> 都有一个单独的堆栈实例, 每个 Source 可以应用堆栈中的 <code>N</code> 个 <code>GE</code>.</td>
</tr>
<tr>
<td align="center">Aggregate by Target</td>
<td align="center">Target 上只有一个堆栈实例而不管 Source 如何, 每个 Source 都可以在 <code>Shared Stack Limit</code> 内应用堆栈.</td>
</tr>
</tbody></table>
<blockquote>
<p>每层 GE 如果是 Modifiers 来计算，则为直接叠加的效果，比如用 Modifiers 来增加 3 攻击力，则第一层为增加 3 攻击力，则第二层为增加 6 攻击力，则第三层为增加 9 攻击力，而如果需要根据层数不同而改变增加的值，则需要使用 Executions。</p>
</blockquote>
<h4 id="限制堆叠数量"><a href="#限制堆叠数量" class="headerlink" title="限制堆叠数量"></a>限制堆叠数量</h4><p><code>Stack Limit Count</code> 限制 Stack 数量：</p>
<ol>
<li>对于 <code>Aggregate by Source</code>：只限制单个 Source 下的堆栈数量，多个 Source 单独计算</li>
<li>对于 <code>Aggregate by Source</code>，只限制 Target 上的堆栈数量</li>
</ol>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016359.png" alt="Pasted image 20231009094743"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016360.png" alt="Pasted image 20231009095252"></p>
<h4 id="持续时间刷新、周期刷新、过期处理"><a href="#持续时间刷新、周期刷新、过期处理" class="headerlink" title="持续时间刷新、周期刷新、过期处理"></a>持续时间刷新、周期刷新、过期处理</h4><ul>
<li><code>Stack Duration Refresh Policy</code>：Apply 新 GE 时是否刷新持续时间，<strong>注意溢出的 Apply 也会刷新</strong>，想关闭可以在下面的 Overflow 条目关闭。</li>
<li><code>Stack Period Reset Policy</code>：同上，是否刷新周期。</li>
<li><code>Stack Expiration Policy</code>：当一层 GE 的 Duration 到期后的处理方式。<ul>
<li><code>Clear Entire Stack</code>：清空全部层数，如 LOL 征服者。</li>
<li><code>Remove Single Stack and Refresh Duration</code>：清空一层，如 LOL 致命节奏。</li>
</ul>
<ul>
<li><code>Refresh Duration</code>：不清空，相当于无限长的 Duration，但可以通过调用 <code>&#123;cpp&#125;FActiveGameplayEffectsContainer::OnStackCountChange(FActiveGameplayEffect&amp; ActiveEffect, int32 OldStackCount, int32 NewStackCount)</code> 方法来自己处理细节，如一次掉两层。</li>
</ul>
</li>
</ul>
<h4 id="监听堆栈变化"><a href="#监听堆栈变化" class="headerlink" title="监听堆栈变化"></a>监听堆栈变化</h4><p>使用 GAS 自带的 AbilityTask <code>WatiForGameplayEffectStackChange</code><br>例如，可以用它来更新玩家拥有的被动护盾堆栈 (层数)<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016361.png" alt="Pasted image 20231203102432"></p>
<h4 id="溢出-Overflow"><a href="#溢出-Overflow" class="headerlink" title="溢出 Overflow"></a>溢出 Overflow</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016362.png" alt="Pasted image 20231203090746"><br>可以设置 <strong>Stack 溢出</strong>会 Apply 的 GE。<strong>通过 GE 应用 GE 的方法之一，需要配合 Stacking 来使用。</strong><br><code>Deny Overflow Application</code>：如果为 True，则溢出的 Apply 不会刷新 Duration。<br><code>Clear Stack On Overflow</code>：溢出时清空堆栈，需要勾选上一个选项后才能选中。</p>
<h3 id="（5）Expiration-到期应用-GE"><a href="#（5）Expiration-到期应用-GE" class="headerlink" title="（5）Expiration 到期应用 GE"></a>（5）Expiration 到期应用 GE</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016363.png" alt="Pasted image 20231203103058"><br><strong>仅能用于 <code>(Duration)GE</code></strong></p>
<ul>
<li><code>Premature Expiration Effect Classes</code>：当 <code>(Duration)GE</code> 的 Duration 被打断或结束时（如通过强制删除，清除标签等）应用 GE</li>
<li><code>Routine Expiration Effect Classes</code>：当 <code>(Duration)GE</code> 的正常到期时应用 GE</li>
</ul>
<h3 id="（6）Tags-标签"><a href="#（6）Tags-标签" class="headerlink" title="（6）Tags 标签"></a>（6）Tags 标签</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016364.png" alt="Pasted image 20231203104334"><br><strong>和 GA 的 Tag 条目类似，设置各种限制条件。</strong></p>
<p><code>GE</code> 可以带有多个 <code>GameplayTagContainer</code>, 设计师可以编辑每个类别的 <code>Added</code> 和 <code>Removed</code> GameplayTagContainer</p>
<ul>
<li>结果会在编译后显示在 <code>Combined GameplayTagContainer</code> 中. <ul>
<li><code>Added</code> 标签是该 <code>GameplayEffect</code> 新增的之前其父类没有的标签,</li>
<li><code>Removed</code> 标签是其父类拥有但该类没有的标签.  </li>
<li><code>Combined Tag = Parent‘s Tag+ Added - Removed</code></li>
</ul>
</li>
</ul>
<ol>
<li><code>GameplayEffectAssetTag</code>：GE 的 Tag，它们自身没有任何功能且只用于描述 <code>GE</code>。</li>
<li><code>GrantedTags</code>：GE 会赋予目标 ASC 的 Tag，<strong>仅适用于 <code>(Infinite)GE</code> 和 <code>(Duration)GE</code>。</strong></li>
<li><code>GrantedBlockedAbilityTags</code>：</li>
<li><code>Ongoing Tag Requirements</code>：GE 满足 Tag 条件才能修改值（Modifier or Execution）。<ul>
<li>一旦 <code>GE</code> 应用后, 这些标签将决定 <code>GE</code> 是开启还是关闭. <strong><code>GE</code> 可以是关闭但仍然是应用的, 通过这项设置 GE 可以仅 Apply 而不修改值</strong></li>
<li>关闭 <code>GE</code> 会移除其已应用地 <code>Modifier</code> 和 <code>GameplayTag</code> , 但是不会移除该 <code>GE</code>, 重新打开 <code>GE</code> 会重新应用其 <code>Modifier</code> 和 <code>GameplayTag</code>.  </li>
<li>仅适用于 <code>(Infinite)GE</code> 和 <code>(Duration)GE</code>。</li>
<li>Ongoing：持续存在的</li>
</ul>
</li>
<li><code>Application Tag Requirements</code>：GE 满足 Tag 条件才能应用（Apply）。</li>
<li><code>Removal Tag Requirements</code>：GE 满足 Tag 条件就会被移除。</li>
<li><code>Remove Gameplay Effects with Tags</code>：Apply 后移除指定 Tag 的 GE。</li>
<li><code>Remove Gameplay Effect Query</code>：上面一条的高级版，可以匹配 GE 的类（Effect Definition），匹配来源（Effect Source）以及匹配 GE 修改的属性（Modifying Attribute），移除成功匹配的 GE。</li>
</ol>
<h4 id="TagResponseTable（标签响应表）"><a href="#TagResponseTable（标签响应表）" class="headerlink" title="TagResponseTable（标签响应表）"></a>TagResponseTable（标签响应表）</h4><p>这也是一种 Stacking 机制，并不在 GE 本身配置。<br>配置以后，可以自动根据标签的状况改变对应 GE 的 Stacking 数。</p>
<p>制作和配置方法如下：</p>
<ul>
<li>制作响应表数据资产</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016365.jpg" alt="eb28f27ccce179de6f8fbf5b8df38fff_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016366.jpg" alt="b8ed4c1c4f5545c654ce6600c47014b9_MD5"></p>
<p>再将资产路径配置到 DefaultGame. ini 中生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">GameplayTagResponseTableName=&quot;/Game/资产路径/NewDataAsset.NewDataAsset&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置资产数据</li>
</ul>
<p>需要配置的内容是 Entries 数组，每一个成员分为 Possitive 和 Negative 两部分。在起作用时，会分别结算两者的标签层数，来决定最终效果。大致步骤如下（<strong>UGameplayTagReponseTable</strong>:: <em>TagResponseEvent</em> ）：</p>
<ol>
<li>分别获取 Positive（P）和 Negative（N）的标签层数</li>
<li>将读取的 P 和 N 值约束到不大于各自的 SoftCountCap（&gt;0 为有效配置）值</li>
<li>得 | P-N|，即绝对值</li>
<li>若 P&gt;&#x3D;N，则移除 N 的 GE，若 N&gt;&#x3D;P，则移除 P 的 GE</li>
<li>施加 P 和 N 中较大者的 GE，层数为 | P-N|（根据 4，P&#x3D;N 时，所有 GE 都会移除）</li>
</ol>
<h3 id="（7）Immunity-免疫"><a href="#（7）Immunity-免疫" class="headerlink" title="（7）Immunity 免疫"></a>（7）Immunity 免疫</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016367.png" alt="Pasted image 20231203103605"><br><code>GE</code> 可以基于 <code>GameplayTag</code> 实现免疫, 有效阻止其他 <code>GE</code> 应用。</p>
<p>尽管免疫可以由 <code>Application Tag Requirements</code> 等方式有效地实现, 但是<strong>使用该系统可以在 <code>GE</code> 被免疫阻止时提供 <code>&#123;cpp&#125; UAbilitySystemComponent::OnImmunityBlockGameplayEffectDelegate</code> 委托 (Delegate).</strong>  </p>
<p><strong>选项：</strong></p>
<ul>
<li><code>GrantedApplicationImmunityTags</code> 会检查 <code>(Source)ASC</code> (包括源 Ability 的 AbilityTag, 如果有的话)是否包含特定的 Tag , 这是一种基于确定 Character 或源 (Source)的标签对其所有 <code>GE</code> 提供免疫的方法.  <ul>
<li>如果拥有 Require Tags 的所有 Tag，并且没有 Ignore Tags 的所有 Tag，则认为匹配成功，该 GE 不会被 Apply。</li>
</ul>
</li>
<li><code>Granted Application Immunity Query</code> 会检查传入的 <code>GameplayEffectSpec</code> 是否与其查询条件相匹配, 从而阻止或允许其应用。更细粒度地匹配，更消耗性能。<ul>
<li>最后三个选项，分别是根据 GE 修改的 Attribute 匹配、根据 GE 来源匹配以及根据 GE 的类匹配。</li>
</ul>
</li>
</ul>
<h3 id="（8）Display-显示"><a href="#（8）Display-显示" class="headerlink" title="（8）Display 显示"></a>（8）Display 显示</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016368.png" alt="Pasted image 20231203105720"><br>与特效相关的设置，调用 Gameplay Cue 的方式之一<br><code>Require Modifier Success to Trigger Cues</code>：需要 GE 的 Modifier 应用成功来才触发 Cue<br><code>Suppress Stacking Cues</code>:  如果为 true，GameplayCues 将只在堆叠 GE 的第一个实例中被触发。</p>
<h3 id="（9）Granted-Abilities"><a href="#（9）Granted-Abilities" class="headerlink" title="（9）Granted Abilities"></a>（9）Granted Abilities</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016369.png" alt="Pasted image 20231203105748"><br>使用 GE 添加 GA 的方式。仅适用于 <code>(Infinite)GE</code> 和 <code>(Duration)GE</code>。</p>
<ul>
<li><code>Level</code>：GA 的等级。</li>
<li><code>Input ID</code>：如果使用旧版输入，每一个操作映射都对应着一个枚举值，输入对应的枚举值就可以将这个新 GA 绑定到输入上。</li>
<li><code>Removal Policy</code>：设置当 GE 被移除时，GA 是否要移除。<ul>
<li><code>Cancel Ability Immediately</code>：移除，并立即触发 EndAbility，结束 GA。</li>
</ul>
<ul>
<li><code>Remove Ability on End</code>：移除，但是不立即触发 EndAbility，GA 继续运行逻辑直到 EndAbility。</li>
<li><code>Do Nothing</code>：GA 不会被移除，直到手动移除。</li>
</ul>
</li>
</ul>
<p><strong>用法思路：</strong></p>
<ol>
<li>当与 ExecCalc 配合使用时，可将它们用于设置高度特殊的游戏性组合。例如，某个 Actor 具有指示该 Actor 浸在油中的 Gameplay Tags 或属性，当它被以火为主题的 GE 击中时，它就可以获得”着火”技能，从而被动地烧毁附近的 Actor 并在接下来的十秒钟之内产生具有粒子和动态光照的视觉效果。</li>
<li>一个普遍用法是当想要强制另一个玩家做某些事的时候, 像击退或拉取时移动他们, 就会对它们应用一个 <code>GE</code> 来授予其一个自动激活的 <code>GA</code> (查看[[#被动Ability]] 来了解如何在 Ability 被授予时自动激活它), 从而使其做出相应的动作.</li>
</ol>
<h3 id="（10）GE-嵌套"><a href="#（10）GE-嵌套" class="headerlink" title="（10）GE 嵌套"></a>（10）GE 嵌套</h3><p>涉及 3 个配置项，对应不同的条件：</p>
<ul>
<li>[[#(1) Gameplay Effect]]  ：<code>Conditional Gameplay Effects</code>：当 GE 成功应用时，可以应用其他 GE。</li>
</ul>
<ul>
<li>[[#溢出 Overflow]]： <strong>Stack 溢出</strong>会 Apply 的 GE</li>
<li>[[#(5) Expiration 到期应用 GE]]：GE 中断或正常结束时，应用配置好的 GE</li>
</ul>
<h2 id="03-GameplayEffectSpec"><a href="#03-GameplayEffectSpec" class="headerlink" title="03 GameplayEffectSpec"></a>03 GameplayEffectSpec</h2><blockquote>
<p>[!NOTE] 应用场景<br><strong>不需要立即 Apply 的 GE，例如发射物</strong>：直到命中目标后再对目标应用 GE。</p>
</blockquote>
<p>Specification：规格&#x2F;格式<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016370.png" alt="Pasted image 20231203161735"><br> <code>Make Outgoing Spec</code> 源码，内部主要实现了：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FGameplayEffectSpec* NewSpec = <span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(GameplayEffect, Context, Level);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FGameplayEffectSpecHandle</span>(NewSpec);</span><br></pre></td></tr></table></figure><br>注意，返回值不是 <code>FGameplayEffectSpec</code>，而是 <code>FGameplayEffectSpecHandle</code>，Handle 内部保存有指向 <code>FGameplayEffectSpec</code> 的智能指针，<code>&#123;cpp&#125; TSharedPtr&lt;FGameplayEffectSpec&gt;  Data; </code></p>
<ul>
<li><code>GE Spec</code> 默认属性和创建时指定的 GE 的 CDO 相同，在 Apply 之前可以在运行时自由的创建和修改。</li>
</ul>
<ul>
<li>内部保存了 <code>FGameplayEffectContextHandle</code>, 表明该 <code>GameplayEffectSpec</code> 由谁创建。</li>
<li><code>GE Spec</code> 不是 <code>FActiveGameplayEffect</code>，后者是 <code>GE Spec</code> Apply 后返回的新实例，被添加到目标 ASC 的 <code>FActiveGameplayEffectContainer</code> 容器</li>
<li>除了 <code>GE</code> 中设置的授予标签, <code>GE Spec</code> 还会授予目标 (Target) <code>DynamicGrantedTags</code></li>
</ul>
<ul>
<li>存储 <code>TMap&lt;FGameplayTag, float&gt; SetByCallerTagMagnitudes</code> 用于 SetByCaller</li>
</ul>
<p><strong><code>FGameplayEffectSpecHandle</code> 允许蓝图生成一个 GameplayEffectSpec，然后通过句柄的共享指针 <code>Data</code> 引用它，以便多次应用&#x2F;应用多个目标。</strong> 创建 <code>GameplayEffectSpec</code> 需要先创建 <code>FGameplayEffectSpecHandle</code> ： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建FGameplayEffectContextHandle</span></span><br><span class="line"><span class="comment">//FGameplayEffectContextHandle告诉我们该Effect是如何来到这里的（是谁/是什么Apply了该Effect）</span></span><br><span class="line">FGameplayEffectContextHandle EffectContextHandle = </span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">MakeEffectContext</span>();  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建FGameplayEffectSpecHandle</span></span><br><span class="line">FGameplayEffectSpecHandle EffectSpecHandle =  </span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">MakeOutgoingSpec</span>(GameplayEffectClass, <span class="number">1.0f</span>, EffectContextHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展</span></span><br><span class="line"><span class="comment">//通过EffectSpecHandle获取GameplayEffect类的信息：</span></span><br><span class="line">EffectSpecHandle.Data.<span class="built_in">Get</span>()-&gt;Def.<span class="built_in">Get</span>()-&gt;DurationPolicy</span><br></pre></td></tr></table></figure>

<h2 id="04-GameplayEffectContext"><a href="#04-GameplayEffectContext" class="headerlink" title="04 GameplayEffectContext"></a>04 GameplayEffectContext</h2><p>存有 <code>GE Spec</code> 的创建者 <code>Instigator</code> 和相关数据（如 <code>TargetData</code>）, 在 GE Spec 执行的整个过程中都会传递，因此它是<strong>追踪执行过程中瞬时信息的绝佳位置</strong>，可以在以在 MMC&#x2F; ExecutionCalculation, AttributeSet 和 GameplayCue) 之间传递任意数据。<br>默认可以传递的数据：</p>
<ul>
<li>Instigator</li>
<li>EffectCauser</li>
<li>AbilityCDO</li>
<li>AbilityLevel</li>
<li>SourceObject</li>
<li>Actors</li>
<li>HitResult</li>
<li>WorldOrigin</li>
<li>…</li>
</ul>
<p>几个可以添加传递数据的函数<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016371.png" alt="Pasted image 20231203174759"></p>
<h3 id="Instigator-和-EffectCauser"><a href="#Instigator-和-EffectCauser" class="headerlink" title="Instigator 和 EffectCauser"></a>Instigator 和 EffectCauser</h3><p>在 <code>ASC-&gt;MakeOutgoingSpec()</code> 前，我们会调用 <code>ASC-&gt;MakeEffectContex()</code> 创建 <code>FGameplayEffectContextHandle</code>，<code>MakeEffectContex()</code> 会将 <code>OwnerActor</code> 设置为 <code>Instigator</code>，将 <code>AvartarActor</code> 设置为 <code>EffectCauser</code>。</p>
<p><code>Instigator</code> 是指<strong>拥有</strong>产生该效果的 Ability 的对象<br><code>EffectCauser</code> 是指 Effect 的物理来源（如武器）。它们可以是相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取EffectCauser</span></span><br><span class="line">EffectSpecHandle.Data-&gt;<span class="built_in">GetContext</span>().<span class="built_in">GetEffectCauser</span>()</span><br></pre></td></tr></table></figure>


<h3 id="创建-EffectContext-子类"><a href="#创建-EffectContext-子类" class="headerlink" title="创建 EffectContext 子类"></a>创建 EffectContext 子类</h3><p><strong>可以对该结构进行子类化，并添加特定于游戏的信息</strong></p>
<p>步骤：</p>
<ol>
<li>继承 <code>FGameplayEffectContext</code>.</li>
<li>重写 <code>FGameplayEffectContext::GetScriptStruct()</code>.</li>
<li>重写 <code>FGameplayEffectContext::Duplicate()</code>.</li>
<li>如果新数据需要复制的话, 重写 <code>FGameplayEffectContext::NetSerialize()</code>.</li>
<li>对子结构体实现 <code>TStructOpsTypeTraits</code>, 就像父结构体 <code>FGameplayEffectContext</code> 有的那样.</li>
<li>继承 <code>UAbilitySystemGlobals</code> 类，重载 <code>AllocGameplayEffectContext()</code> 以返回一个新的子结构体对象.</li>
</ol>
<h4 id="继承-GameplayEffectContext"><a href="#继承-GameplayEffectContext" class="headerlink" title="继承 GameplayEffectContext"></a>继承 GameplayEffectContext</h4><p>本项目在 <code>MageAbilityTypes.h</code> 文件中创建了一个子结构体 <code>FMageGameplayEffectContext</code>，用于监控自定义的瞬时信息。下面的例子在 EffectContext 中添加了 bool 值 <code>IsCriticalHit</code> </p>
<figure class="highlight c++"><figcaption><span>title:MageAbilityTypes.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 继承 FGameplayEffectContext, 添加自定义数据，在MageAbilitySystemGlobals中配置 */</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FMageGameplayEffectContext</span> : <span class="keyword">public</span> FGameplayEffectContext</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** Getter/Setter */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="type">bool</span> <span class="title">GetIsCriticalHit</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bIsCriticalHit; &#125;</span><br><span class="line">	<span class="function">FORCEINLINE <span class="type">void</span> <span class="title">SetIsCriticalHit</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> InbIsCriticalHit)</span> </span>&#123; bIsCriticalHit = InbIsCriticalHit; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// 自定义网络序列化，子类必须重载该函数（新添加的变量不要忘了加入到该函数中）</span></span><br><span class="line">	<span class="comment">/// @param Ar 保存、加载、储存、序列化数据</span></span><br><span class="line">	<span class="comment">/// @param Map 将对象和名字映射到索引，用于网络通信</span></span><br><span class="line">	<span class="comment">/// @param bOutSuccess 输出是否成功</span></span><br><span class="line">	<span class="comment">/// @return </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回用于序列化的实际结构体，子类必须重载该函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UScriptStruct* <span class="title">GetScriptStruct</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">StaticStruct</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 创建此 GameplayEffectContext 的副本，用于复制以便以后修改 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FMageGameplayEffectContext* <span class="title">Duplicate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		FMageGameplayEffectContext* NewContext = <span class="keyword">new</span> <span class="built_in">FMageGameplayEffectContext</span>();</span><br><span class="line">		*NewContext = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetHitResult</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Does a deep copy of the hit result</span></span><br><span class="line">			NewContext-&gt;<span class="built_in">AddHitResult</span>(*<span class="built_in">GetHitResult</span>(), <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> NewContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 是否暴击 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsCriticalHit = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了结构体&lt;FMageGameplayEffectContext&gt;可以做什么</span></span><br><span class="line"><span class="comment"> * 在TStructOpsTypeTraitsBase2类中可以看到所有功能，标记为true即为开启对应功能</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;FMageGameplayEffectContext&gt; : <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FMageGameplayEffectContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span>,</span><br><span class="line">		WithCopy = <span class="literal">true</span>		<span class="comment">//必须开启，用于将 TSharedPtr&lt;FHitResult&gt; 数据复制到各处</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="NetSerialize"><a href="#NetSerialize" class="headerlink" title="NetSerialize"></a>NetSerialize</h4><figure class="highlight c++"><figcaption><span>title:MageAbilityTypes.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FMageGameplayEffectContext::NetSerialize</span><span class="params">(FArchive&amp; Ar, UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *当序列化所有对象时，构造的 所有变量都转换为0和1的字符串</span></span><br><span class="line"><span class="comment">	 *FArchive重载 &lt;&lt;左移运算符，可以用于序列化和反序列化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	uint32 RepBits = <span class="number">0</span>; <span class="comment">//默认为无符号8位整数，用于存储8个bool值。二进制为0000 0000，每一位代表一个bool值, 因为我们用到了多个参数, 扩展到uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Ar.<span class="built_in">IsSaving</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bReplicateInstigator &amp;&amp; Instigator.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//等价于 RepBits = RepBits | (1 &lt;&lt; 0);</span></span><br><span class="line">			<span class="comment">//首先计算(1 &lt;&lt; 0)：1（0000 0001）左移0位，结果为0000 0001</span></span><br><span class="line">			<span class="comment">//然后进行按位或：RepBits = 0000 0000 | 0000 0001 = 0000 0001</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (bReplicateEffectCauser &amp;&amp; EffectCauser.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//等价于 RepBits = RepBits | (1 &lt;&lt; 1);</span></span><br><span class="line">			<span class="comment">//首先计算(1 &lt;&lt; 1)：1（0000 0001）左移1位，结果为0000 0010</span></span><br><span class="line">			<span class="comment">//然后进行按位或：RepBits = 0000 0001 | 0000 0010 = 0000 0011</span></span><br><span class="line">			<span class="comment">//...以此类推, 每一位对应一个bool值</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (AbilityCDO.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (bReplicateSourceObject &amp;&amp; SourceObject.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Actors.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(HitResult.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (bHasWorldOrigin)</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/** 自定义数据 */</span></span><br><span class="line">		<span class="keyword">if</span> (bIsCriticalHit)</span><br><span class="line">		&#123;</span><br><span class="line">			RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ar.<span class="built_in">SerializeBits</span>(&amp;RepBits, <span class="number">7</span>); <span class="comment">//序列化位数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取序列化数据</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 按位与，假设经过上述的处理得到了RepBits = 0111 1101</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) <span class="comment">// 0111 1101 &amp; 0000 0001 = 0000 0001, 对应的倒数第一位为1，所以从Ar中取值</span></span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; Instigator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) <span class="comment">// 0111 1101 &amp; 0000 0010 = 0000 0000, 对应的倒数第二位为0, 所以不从Ar中取值</span></span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; EffectCauser;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) <span class="comment">// 0111 1101 &amp; 0000 0100 = 0000 0100, 对应的倒数第三位为1，所以从Ar中取值</span></span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; AbilityCDO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; SourceObject;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SafeNetSerializeTArray_Default</span>&lt;<span class="number">31</span>&gt;(Ar, Actors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!HitResult.<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				HitResult = <span class="built_in">TSharedPtr</span>&lt;FHitResult&gt;(<span class="keyword">new</span> <span class="built_in">FHitResult</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		HitResult-&gt;<span class="built_in">NetSerialize</span>(Ar, Map, bOutSuccess);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; WorldOrigin;</span><br><span class="line">		bHasWorldOrigin = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bHasWorldOrigin = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; bIsCriticalHit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AddInstigator</span>(Instigator.<span class="built_in">Get</span>(), EffectCauser.<span class="built_in">Get</span>()); <span class="comment">// Just to initialize InstigatorAbilitySystemComponent</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bOutSuccess = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="继承-UAbilitySystemGlobals"><a href="#继承-UAbilitySystemGlobals" class="headerlink" title="继承 UAbilitySystemGlobals"></a>继承 UAbilitySystemGlobals</h4><p>参考本项目中的 <code>MageAbilitySystemGlobals.h</code></p>
<p>需要在 <code>DefaultGame.ini</code> 中指定全局类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 指定全局类 */</span></span><br><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">AbilitySystemGlobalsClassName=<span class="string">&quot;/Script/ProjectGASRPG.MageAbilitySystemGlobals&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MageAbilitySystemGlobals.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMageAbilitySystemGlobals : <span class="keyword">public</span> UAbilitySystemGlobals</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 创建一个新的FMageGameplayEffectContext让ASC使用, 在 UAbilitySystemComponent::MakeEffectContext() 中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FGameplayEffectContext* <span class="title">AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MageAbilitySystemGlobals.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FGameplayEffectContext* <span class="title">UMageAbilitySystemGlobals::AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FMageGameplayEffectContext</span>(); <span class="comment">//返回自定义的MageGameplayEffectContext结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用自定义的信息"><a href="#使用自定义的信息" class="headerlink" title="使用自定义的信息"></a>使用自定义的信息</h4><p>完成上述步骤后，就可以通过访问 <code>FMageGameplayEffectContext</code> 来 Getter&#x2F;Setter <code>bIsCriticalHit</code> 。</p>
<p>本项目在自定义的蓝图函数库中实现了静态 Getter&#x2F;Setter 函数 , 用于访问 <code>bIsCriticalHit</code>。</p>
<figure class="highlight c++"><figcaption><span>title:BlueprintFunctionLibrary</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置暴击状态</span></span><br><span class="line"><span class="comment"> * - UPARAM(ref)宏：使参数通过非const引用传递并仍然显示为输入引脚（默认为输出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetIsCriticalHit</span><span class="params">(UPARAM(ref) FGameplayEffectContextHandle&amp; EffectContextHandle, <span class="type">const</span> <span class="type">bool</span> bIsCriticalHit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAbilitySystemLibrary::SetIsCriticalHit</span><span class="params">(FGameplayEffectContextHandle&amp; EffectContextHandle,<span class="type">const</span> <span class="type">bool</span> bIsCriticalHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FMageGameplayEffectContext* MageEffectContext = <span class="built_in">static_cast</span>&lt;FMageGameplayEffectContext*&gt;(EffectContextHandle.</span><br><span class="line">		<span class="built_in">Get</span>())) <span class="comment">//注意这里不能用Cast, Cast不能用于结构体</span></span><br><span class="line">	&#123;</span><br><span class="line">		MageEffectContext-&gt;<span class="built_in">SetIsCriticalHit</span>(bIsCriticalHit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/** 获取爆击状态 */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GetIsCriticalHit</span><span class="params">(<span class="type">const</span> FGameplayEffectContextHandle&amp; EffectContextHandle)</span></span>;</span><br><span class="line">    	</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMageAbilitySystemLibrary::GetIsCriticalHit</span><span class="params">(<span class="type">const</span> FGameplayEffectContextHandle&amp; EffectContextHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> FMageGameplayEffectContext* MageEffectContext = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> FMageGameplayEffectContext*&gt;(</span><br><span class="line">        EffectContextHandle.<span class="built_in">Get</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MageEffectContext-&gt;<span class="built_in">GetIsCriticalHit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 ExecCalc_Damage 中计算伤害时，将爆击状态传入 EffectContext：</p>
<figure class="highlight c++"><figcaption><span>title:ExecCalc_Damage.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 是否暴击 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bIsCriticalHit = FMath::<span class="built_in">RandRange</span>(<span class="number">0.f</span>, <span class="number">1.f</span>) &lt;= Source_CriticalHitChance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取EffectContext，同步暴击状态 */</span></span><br><span class="line">UMageAbilitySystemLibrary::<span class="built_in">SetIsCriticalHit</span>(EffectContextHandle, bIsCriticalHit);</span><br></pre></td></tr></table></figure>

<p>在属性集中计算 MetaDamage 时，获取爆击状态，根据是否暴击显示不同样式的伤害浮动数字</p>
<figure class="highlight c++"><figcaption><span>title:MageAttributeSet.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 显示伤害浮动数字 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bIsCriticalHit = UMageAbilitySystemLibrary::<span class="built_in">GetIsCriticalHit</span>(Property.EffectContextHandle);</span><br><span class="line"><span class="built_in">ShowDamageFloatingText</span>(Property, TempMetaDamage,bIsCriticalHit);</span><br></pre></td></tr></table></figure>

<h2 id="05-应用-Apply"><a href="#05-应用-Apply" class="headerlink" title="05 应用 Apply"></a>05 应用 Apply</h2><p><strong><code>GameplayEffect</code> 可以被 <code>GA</code> 和 <code>ASC</code> 中的多个函数应用, 其通常是 <code>ApplyGameplayEffectTo</code> 的形式。</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016372.png" alt="Pasted image 20231008205512"><br>这些函数最终都在目标上调用 <code>ApplyGameplayEffectSpecToSelf()</code> 。当调用 <code>ApplyGameplayEffect</code> 时,  内部会从 <code>GE</code> 创建 <code>GE Spec</code> ，实际 Apply 到目标 (Target)的是该 <code>GE Spec</code>。</p>
<p>为了在 <code>GA</code> 之外应用 <code>GE</code>, 例如对于某个投掷物, 你就需要获取到目标的 <code>ASC</code> 并使用它的函数之一来 <code>ApplyGameplayEffectToSelf</code>。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016373.png" alt="Pasted image 20231203113437"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//项目中封装的函数，展示了应用GE的简单流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAbilitySystemLibrary::ApplyEffectToSelf</span><span class="params">(UAbilitySystemComponent* ASC,</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	checkf(GameplayEffectClass, TEXT(<span class="string">&quot;GameplayEffectClass为空，请在 %s 中设置&quot;</span>), *ASC-&gt;GetOwner()-&gt;GetName());</span></span></span><br><span class="line"><span class="params"><span class="function">	FGameplayEffectContextHandle EffectContextHandle = ASC-&gt;MakeEffectContext();</span></span></span><br><span class="line"><span class="params"><span class="function">	EffectContextHandle.AddSourceObject(ASC-&gt;GetAvatarActor()); <span class="comment">//添加源对象，计算MMC时会用到</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FGameplayEffectSpecHandle EffectSpecHandle = ASC-&gt;MakeOutgoingSpec(GameplayEffectClass, Level, EffectContextHandle);</span></span></span><br><span class="line"><span class="params"><span class="function">	ASC-&gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data); <span class="comment">//返回FActiveGameplayEffectHandle</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>


<h2 id="06-移除-Remove"><a href="#06-移除-Remove" class="headerlink" title="06 移除 Remove"></a>06 移除 Remove</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016374.png" alt="Pasted image 20231203113522"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016375.png" alt="Pasted image 20231203113654"><br><code>GameplayEffect</code> 可以被 <code>GameplayAbility</code> 和 <code>ASC</code> 中的多个函数移除，本质上都是最终在目标上调用 <code>RemoveActiveEffects()</code> 函数。<br><code>Remove</code> 函数需要传入一个 <code>FActiveGameplayEffectHandle</code> 来引用指定的 GE，通常来自与 <code>Apply</code> 函数 的返回值。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016376.png" alt="Pasted image 20231203113857"></p>
<h2 id="07-修饰符-Modifier"><a href="#07-修饰符-Modifier" class="headerlink" title="07 修饰符 Modifier"></a>07 修饰符 Modifier</h2><blockquote>
<p>[!NOTE] 理解<br>Modifier 就是一个数学运算的过程！变量 &amp;&amp; 操作符 &#x3D; Modifier</p>
</blockquote>
<p><code>Modifier</code> 可以修改 <code>Attribute</code> 并且是<strong>唯一可以预测修改 <code>Attribute</code> 的方法</strong>。<br>一个 <code>GE</code> 可以有0个或多个 <code>Modifier</code>, 每个 <code>Modifier</code> 通过某个指定的操作只能修改一个 <code>Attribute</code>。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th align="center">ModifierOP</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Add</td>
<td align="center">将<code>Modifier</code>指定的<code>Attribute</code>加上计算结果. 使用负数以实现减法操作.</td>
</tr>
<tr>
<td align="center">Multiply</td>
<td align="center">将<code>Modifier</code>指定的<code>Attribute</code>乘以计算结果.</td>
</tr>
<tr>
<td align="center">Divide</td>
<td align="center">将<code>Modifier</code>指定的<code>Attribute</code>除以计算结果.</td>
</tr>
<tr>
<td align="center">Override</td>
<td align="center">使用计算结果覆盖<code>Modifier</code>指定的<code>Attribute</code>.</td>
</tr>
</tbody></table>
<p><strong>Attribute 的 <code>CurrentValue</code> 是其所有 <code>Modifier</code> 与其 <code>BaseValue</code> 计算得到的结果。</strong><br>像下面这样的 <code>Modifier</code> 计算公式被定义在 <code>GameplayEffectAggregator.cpp</code> 中的 <code>FAggregatorModChannel::EvaluateWithBase</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((InlineBaseValue + Additive) * Multiplicitive) / Division</span><br></pre></td></tr></table></figure>

<p>Override <code>Modifier</code> 会优先覆盖最后应用的 <code>Modifier</code> 得出的最终值.  </p>
<blockquote>
<p>[!NOTE]<br>对于基于百分比的修改, 确保使用<code>Multiply</code>操作以使其在加法操作之后  </p>
</blockquote>
<blockquote>
<p>[!bug]<br> <a href="#concepts-p">预测(Prediction)</a>对于百分比修改有些问题.  </p>
</blockquote>
<h3 id="计算类型"><a href="#计算类型" class="headerlink" title="计算类型"></a>计算类型</h3><p><strong>有四种 <code>Magnitude Calculation Type</code></strong>: </p>
<ul>
<li><code>ScalableFloat</code></li>
<li><code>AttributeBased</code></li>
<li><code>CustomCalculationClass（MMC）</code></li>
<li><code>SetByCaller</code>,<br>它们全都生成一些浮点数, 用于之后基于各自的操作修改指定 <code>Modifier</code> 的 <code>Attribute</code>.</li>
</ul>
<h4 id="Scalable-Float"><a href="#Scalable-Float" class="headerlink" title="Scalable Float"></a>Scalable Float</h4><p>指定一个 FScalableFloat 直接计算</p>
<p>FScalableFloat 结构体可以指向某个横向为变量, 纵向为等级的 Data Table, <code>Scalable Float</code> 会以 Ability 的当前等级自动读取指定 Data Table 的某行值(或者在 <code>GE Spec</code> 中重写的不同等级), 读取到的值会乘以系数(默认为 1)<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016377.png" alt="Pasted image 20231203115507"></p>
<h4 id="Attribute-Based"><a href="#Attribute-Based" class="headerlink" title="Attribute Based"></a>Attribute Based</h4><p>基于已有的属性进行计算 [[#05 派生属性 Derived Attribute]]</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016378.png" alt="Pasted image 20231203120120"></p>
<ul>
<li><code>Backing Attribute</code>：将 Source(<code>GE Spec</code> 的创建者)或 Target(<code>GE Spec</code> 的接收者)上的 CurrentValue 或 BaseValue 视为 <code>Backing Attribute</code> (备份属性), <ul>
<li>可以使用<strong>系数</strong>（Coefficient）和 Pre Add 与 Post Add 来修改它：<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016379.png" alt="Pasted image 20231011231811"></li>
</ul>
</li>
<li><strong>多个 Modifier 计算顺序</strong>：从上到下 <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016380.png" alt="Pasted image 20231011231410"></li>
<li><code>Attribute Curve</code>：基于 CurveTable 计算，代替直接使用 <code>Backing Attribute</code></li>
<li><code>Attribute Calculation Type</code>：<ul>
<li><code>Attribute Magnitude</code>：使用最终的计算值（默认选项，即捕获的属性经过数 Coefficient 和 Pre Add 与 Post Add 计算后的值 ）</li>
<li><code>Attribute Base Value</code>：使用属性的BaseValue</li>
<li><code>Attribute Bonus Magnitude</code>: 使用属性的加成值，即 <code>Attribute Magnitude - Attribute Base Value</code></li>
</ul>
</li>
</ul>
<h4 id="CustomCalculationClass（MMC）"><a href="#CustomCalculationClass（MMC）" class="headerlink" title="CustomCalculationClass（MMC）"></a>CustomCalculationClass（MMC）</h4><blockquote>
<p>[!NOTE] 应用场景<br><strong>可以捕获多个 Attribute，但只能修改一个 Atrribute</strong>。比如可以用于属性计算，攻击力由力量和敏捷属性共同影响，捕获力量和敏捷属性，然后修改攻击力属性。</p>
</blockquote>
<p><code>CustomCalculationClass</code> 需要指定 <code>UGameplayModMagnitudeCalculation</code> 类来计算 Modifier （简称 MMC）</p>
<ul>
<li>MMC 为复杂的 <code>Modifier</code> 提供了最大的灵活性</li>
<li><code>MMC</code> 的优势在于能够完全访问 <code>GameplayEffectSpec</code> 来读取 <code>GameplayTag</code> 和 <code>SetByCaller</code>，从而能够捕获 <code>GE</code> 的 <code>源(Source)</code> 或 <code>目标(Target)</code> 上任意数量的 <code>Attribute</code> 值。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016381.png" alt="Pasted image 20231012111224"></li>
</ul>
<p>捕获 <code>Attribute</code> 会自 <code>ASC</code> 现有的 <code>Modifier</code> 重新计算它们的 <code>CurrentValue</code>, 该重新计算<strong>不会</strong>执行 <code>AbilitySet</code> 中的 <code>PreAttributeChange()</code>, <strong>因此 Clamp 操作必须在 <code>PostGameplayEffectExecute()</code> 中重新处理。</strong></p>
<h5 id="UGameplayModMagnitudeCalculation"><a href="#UGameplayModMagnitudeCalculation" class="headerlink" title="UGameplayModMagnitudeCalculation"></a>UGameplayModMagnitudeCalculation</h5><p><code>UGameplayModMagnitudeCalculation</code> 是用于通过蓝图或 C++ 执行自定义 Modifier 计算的类。它的功能相比 <code>GameplayEffectExecutionCalculation</code> 要弱一些（只能修改一个 Attribute）, <strong>但优点是它是可预测的</strong>. </p>
<p><strong>它唯一要做的就是自 <code>CalculateBaseMagnitude_Implementation()</code> 返回浮点值（可以使用系数（Coefficient）和 Pre 与 Post 进一步处理浮点值结果），你可以在 C++和蓝图中继承并重写该函数.</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category=<span class="string">&quot;Calculation&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CalculateBaseMagnitude</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>内置宏，用于声明捕获属性的</p>
<figure class="highlight c++"><figcaption><span>title:GameplayEffectExecutionCalculation.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 声明捕获属性</span></span><br><span class="line"><span class="comment">/// @param P 捕获的属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_ATTRIBUTE_CAPTUREDEF(P) \</span></span><br><span class="line"><span class="meta">	FProperty* P##Property; \</span></span><br><span class="line"><span class="meta">	FGameplayEffectAttributeCaptureDefinition P##Def; \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/// 定义捕获属性</span></span><br><span class="line"><span class="comment">/// @param S 属性集</span></span><br><span class="line"><span class="comment">/// @param P 捕获的属性</span></span><br><span class="line"><span class="comment">/// @param T 从GE的Source还是Target处捕获属性</span></span><br><span class="line"><span class="comment">/// @param B 是否Snapshot</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_ATTRIBUTE_CAPTUREDEF(S, P, T, B) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	P##Property = FindFieldChecked<span class="string">&lt;FProperty&gt;</span>(S::StaticClass(), GET_MEMBER_NAME_CHECKED(S, P)); \</span></span><br><span class="line"><span class="meta">	P##Def = FGameplayEffectAttributeCaptureDefinition(P##Property, EGameplayEffectAttributeCaptureSource::T, B); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以项目中的 <code>MMC_Defence</code> 类为例，该类继承自 <code>UGameplayModMagnitudeCalculation</code>，用于计算副属性防御力。需要捕获 Source Attribute<br><code>Stamina</code> (主属性-体力)，计算公式为 <code>Defence = (Stamina * 4.8f) + PlayerLevel</code></p>
<figure class="highlight c++"><figcaption><span>title:MMC_Defence.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UMMC_Defence : <span class="keyword">public</span> UGameplayModMagnitudeCalculation</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UMMC_Defence</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 声明捕获属性*/</span></span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Stamina);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:MMC_Defence.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">UMMC_Defence::<span class="built_in">UMMC_Defence</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义捕获属性，第四个参数是Snapshot</span></span><br><span class="line">	<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UMageAttributeSet, Stamina, Target, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉与计算相关的属性</span></span><br><span class="line">    <span class="comment">// 可以通过 GetAttributeCaptureDefinitions() 访问</span></span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(StaminaDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UMMC_Defence::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获取Tag</span></span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在聚合器评估中使用的数据</span></span><br><span class="line">	FAggregatorEvaluateParameters EvaluationParameters;</span><br><span class="line">	EvaluationParameters.SourceTags = SourceTags;</span><br><span class="line">	EvaluationParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从捕获属性中获取BaseValue</span></span><br><span class="line">	<span class="type">float</span> Stamina = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="built_in">GetCapturedAttributeMagnitude</span>(StaminaDef, Spec, EvaluationParameters, Stamina);</span><br><span class="line">	Stamina = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Stamina,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的接口，获取角色等级</span></span><br><span class="line">	<span class="type">const</span> ICombatInterface* CombatInterface = <span class="built_in">Cast</span>&lt;ICombatInterface&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetSourceObject</span>());</span><br><span class="line">	<span class="type">const</span> int32 PlayerLevel = CombatInterface-&gt;<span class="built_in">GetCharacterLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应用计算公式</span></span><br><span class="line">	<span class="keyword">return</span> (Stamina * <span class="number">4.8f</span>) + PlayerLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你没有在 <code>MMC</code> 的构造函数中将 <code>FGameplayEffectAttributeCaptureDefinition</code> 添加到 <code>RelevantAttributesToCapture</code> 中并且尝试捕获 <code>Attribute</code>, 那么将会得到一个关于捕获时缺失 Spec 的错误. 如果不需要捕获 <code>Attribute</code>, 那么就不必添加什么到 <code>RelevantAttributesToCapture</code>.  </p>
<h4 id="Set-By-Caller"><a href="#Set-By-Caller" class="headerlink" title="Set By Caller"></a>Set By Caller</h4><p>直译就是<strong>由调用者（即 <code>GA</code> 或 <code>GE Spec</code> 的创建者 ）设置</strong></p>
<p><code>SetByCaller</code> Modifier 是运行时由 <code>GA</code> 或 <code>GE Spec</code> 的创建者于 <code>GE</code> 之外设置的值, <strong>例如, 如果你想让伤害值随玩家蓄力技能的长短而变化（本项目的技能蓝图 <code>GA_Laser</code> 实现了该功能）</strong>, 那么就需要使用 <code>SetByCaller</code>。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016382.png" alt="Pasted image 20231203150843"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 设置SetbyCaller Magnitude，将float值与Tag一一对应，获取时指定Tag即可获取*/</span></span><br><span class="line"><span class="function">FGameplayEffectSpecHandle <span class="title">UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude</span><span class="params">(FGameplayEffectSpecHandle SpecHandle, FGameplayTag DataTag, <span class="type">float</span> Magnitude)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 内部调用了这个函数：</span></span></span><br><span class="line"><span class="function"><span class="comment">/** Sets the magnitude of a SetByCaller modifier */</span>  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="type">float</span> Magnitude)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取SetbyCaller Magnitude*/</span></span><br><span class="line"><span class="comment">/** Returns the magnitude of a SetByCaller modifier. Will return 0.f and Warn if the magnitude has not been set. */</span>  </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetSetByCallerMagnitude</span><span class="params">(FGameplayTag DataTag, <span class="type">bool</span> WarnIfNotFound = <span class="literal">true</span>, <span class="type">float</span> DefaultIfNotFound = <span class="number">0.f</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>SetByCaller</code> 本质上是存于 <code>GE Spec</code> 中的 <code>TMap&lt;FGameplayTag, float&gt;</code>, <code>Modifier</code> 只是告知 <code>Aggregator</code> 去寻找与提供的 <code>GameplayTag</code> 相关联的 <code>SetByCaller</code> 值。</p>
<blockquote>
<p>[!tip]<br>另外还有根据 FName 标记 SetbyCaller 的函数，建议只使用 <code>GameplayTag</code> 形式而不是 <code>FName</code> 形式, 这可以避免蓝图中的拼写错误, 并且当 <code>GE Spec</code> 复制时, <code>GameplayTag</code> 比 <code>FName</code> 在网络传输中更有效率, 因为 <code>TMap</code> 也会复制.  </p>
</blockquote>
<p><strong>用法：</strong><br>首先创建一个 Outgoing GE Spec, 在应用 GE 之前调用 <code>SetSetByCallerMagnitude</code>，完成设置（GE 中设置的 <code>DataTag</code> 要与 <code>Assign Tag Set by Caller Magenitude</code> 输入的<code>DataTag</code>一致）。后续在在 MMC 或者 ExecCalc 中计算结果时通过返回的 <code>GE Spec</code> 调用 <code>GetSetByCallerMagnitude</code> 就可以获取到设置的值。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016383.png" alt="Pasted image 20231203153421"></p>
<p>我认为 Set By Caller 这种计算方法在蓝图的使用中更为灵活，比如有一个 GE 用来对敌人造成伤害，伤害的大小可以在该项技能的 GA 中通过 Caller 传入。当然 C++中也可以使用。</p>
<hr>
<p>在本项目技能蓝图 <code>GA_Laser</code> 中，实现了根据蓄力时间增加伤害：</p>
<ol>
<li>通过内置的 AbilityTask：<code>WaitInputRelease</code> 获取了按键按压时间</li>
<li>然后使用 Set by Caller 设置蓄力后的伤害值</li>
<li>最后应用 <code>GE_ExecCalc_Damage</code> 通过 ExecCalc 获取 SetbyCaller Magnitude 来计算最终伤害。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016384.png" alt="Pasted image 20231203154833|400"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016385.png" alt="Pasted image 20231203154541"></li>
</ol>
<h3 id="Snapshot-快照"><a href="#Snapshot-快照" class="headerlink" title="Snapshot 快照"></a>Snapshot 快照</h3><p>使用 Attribute Base 或 MMC、ExecCalc 时都可以设置是否开启 Snapshot，<code>Snapshot</code> 用于确定<strong>捕获属性的时机</strong></p>
<table>
<thead>
<tr>
<th align="center">Snapshot</th>
<th align="center">源 (Source)或目标 (Target)</th>
<th align="center">在 GE Spec 中捕获时机</th>
<th align="center">Attribute 被 (Infinite)或 (Duration) GE 修改时自动更新</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开</td>
<td align="center">Source</td>
<td align="center">创建时</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">开</td>
<td align="center">Target</td>
<td align="center">应用时</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">关</td>
<td align="center">Source</td>
<td align="center">应用时</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">关</td>
<td align="center">Target</td>
<td align="center">应用时</td>
<td align="center">是</td>
</tr>
</tbody></table>
<ul>
<li>开启，则捕获 <code>GE Spec</code> 创建时的 <code>Attribute</code><ul>
<li>这时只能捕获 Source 属性，因为刚创建也不知道 Target 是谁！</li>
<li>如果仍选择 Target 属性，则是在应用时捕获</li>
<li>不会自动更新</li>
</ul>
</li>
<li>关闭，则捕获 <code>GE Spec</code> 应用时的 <code>Attribute</code> <ul>
<li>该 <code>Attribute</code> 被 <code>(Infinite)GE</code> 或 <code>(Duration)GE</code>  修改时会自动更新</li>
</ul>
</li>
</ul>
<h3 id="Multiply-和-Divide-Modifier"><a href="#Multiply-和-Divide-Modifier" class="headerlink" title="Multiply 和 Divide Modifier"></a>Multiply 和 Divide Modifier</h3><p>默认情况下, 所有的<code>Multiply</code>和<code>Divide</code>Modifier在对<code>Attribute</code>的BaseValue乘除前都会先加到一起.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::EvaluateWithBase</span><span class="params">(<span class="type">float</span> InlineBaseValue, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">float</span> Additive = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Additive], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Additive), Parameters);</span><br><span class="line">	<span class="type">float</span> Multiplicitive = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Multiplicitive], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Multiplicitive), Parameters);</span><br><span class="line">	<span class="type">float</span> Division = <span class="built_in">SumMods</span>(Mods[EGameplayModOp::Division], GameplayEffectUtilities::<span class="built_in">GetModifierBiasByModifierOp</span>(EGameplayModOp::Division), Parameters);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ((InlineBaseValue + Additive) * Multiplicitive) / Division;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::SumMods</span><span class="params">(<span class="type">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="type">float</span> Bias, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> Sum = Bias;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Sum += (Mod.EvaluatedMagnitude - Bias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>摘自GameplayEffectAggregator.cpp</em>  </p>
<p>在该公式中<code>Multiply</code>和<code>Divide</code>Modifier都有一个值为1的<code>Bias</code>值(加法的<code>Bias</code>值为0), 因此它看起来像:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + (Mod1.Magnitude - <span class="number">1</span>) + (Mod2.Magnitude - <span class="number">1</span>) + ...</span><br></pre></td></tr></table></figure>

<p>该公式会导致一些意料之外的结果, 首先, 它在对BaseValue乘除之前将所有的<code>Modifier</code>都加到了一起, 大部分人都期望将其乘或除在一起, 例如, 你有两个值为1.5的<code>Multiply</code>Modifier, 大部分人都期望将BaseValue乘上<code>1.5 x 1.5 = 2.25</code>, 然而, 这里是将两个1.5加在一起再乘以BaseValue(50%增量 + 另一个50%增量 &#x3D; 100%增量).拿<code>GameplayPrediction.h</code>中的一个例子来说, 给基值速度500加上10%的加速buff就是550, 再加上另一个10%的加速buff就是600.  </p>
<p>其次, 该公式还有一些对于可以使用哪些值而未说明的的规则, 因为这是考虑Paragon的情况而设计的.  </p>
<p>译者注: 说实话, 我没有搞懂下文中原文档作者的逻辑, 可能是没有充分了解项目的原因? 比如在样例项目中, 删除BP_DamageVolume的GameplayEffect中的Executions, 并按照下文例4添加两个Multiply Multipliers, Attribute均为GDAttributeSetBase.XP, Modifier Magnitude均为Scalable Float&#x2F;5.0, 回到游戏, 击杀一个小兵使XP增加到1, 然后进入BP_DamageVolume, 会发现XP依次变为25, 625…, 进行调试也会发现是Modifier依次相乘的, 并不是作者所说的乘法分配律逻辑. 还有就是为什么符合公式规则的<code>1 + (0.5 - 1) + (1.1 - 1) = 0.6</code>是正确的而不符合公式规则的<code>1 + (0.5 - 1) + (0.5 - 1) = 0</code>和<code>1 + (5 - 1) + (5 - 1) = 9</code>就是错误预期? 这个正确和错误预期是以什么为评判标准的? 是否符合公式规则么? 如果各位明白其中道理, 还请不吝赐教, 在此感谢!*  </p>
<p>对于<code>Multiply</code>和<code>Divide</code>中乘法加法公式的规则:  </p>
<ul>
<li>(最多不超过1个值 &lt; 1) AND (任意数量值位于[1, 2))</li>
<li>OR (一个值 &gt;&#x3D; 2)</li>
</ul>
<p>公式中的Bias基本上都会减去<code>[1, 2)</code>区间中的整数位, 第一个Modifier的<code>Bias</code>会从最开始的<code>Sum</code>值减值(在循环体前设置Bias), 这就是为什么某个值它本身能起作用的原因以及某个小于1的值与<code>[1, 2)</code>区间中的值起作用的原因.  </p>
<p><code>Multiply</code>的一些例子:<br>Multipliers: 0.5<br><code>1 + (0.5 - 1) = 0.5</code>, 正确.  </p>
<p>Multipliers: 0.5, 0.5<br><code>1 + (0.5 - 1) + (0.5 - 1) = 0</code>, 错误预期<code>1</code>? 多个小于1的值在<code>Modifier</code>相加中不起作用. Paragon这样设计只是为了使用<a href="#cae-nonstackingge">Multiply Modifier的最负值</a>, 因此最多只会有一个小于1的值乘到BaseValue.  </p>
<p>Multipliers: 1.1, 0.5<br><code>1 + (0.5 - 1) + (1.1 - 1) = 0.6</code>, 正确.  </p>
<p>Multipliers: 5, 5<br><code>1 + (5 - 1) + (5 - 1) = 9</code>, 错误预期<code>10</code>. 它总会是<code>Modifier值的和 - Modifier个数 + 1</code>.  </p>
<p>很多游戏会想要它们的<code>Modify</code>和<code>Divide</code>Modifier在应用到BaseValue之前先乘或除到一起, 为了实现这种需求, 你需要修改<code>FAggregatorModChannel::EvaluateWithBase()</code>的引擎代码.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::EvaluateWithBase</span><span class="params">(<span class="type">float</span> InlineBaseValue, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">float</span> Multiplicitive = <span class="built_in">MultiplyMods</span>(Mods[EGameplayModOp::Multiplicitive], Parameters);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((InlineBaseValue + Additive) * Multiplicitive) / Division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FAggregatorModChannel::MultiplyMods</span><span class="params">(<span class="type">const</span> TArray&lt;FAggregatorMod&gt;&amp; InMods, <span class="type">const</span> FAggregatorEvaluateParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> Multiplier = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> FAggregatorMod&amp; Mod : InMods)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Mod.<span class="built_in">Qualifies</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Multiplier *= Mod.EvaluatedMagnitude;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Multiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Modifier-的-GameplayTag"><a href="#Modifier-的-GameplayTag" class="headerlink" title="Modifier 的 GameplayTag"></a>Modifier 的 GameplayTag</h3><p>每个 Modifier 都可以设置 <code>SourceTag</code> 和 <code>TargetTag</code>, 它们的作用就像 <code>GE</code> 的 <code>Application Tag requirements</code>, 因此只有当<code>GE</code> 应用后才会考虑标签, 对于周期性的 <code>(Infinite)GE</code>, 这些标签只会在第一次应用 Effect 时才会被考虑, 而不是在每次周期执行时.  </p>
<p><code>Attribute Based Modifier</code> 可以额外设置 <code>SourceTagFilter</code> 和 <code>TargetTagFilter</code>. 当确定的 <code>(Source)Attribute</code> 的 Magnitude 时, 这些过滤器就会用来将某些 <code>Modifier</code> 排除在该 Attribute 之外, 源(Source)或目标(Target)中没有过滤器所有标签的 <code>Modifier</code> 也会被排除在外.  </p>
<p>这更详尽的意思是: 源(Source) <code>ASC</code> 和目标(Target) <code>ASC</code> 的标签都被 <code>GE</code> 所捕获, 当 <code>GE Spec</code> 创建时, 源(Source) <code>ASC</code> 的标签被捕获, 当执行 Effect 时, 目标(Target) <code>ASC</code> 的标签被捕获. 当确定 <code>(Infinite)GE</code> 或 <code>(Duration)GE</code>  的 <code>Modifier</code> 是否满足条件可以被应用(也就是聚合器条件(Aggregator Qualify))并且过滤器已经设置时, 被捕获的标签就会和过滤器进行比对.  </p>
<blockquote>
<p>如果这些要求无法满足游戏的需求，可以从<code>UGameplayEffectCustomApplicationRequirement</code> 基类派生数据对象，在其中你可以编写可任意定义复杂应用规则的本地代码。</p>
</blockquote>
<h2 id="08-Execution-Calculation-ExecCalc"><a href="#08-Execution-Calculation-ExecCalc" class="headerlink" title="08  Execution Calculation (ExecCalc)"></a>08  Execution Calculation (ExecCalc)</h2><blockquote>
<p>[!quote] 应用场景<br><strong>需要 <code>Source</code> 或 <code>Target</code> 的大量属性和其他值的伤害计算，可以捕获和修改多个 Attribute。</strong></p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016386.png" alt="Pasted image 20231023233943"></p>
<h3 id="UGameplayEffectExecutionCalculation"><a href="#UGameplayEffectExecutionCalculation" class="headerlink" title="UGameplayEffectExecutionCalculation"></a>UGameplayEffectExecutionCalculation</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016387.png" alt="Pasted image 20231203200829"><br><code>ExecutionCalculation</code> 简称 <code>Execution</code> 或 <code>ExecCalc</code>（我喜欢后者）。是 <code>GE</code> 对 <code>ASC</code> 进行修改<strong>最强有力的方式</strong>. </p>
<ul>
<li>和 <code>MMC</code> 一样, 它也可以捕获 <code>Attribute</code> 并选择性地为其创建 Snapshot。</li>
<li>和 <code>MMC</code> 不同的是, 它可以<strong>修改多个 <code>Attribute</code></strong> 并且基本上可以处理程序员想要做的任何事。</li>
<li><code>ExecCalc</code> 只能由 <code>(Instant)GE</code> 和 <code>(Periodic)GE</code> 使用</li>
</ul>
<p><strong>网络：</strong></p>
<ul>
<li>不可预测</li>
<li>对于 <code>Local Predicted</code>, <code>Server Only</code> 和 <code>Server Initiated</code> 的 <code>GA</code>， <code>ExecCalc</code> 只在服务端调用.</li>
</ul>
<h3 id="ExecutionParams"><a href="#ExecutionParams" class="headerlink" title="ExecutionParams"></a>ExecutionParams</h3><p><code>UGameplayEffectExecutionCalculation</code> 子类只需要重载 <code>Execute</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每当执行 owning GE 时都会调用。允许做任何想做的事，包括生成即时执行的新Modifier。</span></span><br><span class="line"><span class="comment"> * 注：本地子类应重载自动生成的 Execute_Implementation 函数，而不是此函数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param ExecutionParams 自定义执行计算的参数</span></span><br><span class="line"><span class="comment"> * @param OutExecutionOutput [OUT] 由执行程序生成的输出数据，详细说明执行程序的进一步行为或结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category=<span class="string">&quot;Calculation&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的第一个参数十分强大，通过该参数可以获取 <code>OwningSpec</code>、<code>TargetASC</code>、<code>SourceASC</code>。几乎获得了一切计算资源！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Simple accessor to owning gameplay spec */</span></span><br><span class="line"><span class="function"><span class="type">const</span> FGameplayEffectSpec&amp; <span class="title">GetOwningSpec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Simple accessor to target ability system component */</span></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetTargetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Simple accessor to source ability system component (could be null!) */</span></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetSourceAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>本项目中用于计算伤害的 <code>GE_ExecCalc_Damage</code> 使用了 ExecCalc，以此为例讲述一下 ExecCalc 的使用方法。</p>
<ol>
<li>创建 <code>UGameplayEffectExecutionCalculation</code> 子类 <code>UExecCalc_Damage</code>， <code>GE_ExecCalc_Damage</code> 指定该类为 Calculation Class</li>
</ol>
<figure class="highlight c++"><figcaption><span>title:ExecCalc_Damage.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Execution Calculation 计算伤害 */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTGASRPG_API</span> UExecCalc_Damage : <span class="keyword">public</span> UGameplayEffectExecutionCalculation</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UExecCalc_Damage</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为了<strong>设置 <code>Attribute</code> 捕获</strong>, 我们采用 Epic 的 ActionRPG 样例项目使用的方式, 定义一个保存和声明如何捕获 <code>Attribute</code> 的结构体, 并在该结构体的构造函数中创建一个它的副本(Copy). <strong>每个 <code>ExecCalc</code> 都需要有一个这样的结构体.</strong> <ul>
<li>项目中用于计算伤害的 <code>GE_ExecCalc_Damage</code> 使用的 Calc Class 中定义了一个结构体（以下为简化版本）：该结构体指明了我们要捕获 Source 的攻击力和 Target 的防御力。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><figcaption><span>title:ExecCalc_Damage.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 该结构体用于捕获属性的声明和定义 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MageDamageStatics</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/** 声明捕获属性 */</span></span><br><span class="line">	<span class="comment">/** Source */</span></span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Attack);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Target */</span></span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Defense);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MageDamageStatics</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/** 定义捕获属性 */</span></span><br><span class="line">		<span class="comment">/** Source */</span></span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UMageAttributeSet, Attack, Source, <span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Target */</span></span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UMageAttributeSet, Defense, Target, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** MageDamageStatics 单例 */</span></span><br><span class="line"><span class="comment">// 静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> MageDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//C++11 局部静态变量只会初始化一次</span></span><br><span class="line">	<span class="type">static</span> MageDamageStatics DmgStatics;</span><br><span class="line">	<span class="keyword">return</span> DmgStatics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>[!BUG]<br>每个结构体需要一个独一无二的名字, 因为它们共享同一个命名空间, 多个结构体使用相同名字在捕获 <code>Attribute</code> 时会造成错误 (大多是捕获到错误的 <code>Attribute</code> 值).  </p>
</blockquote>
<ol start="3">
<li>实现重载的 Execute 函数，输出计算结果到元属性<code>MetaDamage</code></li>
</ol>
<figure class="highlight c++"><figcaption><span>title:ExecCalc_Damage.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">UExecCalc_Damage::<span class="built_in">UExecCalc_Damage</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//捕捉与计算相关的属性</span></span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().AttackDef);</span><br><span class="line"></span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().DefenseDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UExecCalc_Damage::Execute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams,</span></span></span><br><span class="line"><span class="params"><span class="function">	FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/** 获取ASC */</span></span><br><span class="line">	UAbilitySystemComponent* SourceASC = ExecutionParams.<span class="built_in">GetSourceAbilitySystemComponent</span>();</span><br><span class="line">	UAbilitySystemComponent* TargetASC = ExecutionParams.<span class="built_in">GetTargetAbilitySystemComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取AvatarActor */</span></span><br><span class="line">	AActor* SourceAvatarActor = SourceASC ? SourceASC-&gt;<span class="built_in">GetAvatarActor</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">	AActor* TargetAvatarActor = TargetASC ? TargetASC-&gt;<span class="built_in">GetAvatarActor</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取GameplayEffectSpec */</span></span><br><span class="line">	<span class="type">const</span> FGameplayEffectSpec&amp; EffectSpec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取GameplayEffectContext */</span></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = EffectSpec.<span class="built_in">GetContext</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 获取Tag */</span></span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* SourceTags = EffectSpec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* TargetTags = EffectSpec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">	FAggregatorEvaluateParameters EvaluationParameters;</span><br><span class="line">	EvaluationParameters.SourceTags = SourceTags;</span><br><span class="line">	EvaluationParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取捕获的属性值 */</span></span><br><span class="line">	<span class="type">float</span> Source_Attack= <span class="number">0.0f</span>;</span><br><span class="line">	<span class="type">float</span> Target_Defense = <span class="number">0.0f</span>;</span><br><span class="line">		ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().MaxMagicAttackDef, EvaluationParameters, Source_Attack);</span><br><span class="line">		Source_Attack = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(<span class="number">0.0f</span>,Source_Attack);</span><br><span class="line">	&#125;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().DefenseDef, EvaluationParameters, Target_Defense);</span><br><span class="line">	Target_Defense = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(<span class="number">0.0f</span>,Target_Defense);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//...使用捕获的属性值进行后续计算得到FinalDamage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 最后计算的结果输出，用于修改MetaDamage属性 */</span></span><br><span class="line">	<span class="function"><span class="type">const</span> FGameplayModifierEvaluatedData <span class="title">EvaluatedData</span><span class="params">(UMageAttributeSet::GetMetaDamageAttribute(), EGameplayModOp::Additive, FinalDamage)</span></span>;</span><br><span class="line">	OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(EvaluatedData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="发送数据到-ExecCalc"><a href="#发送数据到-ExecCalc" class="headerlink" title="发送数据到 ExecCalc"></a>发送数据到 ExecCalc</h3><p>除了捕获<code>Attribute</code>, 还有几种方法可以发送数据到<code>ExecutionCalculation</code>.  </p>
<h4 id="SetByCaller"><a href="#SetByCaller" class="headerlink" title="SetByCaller"></a>SetByCaller</h4><p>通过 <code>GetOwningSpec()</code> 可以获取 <code>OwningSpec</code> ，任何设置在 <code>GE Spec</code> 中的 <code>SetByCaller</code> 都可以直接在 <code>Execute()</code> 中读取.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Damage = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Spec.<span class="built_in">GetSetByCallerMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Data.Damage&quot;</span>)), <span class="literal">false</span>, <span class="number">-1.0f</span>), <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Calculation-Modifier"><a href="#Calculation-Modifier" class="headerlink" title="Calculation Modifier"></a>Calculation Modifier</h4><p>如果你想硬编码值到 <code>GE</code>, 可以使用 <code>CalculationModifier</code> 传递, 其使用捕获的 <code>Attribute</code> 之一作为 Backing 数据.  </p>
<p>在这个截图例子中, 我们给捕获的伤害值 <code>Attribute</code> 增加了50, 你也可以将其设为 <code>Override</code> 来直接传入硬编码值.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016388.png" alt="Pasted image 20231203205156"><br>当<code>ExecutionCalculation</code>捕获该<code>Attribute</code>时会读取这个值.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Damage = <span class="number">0.0f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().DamageDef, EvaluationParameters, Damage);</span><br></pre></td></tr></table></figure>

<p><a name="concepts-ge-ec-senddata-backingdatatempvariable"></a></p>
<h4 id="瞬时聚合器-Transient-Aggregator"><a href="#瞬时聚合器-Transient-Aggregator" class="headerlink" title="瞬时聚合器 Transient Aggregator"></a>瞬时聚合器 Transient Aggregator</h4><p>如果你想硬编码值到 <code>GE</code>, 可以在 C++中使用 <code>CalculationModifier</code> 传递, 其使用一个 <code>瞬时聚合器(Transient Aggregator)</code> 作为临时变量, 该临时变量与 <code>GameplayTag</code> 相关联.  <code>GameplayTag</code> 保存在名为 <code>ValidTransientAggregatorIdentifiers</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 该容器中的任何Tag都将显示为有效的 &quot;临时变量&quot;，用于作用域修饰符；用于支持不依赖作用域修饰符的数据驱动变量 */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=NonAttributeCalculation)</span><br><span class="line">FGameplayTagContainer ValidTransientAggregatorIdentifiers;</span><br></pre></td></tr></table></figure>

<p>在这个截图例子中, 我们使用 <code>Data.Damage GameplayTag</code> 将50 加到一个临时变量.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016389.png" alt="848656e3bb55a785b9b408d6d913e0e0_MD5"></p>
<p>添加Backing临时变量到你的<code>ExecutionCalculation</code>构造函数:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValidTransientAggregatorIdentifiers.<span class="built_in">AddTag</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="string">&quot;Data.Damage&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>ExecutionCalculation</code>会使用和<code>Attribute</code>捕获函数相似的特殊捕获函数来读取这个值.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Damage = <span class="number">0.0f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateTransientAggregatorMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="string">&quot;Data.Damage&quot;</span>), EvaluationParameters, Damage);</span><br></pre></td></tr></table></figure>


<h4 id="从-GameplayEffectContext-获取数据"><a href="#从-GameplayEffectContext-获取数据" class="headerlink" title="从 GameplayEffectContext 获取数据"></a>从 GameplayEffectContext 获取数据</h4><p>你可以通过 <code>GE Spec</code> 中的自定义 <code>GameplayEffectContext</code>发送数据到 <code>ExecutionCalculation</code>.<br>具体案例可见：[[#创建 EffectContext 子类]]</p>
<p>在<code>ExecutionCalculation</code>中, 你可以自<code>FGameplayEffectCustomExecutionParameters</code>访问<code>EffectContext</code>.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"></span><br><span class="line">FMageGameplayEffectContext* ContextHandle = <span class="built_in">static_cast</span>&lt;FMageGameplayEffectContext*&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>

<p>如果你需要修改 <code>GE Spec</code> 中的什么或者 <code>EffectContext</code>:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FGameplayEffectSpec* MutableSpec = ExecutionParams.<span class="built_in">GetOwningSpecForPreExecuteMod</span>();</span><br><span class="line"></span><br><span class="line">FMageGameplayEffectContext* ContextHandle = <span class="built_in">static_cast</span>&lt;FMageGameplayEffectContext*&gt;(MutableSpec-&gt;<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>

<p>在 <code>ExecutionCalculation</code> 中修改 <code>GE Spec</code> 时要小心：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 非 const 访问。使用时要小心，尤其是在属性捕获后修改 Spec 时。*/</span></span><br><span class="line"><span class="function">FGameplayEffectSpec* <span class="title">GetOwningSpecForPreExecuteMod</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="09-花费-Cost-GE"><a href="#09-花费-Cost-GE" class="headerlink" title="09 花费(Cost)GE"></a>09 花费(Cost)GE</h2><p><code>GE</code> 花费(Cost)是指 <code>ASC</code> 激活 GA 所必需的 <code>Attribute</code> 量. 如果某个 <code>GA</code> 不能提供 <code>Cost GE</code>, 那么它就不能被激活.<br>该 <code>Cost GE</code> 应该是某个带有一个或多个减少 <code>Attribute</code> 的 Modifier 的 <strong><code>(Instant)GE</code>.</strong> </p>
<p><strong>默认情况下, <code>Cost GE</code> 是可以被预测的</strong>, 建议保留该功能, 也就是<strong>不要使用 <code>ExecCalc</code></strong>,   对于复杂的花费计算推荐使用 <code>MMC</code> </p>
<h3 id="Cost-GE-复用"><a href="#Cost-GE-复用" class="headerlink" title="Cost GE 复用"></a>Cost GE 复用</h3><p>通常可以为每个有花费的 <code>GA</code> 都设置一个单独的 <code>Cost GE</code>, 一个更高阶的技巧是对多个 <code>GA</code> 复用一个 <code>Cost GE</code>, 只需修改自 <code>GA</code> 的 <code>Cost GE</code> 创建的 <code>GE Spec</code> 中指定的数据(花费值是在 <code>GA</code> 上定义的), </p>
<p><strong>这只适用于 <code>(Instanced)GA</code></strong></p>
<p><strong>复用 <code>Cost GE</code> 的两种方法:</strong><br><strong>方法一（本项目使用的方法）</strong>：创建一个公用的 GE: <code>GE_AbilityCost</code> ，使用 <code>MMC Modifier</code> ，该 <code>MMC</code> 可以从 <code>GA</code> 实例读取花费值，你可以从 <code>GE Spec</code> 中获取到该实例.  </p>
<figure class="highlight c++"><figcaption><span>title:MMC_AbilityCost.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UMMC_AbilityCost::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> UMageGameplayAbility* Ability = <span class="built_in">Cast</span>&lt;UMageGameplayAbility&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>());</span><br><span class="line">	<span class="keyword">if</span> (!Ability)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ability-&gt;Cost.<span class="built_in">GetValueAtLevel</span>(Ability-&gt;<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016390.png" alt="Pasted image 20231203220523"><br>在 <code>GameplayAbility</code> 子类 <code>MageGameplayAbility</code> 添加 <code>FScalableFloat</code> 类型的成员变量。创建一个 CurveTable <code>CT_AbilityCost</code> 为每个技能添加曲线</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere)</span><br><span class="line">FScalableFloat Cost;</span><br></pre></td></tr></table></figure>

<p>在 GA 中指定使用的 Cost GE<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016391.png" alt="Pasted image 20231203220920"></p>
<p><strong>方法二</strong>：<strong>重写 <code>UGameplayAbility::GetCostGameplayEffect()</code>.</strong> 重写该函数并在<a href="#concepts-ge-dynamic">运行时</a>创建一个用来读取 <code>GameplayAbility</code> 中花费值的 <code>GameplayEffect</code>.  </p>
<h2 id="10-冷却-Cooldown-GE"><a href="#10-冷却-Cooldown-GE" class="headerlink" title="10 冷却(Cooldown) GE"></a>10 冷却(Cooldown) GE</h2><p><code>GameplayEffect</code> 冷却时间决定了激活 Ability 之后多久可以再次激活. 如果某个 <code>GA</code> 在冷却中, 那么它就不能被激活. </p>
<ul>
<li><strong><code>Cooldown GE</code> 是一个不带有 <code>Modifier</code> 的 <code>(Duration)GE</code>, 计算方式为 <code>Set By Caller</code> 或 <code>MMC</code>。</strong></li>
<li><strong>并且在 <code>GE</code> 的 <code>GrantedTags</code> 中每个 <code>GA</code> 或 Ability 插槽(Slot)(如果你的游戏有分配到插槽的可交换 Ability 且共享同一个冷却)都有一个独一无二的 <code>GameplayTag</code> (<code>Cooldown Tag</code>).</strong> </li>
<li><strong><code>GA</code> 实际上会检查 <code>Cooldown Tag</code> 的存在而不是 <code>Cooldown GE</code> 的存在</strong>, 在 Cooldown GE 持续期间，玩家的 ASC 组件就会携带对应技能的 Cooldown Tag，本质是通过 Tag 来限制的。</li>
</ul>
<p><strong>默认情况下, <code>Cooldown GE</code> 是可以被预测的</strong>, 建议保留该功能, 也就是<strong>不要使用 <code>ExecCalc</code></strong>,   对于复杂的冷却计算推荐使用 <code>MMC</code> </p>
<p>通常会为每个有冷却的 <code>GA</code> 都设置单独的 <code>Cooldown GE</code>, 一个更高阶的技巧是对多个 <code>GA</code> 复用一个 <code>Cooldown GE</code>, 只需修改自 <code>GA</code> 的 <code>Cooldown GE</code> 创建的 <code>GameplayEffectSpec</code> 中指定的数据(冷却时间和 <code>Cooldown Tag</code> 是在 <code>GA</code> 上定义的), <strong>这只作用于 <code>(Instanced)GA</code></strong>  </p>
<h3 id="Cooldown-GE-复用"><a href="#Cooldown-GE-复用" class="headerlink" title="Cooldown GE 复用"></a>Cooldown GE 复用</h3><p><strong>方法一</strong>：使用 <code>SetByCaller</code>. 这是最简单的方式. 使用 <code>GameplayTag</code> 设置 <code>SetByCaller</code> 为共享 <code>Cooldown GE</code> 的持续时间.<br>在 <code>GameplayAbility</code> 子类中, 为持续时间定义一个浮点&#x2F; <code>FScalableFloat</code> 变量, 为独一无二的 <code>Cooldown Tag</code> 定义一个 <code>FGameplayTagContainer</code>, 除此之外还要定义一个临时 <code>FGameplayTagContainer</code>, 其用来作为 <code>Cooldown Tag</code> 与 <code>Cooldown GE</code> 标签并集的返回指针.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FScalableFloat CooldownDuration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FGameplayTagContainer CooldownTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临时容器，我们将在 GetCooldownTags() 中返回其指针。这将是我们的 CooldownTags 和 Cooldown GE&#x27;s Cooldown Tags 的冷却标签的组合。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">FGameplayTagContainer TempCooldownTags;</span><br></pre></td></tr></table></figure>

<p>之后重写<code>UGameplayAbility::GetCooldownTags()</code>以返回<code>Cooldown Tag</code>和所有现有<code>Cooldown GE</code>标签的并集.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> FGameplayTagContainer * <span class="title">UPGGameplayAbility::GetCooldownTags</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer* MutableTags = <span class="built_in">const_cast</span>&lt;FGameplayTagContainer*&gt;(&amp;TempCooldownTags);</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* ParentTags = Super::<span class="built_in">GetCooldownTags</span>();</span><br><span class="line">	<span class="keyword">if</span> (ParentTags)</span><br><span class="line">	&#123;</span><br><span class="line">		MutableTags-&gt;<span class="built_in">AppendTags</span>(*ParentTags);</span><br><span class="line">	&#125;</span><br><span class="line">	MutableTags-&gt;<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line">	<span class="keyword">return</span> MutableTags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后, 重写<code>UGameplayAbility::ApplyCooldown()</code>以注入我们自己的<code>Cooldown Tag</code>, 并将<code>SetByCaller</code>添加到<code>Cooldown GameplayEffectSpec</code>.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPGGameplayAbility::ApplyCooldown</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle Handle, <span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilityActivationInfo ActivationInfo)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UGameplayEffect* CooldownGE = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line">	<span class="keyword">if</span> (CooldownGE)</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayEffectSpecHandle SpecHandle = <span class="built_in">MakeOutgoingGameplayEffectSpec</span>(CooldownGE-&gt;<span class="built_in">GetClass</span>(), <span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">		SpecHandle.Data.<span class="built_in">Get</span>()-&gt;DynamicGrantedTags.<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line">		SpecHandle.Data.<span class="built_in">Get</span>()-&gt;<span class="built_in">SetSetByCallerMagnitude</span>(FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(  OurSetByCallerTag )), CooldownDuration.<span class="built_in">GetValueAtLevel</span>(<span class="built_in">GetAbilityLevel</span>()));</span><br><span class="line">		<span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面图片中, 冷却时间 <code>Modifier</code> 被设置为 <code>SetByCaller</code>, 其 <code>Data Tag</code> 为 <code>Data.Cooldown</code>. <code>Data.Cooldown</code> 就是上面代码中的 <code>OurSetByCallerTag</code>.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016392.png" alt="Pasted image 20231203224733"><br><strong>方法二</strong>：使用 <code>MMC</code>. 它的设置与上文所提的一致, 除了不需要在 <code>Cooldown GE</code> 和 <code>ApplyCost</code> 中设置 <code>SetByCaller</code> 作为持续时间, 相反, 我们需要将持续时间设置为 <code>Custom Calculation类</code> 并将其指向新创建的 <code>MMC</code>.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FScalableFloat CooldownDuration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditAnywhere, Category = <span class="string">&quot;Cooldown&quot;</span>)</span><br><span class="line">FGameplayTagContainer CooldownTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temp container that we will return the pointer to in GetCooldownTags().</span></span><br><span class="line"><span class="comment">// This will be a union of our CooldownTags and the Cooldown GE&#x27;s cooldown tags.</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">FGameplayTagContainer TempCooldownTags;</span><br></pre></td></tr></table></figure>

<p>之后重写<code>UGameplayAbility::GetCooldownTags()</code>以返回<code>Cooldown Tag</code>和所有现有<code>Cooldown GE</code>标签的并集.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> FGameplayTagContainer * <span class="title">UPGGameplayAbility::GetCooldownTags</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer* MutableTags = <span class="built_in">const_cast</span>&lt;FGameplayTagContainer*&gt;(&amp;TempCooldownTags);</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* ParentTags = Super::<span class="built_in">GetCooldownTags</span>();</span><br><span class="line">	<span class="keyword">if</span> (ParentTags)</span><br><span class="line">	&#123;</span><br><span class="line">		MutableTags-&gt;<span class="built_in">AppendTags</span>(*ParentTags);</span><br><span class="line">	&#125;</span><br><span class="line">	MutableTags-&gt;<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line">	<span class="keyword">return</span> MutableTags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后, 重写<code>UGameplayAbility::ApplyCooldown()</code>以将我们的<code>Cooldown Tag</code>注入<code>Cooldown GameplayEffectSpec</code>.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPGGameplayAbility::ApplyCooldown</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle Handle, <span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilityActivationInfo ActivationInfo)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UGameplayEffect* CooldownGE = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line">	<span class="keyword">if</span> (CooldownGE)</span><br><span class="line">	&#123;</span><br><span class="line">		FGameplayEffectSpecHandle SpecHandle = <span class="built_in">MakeOutgoingGameplayEffectSpec</span>(CooldownGE-&gt;<span class="built_in">GetClass</span>(), <span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">		SpecHandle.Data.<span class="built_in">Get</span>()-&gt;DynamicGrantedTags.<span class="built_in">AppendTags</span>(CooldownTags);</span><br><span class="line">		<span class="built_in">ApplyGameplayEffectSpecToOwner</span>(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UPGMMC_HeroAbilityCooldown::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec &amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> UPGGameplayAbility* Ability = <span class="built_in">Cast</span>&lt;UPGGameplayAbility&gt;(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetAbilityInstance_NotReplicated</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Ability)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Ability-&gt;CooldownDuration.<span class="built_in">GetValueAtLevel</span>(Ability-&gt;<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016393.png" alt="5b4d70e70bd3ec3ae4218d8e660ce839_MD5">  </p>
<h3 id="获取-Cooldown-GE-的剩余时间"><a href="#获取-Cooldown-GE-的剩余时间" class="headerlink" title="获取 Cooldown GE 的剩余时间"></a>获取 Cooldown GE 的剩余时间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">APGPlayerState::GetCooldownRemainingForTag</span><span class="params">(FGameplayTagContainer CooldownTags, <span class="type">float</span> &amp; TimeRemaining, <span class="type">float</span> &amp; CooldownDuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; CooldownTags.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		TimeRemaining = <span class="number">0.f</span>;</span><br><span class="line">		CooldownDuration = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">		FGameplayEffectQuery <span class="type">const</span> Query = FGameplayEffectQuery::<span class="built_in">MakeQuery_MatchAnyOwningTags</span>(CooldownTags);</span><br><span class="line">		TArray&lt; TPair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; &gt; DurationAndTimeRemaining = AbilitySystemComponent-&gt;<span class="built_in">GetActiveEffectsTimeRemainingAndDuration</span>(Query);</span><br><span class="line">		<span class="keyword">if</span> (DurationAndTimeRemaining.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			int32 BestIdx = <span class="number">0</span>;</span><br><span class="line">			<span class="type">float</span> LongestTime = DurationAndTimeRemaining[<span class="number">0</span>].Key;</span><br><span class="line">			<span class="keyword">for</span> (int32 Idx = <span class="number">1</span>; Idx &lt; DurationAndTimeRemaining.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (DurationAndTimeRemaining[Idx].Key &gt; LongestTime)</span><br><span class="line">				&#123;</span><br><span class="line">					LongestTime = DurationAndTimeRemaining[Idx].Key;</span><br><span class="line">					BestIdx = Idx;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			TimeRemaining = DurationAndTimeRemaining[BestIdx].Key;</span><br><span class="line">			CooldownDuration = DurationAndTimeRemaining[BestIdx].Value;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端上查询剩余冷却时间要求其可以接收复制的 <code>GE</code>, 这依赖于它们 <code>ASC</code> 的<a href="#concepts-asc-rm">复制模式</a>.  </p>
<h3 id="监听冷却开始和结束"><a href="#监听冷却开始和结束" class="headerlink" title="监听冷却开始和结束"></a>监听冷却开始和结束</h3><p>为了监听某个冷却何时开始, 你可以通过绑定以下两个委托。我<strong>建议监听 <code>Cooldown GE</code> 何时应用</strong>, 因为这时还可以访问应用它的 <code>GameplayEffectSpec</code>. 由此你可以确定当前 <code>Cooldown GE</code> 是客户端预测的还是由服务端校正的.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Cooldown GE应用时响应</span></span><br><span class="line">AbilitySystemComponent-&gt;OnActiveGameplayEffectAddedDelegateToSelf</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Cooldown Tag添加时作出响应</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(CooldownTag, EGameplayTagEventType::NewOrRemoved)</span><br></pre></td></tr></table></figure>



<p>为了监听某个冷却何时结束, 你可以通过绑定以下两个委托。我<strong>建议监听 <code>Cooldown Tag</code> 何时移除</strong>, 因为当服务端校正的 <code>Cooldown GE</code> 到来时, 会移除客户端预测的 <code>Cooldown GE</code>, 这会响应 <code>OnAnyGameplayEffectRemovedDelegate()</code>, 即使仍处于冷却过程中. 预测的 <code>Cooldown GE</code> 在移除时和服务端校正的 <code>Cooldown GE</code> 在应用时 <code>Cooldown Tag</code> 都不会改变.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Cooldown GE移除时响应</span></span><br><span class="line"> AbilitySystemComponent-&gt;<span class="built_in">OnAnyGameplayEffectRemovedDelegate</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Cooldown Tag移除时作出响应</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(CooldownTag, EGameplayTagEventType::NewOrRemoved)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]<br>在客户端上监听某个<code>GameplayEffect</code>添加或移除要求其可以接收复制的<code>GameplayEffect</code>, 这依赖于它们<code>ASC</code>的复制模式</p>
</blockquote>
<p>本项目包含一个用于监听冷却开始和结束的自定义蓝图异步节点 <code>AsyncTaskCooldownChanged.h</code>, <code>WBP_SkillIcon</code> 使用它来更新技能的冷却显示环 UI, 该 <code>AsyncTask</code> 会一直响应直到手动调用 <code>EndTask()</code>。 </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016394.png" alt="Pasted image 20231203230839"></p>
<h3 id="预测冷却时间"><a href="#预测冷却时间" class="headerlink" title="预测冷却时间"></a>预测冷却时间</h3><p>目前冷却时间不是真正可预测的. 我们可以在客户端预测的 <code>Cooldown GE</code> 应用时启动 UI 的冷却时间计时器, 但是 <code>GA</code> 的实际冷却时间是由服务端的冷却时间剩余决定的. 取决于玩家的延迟情况, 可能客户端预测的冷却已经结束, 但是服务端上的 <code>GA</code> 仍处于冷却过程, 这会阻止 <code>GA</code> 的立刻再激活直到服务端冷却结束.  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/liuke101/GASDocumentation/blob/master/Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskCooldownChanged.cpp#L105">GASDocumentation&#x2F;AsyncTaskCooldownChanged.cpp</a> 通过在客户端预测的冷却开始时灰化陨石技能的图标, 之后在服务端校正的 <code>Cooldown GE</code> 到来时启动冷却计时器处理该问题.  </p>
<p>在实际游戏中导致的结果就是高延迟的玩家相比低延迟的玩家对冷却时间短的技能有更低的触发率, 从而处于劣势, Fortnite通过使其武器使用无需冷却<code>GameplayEffect</code>的自定义Bookkeeping而避免该现象.  </p>
<p>Epic希望在未来的<a href="#concepts-p-future">GAS迭代版本</a>中实现真正的冷却预测(玩家可以激活一个在客户端冷却完成但服务端仍处于冷却过程的<code>GameplayAbility</code>).  </p>
<h2 id="11-修改已激活-GameplayEffect-的持续时间"><a href="#11-修改已激活-GameplayEffect-的持续时间" class="headerlink" title="11 修改已激活 GameplayEffect 的持续时间"></a>11 修改已激活 GameplayEffect 的持续时间</h2><p>为了修改 <code>Cooldown GE</code> 或其他任何 <code>(Duration)GE</code> 的剩余时间, 我们需要修改 <code>GameplayEffectSpec</code> 的持续时间, 更新它的 <code>StartServerWorldTime</code>, <code>CachedStartServerWorldTime</code>, <code>StartWorldTime</code>, 并且使用 <code>CheckDuration()</code> 重新检查持续时间. 在服务端上完成这些操作并将 <code>FActiveGameplayEffect</code> 标记为 dirty, 其会将这些修改复制到客户端.<br>Note: 该操作包含一个 <code>const_cast</code>, 这可能不是 <code>Epic</code> 希望的修改持续时间的方法, 但是迄今为止它看起来运行得很好.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPAAbilitySystemComponent::SetGameplayEffectDurationHandle</span><span class="params">(FActiveGameplayEffectHandle Handle, <span class="type">float</span> NewDuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Handle.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FActiveGameplayEffect* ActiveGameplayEffect = <span class="built_in">GetActiveGameplayEffect</span>(Handle);</span><br><span class="line">	<span class="keyword">if</span> (!ActiveGameplayEffect)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FActiveGameplayEffect* AGE = <span class="built_in">const_cast</span>&lt;FActiveGameplayEffect*&gt;(ActiveGameplayEffect);</span><br><span class="line">	<span class="keyword">if</span> (NewDuration &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AGE-&gt;Spec.Duration = NewDuration;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		AGE-&gt;Spec.Duration = <span class="number">0.01f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AGE-&gt;StartServerWorldTime = ActiveGameplayEffects.<span class="built_in">GetServerWorldTime</span>();</span><br><span class="line">	AGE-&gt;CachedStartServerWorldTime = AGE-&gt;StartServerWorldTime;</span><br><span class="line">	AGE-&gt;StartWorldTime = ActiveGameplayEffects.<span class="built_in">GetWorldTime</span>();</span><br><span class="line">	ActiveGameplayEffects.<span class="built_in">MarkItemDirty</span>(*AGE);</span><br><span class="line">	ActiveGameplayEffects.<span class="built_in">CheckDuration</span>(Handle);</span><br><span class="line"></span><br><span class="line">	AGE-&gt;EventSet.OnTimeChanged.<span class="built_in">Broadcast</span>(AGE-&gt;Handle, AGE-&gt;StartWorldTime, AGE-&gt;<span class="built_in">GetDuration</span>());</span><br><span class="line">	<span class="built_in">OnGameplayEffectDurationChange</span>(*AGE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-运行时创建动态-GE"><a href="#12-运行时创建动态-GE" class="headerlink" title="12 运行时创建动态 GE"></a>12 运行时创建动态 GE</h2><p>在运行时创建动态 <code>GE</code> 是一个高阶技术, 你不必经常使用它.  </p>
<p>只有 <code>(Instant)GE</code> 可以在运行时由 C++创建, <code>(Duration)GE</code> 和 <code>(Infinite)GE</code> 不能在运行时动态创建, 因为它们在复制时会寻找并不存在的 <code>GE</code> 类定义. 为了实现该功能, 你应该创建一个原型 <code>GE</code> 类, 就像平时在编辑器中做的那样, 之后根据运行时所需来定制化 <code>GE Spec</code>.  </p>
<p>运行时创建的 <code>(Instant)GE</code> 也可以在客户端<a href="#concepts-p">预测</a>的 <code>GA</code> 中调用. 然而, 目前还不明确动态创建是否有副作用.  </p>
<hr>
<p>本项目在角色 <code>MageAttributeSet</code> 中的值受到攻击时运行时生成 Debuff 临时GE。</p>
<figure class="highlight c++"><figcaption><span>title:MageAttribute.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAttributeSet::Debuff</span><span class="params">(<span class="type">const</span> FEffectProperty&amp; Property)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/** 通过C++创建一个临时GE来实现Debuff */</span></span><br><span class="line">	FMageGameplayTags MageGameplayTags = FMageGameplayTags::<span class="built_in">Instance</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建新的EffectContext</span></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = Property.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContextHandle.<span class="built_in">AddSourceObject</span>(Property.SourceAvatarActor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Debuff信息</span></span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDamage = UMageAbilitySystemLibrary::<span class="built_in">GetDebuffDamage</span>(Property.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffFrequency = UMageAbilitySystemLibrary::<span class="built_in">GetDebuffFrequency</span>(Property.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDuration = UMageAbilitySystemLibrary::<span class="built_in">GetDebuffDuration</span>(Property.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> FGameplayTag DamageTypeTag = UMageAbilitySystemLibrary::<span class="built_in">GetDamageTypeTag</span>(Property.EffectContextHandle);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时GE</span></span><br><span class="line">	<span class="type">const</span> FString DebuffName = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DynamicDebuff_%s&quot;</span>), *DamageTypeTag.<span class="built_in">ToString</span>());</span><br><span class="line">	UGameplayEffect* DebuffEffect = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>(), <span class="built_in">FName</span>(DebuffName));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置DurationPolicy</span></span><br><span class="line">	DebuffEffect-&gt;DurationPolicy = EGameplayEffectDurationType::HasDuration;</span><br><span class="line">	DebuffEffect-&gt;Period = DebuffFrequency;</span><br><span class="line">	DebuffEffect-&gt;DurationMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDuration);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取DebuffTag，该Tag会应用到目标Actor</span></span><br><span class="line">	<span class="comment">// - InheritableOwnedTagsContainer就是GrantedTags</span></span><br><span class="line">	<span class="comment">// - 在对应的拥有ASC的Actor类中中绑定 RegisterGameplayTagEvent 委托，监听Tag的变化</span></span><br><span class="line">	<span class="type">const</span> FGameplayTag DebuffTag = MageGameplayTags.DamageTypeTag_To_DebuffTag[DamageTypeTag];</span><br><span class="line">	DebuffEffect-&gt;InheritableOwnedTagsContainer.<span class="built_in">AddTag</span>(DebuffTag);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置Stack</span></span><br><span class="line">	DebuffEffect-&gt;StackingType = EGameplayEffectStackingType::AggregateBySource;</span><br><span class="line">	DebuffEffect-&gt;StackLimitCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置Modifiers</span></span><br><span class="line">	<span class="type">const</span> int32 Index = DebuffEffect-&gt;Modifiers.<span class="built_in">Num</span>(); <span class="comment">//Modifiers索引</span></span><br><span class="line">	DebuffEffect-&gt;Modifiers.<span class="built_in">Add</span>(<span class="built_in">FGameplayModifierInfo</span>());</span><br><span class="line">	FGameplayModifierInfo&amp; ModifierInfo = DebuffEffect-&gt;Modifiers[Index];</span><br><span class="line">	ModifierInfo.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDamage);</span><br><span class="line">	ModifierInfo.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">	ModifierInfo.Attribute = <span class="built_in">GetMetaDamageAttribute</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//应用GE</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="type">const</span> FGameplayEffectSpec* MutableSpec =<span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(DebuffEffect, EffectContextHandle, <span class="number">1.0f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//注意这里GetContext返回的是新建的EffectContextHandle指向的EffectContext,而不是Property.EffectContextHandle</span></span><br><span class="line">		FMageGameplayEffectContext* MageEffectContext = <span class="built_in">static_cast</span>&lt;FMageGameplayEffectContext*&gt;(MutableSpec-&gt;<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br><span class="line">		MageEffectContext-&gt;<span class="built_in">SetDamageTypeTag</span>(<span class="built_in">MakeShared</span>&lt;FGameplayTag&gt;(DamageTypeTag));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//应用到自身</span></span><br><span class="line">		Property.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*MutableSpec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-GameplayEffect-Containers"><a href="#13-GameplayEffect-Containers" class="headerlink" title="13 GameplayEffect Containers"></a>13 GameplayEffect Containers</h2><p>Epic的<a target="_blank" rel="noopener" href="https://www.unrealengine.com/marketplace/en-US/slug/action-rpg">Action RPG</a>样例项目实现了一个名为<code>FGameplayEffectContainer</code>的结构体, 它不属于原生GAS, 但是对于包含<code>GameplayEffect</code>和<a href="#concepts-targeting-data">TargetData</a>极其好用, 它会使一些过程自动化, 比如从<code>GameplayEffect</code>中创建<code>GameplayEffectSpec</code>并在其<code>GameplayEffectContext</code>中设置默认值. 在<code>GameplayAbility</code>中创建<code>GameplayEffectContainer</code>并将其传递给已生成的投掷物是非常简单和显而易见的, 然而我没有选择在样例项目中实现<code>GameplayEffectContainer</code>, 因为我想向你展示的是没有它的原生GAS, 但是我高度建议你研究一下它并将其纳入到你的项目中.  </p>
<p>为了访问<code>GameplayEffectContainer</code>中的<code>GESpec</code>以求做一些诸如添加<code>SetByCaller</code>的操作, 请使用<code>FGameplayEffectContainer</code>结构体中的<code>GESpec</code>数组索引访问<code>GESpec</code>引用, 这要求你需要提前知道想要访问的<code>GESpec</code>的索引.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016395.png" alt="c0eed7425982aa2e758dd11d77018ee9_MD5">  </p>
<p><code>GameplayEffectContainer</code>还包含一个可选的用于<a href="#concepts-targeting-containers">定位(Target)</a>的高效方法.</p>
<h2 id="14-存在的问题"><a href="#14-存在的问题" class="headerlink" title="14 存在的问题"></a>14 存在的问题</h2><p>GAS 中的现存问题:</p>
<ul>
<li><code>GameplayEffect</code> 延迟调节 (Latency Reconciliation). (不能预测能力冷却时间, 导致高延迟玩家相比低延迟玩家, 对于短冷却时间的能力有更低的激活速率.)</li>
<li>不能预测性地移除 <code>GameplayEffect</code>. 然而我们可以反向预测性地添加 <code>GameplayEffect</code>, 从而高效的移除它. 但是这不总是合适或者可行的, 因此这仍然是个问题.</li>
</ul>
<h1 id="6-Gameplay-Ability"><a href="#6-Gameplay-Ability" class="headerlink" title="6 Gameplay Ability"></a>6 Gameplay Ability</h1><p>  <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016396.png" alt="Pasted image 20231014225909"></p>
<h2 id="01-定义-2"><a href="#01-定义-2" class="headerlink" title="01 定义"></a>01 定义</h2><p><code>GameplayAbility</code> 是一个蓝图对象，<strong>负责执行技能的所有事件</strong>，包括播放动画，触发效果，从所有者获取属性，以及显示视觉效果。</p>
<ul>
<li>提供一种方法来赋予&#x2F;分配可使用的Ability </li>
<li>提供对实例化Ability的管理</li>
<li>提供 Replication 功能  </li>
<li>Ability state 必须始终复制到 UGameplayAbility 本身，但 UAbilitySystemComponent 对于实际激活的 GameplayAbility 提供了 RPC 复制功能</li>
</ul>
<p><strong><code>GameplayAbility</code>示例:</strong>  </p>
<ul>
<li>跳跃</li>
<li>奔跑</li>
<li>射击</li>
<li>每X秒被动地阻挡一次攻击</li>
<li>使用药剂</li>
<li>开门</li>
<li>收集资源</li>
<li>建造</li>
</ul>
<p><strong>不应该使用<code>GameplayAbility</code>的场景:</strong>  </p>
<ul>
<li>基础移动输入</li>
<li>射线检测</li>
<li>一些与UI的交互 - 不要使用<code>GameplayAbility</code>从商店中购买物品<blockquote>
<p>这些不是规定, 只是我的建议而已, 你的设计和实现可能是多样的.</p>
</blockquote>
</li>
</ul>
<p><strong><code>GameplayAbility</code> 使用 AbilityTask 用于随时间推移而发生的行为</strong>(异步事件), 例如等待某个事件, 等待某个 Attribute 改变, 等待玩家选择一个目标或者使用 <code>Root Motion Source</code> 移动某个 <code>Character</code>. </p>
<p>所有的 <code>GA</code> 都会有它们各自由你的游戏逻辑重写的 <code>ActivateAbility()</code> 函数, 附加的逻辑可以添加到 <code>EndAbility()</code>, 其会在 <code>GameplayAbility</code> 完成或取消时执行.  </p>
<p><strong>框架图：</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016330.png"></p>
<p>一个简单的 <code>GameplayAbility</code> 流程图: <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016397.png" alt="10a9b92a92f597843a5ecaeb47b13c25_MD5"></p>
<p>一个更复杂 <code>GameplayAbility</code> 流程图: <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016398.png" alt="7c6a74d820c4d0c583493314e655a78d_MD5">  </p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>将 <code>GA</code> 授予给 ASC 后，<code>GA</code> 的<strong>基本执行生命周期</strong>如下：</p>
<ol>
<li><code>TryActivateAbility</code> 是执行技能的典型方式。该函数调用 <code>CanActivateAbility</code> 来确定技能是否可以立即运行，如果可以，则继续调用 <code>CallActivateAbility</code><ul>
<li><strong><code>CanActivateAbility</code> 判断是否可激活该技能。</strong> <ul>
<li>该函数会调用 <code>CheckCost()</code> 和 <code>CheckCooldown()</code> 检查所属 <code>ASC</code> 是否满足花费和冷却条件</li>
</ul>
</li>
<li><strong><code>CallActivateAbility</code> 执行技能相关的游戏代码</strong></li>
</ul>
</li>
<li>自定义逻辑需要在 C++或蓝图中重载 <code>ActivateAbility</code> </li>
<li>与 Actor 和组件不同，**<code>GA</code> 不会使用”<code>tick</code>“函数完成主要工作，而是在激活过程中启动技能任务，异步完成大部分工作**，然后通过委托（在 C++中）处理这些任务的输出，或者连接节点以输出执行引脚（在蓝图中）。</li>
<li>如果<strong>从 <code>ActivateAbility</code> 中调用 <code>CommitAbility</code> 函数</strong>，它将应用执行 Cost 和 Cooldown 计算<ul>
<li><code>CommitAbility()</code> 会调用 <code>CommitCost()</code> 和 <code>CommitCooldown()</code>,</li>
<li>如果它们不需要同时提交, 设计师可以选择分别调用 <code>CommitCost()</code> 或 <code>CommitCooldown()</code>. </li>
<li>提交 Cost 和 Cooldown 会多次调用 <code>CheckCost()</code> 和 <code>CheckCooldown()</code>.</li>
</ul>
</li>
<li><strong><code>CancelAbility</code> 提供了取消技能的机制，不过技能的 <code>CanBeCanceled</code> 函数可以拒绝请求</strong>。与 <code>CommitAbility</code> 不同，该函数<strong>可供技能外调用者使用</strong>。成功的取消先广播给 <code>OnGameplayAbilityCancelled</code> 委托（通过这个委托可以添加自定义逻辑），然后通过标准代码路径结束技能。</li>
<li><strong><code>EndAbility</code> 会在技能执行完毕后将其关闭</strong>。如果技能被取消，<code>UGameplayAbility</code> 类会将其作为取消流程的一部分自动处理，但其他情况下，开发者都必须调用 C++函数或在技能的蓝图图表中添加节点。如果未能正常结束技能，将导致玩法技能系统认为技能仍在运行，从而带来一些影响，例如禁止将来再使用该技能或任何被该技能阻止的技能。例如，如果游戏的”喝生命药剂”玩法技能没有正常结束，那么使用该技能的角色就无法执行任何在喝血量药剂时无法执行的操作（例如喝其他药剂、快跑、爬梯子等）。<strong>这种阻碍会一直存在，因为玩法技能系统会认为角色还在喝药剂。</strong></li>
</ol>
<h2 id="02-授予-Give"><a href="#02-授予-Give" class="headerlink" title="02 授予 Give"></a>02 授予 Give</h2><blockquote>
<p>[!NOTE] 规定<br>我们授予的实际上是 <code>GA Spec</code>, 而不是直接使用 <code>GA</code> 类。可以这样理解：<code>GA Spec</code> 是用来描述技能，不仅包含 <code>GA</code> 本身，还包含其他相关信息和运行时信息。<br>很多 ASC 内置函数参数要求传入 <code>GA Spec</code>，这样不仅可以直接从 GA Spec 获取 GA，还可以获取其他信息。<br>综上，我们所说的授予 Ability，激活 Ability 都是对 <code>GA Spec</code> 进行处理。<code>GA Spec</code> 包含 <code>GA</code>，当单独说 Ability 这个词汇时，大多数时间是指 <code>GA Spec</code></p>
</blockquote>
<ul>
<li><strong>在 Actor 可以使用某项技能之前，必须向其 <code>ASC</code> 授予该技能。</strong></li>
<li>只能在服务器授予技能, 服务器会自动复制 <code>GA　Spec</code> 到所属 (Owning)客户端</li>
<li>被授予的 <code>GA Spec</code> 会被添加到 ASC 的 <code>FGameplayAbilitySpecContainer ActivatableAbility</code> 容器。</li>
</ul>
<p>ASC 中用于授予技能的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//授予但不激活</span></span><br><span class="line"><span class="comment">//返回 FGameplayAbilitySpecHandle，可用于 TryActivateAbility 等</span></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbility</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//授予后立刻激活一次，技能必须实例化</span></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(FGameplayAbilitySpec&amp; AbilitySpec, <span class="type">const</span> FGameplayEventData* GameplayEventData = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="FGameplayAbilitySpec"><a href="#FGameplayAbilitySpec" class="headerlink" title="FGameplayAbilitySpec"></a>FGameplayAbilitySpec</h3><p><code>FGameplayAbilitySpec</code> 定义了 <code>GA</code> 是什么:</p>
<ul>
<li>包含 GameplayAbility Class, level 和绑定到 input ID 的相关信息。</li>
<li>保存了 <code>GA</code> 的运行时状态</li>
<li><strong>激活 <code>GA Spec</code> 会根据实例化策略创建一个 <code>UGameplayAbility</code> 实例</strong> (<code>Non-Instanced GA</code> 除外)，<strong>该实例存储在 <code>GA Spec</code> 中</strong></li>
</ul>
<p>调用 <code>GiveAbility</code> 函数时，需要传入的参数为 GA Spec 的引用，而不是 GA 类本身。GA Spec 可直接通过调用构造函数生成，其构造函数有三个重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用AbilityClass  */</span></span><br><span class="line"><span class="built_in">FGameplayAbilitySpec</span>(TSubclassOf&lt;UGameplayAbility&gt; InAbilityClass, int32 InLevel = <span class="number">1</span>, int32 InInputID = INDEX_NONE, UObject* InSourceObject = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用AbilityClass CDO 的版本，这是为了向后兼容而存在 */</span></span><br><span class="line"><span class="built_in">FGameplayAbilitySpec</span>(UGameplayAbility* InAbility, int32 InLevel = <span class="number">1</span>, int32 InInputID = INDEX_NONE, UObject* InSourceObject = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用已存在的 spec def */</span></span><br><span class="line"><span class="built_in">FGameplayAbilitySpec</span>(FGameplayAbilitySpecDef&amp; InDef, int32 InGameplayEffectLevel, FActiveGameplayEffectHandle InGameplayEffectHandle = <span class="built_in">FActiveGameplayEffectHandle</span>());</span><br></pre></td></tr></table></figure>

<h3 id="FGameplayAbilitySpecHandle"><a href="#FGameplayAbilitySpecHandle" class="headerlink" title="FGameplayAbilitySpecHandle"></a>FGameplayAbilitySpecHandle</h3><p>注意 <code>GiveAbility</code> 函数的返回值是返回 <code>FGameplayAbilitySpecHandle</code>，**该句柄指向该已被授予的 <code>GA Spec</code>**，全局唯一。后续对该技能的取消和激活操作都需要指定该句柄。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>本项目的玩家角色类使用 <code>TArray&lt;TSubclassOf&lt;UGameplayAbility&gt;&gt;</code> 保存技能，在 PossessedBy 中调用 ASC 的授予技能函数。</p>
<figure class="highlight c++"><figcaption><span>title:Magecharacter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;MageCharacter|GAS&quot;</span>)</span><br><span class="line">TArray&lt;TSubclassOf&lt;UGameplayAbility&gt;&gt; CharacterAbilities;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:Magecharacter.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">InitASC</span>();</span><br><span class="line">	<span class="built_in">GiveCharacterAbilities</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMageCharacter::GiveCharacterAbilities</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只在服务器授予Ability</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">HasAuthority</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(UMageAbilitySystemComponent* MageASC = <span class="built_in">Cast</span>&lt;UMageAbilitySystemComponent&gt;(<span class="built_in">GetAbilitySystemComponent</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		MageASC-&gt;<span class="built_in">GiveCharacterAbilities</span>(CharacterAbilities);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMageAbilitySystemComponent::GiveCharacterAbilities</span><span class="params">(<span class="type">const</span> TArray&lt;TSubclassOf&lt;UGameplayAbility&gt;&gt;&amp; CharacterAbilities)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> AbilityClass : CharacterAbilities)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建GA Spec</span></span><br><span class="line">		<span class="function">FGameplayAbilitySpec <span class="title">AbilitySpec</span><span class="params">(AbilityClass)</span></span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="type">const</span> UMageGameplayAbility* MageGameplayAbility = <span class="built_in">Cast</span>&lt;UMageGameplayAbility&gt;(AbilitySpec.Ability))</span><br><span class="line">		&#123;</span><br><span class="line">			AbilitySpec.Level = MageGameplayAbility-&gt;StartupAbilityLevel; <span class="comment">//设置技能等级</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">/** 将 GA 的 Tag 添加到AbilitySpec, 这些 Tag 将与输入的 Tag 进行匹配*/</span></span><br><span class="line">			AbilitySpec.DynamicAbilityTags.<span class="built_in">AddTag</span>(MageGameplayAbility-&gt;StartupInputTag);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/** 授予Ability */</span></span><br><span class="line">			<span class="built_in">GiveAbility</span>(AbilitySpec); <span class="comment">//授予后不激活</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="03-取消-Ability"><a href="#03-取消-Ability" class="headerlink" title="03 取消 Ability"></a>03 取消 Ability</h2><p><strong>以下函数可以利用授予技能后返回的 <code>FGameplayAbilitySpecHandle</code>，来 <code>取消</code> 对技能系统组件中该技能的访问。</strong> </p>
<ul>
<li><code>ClearAbility</code>: 从技能系统组件中移除指定技能，其会调用 <code>EndAbility()</code> 并设置它的 <code>WasCancelled</code> 参数为 <code>true</code>.  </li>
<li><code>SetRemoveAbilityOnEnd</code>：当该技能执行完毕时，将该技能从技能系统组件中移除。如果未执行该技能，将立即移除它。如果正在执行该技能，将立即清除其输入，这样玩家就无法重新激活它或与它互动。 </li>
<li><code>ClearAllAbilities</code>：从技能系统组件中移除所有技能。此函数是唯一不需要 <code>FGameplayAbilitySpecHandle</code> 的函数。</li>
</ul>
<p>为了从内部取消<code>GameplayAbility</code>, 可以调用<code>CancelAbility()</code>,<br>为了从外部取消<code>GameplayAbility</code>, <code>ASC</code>提供了一些函数:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cancels the specified ability CDO. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbility</span><span class="params">(UGameplayAbility* Ability)</span></span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels the ability indicated by passed in spec handle. If handle is not found among reactivated abilities nothing happens. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbilityHandle</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpecHandle&amp; AbilityHandle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancel all abilities with the specified tags. Will not cancel the Ignore instance */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAbilities</span><span class="params">(<span class="type">const</span> FGameplayTagContainer* WithTags=<span class="literal">nullptr</span>, <span class="type">const</span> FGameplayTagContainer* WithoutTags=<span class="literal">nullptr</span>, UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities regardless of tags. Will not cancel the ignore instance */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelAllAbilities</span><span class="params">(UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities and kills any remaining instanced abilities */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DestroyActiveState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!bug]<br>我发现如果存在一个 <code>(Non-Instanced)GA</code> 时, <code>CancelAllAbilities</code> 似乎不能正常运行, 它似乎会命中这个 <code>(Non-Instanced)GA</code> 并放弃继续处理。 <code>CancelAbility</code> 可以更好地处理 <code>(Non-Instanced)GA</code></p>
</blockquote>
<h2 id="04-激活-Ability"><a href="#04-激活-Ability" class="headerlink" title="04 激活 Ability"></a>04 激活 Ability</h2><p>只要能获取 ASC，就可以在任何地方激活 GA，比如行为树 Task 蓝图，甚至在 GA 蓝图中调用其他 GA。</p>
<p>如果某个 <code>GA</code> 被分配给了一个输入事件, 那么当输入按键按下并且它的 <code>GameplayTag</code> 需求满足时, 它将会<strong>自动激活</strong>, 这可能并非总是激活 <code>GA</code> 的期望方式。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbilitiesByTag</span><span class="params">(<span class="type">const</span> FGameplayTagContainer&amp; GameplayTagContainer, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbilityByClass</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityToActivate, <span class="type">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TriggerAbilityFromGameplayEvent</span><span class="params">(FGameplayAbilitySpecHandle AbilityToTrigger, FGameplayAbilityActorInfo* ActorInfo, FGameplayTag Tag, <span class="type">const</span> FGameplayEventData* Payload, UAbilitySystemComponent&amp; Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(<span class="type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>ASC</code> 提供了多种激活 <code>GA</code> 的方法，可以分为主动激活（释放技能）和被动激活（挨打）两类。</p>
<ul>
<li><p><strong>主动激活</strong></p>
<ol>
<li>**<code>ByTag</code>**。这会使用匹配的 <code>GameplayAbility Trigger</code> <strong>触发所有技能</strong>。这是<mark style="background: #FF5582A6;">触发技能的 <code>GE</code> 的首选方法</mark>。</li>
<li>**<code>ByClass</code>**：一次只能 Activate 一个 GA</li>
<li><strong><code>From GA SpecHandle</code></strong> ：通过蓝图或 C++代码显式激活技能。这在授予技能时由 <code>ASC</code> 提供。</li>
<li><code>GiveAbilityAndActivateOnce</code>：上面讲过，即授予时立即激活一次，技能必须实例化。</li>
</ol>
</li>
<li><p><strong>被动激活</strong></p>
<ol>
<li><code>TriggerAbilityFromGameplayEvent</code>。通过 Event 激活 <code>GA</code> 允许你传递一个该事件的数据负载 <code>Payload</code>.。这会使用匹配的 <code>GameplayAbility Trigger</code> 触发所有技能。如果你需要抽象输入和决策机制，此方法非常适合，因为它提供了最大的灵活度。</li>
<li>通过用户输入激活，项目中在触发 InputAction 时激活技能。</li>
</ol>
</li>
</ul>
<blockquote>
<p>[!warning]<br>不要忘记应该在 <code>GA</code> 终止时调用 <code>EndAbility()</code>, 除非你的 <code>GA</code> 是像被动技能需要一直运行。</p>
</blockquote>
<h4 id="Trigger-与-Event"><a href="#Trigger-与-Event" class="headerlink" title="Trigger 与 Event"></a>Trigger 与 Event</h4><p>Trigger 可以理解为一个 Tag，当 ASC 组件收到一个 Trigger 时，就会自动调用所有拥有该 Trigger 的 GA。</p>
<p>Trigger 的 Tag 在 GA 的 details 面板中设置。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016399.png" alt="Pasted image 20231205212541"><br><strong>Trigger 的触发方式有三种，分别是：</strong></p>
<ul>
<li><code>Gameplay Event</code>: 当 Owner 收到一个带有 Tag 的 Gameplay Event 时<strong>激活一次</strong> GA，此时 Owner <strong>不会拥有对应的 Tag</strong>。</li>
<li><code>Owner Tag Added</code>: 当 Owner <strong>获取对应 Tag</strong> 的时候<strong>激活一次</strong> GA。</li>
<li><code>Owner Tag Present</code>: 当 Owner <strong>拥有 Tag</strong> 时激活 GA，失去 Tag 时移除。</li>
</ul>
<p>一般使用第一种方法，并配合 <code>SendGameplayEventToActor</code> 使用，如下图所示。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016400.png" alt="Pasted image 20231205213128"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAbilitySystemBlueprintLibrary::SendGameplayEventToActor</span><span class="params">(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload)</span></span></span><br></pre></td></tr></table></figure>

<p>使用 <code>Gameplay Event</code> 的好处是，通过 Event 激活 <code>GA</code> 允许你传递一个<strong>数据负载 (<code>Payload</code>)</strong> ，是除了 <code>Get Actor Info</code> 外的另一种信息传递方法。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016401.png" alt="Pasted image 20231205213351"><br>此时应该删除 <code>ActiveAbility</code> 节点，转而使用 <code>ActivateAbilityFromEvent</code> 事件。（<strong>不要通过在左上角重载函数的方式，右键空白处搜索才是对的</strong>）</p>
<blockquote>
<p>[!bug]<br>当从蓝图中的 Event 激活 <code>GA</code> 时, 你必须使用 <code>ActivateAbilityFromEvent</code> 节点, 并且<strong>标准的 <code>ActivateAbility</code> 节点不能出现在图表中</strong>, 如果 <code>ActivateAbility</code> 节点存在, 它就会一直被调用而不调用 <code>ActivateAbilityFromEvent</code> 节点.   </p>
</blockquote>
<h3 id="获取激活的-Ability"><a href="#获取激活的-Ability" class="headerlink" title="获取激活的 Ability"></a>获取激活的 Ability</h3><p>初学者经常会问”我怎样才能获取激活的 Ability?”, 也许是用来设置变量或取消它. 多个 <code>GameplayAbility</code> 可以在同一时刻激活, 因此没有”一个激活的 Ability”, 相反, 你必须便利 <code>ASC</code> 的 <code>ActivatableAbility</code> 列表(<code>ASC</code> 拥有的已授予 <code>GameplayAbility</code>)来获得。</p>
<p><code>UAbilitySystemComponent::GetActivatableAbilities()</code> 会返回一个用于遍历的 <code>TArray&lt;FGameplayAbilitySpec&gt;</code>.   </p>
<p><code>ASC</code> 还有另一个有用的函数, 它将一个 <code>GameplayTagContainer</code> 作为参数来协助搜索, 而无需手动遍历 <code>GameplayAbilitySpec</code> 列表. <code>bOnlyAbilitiesThatSatisfyTagRequirements</code> 参数只会返回那些 <code>GameplayTag</code> 满足需求且可以立刻激活的 <code>GameplayAbilitySpecs</code>。 例如, 你可能有两个基本的攻击 <code>GA</code>, 一个使用武器, 另一个使用拳头, 正确的激活取决于武器是否装备并设置了 <code>GameplayTag</code> 需求. 详见 Epic 关于函数的注释.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UAbilitySystemComponent::<span class="built_in">GetActivatableGameplayAbilitySpecsByAllMatchingTags</span>(<span class="type">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; <span class="keyword">struct</span> FGameplayAbilitySpec* &gt;&amp; MatchingGameplayAbilities, <span class="type">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>一旦你获取到了寻找的 <code>FGameplayAbilitySpec</code>, 那么就可以调用它的 <code>IsActive()</code>.     </p>
<h2 id="05-被动-Ability"><a href="#05-被动-Ability" class="headerlink" title="05 被动 Ability"></a>05 被动 Ability</h2><p>为了实现自动激活和持续运行的被动 <code>GA</code>, 需要重写 <code>UGameplayAbility::OnAvatarSet()</code>, 该函数在授予 <code>GA</code> 并设置 <code>AvatarActor</code> 且调用 <code>TryActivateAbility()</code> 时自动调用.  </p>
<blockquote>
<p>项目可能希望在此初始化被动 Ability 或执行其他 “BeginPlay “类型的逻辑。</p>
</blockquote>
<p>可以添加一个 <code>bool</code> 到你的自定义 <code>UGameplayAbility</code> 类来表明其在授予时是否应该被激活。</p>
<p>被动 <code>GameplayAbility</code> 一般有一个 <code>Server Only</code> 的网络执行策略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGDGameplayAbility::OnAvatarSet</span><span class="params">(<span class="type">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="type">const</span> FGameplayAbilitySpec &amp; Spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnAvatarSet</span>(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ActivateAbilityOnGranted)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本项目使用了更简单的方法</strong>，即使用 <code>GiveAbilityAndActivateOnce()</code> 授予技能，这会在授予后立即激活技能。在 GA 蓝图中，我们不执行 EndAbility，就可以保持持续激活的被动技能。</p>
<h2 id="06-传递数据到-Ability"><a href="#06-传递数据到-Ability" class="headerlink" title="06 传递数据到 Ability"></a>06 传递数据到 Ability</h2><p><code>GA</code> 的一般范式是 <code>Activate-&gt;Generate Data-&gt;Apply-&gt;End</code>. 有时你需要调整现有数据, GAS 提供了一些选项来获取外部数据到你的 <code>GameplayAbility</code>.   </p>
<ol>
<li><p><strong>使用 <code>SendGameplayEventToActor()</code> 激活 Ability</strong></p>
<ul>
<li>使用含有数据负载 (<code>Payload</code>)的 Event 激活 <code>GameplayAbility</code>. </li>
<li>对于客户端预测的 <code>GameplayAbility</code>, Event 的 <code>Payload</code> 是由客户端复制到服务端的. 对于那些不适合任意现有变量的数据可以使用两个 <code>Optional Object</code> <code>或TargetData</code> 变量. </li>
<li><strong>该方法的缺点是不能使用输入绑定激活 Ability</strong>. 为了通过 Event 激活 <code>GA</code>, 该 <code>GA</code> 必须设置其 Trigger, 分配一个 <code>GameplayTag</code> 并选择一个 <code>GameplayEvent</code> 选项. 想要发送事件, 就得使用 <code>SendGameplayEventToActor()</code> 函数.</li>
</ul>
</li>
<li><p><strong>使用 <code>WaitGameplayEvent AbilityTask</code></strong></p>
<ul>
<li>在 <code>GA</code> 激活后, 使用 <code>WaitGameplayEvent AbilityTask</code> 来告知其监听带有负载 <code>Payload</code> 的事件. <code>Payload</code> 及其发送过程与通过 Event 激活 <code>GA</code> 是一样的. </li>
<li>GA 在 <code>Wait Gameplay Event</code> 的时候会在 ASC 内部记录一个回调, 通过 Tag 来映射识别; 而当外部别的 GA 调用 <code>Send Gameplay Event</code> 的时候, 会用 Event 的 Tag 在 ASC 的映射表中搜索, 如果搜索到就会触发对应的回调</li>
<li><strong>该方法的缺点是 Event 不能通过 <code>AbilityTask</code> 复制且只能用于 <code>Local Only</code> 和 <code>Server Only</code> 的 <code>GameplayAbility</code></strong>. 你可以编写自己的 <code>AbilityTask</code> 以支持复制 Event 负载 (Payload).</li>
</ul>
</li>
<li><p><strong>使用 <code>TargetData</code></strong></p>
<ul>
<li>自定义 <code>TargetData</code> 结构体是一种在客户端和服务端之间传递任意数据的好方法.</li>
</ul>
</li>
<li><p><strong>保存数据在 <code>OwnerActor</code> 或者 <code>AvatarActor</code></strong></p>
<ul>
<li>使用保存于 <code>OwnerActor</code>, <code>AvatarActor</code> 或者其他任意你可以获取到引用的对象中的可复制变量. 这种方法最灵活且可以用于由输入绑定激活的 <code>GameplayAbility</code>, </li>
<li>然而, 它不能保证在使用时数据复制, 你必须提前做好准备 - 这意味着如果你设置了一个可复制的变量, 之后立即激活该 <code>GameplayAbility</code>, 那么因为存在潜在的丢包情况, 不能保证接收者上发生的顺序.</li>
</ul>
</li>
</ol>
<h2 id="07-GA-标签"><a href="#07-GA-标签" class="headerlink" title="07 GA 标签"></a>07 GA 标签</h2><p><code>GameplayAbility</code> 自带有内建逻辑的 <code>GameplayTagContainer</code>. </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016402.png" alt="Pasted image 20231015000402"></p>
<table>
<thead>
<tr>
<th align="center">GameplayTagContainer</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ability Tags</td>
<td align="center">此 Ability 有以下 Tag</td>
</tr>
<tr>
<td align="center">Cancel Abilities with Tag</td>
<td align="center">执行此Ability时，带有这些Tag的Ability会被取消</td>
</tr>
<tr>
<td align="center">Block Abilities with Tag</td>
<td align="center">此Ability激活时，带有这些Tag的Ability会被阻止</td>
</tr>
<tr>
<td align="center"><strong>Activation Owned Tags</strong></td>
<td align="center">此Ability激活时应用于激活所有者的Tag。</td>
</tr>
<tr>
<td align="center"><strong>Activation Required Tags</strong></td>
<td align="center">只有当激活的角色&#x2F;组件拥有所有这些 Tag 时，才能激活此Ability。</td>
</tr>
<tr>
<td align="center"><strong>Activation Blocked Tags</strong></td>
<td align="center">如果激活的角色&#x2F;组件具有以下任何一个Tag，此Ability 将被阻止。</td>
</tr>
<tr>
<td align="center">Source Required Tags</td>
<td align="center">只有当源角色&#x2F;组件具有所有这些Tag时才会激活Ability</td>
</tr>
<tr>
<td align="center">Source Blocked Tags</td>
<td align="center">源角色&#x2F;组件具有以下任何一个Tag，此Ability 将被阻止。</td>
</tr>
<tr>
<td align="center">Target Required Tags</td>
<td align="center">只有当目标角色&#x2F;组件具有所有这些Tag时，才能激活此Abilty。</td>
</tr>
<tr>
<td align="center">Target Blocked Tags</td>
<td align="center">目标角色&#x2F;组件具有以下任何一个Tag，此Ability 将被阻止。</td>
</tr>
</tbody></table>
<h2 id="08-升级-Ability"><a href="#08-升级-Ability" class="headerlink" title="08 升级 Ability"></a>08 升级 Ability</h2><p>有两个常见的方法用于升级Ability:  </p>
<table>
<thead>
<tr>
<th align="center">升级方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">升级时取消授予和重新授予</td>
<td align="center">自<code>ASC</code>取消授予(移除)<code>GameplayAbility</code>, 并在下一等级于服务端上重新授予. 如果此时<code>GameplayAbility</code>是激活的, 那么就会终止它.</td>
</tr>
<tr>
<td align="center">增加<code>GameplayAbilitySpec</code>的等级</td>
<td align="center">在服务端上找到<code>GameplayAbilitySpec</code>, 增加它的等级, 并将其标记为Dirty以复制到所属(Owning)客户端. 该方法不会在<code>GameplayAbility</code>激活时将其终止.</td>
</tr>
</tbody></table>
<p>两种方法的主要区别在于你是否想要在升级时取消激活的 <code>GameplayAbility</code>. 基于你的 <code>GameplayAbility</code>, 你很可能需要同时使用两种方法. 我建议在 <code>UGameplayAbility</code> 子类中增加一个布尔值以明确使用哪种方法.   </p>
<h2 id="09-实例化策略-Instanced-Policy"><a href="#09-实例化策略-Instanced-Policy" class="headerlink" title="09 实例化策略 (Instanced Policy)"></a>09 实例化策略 (Instanced Policy)</h2><p>激活 <code>GA Spec</code> 会根据实例化策略创建一个 <code>UGameplayAbility</code> 实例 (<code>Non-Instanced GA</code> 除外)，该实例存储在 <code>GA Spec</code> 中。<strong>在某些情况下可能会非常频繁地执行技能，会出现因快速创建技能对象而对性能产生负面影响的情况。</strong><br>为了解决这个问题，技能可以选择<strong>三种不同的实例化策略</strong>，以在效率和功能之间达到平衡。支持的三种实例化类型： </p>
<table>
<thead>
<tr>
<th align="center">实例化策略</th>
<th align="center">描述</th>
<th align="center">何时使用的例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按 Actor 实例化 (Instanced Per Actor)</td>
<td align="center">每个 <code>ASC</code> 只能有一个在激活之间复用的 <code>GA</code> 实例.</td>
<td align="center">这可能是你使用最频繁的实例化策略. 你可以对任一 <code>GA</code> 使用并在激活之间提供持久化. 设计者可以在激活之间手动重设任意变量.</td>
</tr>
<tr>
<td align="center">按执行实例化 (Instanced Per Execution)</td>
<td align="center">每有一个 <code>GA</code> 激活, 就有一个新的 <code>GA</code> 实例创建.</td>
<td align="center">这些 <code>GA</code> 的好处是每次激活时变量都会重置, 其性能要比 <code>Instanced Per Actor</code> 差, 因为每次激活时都会生成新的 <code>GA</code>.</td>
</tr>
<tr>
<td align="center">非实例化 (Non-Instanced)</td>
<td align="center"><code>GA</code> 操作其 CDO, 没有实例创建.</td>
<td align="center">它是三种方式中性能最好的, 但是使用它是最受限制的. <code>(Non-Instanced)GA</code> 不能存储状态, 这意味着没有动态变量和不能绑定到 <code>AbilityTask</code> 委托. 使用它的最佳场景就是需要频繁使用的简单 Ability, 像 MOBA 或 RTS 游戏中小兵的基础攻击. 样例项目中的跳跃 <code>GameplayAbility</code> 就是 <code>非实例化(Non-Instanced)</code> 的.</td>
</tr>
</tbody></table>
<p>官方文档：</p>
<ol>
<li><strong>按执行实例化：（Instanced per Execution:）</strong> 每次技能运行时，都会产生新的 <code>GA</code> 对象的副本。<ul>
<li>优点：可以自由使用蓝图图表和成员变量，并且所有内容都将在执行开始时初始化为默认值。这是最简单的实例化策略，</li>
<li>缺点：开销较大，该策略更适合不会频繁运行的技能。</li>
</ul>
</li>
<li><strong>按 Actor 实例化：（Instanced per Actor:）</strong> 在技能首次执行会生成该技能的一个实例对象，该对象会在以后的执行中重复使用。这就要求在两次技能执行之间清理成员变量，同时也使保存多个执行的信息成为可能。按 Actor 是较为理想的复制方法，因为技能具有可处理变量和 RPC 的复制对象，而不是浪费网络带宽和 CPU 时间，在每次运行时产生新对象。<strong>该策略适用于大规模的情况，因为大量使用技能的 Actor（例如在大型战斗中）只会在第一次使用技能时产生对象。</strong></li>
<li><strong>非实例化：（Non-Instanced:）</strong> <strong>最高效</strong>的策略。技能不会生成任何对象，而是使用<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/objects-in-unreal-engine">类默认对象</a>（CDO）。<ul>
<li>但是，在高效的同时也伴随着一些限制：<ul>
<li>首先，该策略<strong>要求技能完全用 C ++编写</strong>，因为创建蓝图图表需要对象实例。你可以创建非实例化技能的蓝图类，但这只能更改已公开属性的默认值。</li>
<li>此外，在<strong>执行技能期间</strong>，即使在本机 C ++代码中，技能也<strong>不能更改成员变量，不能绑定代理，也不能复制变量或处理 RPC。</strong></li>
</ul>
</li>
<li>该策略<strong>仅适用于不需要内部变量存储</strong>（尽管可以针对技能用户设置属性）<strong>并且不需要复制任何数据的技能</strong>。它尤其适合频繁运行且被许多角色使用的技能，例如大型 RTS 或 MOBA 作品中部队使用的<strong>基本攻击</strong>。</li>
</ul>
</li>
</ol>
<h2 id="10-绑定输入到-ASC-？"><a href="#10-绑定输入到-ASC-？" class="headerlink" title="10 绑定输入到 ASC?？"></a>10 绑定输入到 ASC?？</h2><h3 id="增强输入系统"><a href="#增强输入系统" class="headerlink" title="增强输入系统"></a>增强输入系统</h3><h3 id="旧版输入系统-InputID"><a href="#旧版输入系统-InputID" class="headerlink" title="旧版输入系统 InputID"></a>旧版输入系统 InputID</h3><p><strong><code>ASC</code> 允许你直接绑定输入事件并当你授予 <code>GA</code> 时分配这些输入到 <code>GA</code></strong> , 如果 <code>GameplayTag</code> 合乎要求, 当按下按键时, 分配到 <code>GA</code> 的<strong>输入事件</strong>会自动激活各自的 <code>GA</code>. <strong>分配的输入事件要求使用响应输入的内置 <code>AbilityTask</code>.</strong>    </p>
<p>除了分配的输入事件可以激活 <code>GA</code>, <code>ASC</code> 也接受一般的 <code>Confirm</code> 和 <code>Cancel</code> 输入, 这些特殊输入被 <code>AbilityTask</code> 用来确定像 <a href="#concepts-targeting-actors">Target Actor</a> 的对象或取消它们.   </p>
<p>为了绑定输入到 <code>ASC</code>, 你必须首先创建一个枚举来将输入事件名称转换为 byte, 枚举名必须准确匹配项目设置中用于输入事件的名称, <code>DisplayName</code> 就无所谓了.   </p>
<p>样例项目中:   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EGDAbilityInputID</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0 None</span></span><br><span class="line">	<span class="function">None			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;None&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 1 Confirm</span></span></span><br><span class="line"><span class="function">	Confirm			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Confirm&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 2 Cancel</span></span></span><br><span class="line"><span class="function">	Cancel			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Cancel&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 3 LMB</span></span></span><br><span class="line"><span class="function">	Ability1		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability1&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 4 RMB</span></span></span><br><span class="line"><span class="function">	Ability2		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability2&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 5 Q</span></span></span><br><span class="line"><span class="function">	Ability3		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability3&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 6 E</span></span></span><br><span class="line"><span class="function">	Ability4		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability4&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 7 R</span></span></span><br><span class="line"><span class="function">	Ability5		<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Ability5&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 8 Sprint</span></span></span><br><span class="line"><span class="function">	Sprint			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Sprint&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	<span class="comment">// 9 Jump</span></span></span><br><span class="line"><span class="function">	Jump			<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Jump&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>如果你的 <code>ASC</code> 位于 <code>Character</code>, 那么就在 <code>SetupPlayerInputComponent()</code> 中包含用于绑定到 <code>ASC</code> 的函数.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind to AbilitySystemComponent</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">BindAbilityActivationToInputComponent</span>(PlayerInputComponent, <span class="built_in">FGameplayAbilityInputBinds</span>(<span class="built_in">FString</span>(<span class="string">&quot;ConfirmTarget&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;CancelTarget&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;EGDAbilityInputID&quot;</span>), <span class="built_in">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="built_in">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br></pre></td></tr></table></figure>

<p><strong>如果你的 <code>ASC</code> 位于 <code>PlayerState</code>, <code>SetupPlayerInputComponent()</code> 中有一个潜在的竞争情况就是 <code>PlayerState</code> 还没有复制到客户端, 因此, 我建议尝试在 <code>SetupPlayerInputComponent()</code> 和 <code>OnRep_PlayerState()</code> 中绑定输入</strong>, 只有 <code>OnRep_PlayerState()</code> 自身是不充分的, 因为可能有种情况是当 <code>PlayerState</code> 在 <code>PlayerController</code> 告知客户端调用用于创建 <code>InputComponent</code> 的 <code>ClientRestart()</code> 前复制时, Actor 的 <code>InputComponent</code> 可能为 NULL. 样例项目演示了尝试使用一个布尔值控制流程从而在两个位置绑定, 这样实际上只绑定了一次.    </p>
<blockquote>
<p>[!NOTE]<br>样例项目枚举中的 <code>Confirm</code> 和 <code>Cancel</code> 没有匹配项目设置中的输入事件名称 (<code>ConfirmTarget</code> 和 <code>CancelTarget</code>), 但是我们在 <code>BindAbilityActivationToInputComponent()</code> 中提供了它们之间的映射, 这是特殊的, 因为我们提供了映射并且它们无需匹配, 但是它们是可以匹配的. 枚举中的其他输入都必须匹配项目设置中的输入事件名称.  </p>
</blockquote>
<p>对于只能用一次输入激活的 <code>GameplayAbility</code> (它们总是像 MOBA 游戏一样存在于相同的”槽”中), 我倾向在 <code>UGameplayAbility</code> 子类中添加一个变量, 这样我就可以定义他们的输入, 之后在授予 Ability 的时候可以从 <code>ClassDefaultObject</code> 中读取这个值.   </p>
<h3 id="绑定输入时不激活-Ability"><a href="#绑定输入时不激活-Ability" class="headerlink" title="绑定输入时不激活 Ability"></a>绑定输入时不激活 Ability</h3><p><strong>如果你不想你的 <code>GameplayAbility</code> 在按键按下时自动激活, 但是仍想将它们绑定到输入以与 <code>AbilityTask</code> 一起使用</strong>, 你可以在 <code>UGameplayAbility</code> 子类中添加一个新的布尔变量, <code>bActivateOnInput</code>, 其默认值为 <code>true</code> 并重写 <code>UAbilitySystemComponent::AbilityLocalInputPressed()</code>.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGSAbilitySystemComponent::AbilityLocalInputPressed</span><span class="params">(int32 InputID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Consume the input if this InputID is overloaded with GenericConfirm/Cancel and the GenericConfim/Cancel callback is bound</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsGenericConfirmInputBound</span>(InputID))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LocalInputConfirm</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsGenericCancelInputBound</span>(InputID))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LocalInputCancel</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ABILITYLIST_SCOPE_LOCK</span>();</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : ActivatableAbilities.Items)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Spec.InputID == InputID)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Spec.Ability)</span><br><span class="line">			&#123;</span><br><span class="line">				Spec.InputPressed = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (Spec.<span class="built_in">IsActive</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="built_in">IsOwnerActorAuthoritative</span>() == <span class="literal">false</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">ServerSetInputPressed</span>(Spec.Handle);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">AbilitySpecInputPressed</span>(Spec);</span><br><span class="line"></span><br><span class="line">					</span><br><span class="line"><span class="comment">//调用 InputPressed 事件。这里不进行复制。如果有人在监听，他们可能会将 InputPressed 事件复制到服务器。					InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.GetActivationPredictionKey());</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					UGSGameplayAbility* GA = <span class="built_in">Cast</span>&lt;UGSGameplayAbility&gt;(Spec.Ability);</span><br><span class="line">					<span class="keyword">if</span> (GA &amp;&amp; GA-&gt;bActivateOnInput)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// Ability is not active, so try to activate it</span></span><br><span class="line">						<span class="built_in">TryActivateAbility</span>(Spec.Handle);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-网络"><a href="#11-网络" class="headerlink" title="11 网络"></a>11 网络</h2><h3 id="网络执行策略-Net-Execution-Policy"><a href="#网络执行策略-Net-Execution-Policy" class="headerlink" title="网络执行策略 (Net Execution Policy)"></a>网络执行策略 (Net Execution Policy)</h3><p>网络执行策略决定了 <code>GameplayAbility</code> 在网络上如何执行</p>
<p><code>GameplayAbility</code> 运行在所属 (Owning)客户端还是服务端取决于<a href="#concepts-ga-net">网络执行策略(Net Execution Policy)</a> 而不是 Simulated Proxy.<br><code>网络执行策略(Net Execution Policy)</code> 决定某个 <code>GameplayAbility</code> 是否是客户端可<a href="#concepts-p">预测</a>的, 其对于可选的 <code>Cost</code> 和 <code>Cooldown GameplayEffect</code> 包含有默认行为.<br><strong><code>Simulated Client</code> 不会运行 <code>GameplayAbility</code>,</strong> 而是当服务端执行 <code>Ability</code> 时, 任何需要在 Simulated Proxy 上展现的视觉效果 (像动画蒙太奇)将会被复制 (Replicate)或者通过 <code>AbilityTask</code> 进行 RPC 或者对于像声音和粒子这样的装饰效果使用 <a href="#concepts-gc">GameplayCue</a>.   </p>
<table>
<thead>
<tr>
<th align="center">网络执行策略 (Net Execution Policy)</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Local Only</td>
<td align="center"><code>GameplayAbility</code> 只运行在所属 (Owning)客户端. 这对那些只需做本地视觉变化的 Ability 很有用. 单人游戏应该使用 <code>Server Only</code>.</td>
</tr>
<tr>
<td align="center">Local Predicted</td>
<td align="center"><code>Local Predicted GameplayAbility</code> 首先在所属 (Owning)客户端激活, 之后在服务端激活. 服务端版本会纠正客户端预测的所有不正确的地方. 参见 Prediction.</td>
</tr>
<tr>
<td align="center">Server Only</td>
<td align="center"><code>GameplayAbility</code> 只运行在服务端. 被动 <code>GameplayAbility</code> 一般是 <code>Server Only</code>. 单人游戏应该使用该项.</td>
</tr>
<tr>
<td align="center">Server Initiated</td>
<td align="center"><code>Server Initiated GameplayAbility</code> 首先在服务端激活, 之后在所属 (Owning)客户端激活. 我个人使用的不多 (如果有的话).</td>
</tr>
</tbody></table>
<h3 id="网络安全策略-Net-Security-Policy"><a href="#网络安全策略-Net-Security-Policy" class="headerlink" title="网络安全策略 (Net Security Policy)"></a>网络安全策略 (Net Security Policy)</h3><p>网络安全策略决定了 Ability 应该在网络的何处执行. 它为尝试执行限制 Ability 的客户端提供了保护.  </p>
<table>
<thead>
<tr>
<th align="center">网络安全策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClientOrServer</td>
<td align="center">没有安全需求. 客户端或服务端可以自由地触发该 Ability 的执行和终止.</td>
</tr>
<tr>
<td align="center">ServerOnlyExecution</td>
<td align="center">客户端对该 Ability 请求的执行会被服务端忽略, 但客户端仍可以请求服务端取消或结束该 Ability.</td>
</tr>
<tr>
<td align="center">ServerOnlyTermination</td>
<td align="center">客户端对该 Ability 请求的取消或结束会被服务端忽略, 但客户端仍可以请求执行该 Ability.</td>
</tr>
<tr>
<td align="center">ServerOnly</td>
<td align="center">服务端控制该 Ability 的执行和终止, 客户端的任何请求都会被忽略.</td>
</tr>
</tbody></table>
<h3 id="客户端预测-GA"><a href="#客户端预测-GA" class="headerlink" title="客户端预测 GA"></a>客户端预测 GA</h3><p>对于<strong>客户端预测</strong><code>GameplayAbility</code> 的激活序列:  </p>
<ol>
<li><strong>所属 (Owning)客户端</strong>调用 <code>TryActivateAbility()</code></li>
<li>调用 <code>InternalTryActivateAbility()</code></li>
<li>调用 <code>CanActivateAbility()</code> 并返回是否满足 <code>GameplayTag</code> 需求, <code>ASC</code> 是否满足技能花费, <code>GameplayAbility</code> 是否不在冷却期和当前是否没有其他实例被激活</li>
<li>调用 <code>CallServerTryActivateAbility()</code> 并传入其生成的 <code>Prediction Key</code></li>
<li>调用 <code>CallActivateAbility()</code></li>
<li>调用 <code>PreActivate()</code>, Epic 称之为”boilerplate init stuff”</li>
<li>调用 <code>ActivateAbility()</code> 最终激活 Ability</li>
</ol>
<p><strong>服务端</strong>接收到 <code>CallServerTryActivateAbility()</code>  </p>
<ol>
<li>调用 <code>ServerTryActivateAbility()</code></li>
<li>调用 <code>InternalServerTryActivateAbility()</code></li>
<li>调用 <code>InternalTryActivateAbility()</code></li>
<li>调用 <code>CanActivateAbility()</code> 并返回是否满足 <code>GameplayTag</code> 需求, <code>ASC</code> 是否满足技能花费, <code>GameplayAbility</code> 是否不在冷却期和当前是否没有其他实例被激活</li>
<li>如果成功则调用 <code>ClientActivateAbilitySucceed()</code> 告知客户端更新它的 <code>ActivationInfo</code> (即该激活已由服务端确认)并广播 <code>OnConfirmDelegate</code> 代理. 这和输入确认 (Input Confirmation)不一样.</li>
<li>调用 <code>CallActivateAbility()</code></li>
<li>调用 <code>PreActivate()</code>, Epic 称之为”boilerplate init stuff”</li>
<li>调用 <code>ActivateAbility()</code> 最终激活 Ability</li>
</ol>
<p>如果服务端在任意时刻激活失败, 就会调用 <code>ClientActivateAbilityFailed()</code>, 立即终止客户端的 <code>GameplayAbility</code> 并撤销所有预测的修改.  </p>
<h3 id="❌Replication-Policy"><a href="#❌Replication-Policy" class="headerlink" title="❌Replication Policy"></a>❌Replication Policy</h3><p><strong>不要使用该选项</strong>. 这个名字会误导你并且你并不需要它. <a href="#concepts-ga-spec">**GameplayAbilitySpec</a> 默认会从服务端向所属 (Owning)客户端复制**, 上文提到过, <code>GameplayAbility</code> 不会运行在 Simulated Proxy 上, 其使用 <code>AbilityTask</code> 和 <code>GameplayCue</code> 来复制或者 RPC 视觉变化到 Simulated Proxy. Epic 的 Dave Ratti 已经表明要在未来<a target="_blank" rel="noopener" href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">移除该选项</a>的意愿.  </p>
<h3 id="❌Server-Respects-Remote-Ability-Cancellation"><a href="#❌Server-Respects-Remote-Ability-Cancellation" class="headerlink" title="❌Server Respects Remote Ability Cancellation"></a>❌Server Respects Remote Ability Cancellation</h3><p>这个选项往往会引起麻烦. 它的意思是如果客户端的 <code>GameplayAbility</code> 由于玩家取消或者自然完成时, 就会强制它的服务端版本结束而不管其是否完成. 最重要的是之后的问题, 特别是对于高延迟玩家所使用的客户端预测的 <code>GameplayAbility</code>. 一般情况下禁用该选项.  </p>
<p><a name="concepts-ga-definition-repinputdirectly"></a></p>
<h3 id="❌Replicate-Input-Directly"><a href="#❌Replicate-Input-Directly" class="headerlink" title="❌Replicate Input Directly"></a>❌Replicate Input Directly</h3><p>设置该选项就会一直向服务端复制输入的按下 (Press)和抬起 (Release)事件. Epic 不建议使用该选项而是依靠创建在已有输入相关的 <a href="#concepts-at">AbilityTask</a> 中的 <code>Generic Replicated Event</code> (如果你的<a href="#concepts-ga-input">输入绑定在ASC</a>).  </p>
<p>Epic 的注释:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Direct Input state replication. These will be called if bReplicateInputDirectly is true on the ability and is generally not a good thing to use. (Instead, prefer to use Generic Replicated Events). */</span></span><br><span class="line"><span class="comment">//直接输入状态复制。如果 ability 上的 bReplicateInputDirectly 为 true，就会调用这些功能，而且一般不适合使用。(相反，最好使用通用复制事件）。</span></span><br><span class="line">UAbilitySystemComponent::<span class="built_in">ServerSetInputPressed</span>()</span><br></pre></td></tr></table></figure>

<h3 id="Ability-批处理"><a href="#Ability-批处理" class="headerlink" title="Ability 批处理"></a>Ability 批处理</h3><p>一般 <code>GameplayAbility</code> 的生命周期最少涉及 2 到 3 个自客户端到服务端的 RPC.  </p>
<ol>
<li>CallServerTryActivateAbility ()</li>
<li>ServerSetReplicatedTargetData () (可选)</li>
<li>ServerEndAbility ()</li>
</ol>
<p>如果 <code>GameplayAbility</code> 在一帧同一原子 (Atomic)组中执行这些操作, 我们就可以优化该工作流, 将所有 2 个或 3 个 RPC 批处理 (整合)为 1 个 RPC. <code>GAS</code> 称这种 RPC 优化为 <code>Ability批处理</code>. 常见的使用 <code>Ability批处理</code> 时机的例子是枪支命中判断. 枪支命中判断时, 会在一帧同一原子 (Atomic)组中做射线检测, 发送 <a href="#concepts-targeting-data">TargetData</a> 到服务端并结束 Ability. GASShooter 样例项目对其枪支命中判断使用了该技术.  </p>
<p>半自动枪支是最好的案例, 其将 <code>CallServerTryActivateAbility()</code>, <code>ServerSetReplicatedTargetData()</code> (子弹命中结果)和 <code>ServerEndAbility()</code> 批处理成一个而不是三个 <code>RPC</code>.  </p>
<p>全自动&#x2F;爆炸开火枪支会对第一发子弹将 <code>CallServerTryActivateAbility()</code> 和 <code>ServerSetReplicatedTargetData()</code> 批处理成一个而不是两个 RPC, 接下来的每一发子弹都是它自己的 <code>ServerSetReplicatedTargetData()</code> RPC, 最后, 当停止射击时, <code>ServerEndAbility()</code> 会作为单独的 RPC 发送. 这是最坏的情况, 我们只保存了第一发子弹的一个 RPC 而不是两个. 这种情况也可以通过 <a href="#concepts-ga-data">GameplayEvent</a> 激活 Ability 来实现, 该 <code>GameplayEvent</code> 会自客户端向服务端发送带有 <code>EventPayload</code> 的子弹 <code>TargetData</code>. 后者的缺点是 <code>TargetData</code> 必须在 Ability 外部生成, 尽管批处理方法在 Ability 内部生成 <code>TargetData</code>.  </p>
<p>Ability 批处理在 <a href="#concepts-asc">ASC</a> 中是默认禁止的. 为了启用 Ability 批处理, 需要重写 <code>ShouldDoServerAbilityRPCBatch()</code> 以返回 true:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldDoServerAbilityRPCBatch</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>现在 Ability 批处理已经启用, 在激活你想使用批处理的 Ability 之前, 必须提前创建一个 <code>FScopedServerAbilityRPCBatcher</code> 结构体, 这个特殊的结构体会在其域内尝试批处理所有跟随它的 Ability, 一旦出了 <code>FScopedServerAbilityRPCBatcher</code> 域, 所有已激活的 Ability 将不再尝试批处理. <code>FScopedServerAbilityRPCBatcher</code> 通过在每个可以批处理的函数中设置特殊代码来运行, 其会拦截 RPC 的发送并将消息打包进一个批处理结构体, 当出了 <code>FScopedServerAbilityRPCBatcher</code> 后, 它会在 <code>UAbilitySystemComponent::EndServerAbilityRPCBatch()</code> 中自动将该批处理结构体 RPC 到服务端, 服务端在 <code>UAbilitySystemComponent::ServerAbilityRPCBatch_Internal(FServerAbilityRPCBatch&amp; BatchInfo)</code> 中接收该批处理结构体, <code>BatchInfo</code> 参数会包含几个 flag, 其包括该 Ability 是否应该结束, 激活时输入是否按下和是否包含 <code>TargetData</code>. 这是个可以设置断点以确认批处理是否正确运行的好函数. 作为选择, 可以使用 <code>AbilitySystem.ServerRPCBatching.Log 1</code> 来启用特别的 Ability 批处理日志.  </p>
<p>这个方法只能在 C++中完成, 并且只能通过 <code>FGameplayAbilitySpecHandle</code> 来激活 Ability.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UGSAbilitySystemComponent::BatchRPCTryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle InAbilityHandle, <span class="type">bool</span> EndAbilityImmediately)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> AbilityActivated = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (InAbilityHandle.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FScopedServerAbilityRPCBatcher <span class="title">GSAbilityRPCBatcher</span><span class="params">(<span class="keyword">this</span>, InAbilityHandle)</span></span>;</span><br><span class="line">		AbilityActivated = <span class="built_in">TryActivateAbility</span>(InAbilityHandle, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (EndAbilityImmediately)</span><br><span class="line">		&#123;</span><br><span class="line">			FGameplayAbilitySpec* AbilitySpec = <span class="built_in">FindAbilitySpecFromHandle</span>(InAbilityHandle);</span><br><span class="line">			<span class="keyword">if</span> (AbilitySpec)</span><br><span class="line">			&#123;</span><br><span class="line">				UGSGameplayAbility* GSAbility = <span class="built_in">Cast</span>&lt;UGSGameplayAbility&gt;(AbilitySpec-&gt;<span class="built_in">GetPrimaryInstance</span>());</span><br><span class="line">				GSAbility-&gt;<span class="built_in">ExternalEndAbility</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> AbilityActivated;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> AbilityActivated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GASShooter 对半自动和全自动枪支使用了相同的批处理 <code>GameplayAbility</code>, 并没有直接调用 <code>EndAbility()</code> (它通过一个只能由客户端调用的 Ability 在该 Ability 外处理, 该只能由客户端调用的 Ability 用于管理玩家输入和基于当前开火模式对批处理 Ability 的调用). 因为所有的 RPC 必须在 <code>FScopedServerAbilityRPCBatcher</code> 域中, 所以我提供了 <code>EndAbilityImmediately</code> 参数以使仅客户端的控制&#x2F;管理可以明确该 Ability 是否可以批处理 <code>EndAbility()</code> (半自动)或不批处理 <code>EndAbility()</code> (全自动)以及之后 <code>EndAbility()</code> 是否可以在其自己的 RPC 中调用.  </p>
<p>GASShooter 暴露了一个蓝图节点以允许上文提到的仅客户端调用的 Ability 所使用的批处理 Ability 来触发批处理 Ability. (译者注: 此处相当拗口, 但原文翻译确实如此, 配合项目浏览也许会更容易明白些.)  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016403.png" alt="789e45f3d6c054bea171333c58322c40_MD5">  </p>
<h1 id="7-Ability-Async-和-Ability-Task"><a href="#7-Ability-Async-和-Ability-Task" class="headerlink" title="7 Ability Async 和 Ability Task"></a>7 Ability Async 和 Ability Task</h1><p><code>Ability Async</code> 和 <code>Abiilty Task</code> 用于执行异步逻辑。它们通常遵循 “启动某项操作并等待完成或中断 “的模式。</p>
<h2 id="Ability-Async"><a href="#Ability-Async" class="headerlink" title="Ability Async"></a>Ability Async</h2><blockquote>
<p>[!NOTE]<br>在任何蓝图执行</p>
</blockquote>
<p>AbilityAsync 是特定 Ability BlueprintAsyncActions 的基类。在基类的基础上增加了对 <code>ASC</code> 的引用。（如果要实现蓝图异步节点监听 ASC 可以直接继承此类，或继承基类然后添加对 ASC 的引用。区别不大）</p>
<ul>
<li><strong>类似于 Ability Task，但它们可以像 Actor 一样从任何蓝图中执行，并且不与特定 Ability 的生命周期绑定。</strong></li>
<li>默认情况下，这些 Action <strong>仅由生成它们的蓝图保持存活</strong>，如果蓝图实例被销毁或生成替代品，这些动作最终将被销毁。</li>
<li><code>EndAction</code> 应在一次 Action 成功或失败时调用，但对于具有多个触发器的较长寿命的 Action ，可从蓝图中调用。</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016404.png" alt="Pasted image 20231206122310"></p>
<h2 id="Ability-Task"><a href="#Ability-Task" class="headerlink" title="Ability Task"></a>Ability Task</h2><blockquote>
<p>[!NOTE]<br>仅 GA 执行</p>
</blockquote>
<p>AbilityTask 是可以<strong>在执行 Ability 的同时进行</strong>的小型、自包含操作（只能由 GA 调用）。</p>
<p>GAS 自带很多 <code>AbilityTask</code>:<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016405.png" alt="Pasted image 20231203095003"></p>
<p>熟悉 AbilityTasks 的最佳方法是查看现有任务，如 UAbilityTask_WaitOverlap（非常简单）和 UAbilityTask_WaitTargetData（复杂得多）。</p>
<p>这些是使用 AbilityTask 的基本要求：</p>
<ol>
<li>在能力任务中定义动态多播、BlueprintAssignable 委托。这些是 Task 的输出。当这些委托触发时，调用的蓝图将重新开始执行。</li>
<li>输入由 static 工厂函数定义，该函数将实例化 Task 的一个实例。该函数的参数定义了 Task 的输入。工厂函数要做的就是实例化 Task ，并可能设置起始参数。它不应调用任何回调委托！</li>
<li>重载 <code>Activate()</code> 函数。该函数应实际 start&#x2F;execute 任务逻辑。在此调用回调委托。</li>
</ol>
<ul>
<li>检查列表：</li>
<li>重载 <code>OnDestroy()</code> 并<strong>取消 Task 注册的任何回调</strong>。同时调用 <code>Super::EndTask</code></li>
<li>实现真正激活 Task 的 <code>Activate</code> 函数。不要在静态工厂函数中激活 Task！应该<strong>在此绑定委托回调</strong></li>
</ul>
<blockquote>
<p>[!warning]<br><code>UAbilityTask</code> 的构造函数中强制硬编码允许最多 1000 个同时运行的 <code>AbilityTask</code>, 当设计那些同时拥有数百个 Character 的游戏 (像 RTS)的 <code>GameplayAbility</code> 时要注意这一点.  </p>
</blockquote>
<h2 id="Spawn-Actor-的-AbilityTask"><a href="#Spawn-Actor-的-AbilityTask" class="headerlink" title="Spawn Actor 的 AbilityTask"></a>Spawn Actor 的 AbilityTask</h2><p>我们为希望 spawn actor 的 AbilityTask 提供了额外支持。虽然这可以在 <code>Activate ()</code> 函数中实现，但无法传递动态的 “<code>ExposeOnSpawn</code> “actor 属性。这是蓝图的一个强大功能，为了支持这一功能，需要实现不同的步骤 3：</p>
<ol>
<li>不通过 <code>Activate ()</code> 函数生成，而是使用 <code>BeginSpawningActor ()</code> 和 <code>FinishSpawningActor ()</code> 函数。<ul>
<li>区别于 <code>Activate()</code>，它们能够使所生成的 Actor 可以通过 <code>meta = (ExposeOnSpawn = true)</code> 向蓝图节点暴露参数。<code>AbilityTask_WaitTargetData</code> 中的 StartLocation、Reticle 参数就是这样来的，它们都是 TargetActor 通过这种方式暴露出来的参数。</li>
<li><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016406.png" alt="Pasted image 20231209000506|243"></li>
</ul>
</li>
<li><code>BeginSpawningActor ()</code> 必须接收名为 “Class “的 <code>TSubclassOf&lt;YourActorClassToSpawn&gt;</code> 参数。它还必须有一个名为 <code>SpawnedActor</code> 的 <code>YourActorClassToSpawn*&amp;</code> 类型的外部引用参数。该函数可以决定是否要生成角色（如果希望根据网络授权来决定是否生成角色，则该函数非常有用）。</li>
</ol>
<ul>
<li><code>BeginSpawningActor ()</code> 可以使用 <code>SpawnActorDeferred</code>  来实例化一个角色。这一点很重要，否则 UCS 将在 SpawnedActor 参数设置之前运行。</li>
<li><code>BeginSpawningActor ()</code> 还应将 SpawnedActor 参数设置为所生成的角色。</li>
<li>接下来，生成的字节码将把 “SpawnedActor 参数 “设置为用户设置的任何参数。</li>
<li>如果你生成了某个 Actor，<code>FinishSpawningActor()</code> 就会被调用，并传入刚刚生成的 Actor。你必须在这个 Actor上调用 <code>ExecuteConstruction</code> + <code>PostActorConstruction</code>！<figure class="highlight c++"><figcaption><span>title:AbilityTask_WaitTargetData</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (HidePin = <span class="string">&quot;OwningAbility&quot;</span>, DefaultToSelf = <span class="string">&quot;OwningAbility&quot;</span>, BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>), Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BeginSpawningActor</span><span class="params">(UGameplayAbility* OwningAbility, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; Class, AGameplayAbilityTargetActor*&amp; SpawnedActor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (HidePin = <span class="string">&quot;OwningAbility&quot;</span>, DefaultToSelf = <span class="string">&quot;OwningAbility&quot;</span>, BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>), Category = <span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FinishSpawningActor</span><span class="params">(UGameplayAbility* OwningAbility, AGameplayAbilityTargetActor* SpawnedActor)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>值得注意的是 <code> BeginSpawningActor</code> 和 <code>FinishSpawningActor</code> 在蓝图中会自动调用，<code>UK2Node_LatentGameplayTaskCall</code> 类保证了这一点。在 C++中则需要手动调用：<br>![[GAS AbilityTask 整理#小部分 Tasks 的自动绑定机制]]</p>
<p>可以在 <code>AbilityTask_SpawnActor()</code> 查看示例。</p>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>[[异步节点]]</p>
<h2 id="使用AbilityTask"><a href="#使用AbilityTask" class="headerlink" title="使用AbilityTask"></a>使用AbilityTask</h2><p>在C++中创建并激活<code>AbilityTask</code>(GDGA_FireGun.cpp):  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">UGDAT_PlayMontageAndWaitForEvent* Task = UGDAT_PlayMontageAndWaitForEvent::<span class="built_in">PlayMontageAndWaitForEvent</span>(<span class="keyword">this</span>, NAME_None, MontageToPlay, <span class="built_in">FGameplayTagContainer</span>(), <span class="number">1.0f</span>, NAME_None, <span class="literal">false</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定回调</span></span><br><span class="line">Task-&gt;OnBlendOut.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCompleted);</span><br><span class="line">Task-&gt;OnCompleted.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCompleted);</span><br><span class="line">Task-&gt;OnInterrupted.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCancelled);</span><br><span class="line">Task-&gt;OnCancelled.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::OnCancelled);</span><br><span class="line">Task-&gt;EventReceived.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UGDGA_FireGun::EventReceived);</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活</span></span><br><span class="line">Task-&gt;<span class="built_in">ReadyForActivation</span>();</span><br></pre></td></tr></table></figure>

<p>在蓝图中, 我们只需使用为 <code>AbilityTask</code> 创建的蓝图节点, 不必调用 <code>ReadyForActivate()</code>, 其由 <code>&#123;cpp&#125;K2Node_LatentGameplayTaskCall.cpp</code> 自动调用.<br><code>K2Node_LatentGameplayTaskCall</code> 也会自动调用 <code>BeginSpawningActor()</code> 和 <code>FinishSpawningActor()</code> (如果它们存在于你的 <code>AbilityTask</code> 类中, 查看 <code>AbilityTask_WaitTargetData</code>), <strong>再强调一遍, <code>K2Node_LatentGameplayTaskCall</code> 只会对蓝图做这些自动操作, 在 C++中, 我们必须手动调用 <code>ReadyForActivation()</code>, <code>BeginSpawningActor()</code> 和 <code>FinishSpawningActor()</code>.</strong>   </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016407.png" alt="888ed3c330cc4a58423f1ba9c3ce0459_MD5">  </p>
<p>如果想要手动取消 <code>AbilityTask</code>, 只需在蓝图(Async Task Proxy)或 C++中对 <code>AbilityTask</code> 对象调用 <code>EndTask()</code>.   </p>
<h1 id="8-Gameplay-Cue"><a href="#8-Gameplay-Cue" class="headerlink" title="8 Gameplay Cue"></a>8 Gameplay Cue</h1><h2 id="01-定义-3"><a href="#01-定义-3" class="headerlink" title="01 定义"></a>01 定义</h2><p><code>GameplayCue</code> 是负责运行视觉和声音效果的 Actor 和 UObject，执行<strong>非游戏逻辑相关的功能, 像音效, 粒子效果, 镜头抖动</strong>等等。</p>
<p><code>GameplayCue</code> 一般是<strong>可复制和可预测</strong>的（除非设置 <code>Executed</code>, <code>Added</code> 或 <code>Removed</code> 是本地的）。是在多人游戏中复制美化效果 (如音效、特效等，称为 Cosmetic)的首选方法。</p>
<p>**<code>GA</code> 和 <code>GE</code> 可以触发 <code>Cue</code>**。它们通过四个可在本地或蓝图代码中覆盖的主函数来产生作用：<code>On Active</code>、<code>While Active</code>、<code>Removed</code> 及 <code>Executed</code>（仅由 GE 使用）。</p>
<p><code>GameplayCue</code> <strong>使用不可靠的复制</strong>，因此有可能一些客户端没有接收到提示或显示其反馈。如果你将 Gameplay 代码绑定到这些 Cue，这可能造成不复制。<strong>因此，<code>GameplayCue</code> 应该仅用于美化反馈。对于需要复制到所有客户端的 Gameplay 相关反馈，你应该转而依赖 Ability Tasks 来处理复制</strong>。<strong>播放蒙太奇（Play Montage）</strong> 技能任务就是很好的例子。 </p>
<h2 id="02-调用-GC"><a href="#02-调用-GC" class="headerlink" title="02 调用 GC"></a>02 调用 GC</h2><p>**一般通过 GE 配置，也可以在 GA 里调用 execute&#x2F;add 触发</p>
<h3 id="通过-GE-调用"><a href="#通过-GE-调用" class="headerlink" title="通过 GE 调用"></a>通过 GE 调用</h3><p><strong><code>GameplayEffect</code> 可以 Add&#x2F;Remove&#x2F;Execute <code>GameplayCue</code>：</strong></p>
<ul>
<li><code>(Instant)GE</code> 可以调用  Execute </li>
<li><code>(Duration)</code> 或 <code>(Infinite)</code> 可以调用 Add 和 Remove.</li>
</ul>
<p>选择 GC 对应的 Tag 即可，可以同时选择多个 Tag，触发多个 GC。</p>
<p>默认在成功应用 (未被 Tag 或 Immunity 阻塞)的 <code>GE</code> 中填写所有应该触发的 <code>GameplayCue</code> 的 <code>GameplayTag</code>.   </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016408.png" alt="Pasted image 20231205225018"></p>
<ul>
<li><code>Require Modifier Success to Trigger Cues</code>：需要 GE 成功修改 Attribute 后才调用 GC，而不仅仅是 Apply 该 GE。</li>
<li><code>Suppress Stacking Cues</code>：如果为 true，GameplayCues 将只在 Stacking GE 的第一个实例中被触发。否则触发多次 GC（如果使用了 Stack，对应的一定是 <code>GameplayCueNotify_Actor</code>）。</li>
<li>Min、Max Level 和 Magnitude Attribute 则与传入参数有关<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016409.png" alt="Pasted image 20231205225346"></li>
<li>Raw Magnitude 即为 Magnitude Attribute 的值，而 Normalized Magnitude 的计算方式如下：</li>
</ul>
<p>$Normalized &#x3D; (Raw - Min) &#x2F; (Max - Min)$</p>
<p>如上图所示，当 Min&#x3D;0 且 Max&#x3D;100 时，Normalized &#x3D; Raw &#x2F; 100，即百分比。</p>
<h3 id="手动调用"><a href="#手动调用" class="headerlink" title="手动调用"></a>手动调用</h3><p><code>UGameplayCueFunctionLibrary</code> 提供了全局的 C++函数和蓝图节点来 <code>Execute</code>, <code>Add</code> 或 <code>Remove</code> GameplayCue.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016410.png" alt="7c2109bfb643c979cab43b16eebe5dfb_MD5">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** GameplayCues can also come on their own. These take an optional effect context to pass through hit result, etc */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, FGameplayEffectContextHandle EffectContext = FGameplayEffectContextHandle())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a persistent gameplay cue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, FGameplayEffectContextHandle EffectContext = FGameplayEffectContextHandle())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Remove a persistent gameplay cue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveGameplayCue</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/** Removes any GameplayCue added on its own, i.e. not as part of a GameplayEffect. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveAllGameplayCues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="03-GameplayCueNotify"><a href="#03-GameplayCueNotify" class="headerlink" title="03 GameplayCueNotify"></a>03 GameplayCueNotify</h2><p>GC 的触发分为两种情况 (两个 <code>GameplayCueNotify</code> 类): <code>Static</code> 和 <code>Actor</code>。</p>
<ul>
<li><code>Static Cue</code> 直接在 <code>CDO</code> 上调用, 这意味着不要在 GC 中存储一些状态信息, 因为它不会生成新的对象; </li>
<li><code>Actor Cue</code> 触发 <code>Spawn</code> 生成新的实例, 这些生效的 GC 最终也是在 ASC 里引用保存<br>它们各自响应不同的事件, 并且不同的 <code>GE</code> 类型可以触发它们. 根据你的逻辑重写相关的事件.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">GameplayCue类</th>
<th align="center">事件</th>
<th align="center">GE类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>GameplayCueNotify_Static</code></td>
<td align="center">Execute</td>
<td align="center">Instant或Periodic</td>
<td align="center">直接操作<code>CDO</code>(意味着没有实例)并且对于一次性效果(像击打伤害)是极好的.</td>
</tr>
<tr>
<td align="center"><code>GameplayCueNotify_Actor</code></td>
<td align="center">Add或Remove</td>
<td align="center">Duration或Infinite</td>
<td align="center">会在Added 时生成一个新的实例, 因为其是实例化的, 所以可以随时间推移执行操作直到被移除(Removed). 这对循环的声音和粒子效果是很好的, 其会在<code>(Duration)GE</code>或<code>(Infinite)GE</code>被移除或手动调用移除时移除. 其也自带选项来管理允许同时添加(Added)多少个, 因此多个相同效果的应用只启用一次声音或粒子效果.</td>
</tr>
</tbody></table>
<p><code>GameplayCueNotify</code> 技术上可以响应任何事件, 但是这是我们一般使用它的方式.   </p>
<blockquote>
<p>[!warning]<br>当使用 <code>GameplayCueNotify_Actor</code> 时, 要勾选 <code>Auto Destroy on Remove</code>, 否则之后对 <code>GameplayCueTag</code> 的 <code>添加(Add)</code> 调用将无法进行.   </p>
</blockquote>
<p>当使用除 <code>Full</code> 之外的 <code>ASC</code> <a href="#concepts-asc-rm">复制模式</a>时, <code>Add</code> 和 <code>Remove</code> 事件会在服务端玩家中触发两次(Listen Server) 一次是应用 <code>GE</code>, 再一次是从”Minimal”<code>NetMultiCast</code> 到客户端. 然而, <code>WhileActive</code> 事件仍会触发一次. 所有的事件在客户端中只触发一次.   </p>
<h2 id="04-GameplayCue-标签"><a href="#04-GameplayCue-标签" class="headerlink" title="04 GameplayCue 标签"></a>04 GameplayCue 标签</h2><p>通常通过发送一个<strong>强制带有 <code>GameplayCue.XX</code> 父层级</strong>的 <code>GameplayTag</code> 和 <code>UGameplayCueManager</code> 中定义的 Execute, Add 或 Remove 来触发 <code>GameplayCue</code>.  </p>
<blockquote>
<p>[!NOTE]<br><strong>再次强调, <code>GameplayCue</code> 的 <code>GameplayTag</code> 需要以 <code>GameplayCue</code> 为开头</strong>, 举例来说, 一个有效的 <code>GameplayCue</code> 的 <code>GameplayTag</code> 可能是 <code>GameplayCue.A.B.C</code>.<br>创建 <code>GameplayCue</code> 时，你会运行要在事件图表中播放的效果的逻辑。<code>GameplayCue</code> 可以与一系列 <code>GameplayTag</code> 关联，并且匹配这些标签的 <code>GE</code> 将<strong>自动应用 Apply 它们</strong>。 </p>
</blockquote>
<p>例如，<strong>如果你将标签 [Ability. Magic. Fire. Weak] 添加到 <code>GameplayCue</code>，拥有 [Ability. Magic. Fire. Weak] 的 <code>GE</code> 将自动生成该 <code>GameplayCue</code> 并运行它</strong>。这样就可以快速轻松创建视觉效果的通用库，而不必手动从代码触发它们。或者，你也可以触发没有 GE 关联的 Cue 。有关此实现的例子，你可以查看 Lyra 示例游戏的武器发射反馈。</p>
<h2 id="05-FGameplayCueParameters"><a href="#05-FGameplayCueParameters" class="headerlink" title="05 FGameplayCueParameters"></a>05 FGameplayCueParameters</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016411.png" alt="Pasted image 20231205230054"></p>
<blockquote>
<p>本项目的 GA_E_MeeAttack 使用 GameplayCue 播放音效和特效</p>
</blockquote>
<p><code>GameplayCue</code> 接受一个包含额外 <code>GameplayCue</code> 信息的 <code>FGameplayCueParameters</code> 结构体作为参数. </p>
<ul>
<li>如果你在 <code>GA</code> 或 <code>ASC</code> 中使用函数手动触发 <code>GameplayCue</code>, 那么就必须手动填充传递给 <code>GameplayCue</code> 的 <code>GameplayCueParameters</code> 结构体. </li>
<li>如果 <code>GameplayCue</code> 由 <code>GE</code> 触发, 那么下列的变量会自动填充到 <code>FGameplayCueParameters</code> 结构体中:   <ul>
<li>AggregatedSourceTags</li>
<li>AggregatedTargetTags</li>
<li>GameplayEffectLevel</li>
<li>AbilityLevel</li>
<li>EffectContext</li>
<li>Magnitude(如果 <code>GE</code> 具有在 <code>GameplayCue</code> 标签容器(TagContainer)上方的下拉列表中选择的 <code>Magnitude Attribute</code> 和影响该 <code>Attribute</code> 的相应 <code>Modifier</code>)</li>
</ul>
</li>
</ul>
<p><strong>当手动触发<code>GameplayCue</code>时, <code>GameplayCueParameters</code>中的<code>SourceObject</code>变量是一个传递任意数据到<code>GameplayCue</code>的好地方.</strong>  </p>
<blockquote>
<p>[!NOTE]<br>参数结构体中的某些变量, 像 <code>Instigator</code>, 可能已经存在于 <code>EffectContext</code> 中. <code>EffectContext</code> 也可以包含 <code>FHitResult</code> 用于存储 <code>GameplayCue</code> 在世界中生成的位置. 子类化 <code>EffectContext</code> 似乎是一个传递更多数据到 <code>GameplayCue</code> 的好方法, 特别是对于那些由 <code>GameplayEffect</code> 触发的 <code>GameplayCue</code>.   </p>
</blockquote>
<p>查看 UAbilitySystemGlobals 中用于填充 <code>GameplayCueParameters</code> 结构体的三个函数以获得更多信息. 它们是虚函数, 因此你可以重写它们以自动填充更多信息.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize GameplayCue Parameters */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectSpecForRPC &amp;Spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters_GESpec</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectSpec &amp;Spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">InitGameplayCueParameters</span><span class="params">(FGameplayCueParameters&amp; CueParameters, <span class="type">const</span> FGameplayEffectContextHandle&amp; EffectContext)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="06-UGameplayCueManager"><a href="#06-UGameplayCueManager" class="headerlink" title="06 UGameplayCueManager"></a>06 UGameplayCueManager</h2><p>默认情况下, 游戏开始时 <code>GameplayCueManager</code> 会扫描游戏的全部目录以寻找 <code>GameplayCueNotify</code> 并将其加载进内存。可以见到以下警告</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogAbilitySystem: Warning: No GameplayCueNotifyPaths were specified in DefaultGame.ini under [/Script/GameplayAbilities.AbilitySystemGlobals]. Falling back to <span class="keyword">using</span> all of /Game/. This may be slow on large projects. Consider specifying which paths are to be searched.</span><br><span class="line"><span class="comment">//在[/Script/ gameplayabilties . abilitysystemglobals]下的DefaultGame.ini中没有指定gameplaycuenotifypath。回到使用所有的/Game/。这在大型项目中可能会很慢。考虑指定要搜索的路径</span></span><br></pre></td></tr></table></figure>

<p>我们可以设置 <code>DefaultGame.ini</code> 来修改 <code>GameplayCueManager</code> 的扫描路径.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">GameplayCueNotifyPaths=<span class="string">&quot;/Game/Blueprints/GAS/GameplayCue&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们确实想要 <code>GameplayCueManager</code> 扫描并找到所有的 <code>GameplayCueNotify</code>, 然而, <strong>我们不想要它异步加载每一个, 因为这会将每个 <code>GameplayCueNotify</code> 和它们所引用的音效和粒子特效放入内存而不管它们是否在关卡中使用</strong>. 在像 Paragon 这样的大型游戏中, 内存中会放入数百兆的无用资源并造成卡顿和启动时无响应.   </p>
<p><strong>在启动时异步加载每个 <code>GameplayCue</code> 的一种可选方法是只异步加载那些会在游戏中触发的 <code>GameplayCue</code></strong> , 这会在异步加载每个 <code>GameplayCue</code> 时减少不必要的内存占用和潜在的游戏无响应几率, 从而避免特定 <code>GameplayCue</code> 在游戏中第一次触发时可能出现的延迟效果.<br><strong>SSD 不存在这种潜在的延迟</strong>, 我还没有在 HDD 上测试过, 如果在 UE 编辑器中使用该选项并且编辑器需要编译粒子系统的话, 就可能会在 GameplayCue 首次加载时有轻微的卡顿或无响应, 这在构建版本中不是问题, 因为粒子系统肯定是编译好的。</p>
<p>首先我们必须继承 <code>UGameplayCueManager</code> 并告知 <code>AbilitySystemGlobals</code> 类在 <code>DefaultGame.ini</code> 中使用我们的 <code>UGameplayCueManager</code> 子类.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">GlobalGameplayCueManagerClass=<span class="string">&quot;/Script/ParagonAssets.PBGameplayCueManager&quot;</span></span><br></pre></td></tr></table></figure>

<p>在我们的 <code>UGameplayCueManager</code> 子类中, 重写 <code>ShouldAsyncLoadRuntimeObjectLibraries()</code>.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldAsyncLoadRuntimeObjectLibraries</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="concepts-gc-prevention"></a></p>
<h2 id="07-阻止-GameplayCue-响应"><a href="#07-阻止-GameplayCue-响应" class="headerlink" title="07 阻止 GameplayCue 响应"></a>07 阻止 GameplayCue 响应</h2><p>有时我们不想响应 <code>GameplayCue</code>, 例如我们阻止了一次攻击, 可能就不想播放附加在伤害 <code>GameplayEffect</code> 上的击打效果或者自定义的效果. 我们可以在 ExecCalc 中调用 <code>OutExecutionOutput.MarkGameplayCuesHandledManually()</code>, 之后手动发送我们的 <code>GameplayCue</code> 事件到 <code>Target</code> 或 <code>Source</code> 的 <code>ASC</code> 中.  </p>
<p>如果你想某个特别指定<code>ASC</code>中的<code>GameplayCue</code>永不触发, 可以设置<code>AbilitySystemComponent-&gt;bSuppressGameplayCues = true;</code>.  </p>
<h2 id="08-网络"><a href="#08-网络" class="headerlink" title="08 网络"></a>08 网络</h2><h3 id="GameplayCue-批处理"><a href="#GameplayCue-批处理" class="headerlink" title="GameplayCue 批处理"></a>GameplayCue 批处理</h3><p><strong>每次<code>GameplayCue</code>触发都是一次不可靠的多播(NetMulticast)RPC</strong>. 在同一时刻触发多个<code>GameplayCue</code>的情况下, 有一些优化方法来将它们压缩成一个RPC或者通过发送更少的数据来节省带宽.  </p>
<h4 id="手动RPC"><a href="#手动RPC" class="headerlink" title="手动RPC"></a>手动RPC</h4><p>假设你有一个可以发射8枚弹丸的霰弹枪, 就会有8个轨迹和碰撞<code>GameplayCue</code>. GASShooter采用将它们联合成一个RPC的延迟(Lazy)方法, 其将所有的轨迹信息保存到<a href="#concepts-ge-ec">EffectContext</a>作为<a href="#concepts-targeting-data">TargetData</a>. 尽管其将RPC数量从8降为1, 然而还是在这一个RPC中通过网络发送大量数据(~500 bytes). 一个进一步优化的方法是使用一个自定义结构体发送RPC, 在该自定义RPC中你需要高效编码命中位置(Hit Location)或者给一个随机种子以在接收端重现&#x2F;近似计算碰撞位置, 客户端之后需要解包该自定义结构体并重现<a href="#concepts-gc-local">客户端执行的<code>GameplayCue</code></a>.  </p>
<p>运行机制:  </p>
<ol>
<li>声明一个<code>FScopedGameplayCueSendContext</code>. 其会阻塞<code>UGameplayCueManager::FlushPendingCues()</code>直到其出域, 意味着所有<code>GameplayCue</code>都将会排队等候直到该<code>FScopedGameplayCueSendContext</code>出域.</li>
<li>重写<code>UGameplayCueManager::FlushPendingCues()</code>以将那些可以基于一些自定义<code>GameplayTag</code>批处理的<code>GameplayCue</code>合并进自定义的结构体并将其RPC到客户端.</li>
<li>客户端接收自定义结构体并将其解包进客户端执行的<code>GameplayCue</code>.</li>
</ol>
<p>该方法也可以在你的<code>GameplayCue</code>需要特别指定的参数时使用, 这些需要特别指定的参数不能由<code>GameplayCueParameter</code>提供, 并且你不想将它们添加到<code>EffectContext</code>, 像伤害数值, 暴击标识, 破盾标识, 处决标识等等.  </p>
<p><a target="_blank" rel="noopener" href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1711546-fscopedgameplaycuesendcontext-gameplaycuemanager">https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1711546-fscopedgameplaycuesendcontext-gameplaycuemanager</a>  </p>
<h3 id="GE-中的多个-GameplayCue"><a href="#GE-中的多个-GameplayCue" class="headerlink" title="GE 中的多个 GameplayCue"></a>GE 中的多个 GameplayCue</h3><p>一个 <code>GE</code> 中的所有 <code>GameplayCue</code> 已经由一个 RPC 发送了. 默认情况下, <code>UGameplayCueManager::InvokeGameplayCueAddedAndWhileActive_FromSpec()</code> 会在不可靠的 (NetMulticast)RPC 中发送整个 <code>GE Spec</code> (除了转换为 <code>FGameplayEffectSpecForRPC</code>)而不管 <code>ASC</code> 的复制模式, 取决于 <code>GE Spec</code> 的内容, 这可能会使用大量带宽, 我们可以通过设置 <code>AbilitySystem.AlwaysConvertGESpecToGCParams 1</code> 来将其优化, 这会将 <code>GE Spec</code> 转换为 <code>FGameplayCueParameter</code> 结构体并且 RPC 它而不是整个 <code>FGameplayEffectSpecForRPC</code>, 这会节省带宽但是只有较少的信息, 取决于 <code>GESpec</code> 如何转换为 <code>GameplayCueParameters</code> 和你的 <code>GameplayCue</code> 需要知道什么.   </p>
<h3 id="客户端-GameplayCue"><a href="#客户端-GameplayCue" class="headerlink" title="客户端 GameplayCue"></a>客户端 GameplayCue</h3><p>从 <code>GA</code> 和 <code>ASC</code> 中暴露的用于触发 <code>GC</code> 的函数<strong>默认是可复制的</strong>. <strong>每个 <code>GameplayCue</code> 事件都是一个多播 (Multicast) RPC</strong>. 这会导致大量 RPC. </p>
<p>GAS 也强制在每次网络更新中最多能有两个相同的 <code>GameplayCue</code> RPC. 我们可以通过使用客户端 <code>GameplayCue</code> 来避免这个问题. 客户端 <code>GameplayCue</code> 只能在单独的客户端上 <code>Execute</code>, <code>Add</code> 或 <code>Remove</code>.  </p>
<p>可以使用客户端 <code>GameplayCue</code> 的场景:  </p>
<ul>
<li>抛射物伤害</li>
<li>近战碰撞伤害</li>
<li>动画蒙太奇触发的 <code>GameplayCue</code></li>
</ul>
<p>你应该添加到 <code>ASC</code> 子类中的客户端 <code>GameplayCue</code> 函数:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GameplayCue&quot;</span>, Meta = (AutoCreateRefTerm = <span class="string">&quot;GameplayCueParameters&quot;</span>, GameplayTagFilter = <span class="string">&quot;GameplayCue&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters&amp; GameplayCueParameters)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::ExecuteGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Executed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::AddGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::OnActive, GameplayCueParameters);</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::WhileActive, GameplayCueParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPAAbilitySystemComponent::RemoveGameplayCueLocal</span><span class="params">(<span class="type">const</span> FGameplayTag GameplayCueTag, <span class="type">const</span> FGameplayCueParameters &amp; GameplayCueParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">GetGameplayCueManager</span>()-&gt;<span class="built_in">HandleGameplayCue</span>(<span class="built_in">GetOwner</span>(), GameplayCueTag, EGameplayCueEvent::Type::Removed, GameplayCueParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个 <code>GameplayCue</code> 是客户端添加的, 那么它也应该自客户端移除. 如果它是通过复制添加的, 那么它也应该通过复制移除.  </p>
<h1 id="9-Ability-System-Globals"><a href="#9-Ability-System-Globals" class="headerlink" title="9 Ability System Globals"></a>9 Ability System Globals</h1><p><code>AbilitySystemGlobals</code> 类保存有关 GAS 的全局信息. 大多数变量可以在 <code>DefaultGame.ini</code> 中设置. 一般你不需要和该类互动, 但是应该知道它的存在. 如果你需要继承像 <code>GameplayCueManager</code>或 <code>GameplayEffectContext</code>这样的对象, 就必须通过 <code>AbilitySystemGlobals</code> 来做.  </p>
<p>想要继承<code>AbilitySystemGlobals</code>, 需要在<code>DefaultGame.ini</code>中设置类名:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">AbilitySystemGlobalsClassName=<span class="string">&quot;/Script/ParagonAssets.PAAbilitySystemGlobals&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="InitGlobalData"><a href="#InitGlobalData" class="headerlink" title="InitGlobalData()"></a>InitGlobalData()</h2><p>从 UE 4.24开始, 必须调用 <code>UAbilitySystemGlobals::InitGlobalData()</code> 来使 <code>TargetData</code>, 否则你会遇到关于 <code>ScriptStructCache</code> 的错误, 并且客户端会从服务端断开连接, 该函数只需要在项目中调用一次. Fortnite 从 AssetManager 类的起始加载函数中调用该函数, Paragon 是从 UEngine::Init()中调用的. 我发现将其放到 <code>UEngineSubsystem::Initialize()</code> 是个好位置, 这也是样例项目中使用的. 我觉得你应该复制这段模板代码到你自己的项目中以避免出现 <code>TargetData</code> 的使用问题.  </p>
<p>如果你在使用<code>AbilitySystemGlobals GlobalAttributeSetDefaultsTableNames</code>时发生崩溃, 可能之后需要像Fortnite一样在<code>AssetManager</code>或<code>GameInstance</code>中调用<code>UAbilitySystemGlobals::InitGlobalData()</code>而不是在<code>UEngineSubsystem::Initialize()</code>中. 该崩溃可能是由于<code>Subsystem</code>的加载顺序引发的, <code>GlobalAttributeDefaultsTables</code>需要加载<code>EditorSubsystem</code>来绑定<code>UAbilitySystemGlobals::InitGlobalData()</code>中的委托.  </p>
<h1 id="10-Targeting"><a href="#10-Targeting" class="headerlink" title="10 Targeting"></a>10 Targeting</h1><p>Targeting：<strong>目标选择</strong></p>
<p>用于解决游戏的目标选择时<strong>信息的获取</strong>和<strong>外观表现</strong></p>
<ul>
<li><code>TargetActor</code> 是执行选择目标逻辑的 Actor</li>
<li><code>TargetData</code> 是选择目标逻辑的计算结果</li>
<li><code>WorldReticle</code> 是选择目标过程中进行表现的 Actor</li>
</ul>
<p>它们三者配合的步骤一般如下：</p>
<ol>
<li>激活技能，使用 AbilityTask 生成 TargetActor  </li>
<li>触发 TargetActor 的选择目标逻辑。<ul>
<li>具体触发的时机要根据玩法决定：<ul>
<li>例如，某些跟踪子弹，会随着我们的准星移动锁定 &#x2F; 解锁目标，在此过程中要不断地更新目标选择，所以可以在 Tick 或 Timer 中反复触发。</li>
<li>例如，一般的直线弹道子弹，“扣动扳机” 时，生成 TargetActor，在其<strong>确认</strong>时一次性触发计算即可。</li>
</ul>
</li>
</ul>
</li>
<li><strong>确认</strong>目标，数据填到 TargetData 结构体实例中，Broadcast 出去（也可能发生<strong>取消</strong>目标）</li>
<li>技能接收到 TargetData，提取信息，执行技能逻辑，例如生成子弹等<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016413.png" alt="Pasted image 20231206223211"><br>具体实现可以参考 GASShooter 项目的 <strong>AGSGATA_LineTrace</strong> 和 <strong>AGSGATA_SphereTrace</strong> 类。</li>
</ol>
<h2 id="Target-Data"><a href="#Target-Data" class="headerlink" title="Target Data"></a>Target Data</h2><h3 id="FGameplayAbilityTargetData"><a href="#FGameplayAbilityTargetData" class="headerlink" title="FGameplayAbilityTargetData"></a>FGameplayAbilityTargetData</h3><p>一个通用的 TargetData 结构体。我们希望通用函数来【生成】这些 TargetData，其他通用函数来【消耗】这些 TargetData。  </p>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li><p><strong>一些 TargetData 【生成】案例：</strong>  </p>
<ul>
<li>Overlap&#x2F;Hit 碰撞事件生成关于谁在近战攻击中被击中的 TargetData</li>
<li>鼠标输入导致 hit trace，十字准星前面的 actor 被转换为 TargetData</li>
<li>鼠标输入导致 TargetData 从所有者的准星视图 origin&#x2F;direction 生成  </li>
<li>一个 AOE 技能，所有在发起者周围半径内的 actor 被添加到 TargetData</li>
<li>Panzer Dragoon 风格的 ‘painting’ targeting 模式（就是按住瞄准，扫描到的敌人身上都生成准星 UI）  </li>
<li>MMORPG 风格的地面 AOE targeting 模式（可能是地面上的位置和被定位的 actor）</li>
</ul>
</li>
<li><p><strong>一些 TargetData 【消耗】案例：</strong>  </p>
<ul>
<li>将 GE 应用到 TargetData 中的所有 actor</li>
<li>从 TargetData 中的所有 actor 中找到最近的 actor</li>
<li>在 TargetData 中的所有 actor 上调用某些函数 </li>
<li>过滤 (Filter)或合并 (merge) TargetData </li>
<li>在 TargetData 位置 Spawn 一个新的 actor*</li>
</ul>
</li>
<li><p>或许最好区分与 Actor 相关的 Targeting 和与定位相关的 Targeting data？  </p>
<ul>
<li>AOE 类型的 Targeting data 模糊了界限</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>Targetdata</code> 保存了特定的 actors&#x2F;object 引用，FHitResult，也能保存通用的 location&#x2F;direction&#x2F;origin 信息。可以继承它以增添想要的任何数据, 其可以简单理解为在客户端和服务端的 <code>GA</code> 中传递数据. </p>
<h4 id="创建TargetData"><a href="#创建TargetData" class="headerlink" title="创建TargetData"></a>创建TargetData</h4><p><code>TargetData</code> 一般由 <code>Target Actor</code> 或者手动创建, 供 <code>AbilityTask</code>]使用, 或者 <code>GE</code> 通过 <code>GE Context</code> 使用。因为<strong>其位于 <code>GE Context</code> 中</strong>, 所以 ExecCalc, MMC, <code>GameplayCue</code> 和 <code>AttributeSet</code> 的后端函数可以访问该 <code>TargetData</code>.   </p>
<h4 id="使用TargetData"><a href="#使用TargetData" class="headerlink" title="使用TargetData"></a>使用TargetData</h4><p><strong>基础结构体 <code>FGameplayAbilityTargetData</code> 不能直接使用, 而是要继承它。</strong> 因为它只定义了数据访问方法，没有定义数据本身。</p>
<p>GAS 的 <code>GameplayAbilityTargetTypes.h</code> 中有一些开箱即用的派生 <code>FGameplayAbilityTargetData</code> 结构体：</p>
<ul>
<li><code>FGameplayAbilityTargetData_LocationInfo</code>  ：带有<strong>源位置</strong>和<strong>目标位置</strong>的 TargetData</li>
<li><code>FGameplayAbilityTargetData_ActorArray</code>：带有<strong>源位置</strong>和<strong>目标 Actot 列表</strong>的 TargetData，适用于 <strong>AOE 攻击</strong>目标选择。</li>
<li><code>FGameplayAbilityTargetData_SingleTargetHit</code>：带有单个 <code>FHitResult</code> 信息的TargetData，适合单目标子弹。TargetData 被打包到 <code>FHitResult</code></li>
</ul>
<h4 id="自定义-TargetData"><a href="#自定义-TargetData" class="headerlink" title="自定义 TargetData"></a>自定义 TargetData</h4><p>上述内置的 TargetData，基本上是够用了，如果需要创建新的 TargetData 类型，就需要视携带的数据类型 <code>FGameplayAbilityTargetData</code> 的虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> TArray&lt;TWeakObjectPtr&lt;AActor&gt;&gt; <span class="built_in">GetActors</span>() <span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetActors</span><span class="params">(TArray&lt;TWeakObjectPtr&lt;AActor&gt;&gt; NewActorArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasHitResult</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> FHitResult* <span class="title">GetHitResult</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReplaceHitWith</span><span class="params">(AActor* NewHitActor, <span class="type">const</span> FHitResult* NewHitResult)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasOrigin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FTransform <span class="title">GetOrigin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasEndPoint</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FVector <span class="title">GetEndPoint</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FTransform <span class="title">GetEndPointTransform</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** See notes on delegate definition FOnTargetActorSwapped */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldCheckForTargetActorSwap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>debug 相关虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the serialization data, must always be overridden */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> UScriptStruct* <span class="title">GetScriptStruct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FGameplayAbilityTargetData::<span class="built_in">StaticStruct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a debug string representation */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FString <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>源代码在实现完类型后，还有附带下面这一段代码，看注释应该和网络同步序列化有关，反正依瓢画葫芦复制 + 替换类型名称即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct TStructOpsTypeTraits&lt;FGameplayAbilityTargetData_ActorArray&gt; : public TStructOpsTypeTraitsBase2&lt;FGameplayAbilityTargetData_ActorArray&gt;</span><br><span class="line">&#123;</span><br><span class="line">    enum</span><br><span class="line">    &#123;</span><br><span class="line">        WithNetSerializer = true    // For now this is REQUIRED for FGameplayAbilityTargetDataHandle net serialization to work</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="FGameplayAbilityTargetDataHandle"><a href="#FGameplayAbilityTargetDataHandle" class="headerlink" title="FGameplayAbilityTargetDataHandle"></a>FGameplayAbilityTargetDataHandle</h3><p><code>FGameplayAbilityTargetDataHandle</code> 包含一个 <code>TArray&lt;TSharedPtr&lt;FGameplayAbilityTargetData&gt;&gt; Data</code>  这个中间结构体可以：</p>
<ul>
<li>避免在蓝图中复制完整的 TargetData 结构体  </li>
<li>允许我们利用 TargetData 结构体中的多态性  </li>
<li>允许我们实现 NetSerialize 并在客户端&#x2F;服务器之间按值复制  </li>
<li>避免使用 UObjects，可用于在蓝图中提供多态性和引用传递。</li>
</ul>
<p>**我们一般不直接传递 <code>FGameplayAbilityTargetData</code> 而是使用 <code>FGameplayAbilityTargetDataHandle TargetActor 对 TargetData 进行广播时，不会直接使用 </code>FGameplayAbilityTargetData<code>的实例，而是需要将其封装为</code>FGameplayAbilityTargetDataHandle&#96; 来广播。</p>
<p>具体过程是 ：</p>
<ol>
<li>创建 TargetData，并且填充数据。</li>
<li>创建 FGameplayAbilityTargetDataHandle 对象（也可以使用带参的构造函数直接构建），并且调用 <code>Add() </code>添加上面创建的 TargetData。</li>
<li>通过广播进行传递。</li>
</ol>
<p>本项目中 <code>AbilityTask_TargetHitUnderCursor.h</code> 创建了 TargetDataHandle, 用于鼠标选取敌人目标：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016414.png" alt="Pasted image 20231208230032|450"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAbilityTask_TargetHitUnderCursor::SendCursorHitData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="type">const</span> APlayerController* PlayerController = Ability-&gt;<span class="built_in">GetCurrentActorInfo</span>()-&gt;PlayerController.<span class="built_in">Get</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 打包命中结果数据</span></span><br><span class="line"><span class="comment">		 * - 注意这里设置了自定义的碰撞通道 ECC_Target, 默认为BlockAll</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		 </span><br><span class="line">		<span class="comment">//使用CursorTrace获取数据</span></span><br><span class="line">		FHitResult CursorHit;</span><br><span class="line">		PlayerController-&gt;<span class="built_in">GetHitResultUnderCursor</span>(ECC_Target, <span class="literal">false</span>, CursorHit);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/** 创建TargetData, 类型为SingleTargetHit */</span></span><br><span class="line">		FGameplayAbilityTargetData_SingleTargetHit* TargetData = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_SingleTargetHit</span>();</span><br><span class="line">		TargetData-&gt;HitResult = CursorHit;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/** 打包TargetData */</span></span><br><span class="line">		FGameplayAbilityTargetDataHandle TargetDataHandle;</span><br><span class="line">		TargetDataHandle.<span class="built_in">Add</span>(TargetData); </span><br><span class="line">		<span class="comment">//可以Add多个TargetData,通过index访问</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 广播 */</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ShouldBroadcastAbilityTaskDelegates</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			ValidData.<span class="built_in">Broadcast</span>(TargetDataHandle);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>多人游戏中， <code>FGameplayAbilityTargetData</code> 是用于通过网络传输定位数据的通用结构体.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016415.png" alt="Pasted image 20231018224610|500"><br>当客户端 Ability Task 激活时，服务器在 $\varepsilon$ 秒后接收到请求。如果需要计算数据，客户端的数据需要 $\delta$ 秒传到服务器。无法确定谁先到达，如果数据到达完了就无法完成服务器端的计算。</p>
<p>解决这个问题的方法是使用 GAS 内置的 TargetData，通过 <code>ServerSetReplicatedTargetData()</code> 函数代替 RPC 将目标数据发送给服务器。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016416.png" alt="Pasted image 20231018230000"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016417.png" alt="Pasted image 20231018230101"><br>先激活的情况：服务器激活时绑定 TargetDataSet 委托，这样当目标数据到达服务器时，TargetDataSet 委托将被广播，因为服务器已经提前绑定了该委托，因此可以接收到目标数据。</p>
<p>后激活的情况：数据先到服务器，TargetDataSet 委托被广播。但此时服务器还没绑定，就会接收不到数据。这种情况下要调用 <code>CallReplicatedTargetDataDelegateIfSet ()</code>。当服务器激活后，它将再次强制广播该委托。(注意这里的复制是从客户端到服务器，不要和网络中的 Replicated 机制混淆)</p>
<h2 id="Target-Actor"><a href="#Target-Actor" class="headerlink" title="Target Actor"></a>Target Actor</h2><p><code>GA</code> 一般使用 <code>AbilityTask_WaitTargetData</code> 生成 <code>TargetActor</code> (<code>WaitTargetDataUsingActor</code> 用来监听已有的 <code>TargetActor</code>)以在世界中可视化和获取定位信息收集的 <code>TargetData</code> 存入 <code>TargetDataHandle</code> 并通过委托返回。</p>
<p>可以把 TargetActor 理解为一个场景信息探测器，使用 LineTrace 或者 Overlap 来获取场景数据，内部实现步骤大致如下：(<strong>TODO</strong>：和上节介绍的 <code>UAbilityTask_TargetHitUnderCursor</code> 代码极其类似，只不过继承了不一样的基类。这里有个疑问，上面的代码用 AbilityTask 是不是不太合适？可否转换成 TargetActor？)</p>
<ol>
<li>使用 LineTrace 或者 Overlap 来获取场景数据</li>
<li>将数据存入 <code>TargetData</code></li>
<li>将 <code>Targetdata</code> 打包，返回<code>TargetDataHandle</code><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016418.png" alt="Pasted image 20231208231455"></li>
</ol>
<p><code>TargetActor</code> 是基于 <code>AActor</code> 的, 因此它可以使用任意种类的可视组件来表示其在何处和如何定位的, 例如静态网格体(Static Mesh)和贴花(Decal)。</p>
<ul>
<li>静态网格体(Static Mesh)可以用来<strong>可视化角色将要建造的物体，</strong></li>
<li>贴花(Decal)可以用来<strong>表现地面上的效果区域</strong>。样例项目使用带有地面贴花的 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/API/Plugins/GameplayAbilities/Abilities/AGameplayAbilityTargetActor_Grou-/index.html">AGameplayAbilityTargetActor_GroundTrace</a> <strong>表示陨石技能的伤害区域效果</strong>. </li>
<li>它<strong>也可以什么都不显示</strong>, 例如, GASShooter 中的枪支命中判断, 要对目标的射线检测显示些什么就是没有意义的.</li>
</ul>
<h3 id="AbilityTask-WaitTargetData"><a href="#AbilityTask-WaitTargetData" class="headerlink" title="AbilityTask_WaitTargetData"></a>AbilityTask_WaitTargetData</h3><p>其他 AbilityTask 可见： [[GAS AbilityTask 整理#TargetData 类]]</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016419.png" alt="Pasted image 20231206214823"></p>
<ol>
<li><code>AbilityTask_WaitTargetData</code> 将一个 <code>AGameplayAbilityTargetActor</code> 类作为参数, 其会在每次 <code>AbilityTask</code> 激活时生成一个实例并且在 <code>AbilityTask</code> 结束时销毁该 <code>TargetActor</code>. </li>
<li><code>AbilityTask_WaitTargetDataUsingActor</code> 接受一个已经生成的 <code>TargetActor</code>, 但是在该 <code>AbilityTask</code> 结束时仍会销毁它.</li>
</ol>
<ul>
<li><strong>优化建议：</strong> 这两种 <code>AbilityTask</code> 都是<strong>低效的</strong>, 因为它们在每次使用时都要生成或需要一个新生成的 <code>TargetActor</code>, 它们用于原型开发是很好的, 但是在实际发布版本中, 如果有持续产生 <code>TargetData</code> 的场景, 像全自动开火, 你可能就要探索优化它的办法. GASShooter 有一个自定义的 <a target="_blank" rel="noopener" href="https://github.com/tranek/GASShooter/blob/master/Source/GASShooter/Public/Characters/Abilities/GSGATA_Trace.h">AGameplayAbilityTargetActor</a> 子类和一个完全重写的 <a target="_blank" rel="noopener" href="https://github.com/tranek/GASShooter/blob/master/Source/GASShooter/Public/Characters/Abilities/AbilityTasks/GSAT_WaitTargetDataUsingActor.h">WaitTargetDataWithReusableActor AbilityTask</a>, 其允许你复用 <code>TargetActor</code> 而无需将其销毁.</li>
</ul>
<p><strong>GASShooter 为了实现复用做了以下修改。</strong></p>
<ol>
<li>实现休眠状态<br>增加 <strong>StopTargeting</strong> 方法，与 StartTargeting 形成一对控制 Actor 休眠状态的函数，相当于反初始化，为的是进入休眠状态，以备下次使用。</li>
<li>避免 Actor 被销毁</li>
<li>重写 CancelTargeting——避免取消操作时被销毁</li>
<li>构造函数中，bDestroyOnConfirmation &#x3D; false——避免确认目标时被销毁</li>
</ol>
<h4 id="ConfirmationType"><a href="#ConfirmationType" class="headerlink" title="ConfirmationType"></a>ConfirmationType</h4><p><code>AbilityTask_WaitTargetData</code> 通过 <code>ConfirmationType</code> 参数决定目标何时被确认。<code>ConfirmationType</code> 指明了目标选择<strong>确认和取消</strong>的时机</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016420.png" alt="Pasted image 20231206223612"></p>
<table>
<thead>
<tr>
<th align="center">EGameplayTargetingConfirmation::Type</th>
<th align="center">何时确认 Target</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Instant</td>
<td align="center">该定位无需特殊逻辑即可立即进行, 或者用户输入决定何时开始.</td>
</tr>
<tr>
<td align="center">UserConfirmed</td>
<td align="center">当 Ability 绑定到 <code>Confirm</code> 输入且用户确认或调用 <code>UAbilitySystemComponent::TargetConfirm()</code> 时触发该 Targeting. <code>TargetActor</code> 也会响应绑定的 <code>Cancel</code> 输入或者调用 <code>UAbilitySystemComponent::TargetCancel()</code> 来取消 Targeting.</td>
</tr>
<tr>
<td align="center">Custom</td>
<td align="center">GameplayTargeting Ability 负责调用 <code>UGameplayAbility::ConfirmTaskByInstanceName()</code> 来决定何时准备好 Targeting Data. <code>TargetActor</code> 也可以响应 <code>UGameplayAbility::CancelTaskByInstanceName()</code> 来取消 Targeting.</td>
</tr>
<tr>
<td align="center">CustomMulti</td>
<td align="center">GameplayTargeting Ability 负责调用 <code>UGameplayAbility::ConfirmTaskByInstanceName()</code> 来决定何时准备好 Targeting Data. <code>TargetActor</code> 也可以响应 <code>UGameplayAbility::CancelTaskByInstanceName()</code> 来取消 Targeting. 不应在数据生成后就结束 AbilityTask, 因为其允许多次确认.</td>
</tr>
</tbody></table>
<p>当使用 <code>non-Instant Type</code> 时, <code>TargetActor</code> 一般就在 <code>Tick()</code> 中执行射线&#x2F;Overlap, 并根据它的实现来更新位置信息到 <code>FHitResult</code>。尽管是在 <code>Tick()</code> 中执行的射线&#x2F;Overlap, 但是一般不用担心, 因为它是不复制的并且一般没有多个 (尽管存在多个) <code>TargetActor</code> 同时运行, 只是要留意它使用的是 <code>Tick()</code>, </p>
<blockquote>
<p>一些复杂的 <code>TargetActor</code> 可能会在其中做很多事情, 就像 GASShooter 中火箭筒的二技能. 当 <code>Tick()</code> 中的检测对客户端响应非常频繁时, <strong>如果性能影响很大的话, 你可能就要考虑降低 <code>TargetActor</code> 的 Tick 频率</strong>. 对于 <code>(Instant)Type</code>, <code>TargetActor</code> 会立即生成, 产生 <code>TargetData</code>, 然后销毁, 并且从不会调用 <code>Tick()</code></p>
</blockquote>
<p><strong>并不是所有的 <code>TargetActor</code> 都支持每个 <code>ConfirmationType</code>, 例如,  <code>AGameplayAbilityTargetActor_GroundTrace</code> 就不支持 <code>(Instant)Type</code></strong> </p>
<h3 id="AGameplayAbilityTargetActor"><a href="#AGameplayAbilityTargetActor" class="headerlink" title="AGameplayAbilityTargetActor"></a>AGameplayAbilityTargetActor</h3><p><code>AGameplayAbilityTargetActor</code> 类不能直接使用，需要实现子类，原因是基类没有实现选择目标逻辑。</p>
<p>GAS 内置了四个可用的 <code>AGameplayAbilityTargetActor</code> 子类：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016421.png" alt="Pasted image 20231206220651"></p>
<p>根据使用的不同 <code>AGameplayAbilityTargetActor</code> 子类, <code>WaitTargetData AbilityTask</code> 节点会暴露不同的 <code>ExposeOnSpawn</code> 参数, 一些常用的参数包括:   </p>
<table>
<thead>
<tr>
<th align="center">常用<code>TargetActor</code>参数</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Debug</td>
<td align="center">如果为真, 每当非发行版本中的<code>TargetActor</code>执行射线检测时, 其会绘制debug射线&#x2F;Overlap信息. 请记住, <code>non-Instant Type TargetActor</code>会在<code>Tick()</code>中执行射线检测, 因此这些debug绘制调用也会在<code>Tick()</code>中触发.</td>
</tr>
<tr>
<td align="center">Filter</td>
<td align="center">[可选]当射线&#x2F;Overlap触发时, 用于从Target中过滤(移除)Actor的特殊结构体. 典型的使用案例是过滤玩家的<code>Pawn</code>, 其要求Target是特殊类. 查看<a href="#concepts-target-data-filters">Target Data Filters</a>以获得更多高级使用案例.</td>
</tr>
<tr>
<td align="center">Reticle Class</td>
<td align="center">[可选]<code>TargetActor</code>生成的<code>AGameplayAbilityWorldReticle</code>子类.</td>
</tr>
<tr>
<td align="center">Reticle Parameters</td>
<td align="center">[可选]配置你的Reticle. 查看<a href="#concepts-targeting-reticles">Reticles</a>.</td>
</tr>
<tr>
<td align="center">Start Location</td>
<td align="center">用于设置射线检测应该从何处开始的特殊结构体. 一般这应该是玩家的视口(Viewport), 枪口或者Pawn的位置.</td>
</tr>
</tbody></table>
<h3 id="自定义-TargetActor"><a href="#自定义-TargetActor" class="headerlink" title="自定义 TargetActor"></a>自定义 TargetActor</h3><p>选择目标逻辑的触发有以下 2 个地方推荐</p>
<ul>
<li><code>AGameplayAbilityTargetActor::ConfirmTargetingAndContinue  </code><br>适合一次性选择，例如常见的点射无跟踪锁定能力的子弹，在 “扣扳机” 时，执行逻辑。</li>
<li><code>Tick</code><br>适合持续更新选择，例如需要预先锁定的跟踪性武器，发射之前可以锁定 &#x2F; 更改目标。</li>
</ul>
<p>确认目标时，通过委托 <code>AGameplayAbilityTargetActor::TargetDataReadyDelegate</code> 将 <code>TargetData</code> 广播出去即可。</p>
<p>以下是 GASShooter 项目中的步枪子弹触发选择目标的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步枪子弹，AbilityTask会立即调用此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGSGATA_Trace::ConfirmTargetingAndContinue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (SourceActor)</span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;FHitResult&gt; HitResults = <span class="built_in">PerformTrace</span>(SourceActor);</span><br><span class="line">		FGameplayAbilityTargetDataHandle Handle = <span class="built_in">MakeTargetData</span>(HitResults);</span><br><span class="line">		TargetDataReadyDelegate.<span class="built_in">Broadcast</span>(Handle);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 GASShooter 项目中的火箭发射器触发选择目标的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 火箭弹，每帧检测目标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGSGATA_Trace::Tick</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	TArray&lt;FHitResult&gt; HitResults;</span><br><span class="line">	<span class="keyword">if</span> (bDebug || bUsePersistentHitResults) <span class="comment">// true for 火箭弹</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Only need to trace on Tick if we&#x27;re showing debug or if we use persistent hit results, otherwise we just use the confirmation trace</span></span><br><span class="line">		HitResults = <span class="built_in">PerformTrace</span>(SourceActor);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化-TargetActor"><a href="#持久化-TargetActor" class="headerlink" title="持久化 TargetActor"></a>持久化 TargetActor</h3><p>使用默认的 <code>TargetActor</code> 类时, Actor 只有直接在射线&#x2F;Overlap 中时才是有效的, 如果它离开射线&#x2F;Overlap(它移动开或你的视线转向别处), 就不再有效了.<br><strong>如果你想 <code>TargetActor</code> 记住最后有效的 Target, 就需要添加这项功能到一个自定义的 <code>TargetActor</code> 类. 我称之为持久化 Target</strong>, 因为其会持续存在直到 <code>TargetActor</code> 接收到确认或取消消息, <code>TargetActor</code> 会在它的射线&#x2F;Overlap 中找到一个新的有效 Target, 或者 Target 不再有效(已销毁).<br><strong>GASShooter 对火箭筒二技能的制导火箭定位使用了持久化 Target.</strong>   （TODO：使用持久化 Target 做 MMO 的目标选择）</p>
<h3 id="TargetDataFilter"><a href="#TargetDataFilter" class="headerlink" title="TargetDataFilter"></a>TargetDataFilter</h3><p>同时使用 <code>Make GameplayTargetDataFilter</code> 和 <code>Make Filter Handle</code> 节点, 你可以过滤玩家的 <code>Pawn</code> 或者只选择某个特定类. 如果需要更多高级过滤条件, 可以继承 <code>FGameplayTargetDataFilter</code> 并重写 <code>FilterPassesForActor</code> 函数.   </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016422.png" alt="Pasted image 20231206221032"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GASDOCUMENTATION_API</span> FGDNameTargetDataFilter : <span class="keyword">public</span> FGameplayTargetDataFilter</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Returns true if the actor passes the filter and will be targeted */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">FilterPassesForActor</span><span class="params">(<span class="type">const</span> AActor* ActorToBeFiltered)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">However, <span class="keyword">this</span> will <span class="keyword">not</span> work directly into the Wait Target Data node as it <span class="keyword">requires</span> a FGameplayTargetDataFilterHandle. A <span class="keyword">new</span> custom Make Filter Handle must be made to accept the subclass:</span><br><span class="line"></span><br><span class="line">FGameplayTargetDataFilterHandle UGDTargetDataFilterBlueprintLibrary::<span class="built_in">MakeGDNameFilterHandle</span>(FGDNameTargetDataFilter Filter, AActor* FilterActor)</span><br><span class="line">&#123;</span><br><span class="line">	FGameplayTargetDataFilter* NewFilter = <span class="keyword">new</span> <span class="built_in">FGDNameTargetDataFilter</span>(Filter);</span><br><span class="line">	NewFilter-&gt;<span class="built_in">InitializeFilterContext</span>(FilterActor);</span><br><span class="line"></span><br><span class="line">	FGameplayTargetDataFilterHandle FilterHandle;</span><br><span class="line">	FilterHandle.Filter = <span class="built_in">TSharedPtr</span>&lt;FGameplayTargetDataFilter&gt;(NewFilter);</span><br><span class="line">	<span class="keyword">return</span> FilterHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><strong><code>TargetActor</code> 默认是不可复制的</strong>. 然而, 如果在你的游戏中向其他玩家展示本地玩家正在定位的目标是有意义的, 那么它也可以被设计成可复制的, <code>WaitTargetData AbilityTask</code> 也确实包含其通过 RPC 和服务端通信的默认功能. 如果 <code>TargetActor</code> 的 <code>ShouldProduceTargetDataOnServer</code> 属性设置为 false, 那么客户端就会在确认时通过 <code>UAbilityTask_WaitTargetData::OnTargetDataReadyCallback()</code> 中的 <code>CallServerSetReplicatedTargetData()</code> RPC 它的 <code>TargetData</code> 到服务端. 如果 <code>ShouldProduceTargetDataOnServer</code> 为 true, 那么客户端就会发送一个通用确认事件, <code>EAbilityGenericReplicatedEvent::GenericConfirm</code>, 在 <code>UAbilityTask_WaitTargetData::OnTargetDataReadyCallback()</code> 中 RPC 到服务端, 服务端在接收到 RPC 时就会执行射线或者 Overlap 检测以生成数据. 如果客户端取消该定位, 它会发送一个通用取消事件, <code>EAbilityGenericReplicatedEvent::GenericCancel</code>, 在 <code>UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback</code> 中 RPC 到服务端. 你可以看到, 在 <code>TargetActor</code> 和 <code>WaitTargetData AbilityTask</code> 中存在大量委托, <code>TargetActor</code> 响应输入来产生广播 <code>TargetData</code> 的准备, 确认或者取消委托, <code>WaitTargetData</code> 监听 <code>TargetActor</code> 的 <code>TargetData</code> 的准备, 确认和取消委托, 并将该信息转发回 <code>GameplayAbility</code> 和服务端. 如果是向服务端发送 <code>TargetData</code>, 为了防止作弊, 可能需要在服务端做校验以保证该 <code>TargetData</code> 是合理的. 直接在服务端上产生 <code>TargetData</code> 可以完全避免这个问题, 但是可能会导致所属 (Owning)客户端的错误预测.   </p>
<h2 id="Reticle"><a href="#Reticle" class="headerlink" title="Reticle"></a>Reticle</h2><p>当使用已确认的 <code>non-Instant Type</code> TargetActor 进行目标选择时, <code>AGameplayAbilityWorldReticle</code> 类可以可视化正在定位的目标. 其可在 <code> AbiltyTask_WaitTargetData</code> 的 <code>Reticle Class</code> 参数中配置。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016423.png" alt="Pasted image 20231206221402"></p>
<p>类中只有一个 <code>FaceTowardSource</code> 函数有业务逻辑，其它方法主要是一些面向设计师的 <code>BlueprintImplementableEvents</code> (它们被设计用来在蓝图中开发):  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ... AGameplayAbilityWorldReticle : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnValidTargetChanged</span><span class="params">(<span class="type">bool</span> bNewValue)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Called whenever bIsTargetAnActor changes value. */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnTargetingAnActor</span><span class="params">(<span class="type">bool</span> bNewValue)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnParametersInitialized</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetReticleMaterialParamFloat</span><span class="params">(FName ParamName, <span class="type">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = Reticle)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetReticleMaterialParamVector</span><span class="params">(FName ParamName, FVector value)</span></span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的使用应该是<strong>轻逻辑，重表现</strong>，<strong>主要逻辑应该写在 TargetActor 上</strong>。可以参考 GASShooter 的 <code>BP_SingleTargetReticle</code>。</p>
<hr>
<p><code>TargetActor</code> 负责所有 <code>Reticle</code> 生命周期的生成和销毁. <code>Reticle</code> 是 <code>AActor</code>, 因此其可以使用任意种类的可视组件作为表现形式.<br>GASShooter 中常见的一种实现方式是使用 <code>WidgetComponent</code> 在屏幕空间中显示 UMG Widget(永远面对玩家的摄像机). <strong><code>Reticle</code> 不知道其正在定位的 Actor, 但是你可以通过继承在自定义 <code>TargetActor</code> 中实现该功能. <code>TargetActor</code> 一般在每次 <code>Tick()</code> 中更新 <code>Reticle</code> 的位置为 Target 的位置.</strong>  </p>
<p>GASShooter对火箭筒二技能制导火箭锁定的目标使用了<code>Reticle</code>. 敌人身上的红色标识就是<code>Reticle</code>, 相似的白色图像是火箭筒的准星.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016424.png" alt="7a05152ed5871153b641841e4f366f1c_MD5">  </p>
<h3 id="自定义FWorldReticleParameters"><a href="#自定义FWorldReticleParameters" class="headerlink" title="自定义FWorldReticleParameters"></a>自定义FWorldReticleParameters</h3><p><code>Reticle</code> 可以选择使用 <code>TargetActor</code> 提供的 <code>FWorldReticleParameters</code> 进行初始化, 默认结构体只提供一个变量 <code>FVector AOEScale</code>, 尽管你可以在技术上继承该结构体, 但是 <code>TargetActor</code> 只接受基类结构体, <strong>不允许在默认 <code>TargetActor</code> 中子类化该结构体。</strong></p>
<p>然而, <strong>如果你创建了自己的自定义 <code>TargetActor</code>, 就可以提供自定义的 <code>Reticle</code> 参数结构体并在生成 <code>Reticle</code> 时手动传递它到 <code>AGameplayAbilityWorldReticles</code> 子类.</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016425.png" alt="Pasted image 20231206221556"></p>
<h3 id="持久化-Reticle"><a href="#持久化-Reticle" class="headerlink" title="持久化 Reticle"></a>持久化 Reticle</h3><p><code>Reticle</code> 只会显示在默认 <code>TargetActor</code> 的当前有效 Target 上, 例如, 如果你正在使用 <code>AGameplayAbilityTargetActor_SingleLineTrace</code> 对目标执行射线检测, 敌人只有直接处于射线路径上时 <code>Reticle</code> 才会显示, 如果角色视线看向别处, 那么该敌人就不再是一个有效 Target, 因此该 <code>Reticle</code> 就会消失。</p>
<p><strong>如果你想 <code>Reticle</code> 保留在最后一个有效 Target 上, 就需要自定义 <code>TargetActor</code> 来记住最后一个有效 Target 并使 <code>Reticle</code> 保留在其上. 我称之为持久化 Target,</strong> 因为其会持续存在直到 <code>TargetActor</code> 接收到确认或取消消息, <code>TargetActor</code> 会在它的射线&#x2F;Overlap 中找到一个新的有效 Target, 或者 Target 不再有效(已销毁). GASShooter 对火箭筒二技能的制导火箭定位使用了持久化 Target。</p>
<h3 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h3><p><code>Reticle</code> 默认是不可复制的, 但是如果在你的游戏中向其他玩家展示本地玩家正在定位的目标是有意义的, 那么它也可以被设计成可复制的.  </p>
<h2 id="Gameplay-Effect-Containers-Targeting"><a href="#Gameplay-Effect-Containers-Targeting" class="headerlink" title="Gameplay Effect Containers Targeting"></a>Gameplay Effect Containers Targeting</h2><p><a href="#concepts-ge-containers">GameplayEffectContainer</a> 提供了一个可选的产生 <a href="#concepts-targeting-data">TargetData</a> 的高效方法. 当 <code>EffectContainer</code> 在客户端和服务端上应用时, 该定位会立即进行, 它<strong>比 TargetActor 更有效率</strong>, 因为它是运行在定位对象的 CDO(Class Default Object)上的(没有 Actor 的生成和销毁), 但是它<strong>不支持用户输入, 无需确认即可立即进行, 不能取消, 并且不能从客户端向服务端发送数据(在两者上产生数据), 它对即时射线检测和碰撞 Overlap 很有用.</strong></p>
<p>这些 Target 类型定义于 URPGTargetType，你可以根据获取 Target 的方式进行拓展，调用 TargetType 获取目标的逻辑位于 MakeEffectContainerSpecFromContainer：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Container.TargetType.<span class="built_in">Get</span>())</span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;FHitResult&gt; HitResults;</span><br><span class="line">    TArray&lt;AActor *&gt; TargetActors;</span><br><span class="line">    <span class="type">const</span> URPGTargetType *TargetTypeCDO = Container.TargetType.<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">    AActor *AvatarActor = <span class="built_in">GetAvatarActorFromActorInfo</span>();</span><br><span class="line">    TargetTypeCDO-&gt;<span class="built_in">GetTargets</span>(OwningCharacter, AvatarActor, EventData, HitResults, TargetActors);</span><br><span class="line">    ReturnSpec.<span class="built_in">AddTargets</span>(HitResults, TargetActors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Epic的<a target="_blank" rel="noopener" href="https://www.unrealengine.com/marketplace/en-US/slug/action-rpg">Action RPG Sample Project</a>包含两种使用Container定位的样例 —— 定位Ability拥有者和从事件拉取<code>TargetData</code>, 它还在蓝图中实现了在距玩家某个偏移处(由蓝图子类设置)做球形射线检测(Sphere Trace), 你可以在C++或蓝图中继承<code>URPGTargetType</code>以实现自己的定位类型.  </p>
<h1 id="11-预测-Prediction"><a href="#11-预测-Prediction" class="headerlink" title="11 预测 (Prediction)"></a>11 预测 (Prediction)</h1><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016426.png" alt="Pasted image 20231019101949"></p>
<p>GAS 带有开箱即用的客户端预测功能, 然而, 它不能预测所有。 <strong>GAS 中客户端预测的意思是客户端无需等待服务端的许可而激活 <code>GA</code> 和应用 <code>GE</code>。</strong><br>它可以”预测”许可其可以这样做的服务端和其应用 <code>GE</code> 的目标. 服务端在客户端激活之后运行 <code>GA</code> (网络延迟)并告知客户端它的预测是否正确, 如果客户端的预测出错, 那么它就会”回滚”其”错误预测”的修改以匹配服务端.  </p>
<p><strong>Epic 的理念是只能预测”不受伤害 (get away with)”的事情</strong>. 例如, Paragon 和 Fortnite 不能预测伤害值, 它们很可能对伤害值使用了 <a href="#concepts-ge-ec">ExecutionCalculations</a>, 而这无论如何是不能预测的. 这并不是说你不能试着预测像伤害值这样的事情, 无论如何, 如果你这样做了并且效果很好, 那就是极好的.  </p>
<blockquote>
<p>… we are also not all in on a “predict everything: seamlessly and automatically” solution. We still feel player prediction is best kept to a minimum (meaning: predict the minimum amount of stuff you can get away with).<br>我们也不完全赞同 “无缝自动预测一切 “的解决方案。我们仍然认为玩家预测最好保持在最低水平（意思是：预测你能做到的最低数量）<br><em>来自 Epic 的 Dave Ratti 在新的<a href="#concepts-p-npp">网络预测插件</a>中的注释.</em>  </p>
</blockquote>
<p>GAS 相关预测的最佳源码是插件源码中的 <code>GameplayPrediction.h</code>.  </p>
<p><strong>什么是可预测的:</strong>  </p>
<ul>
<li>Ability 激活</li>
<li>触发事件 Triggered Event</li>
<li>GameplayEffect 应用<ul>
<li>Attribute Modifiers (执行 (Execution)目前无法预测)</li>
<li>GameplayTag Modification</li>
</ul>
</li>
<li>GameplayCue 事件 (从预测的 Gameplay Ability 和它们自己的事件)</li>
<li>蒙太奇</li>
<li>移动 (内建在 UE4 UCharacterMovement 中)</li>
</ul>
<p><strong>什么是不可预测的:</strong>  </p>
<ul>
<li>GameplayEffect 移除</li>
<li>（Periodic）GameplayEffect 周期效果</li>
</ul>
<p>尽管我们可以预测 <code>GameplayEffect</code> 的应用, 但是不能预测 <code>GameplayEffect</code> 的移除. 绕过这条限制的一个方法是当想要移除 <code>GameplayEffect</code> 时, 可以预测性地执行相反的效果, 假设我们要降低 40%移动速度, 可以通过应用增加 40%移动速度的 buff 来预测性地将其移除, 之后同时移除这两个 <code>GameplayEffect</code>. 这并不是对每个场景都适用, 因此仍然需要对预测性地移除 <code>GameplayEffect</code> 的支持. 来自 Epic 的 Dave Ratti 已经表达过在 <a target="_blank" rel="noopener" href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">GAS的迭代版本中</a>增加它的期望.   </p>
<p>因为我们不能预测 <code>GameplayEffect</code> 的移除, 所以就不能完全预测 <code>GameplayAbility</code> 的冷却时间, 并且也没有相反的 <code>GameplayEffect</code> 这种变通方案可供使用. 服务端复制的 <code>Cooldown GE</code> 将会存于客户端上, 并且任何对其绕过的尝试 (例如使用 <code>Minimal</code> 复制模式)都会被服务端拒绝. 这意味着高延迟的客户端会花费较长事件来告知服务端开始冷却和接收到服务端 <code>Cooldown GE</code> 的移除. 这意味着高延迟的玩家会比低延迟的玩家有更低的触发率, 从而劣势于低延迟玩家. Fortnite 通过使用自定义 Bookkeeping 而不是 <code>Cooldown GE</code> 的方法避免了该问题.   </p>
<p><strong>关于预测伤害值, 我个人不建议使用, 尽管它是大多数刚接触 GAS 的人最先做的事情之一, 我特别不建议尝试预测死亡, 虽然你可以预测伤害值, 但是这样做很棘手</strong>. 如果你错误预测地应用了伤害, 那么玩家将会看到敌人的生命值会跳动, 如果你尝试预测死亡, 那么这将会是特别尴尬和令人沮丧的, 假设你错误预测了某个 <code>Character</code> 的死亡, 那么它就会开启布娃娃模拟, 只有当服务端纠正后才会停止布娃娃模拟并继续向你射击. </p>
<p><strong>Note:</strong> 修改 <code>Attribute</code> 的 <code>(Instant)GE</code> (像 <code>Cost GE</code>)在你自身可以无缝预测, 预测修改其他 Character 的 <code>(Instant)Attribute</code> 会显示短暂的异常或者 <code>Attribute</code> 中的暂时性问题. 预测的 <code>(Instant)GE</code> 实际上被视为 <code>(Infinite)GE</code>, 因此如果错误预测的话还可以回滚. 当服务端的 <code>GameplayEffect</code> 被应用时, 其实是存在两个相同的 <code>GameplayEffect</code> 的, 会在短时间内造成 <code>Modifier</code> 应用两次或者不应用, 其最终会纠正自身, 但是有时候这个异常现象对玩家来说是显著的.   </p>
<p>GAS 的预测实现尝试解决的问题:  </p>
<blockquote>
<ol>
<li>“我能这样做吗?” (Can I do this?) 预测的基本协议.</li>
<li>“撤销” (Undo) 当预测错误时如何消除其副作用.</li>
<li>“重现” (Redo) 如何避免已经在客户端预测但还是从服务端复制的重播副作用.</li>
<li>“完整” (Completeness) 如何确认我们真的预测了所有副作用.</li>
<li>“依赖” (Dependencies) 如何管理依赖预测和预测事件链.</li>
<li>“重写” (Override) 如何预测地重写由服务端复制&#x2F;拥有的状态.</li>
</ol>
</blockquote>
<p>源自 <code>GameplayPrediction.h</code>  </p>
<p><a name="concepts-p-key"></a></p>
<h2 id="Prediction-Key"><a href="#Prediction-Key" class="headerlink" title="Prediction Key"></a>Prediction Key</h2><p>GAS 的预测建立在 <code>Prediction Key</code> 的概念上, 其是一个由客户端激活 <code>GameplayAbility</code> 时生成的整型标识符.  </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016427.png" alt="Pasted image 20231019103742"><br>PredictionKey 基于 <code>FPredictionKey</code>，只是一个唯一的 ID 存储在客户端。</p>
<ul>
<li>客户端执行预测时，它将向上发送 PredictionKey 到服务器并关联其客户端预测行为（Action）和该 Key 的副效果（Side Effect）。</li>
<li>服务器将收到该 Key，并接收或拒绝它。</li>
<li>然后，它将把服务器端创建的任何 Side Effect 与该 Key 相关联，并响应客户端通知它该 Key 已被接受或拒绝。  </li>
<li>当服务器返回 PredictionKey 时，它将只返回到最初将其发送到服务器的客户端。其他客户端简单的接收一个无效 Key 或 ID 为 0 。这个过程在 <code>FPredictionKey:: NetSerialize()</code> 中完成</li>
</ul>
<blockquote>
<p>[!NOTE] SideEffect<br>就是 GameplayEffect，只在有<strong>有效</strong>的 PredictionKey 的情况下才能应用于客户端。<br>如果 GameplayEffect 被预测，那么其所作的以下任何事情也会被预测：</p>
<ul>
<li>Attribute Modifications</li>
<li>Gameplay Tag Modifications</li>
<li>GameplayCue</li>
</ul>
<p>当一个 FActiveGameplayEffect 被创建，他将这个 PredictionKey 存储在服务器，自身也获得相同的 Key。复制到客户端时，客户端可以检查 Key。如果客户端上已经有一个具有相同 key 的激活的 GameplayEffect ，说明本地已经完成了，不需要再次应用 effect（OnApplied 逻辑不再执行），避免重复的应用 effect。</p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016428.png" alt="Pasted image 20231019104749"></p>
<ul>
<li>客户端激活 <code>GameplayAbility</code> 时生成 <code>Prediction Key</code>, 这是 <code>Activation Prediction Key</code>.  </li>
<li>客户端使用 <code>CallServerTryActivateAbility()</code> 将该 <code>Prediction Key</code> 发送到服务端.</li>
<li>客户端在 <code>Prediction Key</code> 有效时将其添加到应用的所有 <code>GameplayEffect</code>.</li>
<li>客户端的 <code>Prediction Key</code> 出域. 之后该 <code>GameplayAbility</code> 中的预测效果 (Effect)需要一个新的 <a href="#concepts-p-windows">Scoped Prediction Window</a>.</li>
<li>服务端从客户端接收 <code>Prediction Key</code>.</li>
<li>服务端将 <code>Prediction Key</code> 添加到其应用的所有 <code>GameplayEffect</code>.</li>
<li>服务端复制该 <code>Prediction Key</code> 回客户端.</li>
<li>客户端使用 <code>Prediction Key</code> 从服务端接收复制的 <code>GameplayEffect</code>, 该 <code>Prediction Key</code> 用于应用 <code>GameplayEffect</code>. 如果任何复制的 <code>GameplayEffect</code> 与客户端使用相同 <code>Prediction Key</code> 应用的 <code>GameplayEffect</code> 相匹配, 那么其就是正确预测的. 目标上暂时会有 <code>GameplayEffect</code> 的两份拷贝直到客户端移除它预测的那一个.</li>
<li>客户端从服务端上接收回 <code>Prediction Key</code>, 这是复制的 <code>Prediction Key</code>, 该 <code>Prediction Key</code> 现在被标记为陈旧 (Stale).</li>
<li>客户端移除所有由复制的陈旧 (Stale) <code>Prediction Key</code> 创建的 <code>GameplayEffect</code>. 由服务端复制的 <code>GameplayEffect</code> 会持续存在. 任何客户端添加的和没有从服务端接收到一个匹配的复制版本的都被视为错误预测.</li>
</ul>
<p>在源于 <code>Activation Prediction Key</code> 激活的 <code>GameplayAbility</code> 中的一个 <code>instruction &quot;window&quot;</code> 原子 (Atomic)组期间, <code>Prediction Key</code> 是保证有效的, 你可以理解为 <code>Prediction Key</code> 只在一帧期间是有效的. 任何潜在行为 <code>AbilityTask</code> 的回调函数将不再拥有一个有效的 <code>Prediction Key</code>, 除非该 <code>AbilityTask</code> 有内建的可以生成新 <a href="#concepts-p-windows">Scoped Prediction Window</a> 的复制点(Sync Point).  </p>
<h2 id="在-Ability-中创建新的预测窗口-Prediction-Window"><a href="#在-Ability-中创建新的预测窗口-Prediction-Window" class="headerlink" title="在 Ability 中创建新的预测窗口 (Prediction Window)"></a>在 Ability 中创建新的预测窗口 (Prediction Window)</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070016429.png" alt="Pasted image 20231019104336|500"><br>存在一个可以发生预测行为的窗口，称为**预测窗口 (Prediction Window)**，每当窗口打开，客户端可以执行可以改变游戏状态的重要行为（例如使用属性资源）而无需请求服务器的许可。</p>
<p>为了在 <code>AbilityTask</code> 的回调函数中预测更多的行为, 我们需要使用新的 <code>Scoped Prediction Key</code> 创建 <code>Scoped Prediction Window</code>, 有时这被视为客户端和服务端间的复制点 (Sync Point). 一些 <code>AbilityTask</code>, 像所有输入相关的 <code>AbilityTask</code>, 带有创建新 <code>Scoped Prediction Window</code> 的内建功能, 意味着 <code>AbilityTask</code> 回调函数中的原子 (Atomic)代码有一个有效的 <code>Scoped Prediction Key</code> 可供使用. 像 <code>WaitDelay</code> 的其他 Task 没有创建新 <code>Scoped Prediction Window</code> 以用于回调函数的内建代码, 如果你需要在 <code>WaitDelay</code> 这样的 <code>AbilityTask</code> 后预测行为, 就必须使用 <code>OnlyServerWait</code> 选项的 <code>WaitNetSync AbilityTask</code> 手动来做, 当客户端触发 <code>OnlyServerWait</code> 选项的 <code>WaitNetSync</code> 时, 它会生成一个新的基于 <code>GameplayAbility</code> 的 <code>Activation Prediction Key</code> 的 <code>Scoped Prediction Key</code>, RPC 其到服务端, 并将其添加到所有新应用的 <code>GameplayEffect</code>. 当服务端触发 <code>OnlyServerWait</code> 选项的 <code>WaitNetSync</code> 时, 它会在继续前等待直到接收到客户端新的 <code>Scoped Prediction Key</code>, 该 <code>Scoped Prediction Key</code> 会执行和 <code>Activation Prediction Key</code> 同样的操作 —— 应用到 <code>GameplayEffect</code> 并复制回客户端标记为陈旧 (Stale). <code>Scoped Prediction Key</code> 直到出域前都有效, 也就表示 <code>Scoped Prediction Window</code> 已经关闭了. 所以只有原子 (Atomic)操作, nothing latent, 可以使用新的 <code>Scoped Prediction Key</code>.   </p>
<p>你可以根据需求创建任意数量的 <code>Scoped Prediction Window</code>.   </p>
<p>如果你想添加复制点 (Sync Point)功能到自己的自定义 <code>AbilityTask</code>, 请查看那些输入 <code>AbilityTask</code> 是如何从根本上注入 <code>WaitNetSync  AbilityTask</code> 代码到自身的.  </p>
<p><strong>Note:</strong> 当使用 <code>WaitNetSync</code> 时, 会阻塞服务端 <code>GameplayAbility</code> 继续执行直到其接收到客户端的消息. 这可能会被破解游戏的恶意用户滥用以故意延迟发送新的 <code>Scoped Prediction Key</code>, 尽管 Epic 很少使用 <code>WaitNetSync</code>, 但如果你对此担忧的话, 其建议创建一个带有延迟的新 <code>AbilityTask</code>, 它会自动继续运行而无需等待客户端消息.   </p>
<p>样例项目在奔跑 <code>GameplayAbility</code> 中使用了 <code>WaitNetSync</code> 以在每次应用耐力花费时创建新的 <code>Scoped Prediction Window</code>, 这样我们就可以进行预测. 理想上当应用花费和冷却时间时我们就想要一个有效的 <code>Prediction Key</code>.   </p>
<p>如果你有一个在所属 (Owning)客户端执行两次的预测 <code>GameplayEffect</code>, 那么你的 <code>Prediction Key</code> 就是陈旧 (Stall)的, 并且正在经历”redo”问题. 你通常可以在应用 <code>GameplayEffect</code> 之前将 <code>OnlyServerWait</code> 选项的 <code>WaitNetSync AbilityTask</code> 放到正确的位置以创建新的 <code>Scoped Prediction Key</code> 来解决这个问题.   </p>
<h2 id="预测性地生成-Actor"><a href="#预测性地生成-Actor" class="headerlink" title="预测性地生成 Actor"></a>预测性地生成 Actor</h2><p>在客户端预测性地生成 Actor 是一项高级技术. GAS 对此没有提供开箱即用的功能 (<code>SpawnActor AbilityTask</code> 只在服务端生成 Actor). 其关键是在客户端和服务端都生成复制的 Actor.  </p>
<p>如果 Actor 只是用于场景装饰或者不服务于任何游戏逻辑, 简单的解决方案就是重写 Actor 的 <code>IsNetRelevantFor()</code> 函数以限制服务端复制到所属 (Owning)客户端, 所属 (Owning)客户端会拥有其本地生成的版本, 而服务端和其他客户端会拥有服务端复制的版本.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">APAReplicatedActorExceptOwner::IsNetRelevantFor</span><span class="params">(<span class="type">const</span> AActor * RealViewer, <span class="type">const</span> AActor * ViewTarget, <span class="type">const</span> FVector &amp; SrcLocation)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">IsOwnedBy</span>(ViewTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果生成的 Actor 影响了游戏逻辑, 像投掷物就需要预测伤害值, 那么你需要本文档范围之外的高级知识, 在 Epic Games 的 Github 上查看 UnrealTournament 是如何生成投掷物的, 它有一个只在所属 (Owning)客户端生成且与服务端复制的投掷物.  </p>
<p><a name="concepts-p-future"></a></p>
<h2 id="GAS-中预测的未来"><a href="#GAS-中预测的未来" class="headerlink" title="GAS 中预测的未来"></a>GAS 中预测的未来</h2><p><code>GameplayPrediction.h</code> 说明了在未来可能会增加预测 <code>GameplayEffect</code> 移除和周期 <code>GameplayEffect</code> 的功能.  </p>
<p>来自 Epic 的 Dave Ratti 已经<a target="_blank" rel="noopener" href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89">表达过对其修复的兴趣</a>, 包括预测冷却时间时的延迟问题和高延迟玩家对低延迟玩家的劣势.  </p>
<p>来自 Epic 之手的新<a href="#concepts-p-npp">网络预测插件(Network Prediction plugin)</a> 期望能与 GAS 充分交互, 就像在次之前的 <code>CharacterMovementComponent</code>.  </p>
<h2 id="网络预测插件-Network-Prediction-plugin"><a href="#网络预测插件-Network-Prediction-plugin" class="headerlink" title="网络预测插件 (Network Prediction plugin)"></a>网络预测插件 (Network Prediction plugin)</h2><p>Epic 最近发起了一项倡议, 将使用新的网络预测插件替换 <code>CharacterMovementComponent</code>, 该插件仍处于起步阶段, 但是在 Unreal Engine Github 上已经可以访问了, 现在说未来哪个引擎版本将首次搭载其试验版还为时尚早.  </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/46645.html">http://liuke101.github.io/post/46645.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GAS/">GAS</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/28208.html" title="UE伤害系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UE伤害系统</div></div></a></div><div class="next-post pull-right"><a href="/post/46644.html" title="UE AI系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UE AI系统</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GAS-%E6%8F%92%E4%BB%B6"><span class="toc-text">GAS 插件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%BC%80%E5%90%AF-GAS"><span class="toc-text">0 开启 GAS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Ability-System-Component"><span class="toc-text">1 Ability System Component</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IAbilitySystemInterface"><span class="toc-text">IAbilitySystemInterface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OwnerActor-%E4%B8%8E-AvatarActor-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">OwnerActor 与 AvatarActor 实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FGameplayAbilityActorInfo"><span class="toc-text">FGameplayAbilityActorInfo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-text">两个容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ABILITYLIST-SCOPE-LOCK"><span class="toc-text">ABILITYLIST_SCOPE_LOCK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">复制模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NetUpdateFrequency"><span class="toc-text">NetUpdateFrequency</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Gameplay-Tags"><span class="toc-text">2 Gameplay Tags</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IGameplayTagAssetInterface"><span class="toc-text">IGameplayTagAssetInterface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FGameplayTagContainer"><span class="toc-text">FGameplayTagContainer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag-%E5%8F%98%E5%8C%96%E5%A7%94%E6%89%98"><span class="toc-text">Tag 变化委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Tag"><span class="toc-text">获取 Tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A4%8D%E5%88%B6%E4%B8%8E-LooseGameplayTag"><span class="toc-text">网络复制与 LooseGameplayTag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4Tag"><span class="toc-text">过滤Tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-C-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86-Tag"><span class="toc-text">通过 C++ 创建和管理 Tag</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Attribute"><span class="toc-text">3 Attribute</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%AE%9A%E4%B9%89"><span class="toc-text">01 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-BaseValue-%E4%B8%8E-CurrentValue"><span class="toc-text">02 BaseValue 与 CurrentValue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-MetaAttribute"><span class="toc-text">03 MetaAttribute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7-Derived-Attribute"><span class="toc-text">04 派生属性 Derived Attribute</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-AttributeSet"><span class="toc-text">4 AttributeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E6%B3%A8%E5%86%8C-AttributeSet-%E5%88%B0-ASC"><span class="toc-text">01 注册 AttributeSet 到 ASC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%AE%9A%E4%B9%89-Attribute"><span class="toc-text">02 定义 Attribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%88%9D%E5%A7%8B%E5%8C%96-Attribute"><span class="toc-text">03 初始化 Attribute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-GE%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">通过 GE（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-ATTRIBUTE-ACCESSORS-%E5%AE%8F%E7%9A%84-Init-%E6%96%B9%E6%B3%95"><span class="toc-text">通过 ATTRIBUTE_ACCESSORS 宏的 Init 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="toc-text">使用数据表初始化(不推荐)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-text">导入数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-text">手动填充数据表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%9E%E6%80%A7%E9%9B%86-FAttributeSetInitter"><span class="toc-text">多属性集  FAttributeSetInitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E4%BD%BF%E7%94%A8-GE-%E4%BF%AE%E6%94%B9-Attribute"><span class="toc-text">04 使用 GE 修改 Attribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">05 生命周期函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#06-PreAttributeChange"><span class="toc-text">06 PreAttributeChange()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-PostGameplayEffectExecute"><span class="toc-text">07  PostGameplayEffectExecute()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E7%9B%91%E5%90%AC-Attribute-%E5%8F%98%E5%8C%96%E5%A7%94%E6%89%98"><span class="toc-text">06 监听 Attribute 变化委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E8%81%9A%E5%90%88%E5%99%A8-Aggregator"><span class="toc-text">07 聚合器 Aggregator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OnAttributeAggregatorCreated"><span class="toc-text">OnAttributeAggregatorCreated()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Gameplay-Effect"><span class="toc-text">5 Gameplay Effect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">01 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">02 配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Gameplay-Effect"><span class="toc-text">（1）Gameplay Effect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E7%AD%96%E7%95%A5-Duration-Policy"><span class="toc-text">持续策略 Duration Policy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Period-%E5%91%A8%E6%9C%9F"><span class="toc-text">（2）Period 周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Application-%E8%AE%BE%E7%BD%AE-Apply-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9D%A1%E4%BB%B6"><span class="toc-text">（3）Application  设置 Apply 概率和条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Stacking-%E5%A0%86%E5%8F%A0"><span class="toc-text">（4）Stacking 堆叠</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E7%B1%BB%E5%9E%8B"><span class="toc-text">堆叠类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%A0%86%E5%8F%A0%E6%95%B0%E9%87%8F"><span class="toc-text">限制堆叠数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E5%88%B7%E6%96%B0%E3%80%81%E5%91%A8%E6%9C%9F%E5%88%B7%E6%96%B0%E3%80%81%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-text">持续时间刷新、周期刷新、过期处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%A0%86%E6%A0%88%E5%8F%98%E5%8C%96"><span class="toc-text">监听堆栈变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA-Overflow"><span class="toc-text">溢出 Overflow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Expiration-%E5%88%B0%E6%9C%9F%E5%BA%94%E7%94%A8-GE"><span class="toc-text">（5）Expiration 到期应用 GE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89Tags-%E6%A0%87%E7%AD%BE"><span class="toc-text">（6）Tags 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TagResponseTable%EF%BC%88%E6%A0%87%E7%AD%BE%E5%93%8D%E5%BA%94%E8%A1%A8%EF%BC%89"><span class="toc-text">TagResponseTable（标签响应表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89Immunity-%E5%85%8D%E7%96%AB"><span class="toc-text">（7）Immunity 免疫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89Display-%E6%98%BE%E7%A4%BA"><span class="toc-text">（8）Display 显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%889%EF%BC%89Granted-Abilities"><span class="toc-text">（9）Granted Abilities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89GE-%E5%B5%8C%E5%A5%97"><span class="toc-text">（10）GE 嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-GameplayEffectSpec"><span class="toc-text">03 GameplayEffectSpec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-GameplayEffectContext"><span class="toc-text">04 GameplayEffectContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Instigator-%E5%92%8C-EffectCauser"><span class="toc-text">Instigator 和 EffectCauser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-EffectContext-%E5%AD%90%E7%B1%BB"><span class="toc-text">创建 EffectContext 子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-GameplayEffectContext"><span class="toc-text">继承 GameplayEffectContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NetSerialize"><span class="toc-text">NetSerialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-UAbilitySystemGlobals"><span class="toc-text">继承 UAbilitySystemGlobals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">使用自定义的信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E5%BA%94%E7%94%A8-Apply"><span class="toc-text">05 应用 Apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E7%A7%BB%E9%99%A4-Remove"><span class="toc-text">06 移除 Remove</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E4%BF%AE%E9%A5%B0%E7%AC%A6-Modifier"><span class="toc-text">07 修饰符 Modifier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">计算类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scalable-Float"><span class="toc-text">Scalable Float</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attribute-Based"><span class="toc-text">Attribute Based</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CustomCalculationClass%EF%BC%88MMC%EF%BC%89"><span class="toc-text">CustomCalculationClass（MMC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UGameplayModMagnitudeCalculation"><span class="toc-text">UGameplayModMagnitudeCalculation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-By-Caller"><span class="toc-text">Set By Caller</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot-%E5%BF%AB%E7%85%A7"><span class="toc-text">Snapshot 快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiply-%E5%92%8C-Divide-Modifier"><span class="toc-text">Multiply 和 Divide Modifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier-%E7%9A%84-GameplayTag"><span class="toc-text">Modifier 的 GameplayTag</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-Execution-Calculation-ExecCalc"><span class="toc-text">08  Execution Calculation (ExecCalc)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UGameplayEffectExecutionCalculation"><span class="toc-text">UGameplayEffectExecutionCalculation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutionParams"><span class="toc-text">ExecutionParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0-ExecCalc"><span class="toc-text">发送数据到 ExecCalc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SetByCaller"><span class="toc-text">SetByCaller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calculation-Modifier"><span class="toc-text">Calculation Modifier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9E%AC%E6%97%B6%E8%81%9A%E5%90%88%E5%99%A8-Transient-Aggregator"><span class="toc-text">瞬时聚合器 Transient Aggregator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-GameplayEffectContext-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">从 GameplayEffectContext 获取数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-%E8%8A%B1%E8%B4%B9-Cost-GE"><span class="toc-text">09 花费(Cost)GE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cost-GE-%E5%A4%8D%E7%94%A8"><span class="toc-text">Cost GE 复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%86%B7%E5%8D%B4-Cooldown-GE"><span class="toc-text">10 冷却(Cooldown) GE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cooldown-GE-%E5%A4%8D%E7%94%A8"><span class="toc-text">Cooldown GE 复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Cooldown-GE-%E7%9A%84%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4"><span class="toc-text">获取 Cooldown GE 的剩余时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%86%B7%E5%8D%B4%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="toc-text">监听冷却开始和结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%86%B7%E5%8D%B4%E6%97%B6%E9%97%B4"><span class="toc-text">预测冷却时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%BF%80%E6%B4%BB-GameplayEffect-%E7%9A%84%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4"><span class="toc-text">11 修改已激活 GameplayEffect 的持续时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81-GE"><span class="toc-text">12 运行时创建动态 GE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-GameplayEffect-Containers"><span class="toc-text">13 GameplayEffect Containers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">14 存在的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Gameplay-Ability"><span class="toc-text">6 Gameplay Ability</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">01 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E6%8E%88%E4%BA%88-Give"><span class="toc-text">02 授予 Give</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FGameplayAbilitySpec"><span class="toc-text">FGameplayAbilitySpec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FGameplayAbilitySpecHandle"><span class="toc-text">FGameplayAbilitySpecHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%8F%96%E6%B6%88-Ability"><span class="toc-text">03 取消 Ability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E6%BF%80%E6%B4%BB-Ability"><span class="toc-text">04 激活 Ability</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trigger-%E4%B8%8E-Event"><span class="toc-text">Trigger 与 Event</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%BF%80%E6%B4%BB%E7%9A%84-Ability"><span class="toc-text">获取激活的 Ability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E8%A2%AB%E5%8A%A8-Ability"><span class="toc-text">05 被动 Ability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%88%B0-Ability"><span class="toc-text">06 传递数据到 Ability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-GA-%E6%A0%87%E7%AD%BE"><span class="toc-text">07 GA 标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-%E5%8D%87%E7%BA%A7-Ability"><span class="toc-text">08 升级 Ability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5-Instanced-Policy"><span class="toc-text">09 实例化策略 (Instanced Policy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BB%91%E5%AE%9A%E8%BE%93%E5%85%A5%E5%88%B0-ASC-%EF%BC%9F"><span class="toc-text">10 绑定输入到 ASC?？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="toc-text">增强输入系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7%E7%89%88%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F-InputID"><span class="toc-text">旧版输入系统 InputID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%BE%93%E5%85%A5%E6%97%B6%E4%B8%8D%E6%BF%80%E6%B4%BB-Ability"><span class="toc-text">绑定输入时不激活 Ability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BD%91%E7%BB%9C"><span class="toc-text">11 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5-Net-Execution-Policy"><span class="toc-text">网络执行策略 (Net Execution Policy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-Net-Security-Policy"><span class="toc-text">网络安全策略 (Net Security Policy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A2%84%E6%B5%8B-GA"><span class="toc-text">客户端预测 GA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8CReplication-Policy"><span class="toc-text">❌Replication Policy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8CServer-Respects-Remote-Ability-Cancellation"><span class="toc-text">❌Server Respects Remote Ability Cancellation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8CReplicate-Input-Directly"><span class="toc-text">❌Replicate Input Directly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ability-%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-text">Ability 批处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Ability-Async-%E5%92%8C-Ability-Task"><span class="toc-text">7 Ability Async 和 Ability Task</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ability-Async"><span class="toc-text">Ability Async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ability-Task"><span class="toc-text">Ability Task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spawn-Actor-%E7%9A%84-AbilityTask"><span class="toc-text">Spawn Actor 的 AbilityTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-text">自定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AbilityTask"><span class="toc-text">使用AbilityTask</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Gameplay-Cue"><span class="toc-text">8 Gameplay Cue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%AE%9A%E4%B9%89-3"><span class="toc-text">01 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E8%B0%83%E7%94%A8-GC"><span class="toc-text">02 调用 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-GE-%E8%B0%83%E7%94%A8"><span class="toc-text">通过 GE 调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8"><span class="toc-text">手动调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-GameplayCueNotify"><span class="toc-text">03 GameplayCueNotify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-GameplayCue-%E6%A0%87%E7%AD%BE"><span class="toc-text">04 GameplayCue 标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-FGameplayCueParameters"><span class="toc-text">05 FGameplayCueParameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-UGameplayCueManager"><span class="toc-text">06 UGameplayCueManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E9%98%BB%E6%AD%A2-GameplayCue-%E5%93%8D%E5%BA%94"><span class="toc-text">07 阻止 GameplayCue 响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-%E7%BD%91%E7%BB%9C"><span class="toc-text">08 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GameplayCue-%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-text">GameplayCue 批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8RPC"><span class="toc-text">手动RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GE-%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA-GameplayCue"><span class="toc-text">GE 中的多个 GameplayCue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-GameplayCue"><span class="toc-text">客户端 GameplayCue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Ability-System-Globals"><span class="toc-text">9 Ability System Globals</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InitGlobalData"><span class="toc-text">InitGlobalData()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Targeting"><span class="toc-text">10 Targeting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Target-Data"><span class="toc-text">Target Data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FGameplayAbilityTargetData"><span class="toc-text">FGameplayAbilityTargetData</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BATargetData"><span class="toc-text">创建TargetData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TargetData"><span class="toc-text">使用TargetData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-TargetData"><span class="toc-text">自定义 TargetData</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FGameplayAbilityTargetDataHandle"><span class="toc-text">FGameplayAbilityTargetDataHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-text">网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Target-Actor"><span class="toc-text">Target Actor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbilityTask-WaitTargetData"><span class="toc-text">AbilityTask_WaitTargetData</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfirmationType"><span class="toc-text">ConfirmationType</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AGameplayAbilityTargetActor"><span class="toc-text">AGameplayAbilityTargetActor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-TargetActor"><span class="toc-text">自定义 TargetActor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96-TargetActor"><span class="toc-text">持久化 TargetActor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TargetDataFilter"><span class="toc-text">TargetDataFilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reticle"><span class="toc-text">Reticle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89FWorldReticleParameters"><span class="toc-text">自定义FWorldReticleParameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96-Reticle"><span class="toc-text">持久化 Reticle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6-1"><span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gameplay-Effect-Containers-Targeting"><span class="toc-text">Gameplay Effect Containers Targeting</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E9%A2%84%E6%B5%8B-Prediction"><span class="toc-text">11 预测 (Prediction)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prediction-Key"><span class="toc-text">Prediction Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Ability-%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E9%A2%84%E6%B5%8B%E7%AA%97%E5%8F%A3-Prediction-Window"><span class="toc-text">在 Ability 中创建新的预测窗口 (Prediction Window)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E6%80%A7%E5%9C%B0%E7%94%9F%E6%88%90-Actor"><span class="toc-text">预测性地生成 Actor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GAS-%E4%B8%AD%E9%A2%84%E6%B5%8B%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-text">GAS 中预测的未来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%A2%84%E6%B5%8B%E6%8F%92%E4%BB%B6-Network-Prediction-plugin"><span class="toc-text">网络预测插件 (Network Prediction plugin)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>