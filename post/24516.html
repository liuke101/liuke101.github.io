<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【图形系统08】透明 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[!error] 渲染管线的差异由于 URP 管线不适用多 pass，一些在 Built-in 中的双 pass 的实现都可以用单 pass 实现。具体原因，还不清楚。有待学习  1 Unity 渲染顺序在 Unity 中，渲染顺序是根据以下参数依次按条件先后顺序进行排序渲染处理。先按上层条件排序，如上层条件相同，则进入下层条件牌序，最终分出先后 **Camera Depth &gt; Rend">
<meta property="og:type" content="article">
<meta property="og:title" content="【图形系统08】透明">
<meta property="og:url" content="http://liuke101.github.io/post/24516.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="[!error] 渲染管线的差异由于 URP 管线不适用多 pass，一些在 Built-in 中的双 pass 的实现都可以用单 pass 实现。具体原因，还不清楚。有待学习  1 Unity 渲染顺序在 Unity 中，渲染顺序是根据以下参数依次按条件先后顺序进行排序渲染处理。先按上层条件排序，如上层条件相同，则进入下层条件牌序，最终分出先后 **Camera Depth &gt; Rend">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332483.png">
<meta property="article:published_time" content="2023-09-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-06T15:46:52.671Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332483.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/24516.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【图形系统08】透明',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 23:46:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332483.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【图形系统08】透明</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-27T16:00:00.000Z" title="发表于 2023-09-28 00:00:00">2023-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T15:46:52.671Z" title="更新于 2024-08-06 23:46:52">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【图形系统08】透明"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/24516.html#post-comment"><span class="waline-comment-count" data-path="/post/24516.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>[!error] 渲染管线的差异<br>由于 URP 管线不适用多 pass，一些在 Built-in 中的双 pass 的实现都可以用单 pass 实现。具体原因，还不清楚。有待学习</p>
</blockquote>
<h1 id="1-Unity-渲染顺序"><a href="#1-Unity-渲染顺序" class="headerlink" title="1 Unity 渲染顺序"></a>1 Unity 渲染顺序</h1><p><strong>在 Unity 中，渲染顺序是根据以下参数依次按条件先后顺序进行排序渲染处理</strong>。先按上层条件排序，如上层条件相同，则进入下层条件牌序，最终分出先后</p>
<p>**Camera Depth &gt; Render Queue 大于还是小于等于 2500 &gt; Sorting Layer &gt; Order in Layer &gt; Render Queue &gt; Camera order algorithm</p>
<ol>
<li>Camera Depth：值越小越优先渲染，优先渲染可能会被覆盖</li>
<li>Render Queue &lt;&#x3D; 2500：视为不透明物体<ol>
<li>按照 Sorting Layer &#x2F; Order in Layer 设置的值，越小越优先。若无此属性，等同于 Sorting Layer &#x3D; default，Order in Layer &#x3D; 0 参与排序 </li>
<li>Render Queue 越小越优先</li>
<li>Render Queue 相等，由<strong>近到远排序</strong></li>
</ol>
</li>
<li>Render Queue &gt;&#x3D; 2500：视为透明物体<ol>
<li>按照 Sorting Layer &#x2F; Order in Layer 设置的值，越小越优先。无此属性，等同于 Sorting Layer &#x3D; default，Order in Layer &#x3D; 0 参与排序</li>
<li>Render Queue 越小越优先</li>
<li>Render Queue 相等，由<strong>远到近排序</strong></li>
</ol>
</li>
</ol>
<p>注意：</p>
<ul>
<li>Sprite 组件和 Canvas 组件默认使用的 Shader 没有深度写入，但是进行深度测试。默认 RenderQueue 均为 Transparent</li>
<li>SkyBox 渲染发生在渲染不透明物体（Render Queue &lt;&#x3D; 2500）之后，透明物体（Render Queue &gt;&#x3D; 2500）之前。</li>
</ul>
<h2 id="Camera-Depth"><a href="#Camera-Depth" class="headerlink" title="Camera Depth"></a>Camera Depth</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332080.jpg" alt="c41cf813488837339d527b343fd9840f_MD5"></p>
<h2 id="Sorting-Layer"><a href="#Sorting-Layer" class="headerlink" title="Sorting Layer"></a>Sorting Layer</h2><p>Layer 层级<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332081.jpg" alt="29f5c88b31d2d14474e6a32292a876a7_MD5"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332082.jpg" alt="8e7a22d963d86de96cb7d3b3f06399b9_MD5"></p>
<h2 id="Order-in-Layer"><a href="#Order-in-Layer" class="headerlink" title="Order in Layer"></a>Order in Layer</h2><p>同一 Layer 中的排序<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332083.jpg" alt="ca37a2ad867ee77bcfa77d3da7caae06_MD5"></p>
<h2 id="Render-Queue"><a href="#Render-Queue" class="headerlink" title="Render Queue"></a>Render Queue</h2><p>渲染队列<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332084.jpg" alt="9fa4b63e50b7a4612d5d0a08591529f7_MD5"></p>
<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Properties</th><th>Value</th><th>渲染队列描述</th><th>说明</th></tr><tr><td>Background</td><td>1000</td><td>This Render Queue is rendered before any others</td><td>这个队列通常被最先渲染（比如天空盒）。</td></tr><tr><td>Geometry</td><td>2000</td><td>Opaque geometry uses this queue</td><td>这个默认的渲染队列。它被用于绝大数对象。不透明几何体使用该队列。</td></tr><tr><td>AlphaTest</td><td>2450</td><td>Alpha tested geometry uses this queue</td><td>需要开启透明度测试的物体。Unity5 以后从 Geometry 队列中拆出来，因为在所有不透明物体渲染完之后再渲染会比较高效。</td></tr><tr><td>GeometryLast</td><td>2500</td><td>Last Render Queue that is considered "opaque"</td><td>所有 Geometry 和 AlphaTest 队列的物体渲染完后。</td></tr><tr><td>Transparent</td><td>3000</td><td>This Render Queue is rendered after Geometry and AlphaTest, in back-to-front order</td><td>所有 Geometry 和 AlphaTest 队列渲染完后，再按照从后往前的顺序进行渲染，任何使用了透明度混合的物体都应该使用该队列（例如玻璃和粒子效果）。</td></tr><tr><td>Overlay</td><td>4000</td><td>This Render Queue is meat for overlay effects</td><td>该队列用于实现一些叠加效果，适合最后渲染的物体（如镜头光晕）。</td></tr></tbody></table>

<h2 id="Camera-render-algorithm"><a href="#Camera-render-algorithm" class="headerlink" title="Camera render algorithm"></a>Camera render algorithm</h2><h3 id="不透明物体排序算法"><a href="#不透明物体排序算法" class="headerlink" title="不透明物体排序算法"></a>不透明物体排序算法</h3><p>camera. opaqueSortMode</p>
<ul>
<li>Default ：在 Unity 2018.1 预设值 FrontToBack</li>
<li>FrontToBack ：从近到远排序绘制，由于 z-buffering 机制，能使得 GPU rendering 时有更好的性能</li>
<li>NoDistanceSort：关闭排序绘制，能减低 CPU 的使用量</li>
</ul>
<h3 id="透明物体排序算法"><a href="#透明物体排序算法" class="headerlink" title="透明物体排序算法"></a>透明物体排序算法</h3><p>camera. transparencySortMode</p>
<ul>
<li>Default：根据 camera projection mode 调整</li>
<li>Perspective：根据 camera 位置到物体中心（object center）的距离排序</li>
<li>Orthographic：根据 view plane 到物体中心（object center）的距离排序</li>
<li>CustomAxis：指定 axis 排序，专门用于 2D 游戏制作</li>
</ul>
<h2 id="UGUI’s-rendering-order"><a href="#UGUI’s-rendering-order" class="headerlink" title="UGUI’s rendering order"></a>UGUI’s rendering order</h2><p>CanvasRenderer 可视为画在画布 Canvas 的元件，之后该画布再画在最终的画面上（eg：render target）</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Screen Space - Overlay</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332085.jpg" alt="55a299e7de41c82f4c3575de0fdde378_MD5"></p>
<ul>
<li>该 Canvas 由隐藏的 camera 处理，其 depth &#x3D; 101（最后才处理，用户自建的 Camera Depth 最多 100）</li>
<li>多个相同的 canvas 使用 Sort order 来决定绘制顺序</li>
</ul>
<p>Screen Space - Camera &amp; World Space</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332086.jpg" alt="bcef7b0b7bb75a0d0bd756cd891f833f_MD5"></p>
<ul>
<li>存在世界场景的平面</li>
<li>多个相同的 canvas 使用 Sorting Layer 以及 Order in Layer 来决定绘制顺序</li>
</ul>
<h3 id="CanvasRenderer"><a href="#CanvasRenderer" class="headerlink" title="CanvasRenderer"></a>CanvasRenderer</h3><p>关于同一个 canvas 下，其 CanvasRenderer 之间的 rendering order：<strong>Render Queue &gt; Transform order</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332087.jpg" alt="13689268295ba6d6c9a4925ed171ae8a_MD5"></p>
<ul>
<li>Render Queue：材质球的 Render Queue</li>
<li>Transform order：依照 Transform Hierarchy 关系，采用 Pre-order 方式排序</li>
</ul>
<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td>当所属 Canvas 的 render mode 为 Screen Space - Overlay，则无视 Render Queue。</td></tr></tbody></table>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li><p>3D</p>
<ul>
<li>不透明物体 &amp; 半透明物体（例如草、铁丝网等）依照场景摆放<ul>
<li>不需要特别设定 rendering order</li>
<li>一切交给 z-buffering 机制</li>
</ul>
</li>
<li>透明物体或者粒子特效可透过 Sorting Layer &amp; Order in Layer 机制调整 rendering order<ul>
<li>透明物体 shader 通常不会写 z-buffer（ZWrite Off）</li>
<li>可 hack inspector 来设定 renderer. sortingLayerID 以及 renderer. sortingOrder</li>
</ul>
</li>
</ul>
</li>
<li><p>2D</p>
<ul>
<li>Sprite renderer 使用 Sorting Layer &amp; Order in Layer 机制来调整 rendering order，以控制 depth</li>
</ul>
</li>
<li><p>UGUI</p>
<ul>
<li>利用 transform hierarchy 来建立 rendering order，根据性能优化可以拆成多个 canvas</li>
<li>若采用 Canvas render mode：World Space，想让 UI 与 3D 场景物体的结合，可将 canvas 视为 3D 物体去设计场景架构</li>
</ul>
</li>
</ul>
<h1 id="2-Unity-渲染半透明物体的解决方案"><a href="#2-Unity-渲染半透明物体的解决方案" class="headerlink" title="2  Unity 渲染半透明物体的解决方案"></a>2  Unity 渲染半透明物体的解决方案</h1><blockquote>
<p>[!NOTE] Unity 中的渲染顺序<br>按 shader 指定的渲染队列顺序<br>Background—&gt;Geometry (默认队列)—&gt;AlphaTest—&gt;Transparent—&gt;Overlay<br>   这里总结不全，看一下上面的文章</p>
</blockquote>
<p><strong>一般采用的方案</strong>：<br>(1) 先渲染所有不透明物体，并<strong>开启它们的深度测试和深度写入</strong>。<br>(2) 把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并<strong>开启它们的深度测试，但关闭深度写入</strong>。</p>
<p>即便按照上述这种正确的渲染顺序，仍会存在问题： [[08 透明#^t3bkkp]]，半透明排序的问题只能尽量减少，无法避免。</p>
<p>Unity 为了解决渲染顺序的问题提供了 <strong>渲染队列 (render queue)</strong> 这一解决方案。我们可以使用 <strong><code>SubShader Queue</code></strong> 标签来决定我们的模型将归于哪个渲染队列。 <strong>Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染</strong>。<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332089.png" alt="Pasted image 20221003232825"></p>
<h1 id="2-透明度测试和透明度混合"><a href="#2-透明度测试和透明度混合" class="headerlink" title="2 透明度测试和透明度混合"></a>2 透明度测试和透明度混合</h1><p>Unity 中，我们通常使用两种方法来实现透明效果：</p>
<ol>
<li>**透明度测试(Alpha Test)**：无法得到半透明，要么完全透明，要么完全不透明<ul>
<li><strong>只要一个片元的透明度不满足条件（通常是小于某个阙值），那么它对应的片元就会被舍弃。</strong> 被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；</li>
<li><strong>否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。</strong> </li>
<li>也就是说，透明度测试是<mark style="background: #FF5582A6;">不需要关闭深度写入</mark>的，它和其他不透明物体最大的不同就是它会根据透明度来舍弃些片元。<strong>虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</strong></li>
</ul>
</li>
<li>**透明度混合 (Alpha Blending)**： 这种方法可以得到真正的半透明效果<ul>
<li>它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</li>
<li>透明度混合需要<strong>关闭深度写入，破坏了深度缓冲机制，这使得我们要非常小心物体的渲染顺序</strong>。需要注意的是，透明度混合<mark style="background: #FF5582A6;">只关闭了深度写入，但没有关闭深度测试</mark>。</li>
<li>当使用透明度混合渲染一个片元时，会进行深度测试，测试通过才会进行混合操作。这一点决定了当一个不透明物体出现在一个透明物体前，我们先渲染不透明物体并进行了深度写入，后面的透明物体无法通过深度测试所以被遮挡。</li>
<li><strong>深度缓冲中的值其实是像素级别的，即每个像素有一个深度值。但是由于我们关闭了深度写入，无法对模型进行像素级别的排序</strong>。当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果（解决办法 [[#2. 开启深度写入的半透明效果]]）</li>
</ul>
</li>
</ol>
<ul>
<li><p>? <strong>为什么要关闭深度写入？</strong><br>正常来说，我们可以透过半透明物体的前表面看到后表面，假设不关闭深度写入，按照半透明从后往前的渲染顺序。先渲染后表面写入深度缓冲和颜色缓冲，然后渲染前表面。由于前表面更靠近摄像机，深度测试通过，并写入深度和颜色缓冲，覆盖掉了后表面，我们就无法看到后表面了。所以为了半透明的正常显示，不得不关闭深度写入。</p>
</li>
<li><p>? <strong>为什么关闭了深度写入，渲染顺序很重要？</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332090.png" alt="Pasted image 20230620142344"><br>第一种情况，我们先渲染 B, 再渲染 A（<strong>先渲染不透明物体，再渲染半透明物体，结果正确</strong>）。那么由于不透明物体开启了深度测试和深度写入，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比 A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 的颜色进行混合，得到正确的半透明效果。<br>第二种情况，我们先渲染 A，再渲染 B（<strong>先渲染半透明物体，再渲染不透明物体，结果错误</strong>）。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现，“咦，深度缓存中还没有人来过，那我就放心地写入颜色缓冲了!”，结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。 ^t3bkkp</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332091.png" alt="Pasted image 20230620142352"><br>第一种情况，我们先渲染 B，再渲染 A （<strong>从后往前渲染半透明物体，结果正确</strong>）。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。<br>第二种情况，我们先渲染 A，再渲染 B （<strong>从前往后渲染半透明物体，结果错误</strong>）。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面，得到的就是错误的半透明结构。</p>
<p>按照正确的渲染顺序仍存在问题，在一些情况下，半透明物体还是会出现“穿帮镜头”。</p>
<p><strong>深度缓冲中的值其实是像素级别的，即每个像素有一个深度值。但是由于我们关闭了深度写入，无法对模型进行像素级别的排序</strong>。<br><strong>我们只是按照距离摄像机的远近进行排序，这是对单个物体级别进行排序</strong>，这意味着排序结果是，要么物体 A 全部在 B 前面渲染，要么 A 全部在 B 后面渲染。如果存在<strong>循环重叠</strong>的情况，那么使用这种方法就永远无法得到正确的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332092.png" alt="Pasted image 20230620143149"><br>在图 8.3 中，由于 3 个物体互相重叠，我们不可能得到一个正确的排序顺序。这种时候，我们可以选择把物体拆分成两个部分，然后再进行正确的排序。但即便我们通过分割的方法解决了循环覆盖的问题，还是会有其他的情况来”捣乱”。考虑图 8.4 给出的情况。</p>
<p>这里的问题是: 如何排序? 我们知道，一个物体的网格结构往往占据了空间中的某一块区域, 也就是说，这个网格上每一个点的深度值可能都是不一样的，<strong>我们选择哪个深度值来作为整个物体的深度值和其他物体进行排序呢? 是网格中点吗? 还是最远的点? 还是最近的点? 不幸的是, 对于图 8.4 中的情况，选择哪个深度值都会得到错误的结果</strong>, 我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。</p>
<p><strong>减少错误排序的方法</strong></p>
<ol>
<li>分割网格，尽可能让模型是凸面体, 并且考虑将复杂的模型拆分成可以独立排序的多个子模型</li>
<li>如果不想分割网格，可以试着让透明通道更加柔和，使穿插看起来并不是那么明显</li>
<li>使用开启了深度写入的半透明效果来近似模拟物体的半透明 (详见 8.5 节)</li>
<li>Unity 为了解决渲染顺序的问题，提供了渲染队列（render queue）解决方案。</li>
</ol>
<h3 id="透明度测试-Alpha-Test（Alpha-Cutout）"><a href="#透明度测试-Alpha-Test（Alpha-Cutout）" class="headerlink" title="透明度测试 Alpha Test（Alpha Cutout）"></a>透明度测试 Alpha Test（Alpha Cutout）</h3><p>透明度测试：只要一个片元的透明度不满足条件 (通常是小于某个阙值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响; 否则，就会按照普通的不透明物体的处理方式来处理它。</p>
<blockquote>
<p>[!NOTE] Clip 函数<br>void clip(float4 x);void clip(float3 x);void clip(float2 x);void clip(float1 x);void clip(float x);<br><strong>给定参数任何一个分量是负数，就舍弃当前像素的输出颜色</strong></p>
<p>void clip (float4)<br>{<br>        if ((any&lt;0))<br>        discard;<br>}</p>
</blockquote>
<p>透明度测试的显示效果比较极端：要么完全透明（看不到），要么完全不透明。而且，透明效果的边缘有锯齿，这是因为在边界处纹理的透明度变化精度问题，为了得到更加柔滑的透明效果，就可以使用透明度混合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332070.png" alt="image-20220704153317101"> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332071.png" alt="image-20220704153515750"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MyAlphaTest&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Cutoff (<span class="string">&quot;Alpha Cutoff&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>))= <span class="number">0.5</span>   </span><br><span class="line">        <span class="comment">//为了控制透明度测试时使用的阈值。_Cutoff参数用于决定我们调用clip进行透明度测试时使用的判断条件，范围是[0,1]，这是因为纹理像素的透明度就在此范围内</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span>                <span class="comment">//透明度测试使用AlphaTest渲染队列</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span>           <span class="comment">//该Shader不会受到投影器的影响</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;TransparentCutout&quot;</span>    <span class="comment">//把该Shader归入到提前定义的组中（TransparentCutout组），以指明该Shader时一个使用了透明度测试的Shader，该标签通常被用于着色器替换功能</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//透明度测试</span></span><br><span class="line">                clip(texColor.a - _Cutoff);</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Transparent/Cutout/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="透明度混合-Alpha-Blend"><a href="#透明度混合-Alpha-Blend" class="headerlink" title="透明度混合 Alpha Blend"></a>透明度混合 Alpha Blend</h3><h4 id="1-一般方法"><a href="#1-一般方法" class="headerlink" title="1. 一般方法"></a>1. 一般方法</h4><p>透明度混合：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，<strong>透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332072.png" alt="image-20220704153735600"></p>
<p>本节使用的 Blend 命令为： <code>Blend SrcAlpha OneMinusSrcAlpha</code><br>$DstColor_{new}&#x3D;SrcAlpha×SrcColor+(1-SrcAlpha)× DstColorold$<br>比如源颜色的不透明度 $\alpha$ 值为 0.25，那么可以理解为用最终颜色由 25% 的源颜色，和 75%的目标颜色组成。</p>
<p><strong>透明度混合可以得到更加柔和的透明效果，但是这种方法仍有弊端：关闭深度写入后，造成错误排序，无法对模型进行像素级别的深度排序。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332073.png" alt="image-20220704154122183"></p>
<p><strong>实现效果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332074.png" alt="image-20220704153821708"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332075.png" alt="image-20220704154027806"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MyAlphaBlendMat&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _AlphaScale (<span class="string">&quot;Alpha Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>))= <span class="number">0.5</span>   </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>                <span class="comment">//透明度混合使用Transparent渲染队列</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span>           <span class="comment">//该Shader不会受到投影器的影响</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span>    <span class="comment">//把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            ZWrite Off <span class="comment">//关闭深度写入</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha  <span class="comment">//Blend设置混合模式</span></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;  <span class="comment">//用于在透明纹理的基础上控制整体的透明度</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);  <span class="comment">//设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-开启深度写入的半透明效果"><a href="#2-开启深度写入的半透明效果" class="headerlink" title="2. 开启深度写入的半透明效果"></a>2. 开启深度写入的半透明效果</h4><h5 id="Built-in-实现"><a href="#Built-in-实现" class="headerlink" title="Built-in 实现"></a>Built-in 实现</h5><p>由于透明度混合关闭深度写入，我们就无法对模型进行像素级别的深度排序。当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候, 就会有各种各样因为排序错误而产生的错误的透明效果。</p>
<p><strong>我们可以想办法重新利用深度写入, 一种解决办法是是使用两个 Pass 来渲染模型:</strong> </p>
<ol>
<li>第一个 Pass： 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中;</li>
<li>第二个 Pass ：进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。</li>
</ol>
<p>使用这种方法我们仍可以实现模型与他后面的背景混合的效果，同时模型内部之间不会有任何的半透明效果。但这种方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。</p>
<p><strong>这个新添加的 Pass 的目的仅仅是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元。</strong> 因此，Pass 的第一行开启了深度写入。<br>在第二行，我们使用了一个新的渲染命令—— <code>ColorMask</code>。<br><strong>在 ShaderLab 中，<code>ColorMask</code> 用于设置颜色通道的写掩码 (write mask)。它的语义如下:</strong><br><code>ColorMask RGB/A/0/其他任何 R、G、B、A 的组合</code></p>
<p><strong>当 ColorMask 设为 0 时，即使用 <code>ColorMask 0</code> 指令，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。</strong> 这正是我们需要的，该 Pass 只需写入深度缓存即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332076.png" alt="image-20220704154337978"></p>
<figure class="highlight c"><figcaption><span>h:20,28</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/MyAlphaBlendZwriteMat&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _AlphaScale (<span class="string">&quot;Alpha Scale&quot;</span>, Range (<span class="number">0</span>, <span class="number">1</span>))= <span class="number">0.5</span>   </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>                <span class="comment">//透明度混合使用Transparent渲染队列</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span>           <span class="comment">//该Shader不会受到投影器的影响</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span>    <span class="comment">//把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用两个Pass来渲染模型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个Pass开启深度写入，但不输出颜色，目的仅仅是为了把该模型的深度值写入深度缓冲中</span></span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            Zwrite On</span><br><span class="line">            ColorMask <span class="number">0</span></span><br><span class="line">            <span class="comment">//ColorMask用于设置颜色通道的写掩码（write mask）,设为0，意味着该Pass不写入任何颜色通道</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个Pass进行正常的透明度混合，由于上一个Pass已经得到了逐像素的正确深度信息，该Pass就可以按照像素级别的深度排序结果进行透明渲染</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            ZWrite Off <span class="comment">//关闭深度写入</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha  <span class="comment">//Blend设置混合模式</span></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;  <span class="comment">//用于在透明纹理的基础上控制整体的透明度</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fixed4 texColor = tex2D (_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);  <span class="comment">//设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="URP-实现"><a href="#URP-实现" class="headerlink" title="URP 实现"></a>URP 实现</h5><p>与 Built-in 实现下不同的是，在 URP 下无需额外增加一个 Pass 去单独渲染深度缓冲区，可以直接开启深度写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;URP/AlphaBlendingWithZWrite&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123; &#125;</span><br><span class="line">        _AlphaScale (<span class="string">&quot;Alpha Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//         指定渲染通道使用URP渲染管线            		渲染队列 = 透明度混合		忽略投影 = Ture				渲染类型 = 透明物体</span></span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalRenderPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 添加额外的Pass，仅用于渲染到深度缓冲区</span></span><br><span class="line"><span class="comment">        Pass</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            // 开启深度写入</span></span><br><span class="line"><span class="comment">            ZWrite On</span></span><br><span class="line"><span class="comment">            // 用于控制Pass不写入任何颜色通道</span></span><br><span class="line"><span class="comment">            ColorMask 0</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span> &#125;</span><br><span class="line">            <span class="comment">// 关闭渲染剔除</span></span><br><span class="line">            Cull Off</span><br><span class="line">            ZWrite On</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 引用URP函数库</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 声明纹理</span></span><br><span class="line">            TEXTURE2D(_MainTex);</span><br><span class="line">            <span class="comment">// 声明采样器</span></span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line">            </span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            half4 _Color;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            half _AlphaScale;</span><br><span class="line">            CBUFFER_END</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal: NORMAL;</span><br><span class="line">                float4 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos: SV_POSITION;</span><br><span class="line">                float3 worldNormal: TEXCOORD0;</span><br><span class="line">                float3 worldPos: TEXCOORD1;</span><br><span class="line">                float2 uv: TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 初始化变量</span></span><br><span class="line">                ZERO_INITIALIZE(v2f, o);</span><br><span class="line">                </span><br><span class="line">                o.pos = TransformObjectToHClip(v.vertex.xyz);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = TransformObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = TransformObjectToWorld(v.vertex.xyz);</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(v2f i)</span>: SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                half3 worldLightDir = normalize(TransformObjectToWorldDir(_MainLightPosition.xyz));</span><br><span class="line">                </span><br><span class="line">                half4 texColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                half3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                half3 ambient = _GlossyEnvironmentColor.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                half3 diffuse = _MainLightColor.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> half4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDHLSL</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Packages/com.unity.render-pipelines.universal/SimpleLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双面渲染"><a href="#双面渲染" class="headerlink" title="双面渲染"></a>双面渲染</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332077.png" alt="image-20220704155211450"></p>
<h4 id="1-透明度测试的双面渲染"><a href="#1-透明度测试的双面渲染" class="headerlink" title="1. 透明度测试的双面渲染"></a>1. 透明度测试的双面渲染</h4><p>代码和透明度测试一样，只需要添加 <code>Cull Off</code> 指令<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332078.png" alt="image-20220704155008714"></p>
<h4 id="2-透明度混合的双面渲染"><a href="#2-透明度混合的双面渲染" class="headerlink" title="2. 透明度混合的双面渲染"></a>2. 透明度混合的双面渲染</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332093.jpg" alt="58898c932eae8d9bc2a4e81f2ee3a426_MD5|350"></p>
<h5 id="Built-in-实现-1"><a href="#Built-in-实现-1" class="headerlink" title="Built-in 实现"></a>Built-in 实现</h5><p>再透明度混合代码的基础上直接添加 <code>Cull Off</code> 指令，无法保证同一个物体的正面和背面图元的渲染顺序。</p>
<p>为此，我们选择把双面渲染的工作分成两个 Pass：</p>
<ul>
<li>第一个 Pass 只渲染背面</li>
<li>第二个 Pass 只渲染正面</li>
</ul>
<p><strong>由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332079.png" alt="image-20220704155047959"></p>
<h5 id="URP-实现-1"><a href="#URP-实现-1" class="headerlink" title="URP 实现"></a>URP 实现</h5><p>与 Built-in 实现不同，在 URP 下无需用双 Pass 进行正反面渲染，直接关闭渲染剔除即可实现对透明物体的双面渲染</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;URP/AlphaBlendWithBothSide&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123; &#125;</span><br><span class="line">        _AlphaScale (<span class="string">&quot;Alpha Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalRenderPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span> &#125;</span><br><span class="line">            <span class="comment">// 关闭渲染剔除</span></span><br><span class="line">            Cull Off</span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 混合因子设置</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 引用URP函数库</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 声明纹理</span></span><br><span class="line">            TEXTURE2D(_MainTex);</span><br><span class="line">            <span class="comment">// 声明采样器</span></span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line">            </span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            half4 _Color;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            half _AlphaScale;</span><br><span class="line">            CBUFFER_END</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal: NORMAL;</span><br><span class="line">                float4 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos: SV_POSITION;</span><br><span class="line">                float3 worldNormal: TEXCOORD0;</span><br><span class="line">                float3 worldPos: TEXCOORD1;</span><br><span class="line">                float2 uv: TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 初始化变量</span></span><br><span class="line">                ZERO_INITIALIZE(v2f, o);</span><br><span class="line">                </span><br><span class="line">                o.pos = TransformObjectToHClip(v.vertex.xyz);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = TransformObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = TransformObjectToWorld(v.vertex.xyz);</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(v2f i)</span>: SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                half3 worldLightDir = normalize(TransformObjectToWorldDir(_MainLightPosition.xyz));</span><br><span class="line">                </span><br><span class="line">                half4 texColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                half3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                half3 ambient =_GlossyEnvironmentColor.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                half3 diffuse = _MainLightColor.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> half4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;            </span><br><span class="line">            ENDHLSL            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Packages/com.unity.render-pipelines.universal/SimpleLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Additive"><a href="#Additive" class="headerlink" title="Additive"></a>Additive</h1><h1 id="3-Alpha-预乘"><a href="#3-Alpha-预乘" class="headerlink" title="3 Alpha 预乘"></a>3 Alpha 预乘</h1><p><img src="/undefined" alt="AP01_L15_5"></p>
<p>![[03 定向光#3.4.1 Premultiplied（预乘） Alpha]]</p>
<h2 id="Tip1-理解-Alpha-混合"><a href="#Tip1-理解-Alpha-混合" class="headerlink" title="Tip1: 理解 Alpha 混合"></a>Tip1: 理解 Alpha 混合</h2><p>最常见的混合是 “over” 混合，假设已经有一张 RenderTexture，RT 上像素的 RGB 我们称其为 $RGB_{dst}$ ，alpha 为 $A_{dst}$ 。现在有一个像素 $(RGB_{src}, A_{src})$ 要和 RT 上的像素混合，那正确的混合会这样进行：</p>
<p>$RGB’<em>{result} &#x3D; A</em>{src} *RGB_{src}+ (A_{dst}*RGB_{dst} ) *(1-A_{src})$</p>
<p>$A_{result} &#x3D; A_{src} + A_{dst} * (1-A_{src})$</p>
<p>最终混合出来的颜色由两部组成：</p>
<ul>
<li>$A_{src} *RGB_{src}$ 代表 $RGB{src}$ 对最终颜色的贡献，它受 alpha 影响，如果 alpha 为 0 则对最终像素没有影响，如果 alpha 为 1 则贡献 100% 的 $RGB{src}$</li>
<li>$A_{dst} * RGB_{dst}$ 是 RT 中像素原本没有其它像素覆盖时的贡献值，但是现在被一个新来的像素遮挡了，被遮挡了 $(1-A_{src})$ ，因此 RT 中像素最终贡献了 $(A_{dst}*RGB_{dst}) * (1-A_{src})$</li>
</ul>
<p><strong>由此可见，无论对于 src 还是 dst，</strong> $A * RGB$ <strong>才是实际的有效颜色，称其为 premultiplied alpha。</strong></p>
<p>我们令 $RGB’ &#x3D; A * RGB$ ，则颜色混合可以改写为</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>这么看就更清楚了：</p>
<p><strong>最终的输出 &#x3D; 新叠加像素的有效颜色 + RT 中原有像素的有效颜色 * 新像素的遮挡</strong></p>
<h2 id="Tip2-SrcAlpha-OneMinusSrcAlpha-颜色混合正确是有前提的"><a href="#Tip2-SrcAlpha-OneMinusSrcAlpha-颜色混合正确是有前提的" class="headerlink" title="Tip2: SrcAlpha, OneMinusSrcAlpha 颜色混合正确是有前提的"></a><strong>Tip2: SrcAlpha, OneMinusSrcAlpha 颜色混合正确是有前提的</strong></h2><p>例如 Unity 中的透明混合，默认采用 SrcAlpha, OneMinusSrcAlpha 这种方式，如果用符号表示出来是这样的：</p>
<p>$RGB_{result} &#x3D; A_{src} * RGB_{src} + RGB_{dst} * (1-A_{src})$</p>
<p>对比之前给出的计算</p>
<p>$RGB’<em>{result} &#x3D; A</em>{src} *RGB_{src}+ (A_{dst}*RGB_{dst} ) *(1-A_{src})$</p>
<p>加号右侧少乘了 $A_{dst}$ ，这是为什么呢？</p>
<p><strong>SrcAlpha, OneMinusSrcAlpha 正确的前提是混合目标是不透明的，即</strong> $A_{dst}$ <strong>为 1。</strong></p>
<p>平时渲染时，常见的情况是先渲染不透明物体，再渲染不透明的天空盒，最后再渲染半透明物体做 alpha 混合，在这种情况下渲染目标是不透明的，<strong>不透明物体的有效颜色即其颜色本身</strong>。</p>
<p>在满足这个前提下</p>
<p>$RGB_{result} &#x3D; A_{src} * RGB_{src} + RGB_{dst} * (1-A_{src})$</p>
<p>才会成立，其本质为</p>
<p>$RGB’_{result} &#x3D; A_{src} * RGB_{src} + (1.0 * RGB_{dst}) * (1-A_{src})$</p>
<p>依然是符合 tip1 中给出的结论</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>只不过此时的 $RGB’<em>{dst}$ 等于  $RGB</em>{dst}$ 。</p>
<p>可能有人会产生疑问，不透明背景上混合半透明后，怎么看待混合后的透明度？</p>
<p>我们回过头去看 tip1 中 alpha 的计算</p>
<p>$A_{result} &#x3D; A_{src} + A_{dst} * (1-A_{src})$ ，</p>
<p>$&#x3D; 1.0 * A_{src} + A_{dst} * (1-A_{src})$</p>
<p>$&#x3D; lerp(A_{dst}, 1.0, A_{src})$</p>
<p>发现没有，<strong>其本质是以 $A_{src}$ 作为参数的 $A_{dst}$ 到 1.0 线性插值</strong>。当 $A_{dst}$ 为 1.0 时，无论 $A_{src}$ 是何值，最终输出都是 1.0。回到现实中，这很好理解，砖墙前放一块玻璃，当我们将玻璃和墙看作一个整体时，它们是不透明的。</p>
<h2 id="Tip3-SrcAlpha-OneMinusSrcAlpha-混合出来的-Alpha-值是无意义的"><a href="#Tip3-SrcAlpha-OneMinusSrcAlpha-混合出来的-Alpha-值是无意义的" class="headerlink" title="Tip3: SrcAlpha, OneMinusSrcAlpha 混合出来的 Alpha 值是无意义的"></a>Tip3: SrcAlpha, OneMinusSrcAlpha 混合出来的 Alpha 值是无意义的</h2><p>这种常见混合方式根据 tip2，其已默认渲染目标的 alpha 为 1，因此它不关心 alpha 结果的正确性。</p>
<p>根据其表达式</p>
<p>$RGB_{result} &#x3D; A_{src} * RGB_{src} + RGB_{dst} * (1-A_{src})$</p>
<p>我们可以清晰的看到，这里没有出现 $A_{dst}$ ，得出正确的 RGB 与 RT 中的 alpha 存什么没有任何关联。</p>
<p>通过 SrcAlpha, OneMinusSrcAlpha 方式我们会计算得到</p>
<p>$A_{result} &#x3D; A_{src} * A_{src} + A_{dst} * (1-A_{src})$</p>
<p>这个结果没有意义。<strong>有些情况下，可以利用这种性质，将 RT 中没有被用到的 alpha 通道利用起来</strong>，例如存储 bloom 系数。</p>
<p><strong>正因如此，想要单独渲染含半透的角色、特效到 RT，再混合到界面必须修改 Alpha 的计算方式，请看 tip4。</strong></p>
<h2 id="Tip4-如何正渲染半透-RenderTexture"><a href="#Tip4-如何正渲染半透-RenderTexture" class="headerlink" title="Tip4: 如何正渲染半透 RenderTexture"></a>Tip4: 如何正渲染半透 RenderTexture</h2><p>可以使用 《GPU Gems 3》 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-23-high-speed-screen-particles">Chapter 23. High-Speed, Off-Screen Particles</a> 中提到的反转 alpha 的方法，和本文的主题无关不展开讲了。另外可以从前往后排序用 “under” 混合也是可以的。</p>
<p><strong>最直接了当的方法就是采用 premultiplied alpha 的混合方式。</strong>  </p>
<h2 id="Tip5-理解预乘-Alpha-混合公式的颜色部分"><a href="#Tip5-理解预乘-Alpha-混合公式的颜色部分" class="headerlink" title="Tip5: 理解预乘 Alpha 混合公式的颜色部分"></a>Tip5: 理解预乘 Alpha 混合公式的颜色部分</h2><p>Premultiplied alpha 混合采用 One, OneMinusSrcAlpha，其实我们在 tip1 中就已经看到了，</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>即</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src} * 1.0 + RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>One 就是这里的 1.0 而 OneMinusSrcAlpha 就是 $(1-A_{src})$ 。</p>
<p>$RGB’<em>{dst}$ 来自于混合的结果，真正留给我们的问题是 $RGB’</em>{src}$ 如何获得。</p>
<p><strong>最简单方式就是纹理中的 RGB 预乘好 alpha，那我们采样得到的颜色直接就是有效 RGB。</strong></p>
<p><strong>另外需要注意的是这里输出的 RGB 是预乘 alpha 的 RGB，详见 tip8。</strong></p>
<h2 id="Tip6-纹理预乘-Alpha-实践上可能有潜在问题"><a href="#Tip6-纹理预乘-Alpha-实践上可能有潜在问题" class="headerlink" title="Tip6: 纹理预乘 Alpha 实践上可能有潜在问题"></a>Tip6: 纹理预乘 Alpha 实践上可能有潜在问题</h2><p>在实践中，我们的纹理的数据源大多是 RGBA32，即单通道 8 比特，只能表示 0-255 的整数，同时游戏资产还会根据目标平台做纹理压缩。</p>
<p><strong>由于精度问题，原本相近的颜色在预乘后会存储为更相近，甚至相同的颜色，经压缩后很容易产生大量 artifacts。要使用预乘 alpha 的纹理，一般会建议采用单通道 16 位的存储。</strong></p>
<p><strong>由于这种情况，即使预乘有很好的纹理过滤特性，也没有被广泛采用</strong>，我所了解 WebGL 由于网页对于 alpha composition 的天然需求，做了这方面的支持。  </p>
<h2 id="Tip7-即使不纹理预乘，采用预乘-Alpha-的混合公式也有好处"><a href="#Tip7-即使不纹理预乘，采用预乘-Alpha-的混合公式也有好处" class="headerlink" title="Tip7: 即使不纹理预乘，采用预乘 Alpha 的混合公式也有好处"></a>Tip7: 即使不纹理预乘，采用预乘 Alpha 的混合公式也有好处</h2><p><strong>采用 One, OneMinusSrcAlpha 混合有个很好的特性，可以统一 Blend 和 Additive，减少 BlendState 切换，还能增加效果。</strong></p>
<p>推荐阅读 <a target="_blank" rel="noopener" href="https://amindforeverprogramming.blogspot.com/2013/07/why-alpha-premultiplied-colour-blending.html">https://amindforeverprogramming.blogspot.com/2013/07/why-alpha-premultiplied-colour-blending.html</a> ，这里简单介绍下思路：</p>
<ul>
<li>把非预乘纹理的采样到的 RGBA，我们在 shader 中输出 (RGB*A, A) 就是 Blend 模式。</li>
<li>把非预乘纹理的采样到的 RGBA，我们在 shader 中输出 (RGB*A, 0) 就是 Additive 模式。</li>
</ul>
<p>输出的 Alpha 可以定义一个 uniform t 控制，输出 (RGB<em>A, A</em>t)，这样通过 t 就是控制 Blend 和 Additive 模式之间的过渡。</p>
<p>如果再定义一个 uniform s，输出 (RGB<em>A</em>s, A<em>t</em>s)，我们还可以通过 s 控制其整体透明度，用于淡入淡出！简直就是特效的救星。</p>
<p>众所周知，采用 Additive 模式的特效，在亮的场景中几乎看不到效果，而 Blend 模式的特效在暗的场景中提不亮。采用 One OneMinusSrcAlpha 就可以使用中间态来做出适配比较好的特效，而且不需要 framebuffer fetch。</p>
<h2 id="Tip8-Premultiplied-Alpha-运算是封闭的"><a href="#Tip8-Premultiplied-Alpha-运算是封闭的" class="headerlink" title="Tip8: Premultiplied Alpha 运算是封闭的"></a>Tip8: Premultiplied Alpha 运算是封闭的</h2><p>换人话来讲，就是<strong>预乘 alpha 混合得到的颜色也是预乘 alpha 的</strong>。</p>
<p>细心的同学会注意到，在 tip1 中</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>作为运算结果的 $RGB’_{result}$ 是有 prime 符号的，正是想提示这一点。</p>
<p>最终输出的有效颜色来自两部分，</p>
<ul>
<li>叠加上去的 src 像素贡献的有效颜色</li>
<li>背景 dst 像素贡献的有效颜色，它被 src 遮挡掉一部分，遮挡的量是 $(1-A_{arc})$</li>
</ul>
<p>我们观察 tip1 中给出的两式</p>
<p>$$RGB’<em>{result} &#x3D; A</em>{src} *RGB_{src}+ (A_{dst}*RGB_{dst} ) *(1-A_{src}) \tag{1}$$</p>
<p>$$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src}) \tag{2}$$</p>
<p>(1)(2) 的计算过程是一样的，这就不禁会产生疑问：(1) 式混合两个未预乘 alpha 的 RGB，结果是预乘 alpha 的 RGB？</p>
<p>这没错，<strong>未预乘 alpha 的颜色经混合得到的是预乘 alpha 的颜色。</strong></p>
<p><strong>那平时用 SrcAlpha, OneMinusSrcAlpha 为什么能得到未预乘的结果呢？</strong></p>
<p><strong>原因正是 tip2。</strong></p>
<p>由于 SrcAlpha, OneMinusSrcAlpha 混合隐含了一个假设，渲染目标是不透明的。在这个前提下，用正确的混合公式计算，我们可以得到：</p>
<ul>
<li>预乘了 alpha 的 $RGB’_{result}$</li>
<li>$A_{result} &#x3D;1.0$</li>
</ul>
<p>我们在 tip2 中已经讲过，与不透明目标混合得到的 alpha 恒为 1。</p>
<p>显而易见，当 alpha 为 1 时， $RGB’_{result}$ 等于 $RGB_{result}$ 。</p>
<p>因此 (1) 式在当渲染目标是不透明时，改成下式是成立的</p>
<p>$RGB_{result} &#x3D; A_{src} *RGB_{src}+ (A_{dst}*RGB_{dst} ) *(1-A_{src})$</p>
<p>小结一下</p>
<ul>
<li>预乘 alpha 的颜色经透明混合得到的颜色也是预乘 alpha 的</li>
<li>未预乘 alpha 的颜色经透明混合得到的是预乘 alpha 的颜色</li>
<li>SrcAlpha, OneMinusSrcAlpha 假设了渲染目标不透明，因此结果你可以说是预乘的，也可以说是没预乘的，因为两个值此时是一样的</li>
<li>如果渲染目标是半透明的，未预乘混合后需要 ”unmultiply” 才能恢复未预乘的颜色，详见 tip10</li>
</ul>
<h2 id="Tip9-理解预乘-Alpha-混合公式的-Alpha-部分"><a href="#Tip9-理解预乘-Alpha-混合公式的-Alpha-部分" class="headerlink" title="Tip9: 理解预乘 Alpha 混合公式的 Alpha 部分"></a>Tip9: 理解预乘 Alpha 混合公式的 Alpha 部分</h2><p><strong>预乘 Alpha 混合时，颜色分量和 Alpha 分量的运算是一致的。</strong>对比一下</p>
<p>$RGB’<em>{result} &#x3D; RGB’</em>{src}+ RGB’<em>{dst} * (1-A</em>{src})$</p>
<p>$A_{result} &#x3D; A_{src} + A_{dst} * (1-A_{src})$</p>
<p>都是 $Result &#x3D; Src + Dst * (1-A_{src})$ 。</p>
<p>因此，不需要额外指定 alpha 分量的混合公式，就能得到有意义的 alpha 值，而且<strong>无论渲染目标是透明还是不透明，结果都是正确的。</strong>（Tip4）</p>
<p>Tip2 和 tip3 中讲到过 SrcAlpha, OneMinusSrcAlpha 混合正确是有条件的，必须满足渲染目标是不透明的，而且得到的 alpha 也是无意义的。相比之下用 premultiplied alpha 做混合优势就太明显了。</p>
<p><strong>如果提前知道会往不透明渲染目标混合，那预乘 alpha 混合也可以借鉴 tip3 中的做法把 RT 的 alpha 通道利用起来。</strong></p>
<h2 id="Tip10-仅当必要时-Unmultiply"><a href="#Tip10-仅当必要时-Unmultiply" class="headerlink" title="Tip10: 仅当必要时 Unmultiply"></a>Tip10: 仅当必要时 Unmultiply</h2><p>凡是讲 premultiplied alpha 都会告诉你，可以通过</p>
<p>$RGB &#x3D; \frac{RGB’}{A}$ 还原未预乘的颜色值，常见的、未预乘的颜色值也叫 straight alpha 或 unassociated alpha，而预乘好的叫 premultiplied alpha 或 associated alpha。这种还原操作在渲染自己可控的环境下几乎用不到。</p>
<p>根据 tip8，预乘 alpha 混合时运算封闭，可以多次混合不需要还原 straight alpha。</p>
<p>但如果用未预乘 alpha 混合时，如果渲染目标是半透明的，每次混合完成都要 unmultiply 回 straight alpha 才能继续混合，而且当一个网格有多层透明叠加时结果是错误的。</p>
<p><strong>从实践上讲，预乘 alpha 混合的结果需要 unmultiply 主要就这种情况：三方组件只接受 straight alpha 表示的纹理。</strong></p>
<p>Framebuffer 显示到屏幕上输出时 RT 最终总是不透明的，不透明的 alpha 为 1，预乘和未预乘没有区别，也不用特殊处理。</p>
<h2 id="Tip11：Bleed-Alpha-与预乘-Alpha-原理不同，目的相同，结果略有不同"><a href="#Tip11：Bleed-Alpha-与预乘-Alpha-原理不同，目的相同，结果略有不同" class="headerlink" title="Tip11：Bleed Alpha 与预乘 Alpha 原理不同，目的相同，结果略有不同"></a>Tip11：Bleed Alpha 与预乘 Alpha 原理不同，目的相同，结果略有不同</h2><p>Alpha bleeding 的原理以前已经写过了</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/340754532">undefined</a></p>
<p>预乘 alpha 和 bleed alpha 目的都是减少半透明纹理过滤产生的瑕疵，但它们有一些比较显著的区别：</p>
<ul>
<li>Bleed alpha 不需要修改混合公式</li>
<li>Bleed alpha 只能优化完全透明和非完全透明像素边缘的过滤瑕疵</li>
<li>预乘 alpha 不仅可以达到 bleed alpha 的结果，半透像素之间的过滤效果也能得到优化</li>
<li>预乘 alpha 需要修改混合公式，可能产生 tip6 中提到的情况</li>
</ul>
<p><strong>当不使用 premultiplied alpha 时，预处理贴图 bleed alpha 是一个 “免费” 替代品。</strong>虽然效果上会有折扣，但性价比极高。</p>
<h2 id="Tip12-纹理预乘-Alpha-可以减少纹理过滤带来的-artifacts"><a href="#Tip12-纹理预乘-Alpha-可以减少纹理过滤带来的-artifacts" class="headerlink" title="Tip12: 纹理预乘 Alpha 可以减少纹理过滤带来的 artifacts"></a>Tip12: 纹理预乘 Alpha 可以减少纹理过滤带来的 artifacts</h2><p>介绍 premultiplied alpha 的文章大多都会从纹理过滤的角度讲，个人认为没有充分理解 alpha 混合的情况下，如果还结合着 SrcAlpha, OneMinusSrcAlpha 混合的简单认知去看 premultiplied alpha 很容易一头雾水。</p>
<p>本文已经够长了，应该没也几个人会耐心看完，</p>
<p>本文不再探讨纹理过滤的内容了，这里推荐两篇不错的文章</p>
<p><a target="_blank" rel="noopener" href="https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre">Alpha Blending: To Pre or Not To Pre</a><a target="_blank" rel="noopener" href="http://www.adriancourreges.com/blog/2017/05/09/beware-of-transparent-pixels/">Beware of Transparent Pixels - Adrian Courrèges</a></p>
<p>Nvidia 的这篇从 mipmap 的角度而 Adrian 的文章从双线性过滤的角度介绍了 premultiplied alpha 是如何减少半透纹理过滤带来的 artifacts。</p>
<p>小结一下，<strong>纹理预乘 alpha 可以减少 downsampling、upsampling、非 pixel perfect 各种情况下半透纹理过滤产生的 artifacts。</strong></p>
<p>喜欢我的文章请点赞、收藏加关注，转发给有需要的朋友。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/24516.html">http://liuke101.github.io/post/24516.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332483.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/62230.html" title="【图形系统10】色彩"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292341510.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【图形系统10】色彩</div></div></a></div><div class="next-post pull-right"><a href="/post/28735.html" title="【图形系统09】阴影"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292335674.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【图形系统09】阴影</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/49886.html" title="光线追踪理论"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292358872.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">光线追踪理论</div></div></a></div><div><a href="/post/64863.html" title="全局光照GI"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300005318.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-28</div><div class="title">全局光照GI</div></div></a></div><div><a href="/post/19081.html" title="PBR理论"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292357277.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="title">PBR理论</div></div></a></div><div><a href="/post/55802.html" title="环境光照IBL"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300003151.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-16</div><div class="title">环境光照IBL</div></div></a></div><div><a href="/post/38389.html" title="路径追踪"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404300000048.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">路径追踪</div></div></a></div><div><a href="/post/6103.html" title="辐射度量学"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292355395.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-16</div><div class="title">辐射度量学</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Unity-%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-text">1 Unity 渲染顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Camera-Depth"><span class="toc-text">Camera Depth</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting-Layer"><span class="toc-text">Sorting Layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Order-in-Layer"><span class="toc-text">Order in Layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Render-Queue"><span class="toc-text">Render Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Camera-render-algorithm"><span class="toc-text">Camera render algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">不透明物体排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">透明物体排序算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UGUI%E2%80%99s-rendering-order"><span class="toc-text">UGUI’s rendering order</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas"><span class="toc-text">Canvas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CanvasRenderer"><span class="toc-text">CanvasRenderer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Unity-%E6%B8%B2%E6%9F%93%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2  Unity 渲染半透明物体的解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88"><span class="toc-text">2 透明度测试和透明度混合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95-Alpha-Test%EF%BC%88Alpha-Cutout%EF%BC%89"><span class="toc-text">透明度测试 Alpha Test（Alpha Cutout）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88-Alpha-Blend"><span class="toc-text">透明度混合 Alpha Blend</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="toc-text">1. 一般方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-text">2. 开启深度写入的半透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Built-in-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Built-in 实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#URP-%E5%AE%9E%E7%8E%B0"><span class="toc-text">URP 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-text">双面渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-text">1. 透明度测试的双面渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-text">2. 透明度混合的双面渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Built-in-%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">Built-in 实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#URP-%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">URP 实现</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Additive"><span class="toc-text">Additive</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Alpha-%E9%A2%84%E4%B9%98"><span class="toc-text">3 Alpha 预乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip1-%E7%90%86%E8%A7%A3-Alpha-%E6%B7%B7%E5%90%88"><span class="toc-text">Tip1: 理解 Alpha 混合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip2-SrcAlpha-OneMinusSrcAlpha-%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E6%AD%A3%E7%A1%AE%E6%98%AF%E6%9C%89%E5%89%8D%E6%8F%90%E7%9A%84"><span class="toc-text">Tip2: SrcAlpha, OneMinusSrcAlpha 颜色混合正确是有前提的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip3-SrcAlpha-OneMinusSrcAlpha-%E6%B7%B7%E5%90%88%E5%87%BA%E6%9D%A5%E7%9A%84-Alpha-%E5%80%BC%E6%98%AF%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84"><span class="toc-text">Tip3: SrcAlpha, OneMinusSrcAlpha 混合出来的 Alpha 值是无意义的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip4-%E5%A6%82%E4%BD%95%E6%AD%A3%E6%B8%B2%E6%9F%93%E5%8D%8A%E9%80%8F-RenderTexture"><span class="toc-text">Tip4: 如何正渲染半透 RenderTexture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip5-%E7%90%86%E8%A7%A3%E9%A2%84%E4%B9%98-Alpha-%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%9A%84%E9%A2%9C%E8%89%B2%E9%83%A8%E5%88%86"><span class="toc-text">Tip5: 理解预乘 Alpha 混合公式的颜色部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip6-%E7%BA%B9%E7%90%86%E9%A2%84%E4%B9%98-Alpha-%E5%AE%9E%E8%B7%B5%E4%B8%8A%E5%8F%AF%E8%83%BD%E6%9C%89%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">Tip6: 纹理预乘 Alpha 实践上可能有潜在问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip7-%E5%8D%B3%E4%BD%BF%E4%B8%8D%E7%BA%B9%E7%90%86%E9%A2%84%E4%B9%98%EF%BC%8C%E9%87%87%E7%94%A8%E9%A2%84%E4%B9%98-Alpha-%E7%9A%84%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E4%B9%9F%E6%9C%89%E5%A5%BD%E5%A4%84"><span class="toc-text">Tip7: 即使不纹理预乘，采用预乘 Alpha 的混合公式也有好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip8-Premultiplied-Alpha-%E8%BF%90%E7%AE%97%E6%98%AF%E5%B0%81%E9%97%AD%E7%9A%84"><span class="toc-text">Tip8: Premultiplied Alpha 运算是封闭的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip9-%E7%90%86%E8%A7%A3%E9%A2%84%E4%B9%98-Alpha-%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%9A%84-Alpha-%E9%83%A8%E5%88%86"><span class="toc-text">Tip9: 理解预乘 Alpha 混合公式的 Alpha 部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip10-%E4%BB%85%E5%BD%93%E5%BF%85%E8%A6%81%E6%97%B6-Unmultiply"><span class="toc-text">Tip10: 仅当必要时 Unmultiply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip11%EF%BC%9ABleed-Alpha-%E4%B8%8E%E9%A2%84%E4%B9%98-Alpha-%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C%EF%BC%8C%E7%9B%AE%E7%9A%84%E7%9B%B8%E5%90%8C%EF%BC%8C%E7%BB%93%E6%9E%9C%E7%95%A5%E6%9C%89%E4%B8%8D%E5%90%8C"><span class="toc-text">Tip11：Bleed Alpha 与预乘 Alpha 原理不同，目的相同，结果略有不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tip12-%E7%BA%B9%E7%90%86%E9%A2%84%E4%B9%98-Alpha-%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%91%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4%E5%B8%A6%E6%9D%A5%E7%9A%84-artifacts"><span class="toc-text">Tip12: 纹理预乘 Alpha 可以减少纹理过滤带来的 artifacts</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28208.html" title="UE伤害系统">UE伤害系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28207.html" title="UE输入系统">UE输入系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292332483.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>