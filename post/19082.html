<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UEC++类型 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、属性 UPROPERTY属性声明属性使用标准的 C++变量语法声明，前面用 UPROPERTY 宏来定义属性元数据和变量说明符。UPROPERT 宏作为声明序言的变量可被引擎执行垃圾回收，也可在虚幻编辑器中显示和编辑。 12UPROPERTY([specifier, specifier, ...], [meta(key&#x3D;value, key&#x3D;value, ...)])Type Variable">
<meta property="og:type" content="article">
<meta property="og:title" content="UEC++类型">
<meta property="og:url" content="http://liuke101.github.io/post/19082.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="一、属性 UPROPERTY属性声明属性使用标准的 C++变量语法声明，前面用 UPROPERTY 宏来定义属性元数据和变量说明符。UPROPERT 宏作为声明序言的变量可被引擎执行垃圾回收，也可在虚幻编辑器中显示和编辑。 12UPROPERTY([specifier, specifier, ...], [meta(key&#x3D;value, key&#x3D;value, ...)])Type Variable">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-24T16:20:36.246Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="UEC++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/19082.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UEC++类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-25 00:20:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UEC++类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-09T16:00:00.000Z" title="发表于 2023-09-10 00:00:00">2023-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-24T16:20:36.246Z" title="更新于 2024-08-25 00:20:36">2024-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/">虚幻引擎</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UEC++类型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/19082.html#post-comment"><span class="waline-comment-count" data-path="/post/19082.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、属性-UPROPERTY"><a href="#一、属性-UPROPERTY" class="headerlink" title="一、属性 UPROPERTY"></a>一、属性 UPROPERTY</h1><h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><p>属性使用标准的 C++变量语法声明，前面用 <code>UPROPERTY</code> 宏来定义属性元数据和变量说明符。<br><code>UPROPERT</code> 宏作为声明序言的变量可被引擎执行垃圾回收，也可在虚幻编辑器中显示和编辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>([specifier, specifier, ...], [<span class="built_in">meta</span>(key=value, key=value, ...)])</span><br><span class="line">Type VariableName;</span><br></pre></td></tr></table></figure>

<h2 id="属性说明符"><a href="#属性说明符" class="headerlink" title="属性说明符"></a>属性说明符</h2><p>声明属性时，<strong>属性说明符</strong> 可被添加到声明，以控制属性与引擎和编辑器诸多方面的相处方式。</p>
<p>&#96;&#96;</p>
<blockquote>
<p>实例：实例化到场景中的<br>原型：未实例化，比如直接点开蓝图</p>
</blockquote>
<p>注意：<code>EditAnyWhere</code> 可以分别在实例和原型修改值。如果实例没有修改，则值始终等于原型中的值。如果实例修改了，则覆盖原型中的值。</p>
<table>
<thead>
<tr>
<th>属性标签</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>AdvancedDisplay</code></td>
<td>属性将被放置在其出现的任意面板的<strong>高级（下拉） 部分</strong>中。</td>
</tr>
<tr>
<td><code>AssetRegistrySearchable</code></td>
<td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintAssignable</code></strong></td>
<td>⭐只能与<strong>多播委托</strong>共用。公开属性在蓝图中指定。</td>
</tr>
<tr>
<td><code>BlueprintAuthorityOnly</code></td>
<td>此属性必须为一个多播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintCallable</code></strong></td>
<td>⭐ 仅用于<strong>多播委托</strong>。应公开属性在蓝图代码中调用。</td>
</tr>
<tr>
<td><code>BlueprintGetter=GetterFunctionName</code></td>
<td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintReadOnly</code></strong></td>
<td>⭐此属性可由蓝图读取，但不能被修改。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintReadWrite</code></strong></td>
<td>⭐可从蓝图读取或写入此属性。</td>
</tr>
<tr>
<td><code>BlueprintSetter=SetterFunctionName</code></td>
<td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td>
</tr>
<tr>
<td>⭐ <strong><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></strong></td>
<td>⭐指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td>
</tr>
<tr>
<td><code>Config</code></td>
<td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td>
</tr>
<tr>
<td><code>DuplicateTransient</code></td>
<td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td>
</tr>
<tr>
<td>⭐ <strong><code>EditAnywhere</code></strong></td>
<td>⭐说明此属性可通过属性窗口在原型和实例上进行编辑。</td>
</tr>
<tr>
<td>⭐ <strong><code>EditDefaultsOnly</code></strong></td>
<td>⭐说明此属性可通过属性窗口进行编辑，但只能在原型上进行。</td>
</tr>
<tr>
<td><code>EditFixedSize</code></td>
<td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td>
</tr>
<tr>
<td><code>EditInline</code></td>
<td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td>
</tr>
<tr>
<td>⭐ <strong><code>EditInstanceOnly</code></strong></td>
<td>⭐说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。</td>
</tr>
<tr>
<td><code>Export</code></td>
<td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td>
</tr>
<tr>
<td><code>GlobalConfig</code></td>
<td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td>
</tr>
<tr>
<td><code>Instanced</code></td>
<td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td>
</tr>
<tr>
<td><code>Interp</code></td>
<td>说明值可随时间由Sequencer中的一个轨道驱动。</td>
</tr>
<tr>
<td><code>Localized</code></td>
<td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td>
</tr>
<tr>
<td><code>Native</code></td>
<td>属性为本地：C++代码负责对其进行序列化并公开到<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/unreal-object-handling-in-unreal-engine">垃圾回收</a>。</td>
</tr>
<tr>
<td><code>NoClear</code></td>
<td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td>
</tr>
<tr>
<td><code>NoExport</code></td>
<td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td>
</tr>
<tr>
<td><code>NonPIEDuplicateTransient</code></td>
<td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td>
</tr>
<tr>
<td><code>NonTransactional</code></td>
<td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td>
</tr>
<tr>
<td><code>NotReplicated</code></td>
<td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td>
</tr>
<tr>
<td>⭐ <strong><code>Replicated</code></strong></td>
<td>属性应随网络进行复制。</td>
</tr>
<tr>
<td>⭐ <strong><code>ReplicatedUsing=FunctionName</code></strong></td>
<td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td>
</tr>
<tr>
<td><code>RepRetry</code></td>
<td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td>
</tr>
<tr>
<td><code>SaveGame</code></td>
<td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td>
</tr>
<tr>
<td><code>SerializeText</code></td>
<td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td>
</tr>
<tr>
<td><code>SkipSerialization</code></td>
<td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td>
</tr>
<tr>
<td><code>SimpleDisplay</code></td>
<td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开”高级”部分即可见。</td>
</tr>
<tr>
<td><code>TextExportTransient</code></td>
<td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td>
</tr>
<tr>
<td><code>Transient</code></td>
<td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td>
</tr>
<tr>
<td>⭐ <strong><code>VisibleAnywhere</code></strong></td>
<td>⭐ 说明此属性在所有属性窗口中<strong>可见</strong>，但<strong>无法被编辑</strong>。此说明符与”Edit”说明符不兼容。</td>
</tr>
<tr>
<td>⭐ <strong><code>VisibleDefaultsOnly</code></strong></td>
<td>⭐ 说明此属性只在原型的属性窗口中可见，<strong>无法被编辑</strong>。此说明符与所有”Edit”说明符均不兼容。</td>
</tr>
<tr>
<td>⭐ <strong><code>VisibleInstanceOnly</code></strong></td>
<td>⭐ 说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），<strong>无法被编辑</strong>。此说明符与所有”Edit”说明符均不兼容。</td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>![[Pasted image 20230902142824.png|181]]</p>
<blockquote>
<p>上面为原生 C++类型，下面为对应的 UE 类型</p>
</blockquote>
<p>为什么 UE 自己定义类型？</p>
<ol>
<li>跨平台</li>
<li>兼容反射</li>
<li>方便宏替换，C++原生类型有空格不方便<br>![[Pasted image 20230901195356.png]]</li>
</ol>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>整数数据类型转换是”int”或”uint”后跟位大小。</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>uint8</strong></td>
<td>8位无符号</td>
</tr>
<tr>
<td><strong>uint16</strong></td>
<td>16位无符号</td>
</tr>
<tr>
<td><strong>uint32</strong></td>
<td>32位无符号</td>
</tr>
<tr>
<td><strong>uint64</strong></td>
<td>64位无符号</td>
</tr>
<tr>
<td><strong>int8</strong></td>
<td>8位有符号</td>
</tr>
<tr>
<td><strong>int16</strong></td>
<td>16位有符号</td>
</tr>
<tr>
<td><strong>int32</strong></td>
<td>32位有符号</td>
</tr>
<tr>
<td><strong>int64</strong></td>
<td>64位有符号</td>
</tr>
</tbody></table>
<h4 id="作为位掩码"><a href="#作为位掩码" class="headerlink" title="作为位掩码"></a>作为位掩码</h4><h5 id="整数属性位掩码"><a href="#整数属性位掩码" class="headerlink" title="整数属性位掩码"></a>整数属性位掩码</h5><p>整数属性现在可<strong>以位掩码形式公开给编辑器</strong>。要将整数属性标记为位掩码，只需在 meta 分段中添加 <code>Bitmask</code> 即可，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ BasicBits appears as a list of generic flags in the editor, instead of an integer field. */</span></span><br><span class="line"><span class="comment">//BasicBits在编辑器中显示为一个通用flag标志列表，而不是一个整数字段</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Meta = (Bitmask))</span><br><span class="line">int32 BasicBits;</span><br></pre></td></tr></table></figure>

<p>添加此元标记将使整数作为下拉列表形式可供编辑，它们使用笼统命名标记（”Flag 1”、”Flag 2”、”Flag 3”等等），可以 单独打开或关闭。</p>
<p>![[cd2166f5df34fcddfa25e7e5196ce3a7_MD5.jpg]]</p>
<h5 id="蓝图整数位掩码"><a href="#蓝图整数位掩码" class="headerlink" title="蓝图整数位掩码"></a>蓝图整数位掩码</h5><p><strong>也可以让蓝图可调用函数的整型参数表现为位掩码</strong>，方法是在参数的 <code>UPARAM</code> 指定器上添加 <code>Bitmask</code> 元标签（不需要值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ You can set MyFunction using a generic list of flags instead of typing in an integer value. */</span></span><br><span class="line"><span class="comment">//你可以使用一个通用的flag标志列表来设置MyFunction，而不是输入一个整数值。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">(UPARAM(meta=(Bitmask)) int32 BasicBitsParam)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="自定义位标记名称"><a href="#自定义位标记名称" class="headerlink" title="自定义位标记名称"></a>自定义位标记名称</h5><p><strong>自定义位标记名称</strong>，首先必须使用<code>Bitflags</code>元标记来创建 <code>UENUM</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(Meta = (Bitflags))</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EColorBits</span></span><br><span class="line">&#123;</span><br><span class="line">    ECB_Red,</span><br><span class="line">    ECB_Green,</span><br><span class="line">    ECB_Blue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比特掩码枚举类型的范围是0到31，包括0和31。其对应于32位整型变量的位数（从第0位开始）。在上面的例子中，第0位是 <code>ECB_Red</code>，第1位是 <code>ECB_Green</code>，第2位是 <code>ECB_Blue</code>。</p>
<p>作为<strong>另一种声明方式，你可以使用 <code>ENUM_CLASS_FLAGS</code> 在定义完枚举类型后，将其变成一个位掩码。</strong> 为了在编辑器中使用标志选择器（flag selector），我们还必须添加元字段 <code>UseEnumValuesAsMaskValuesInEditor</code> 并将其设置为 <code>true</code>。关键的区别在于，这个方法直接使用掩码值，而不是比特数。使用此方法制作的等效枚举类型看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EColorBits</span></span><br><span class="line">&#123;</span><br><span class="line">    ECB_Red = <span class="number">0x01</span>,</span><br><span class="line">    ECB_Green = <span class="number">0x02</span>,</span><br><span class="line">    ECB_Blue = <span class="number">0x04</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ENUM_CLASS_FLAGS</span>(EColorBits);</span><br></pre></td></tr></table></figure>

<p><strong>创建该UENUM后，可以使用<code>BitmaskEnum</code>元标记来引用它</strong>，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ This property lists flags matching the names of values from EColorBits. */</span></span><br><span class="line"><span class="comment">//这个属性列出了与EColorBits中值的名称相匹配的标志</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Meta = (Bitmask, BitmaskEnum = <span class="string">&quot;EColorBits&quot;</span>))</span><br><span class="line">int32 ColorFlags;</span><br></pre></td></tr></table></figure>

<p>完成这个更改后，下拉框中列出的位标记将使用列举类条目的名称和值。在上述示例中， ECB_Red 值为0，表示它被选中时将激活位0（将ColorFlags增加1）。ECB_Green对应于位1（将ColorFlags增加2），ECB_Blue 对应于位2（将ColorFlags增加4）。</p>
<p>![[47dbb9ed69b8e8601e913aa90c304f74_MD5.jpg]]</p>
<p><strong>同样，你可以在 <code>UPARAM</code> 标签的meta部分添加 <code>BitmaskEnum</code> 和对应的枚举类型名称来定制它。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ MyOtherFunction shows flags named after the values from EColorBits. */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyOtherFunction</span><span class="params">(UPARAM(meta=(Bitmask, BitmaskEnum = <span class="string">&quot;EColorBits&quot;</span>)) int32 ColorFlagsParam)</span></span></span><br></pre></td></tr></table></figure>

<p>虽然列举类型包含超过32个条目，但在属性编辑器UI中，位掩码关联中只会看到前32个值。同样，虽然可接受显式值条目，但显式值介于0-31的条目不会包含在下拉列表中。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>虚幻使用标准 C++浮点类型、浮点和双精度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>  <span class="comment">//32bit</span></span><br><span class="line"><span class="type">double</span> <span class="comment">//64bit</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>布尔类型可以使用 C++ bool 关键字表示或表示为位域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 bIsHungry : <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> bIsThirsty;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举主要有两种，典型的 <code>enum</code> 和 C++11 引入的 <code>enum class</code>。</p>
<ul>
<li><code>enum class</code> 限定了作用域</li>
<li><code>enum</code> 类型不太安全，可以使用 <code>TEnumAsByte</code> 来处理 enum 类型。（enum class 则不需要处理）</li>
</ul>
<p><code>TEnumAsByte</code> 类型的主要作用是在 C++ 代码中声明和操作枚举类型的变量。它提供了一种类型安全的方式来处理枚举值，并确保正确的枚举值转换。</p>
<p>使用 TEnumAsByte 类型时，您需要指定要包装的枚举类型作为模板参数。例如，如果您有一个名为 EMyEnum 的枚举类型，您可以声明一个 TEnumAsByte 类型的变量来存储该枚举的值。</p>
<p>以下是 TEnumAsByte 类型的一些常见用法：</p>
<ol>
<li>声明变量：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEnumAsByte&lt;EMyEnum&gt; MyEnumValue;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化变量：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyEnumValue = EMyEnum::Value1;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取变量的枚举值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMyEnum EnumValue = MyEnumValue.<span class="built_in">Get</span>();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置变量的枚举值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyEnumValue.<span class="built_in">Set</span>(EMyEnum::Value2);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>比较变量的枚举值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MyEnumValue == EMyEnum::Value3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过使用 TEnumAsByte 类型，您可以确保在处理枚举类型时遵循类型安全性，并减少由于不正确的枚举值转换而引起的错误。</p>
<h1 id="二、类-UCLASS"><a href="#二、类-UCLASS" class="headerlink" title="二、类 UCLASS"></a>二、类 UCLASS</h1><p>虚幻引擎包含一个用于处理游戏对象的强大系统。虚幻引擎中**所有对象的基类都是 <code>UObject</code>**。</p>
<p>声明包含一个类的标准 C++ 类声明。在标准声明之上，描述符（如类说明符和元数据）将被传递到 <code>UCLASS</code> 宏。<br><strong><code>UCLASS</code> 宏的作用</strong>是标记 <code>UObject</code> 的子类，以便 <strong>UObject</strong> 处理系统可以识别它们。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>([specifier, specifier, ...], [<span class="built_in">meta</span>(key=value, key=value, ...)])</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> : <span class="keyword">public</span> ParentName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-UCLASS-宏"><a href="#1-UCLASS-宏" class="headerlink" title="1 UCLASS 宏"></a>1 UCLASS 宏</h2><p><strong>UCLASS</strong> 宏为 <code>UObject</code> 提供了一个 <code>UCLASS</code> 引用，用于描述它在虚幻引擎中的类型。每个 <code>UCLASS</code> 都保留一个称作 <strong>类默认对象（Class Default Object）</strong> 的对象，简称 <code>CDO</code>。<code>CDO</code> 是 UE 反射系统中包含对象的原版副本，引擎启动时创建。<br>引擎初始化时，他会为每个类创建类默认对象，然后执行每个类的构造函数，设置他们的默认值。由 C++类创建的蓝图从 CDO 中获得始化的默认值</p>
<p>你可以为指定对象获取其 <code>UCLASS</code> 和 <code>CDO</code>，虽然它们通常都是只读类型。</p>
<blockquote>
<p>使用 <strong><code>GetClass()</code></strong> 函数即可访问对象实例的 UCLASS。</p>
</blockquote>
<blockquote>
<p>[!NOTE]<br><code>UObject</code> 类还可包括仅限本地的属性，这些属性没有用 <code>UFUNCTION</code> 或者 <code>UPROPERTY</code> 指定器标记用于反射。<strong>只有用指定器宏标记过的函数和属性会列举在它们对应的 <code>UCLASS</code> 中。</strong></p>
</blockquote>
<h2 id="2-类说明符"><a href="#2-类说明符" class="headerlink" title="2 类说明符"></a>2 类说明符</h2><p>声明类时，可以为声明添加 <strong>类说明符</strong>，以控制类相对于引擎和编辑器的各个方面的行为。</p>
<table>
<thead>
<tr>
<th>类说明符</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>Abstract</code></td>
<td><strong>Abstract</strong> 说明符会将类声明为”<strong>抽象基类</strong>“，<strong>阻止用户向关卡中添加此类的 Actor</strong>。对于单独存在时没有意义的类，此说明符非常有用。例如，<code>ATriggerBase</code> 基类是抽象类，而 <code>ATriggerBox</code> 子类不是抽象类，可以放置在关卡中。</td>
</tr>
<tr>
<td><code>AdvancedClassDisplay</code></td>
<td><strong>AdvancedClassDisplay</strong> 说明符强制类的所有属性仅在显示这些属性的 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/level-editor-details-panel-in-unreal-engine">“细节面板（Details Panel）”</a> 的”高级（Advanced）”部分中显示。要覆盖单个属性上的此说明符，在该属性上使用 <code>SimpleDisplay</code> 说明符。</td>
</tr>
<tr>
<td><code>AutoCollapseCategories=(Category1, Category2, ...)</code></td>
<td><code>AutoCollapseCategories</code> 说明符使父类上的 <strong>AutoExpandCategories</strong> 说明符的列出类别的效果无效。</td>
</tr>
<tr>
<td><code>AutoExpandCategories=(Category1, Category2, ...)</code></td>
<td>为此类的对象指定应自动在虚幻编辑器属性窗口中展开的一个或多个类别。要自动展开未使用类别声明的变量，请使用声明变量的类的名称。</td>
</tr>
<tr>
<td>⭐ <strong><code>Blueprintable</code></strong></td>
<td>⭐将此类公开为用于<strong>创建蓝图的可接受基类</strong>。默认为 <code>NotBlueprintable</code>，除非继承时就并非如此。此说明符由子类继承。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintType</code></strong></td>
<td>将此类公开为可用于蓝图中的变量的类型。</td>
</tr>
<tr>
<td><code>ClassGroup=GroupName</code></td>
<td>指示在虚幻编辑器的 Actor 浏览器中启用 <strong>组视图（Group View）</strong> 时，<strong>Actor 浏览器</strong> 应在指定的 <code>GroupName</code> 中包含此类及此类的所有子类。</td>
</tr>
<tr>
<td><code>CollapseCategories</code></td>
<td>指示此类的属性不应划分到虚幻编辑器属性窗口的类别中。此说明符会传播到子类，可由 <code>DontCollapseCategories</code> 说明符覆盖。</td>
</tr>
<tr>
<td><code>Config=ConfigName</code></td>
<td>指示此类可在配置文件（<code>.ini</code>）中存储数据。如果存在任何使用 <code>config</code> 或 <code>globalconfig</code> 说明符声明的类属性，此说明符将使这些属性存储在指定的配置文件中。此说明符会传播到所有子类并且无法使此说明符无效，但是子类可通过重新声明 <code>config</code> 说明符并提供不同的 <code>ConfigName</code> 来更改配置文件。常见的 <code>ConfigName</code> 值是”Engine”、”Editor”、”Input”和”Game”。</td>
</tr>
<tr>
<td><code>Const</code></td>
<td>此类中的所有属性和函数都是 <code>const</code> 并且导出为 <code>const</code>。此说明符由子类继承。</td>
</tr>
<tr>
<td><code>ConversionRoot</code></td>
<td>根转换，将子类限制为仅可沿层级向上转换为第一个根类的子类。</td>
</tr>
<tr>
<td><code>CustomConstructor</code></td>
<td>阻止构造函数声明自动生成。</td>
</tr>
<tr>
<td><code>DefaultToInstanced</code></td>
<td>此类的所有实例都被认为是”实例化的”。实例化的类（组件）将在构造时被复制。此说明符由子类继承。</td>
</tr>
<tr>
<td><code>DependsOn=(ClassName1, ClassName2, ...)</code></td>
<td>列出的所有类将先于此类被编译。提供的类名必须指示同一个或前一个包中的类。可以使用单个 <code>DependsOn</code> 行（以逗号分隔）来标识多个依赖类，或者可以通过为每个类使用单独的 <code>DependsOn</code> 行来指定多个依赖类。当某个类使用在另一个类中声明的结构体或枚举时，这非常重要，因为编译器仅知道它已编译了类中的哪些部分。</td>
</tr>
<tr>
<td><code>Deprecated</code></td>
<td>此类已弃用，序列化时将不保存此类的对象。此说明符由子类继承。</td>
</tr>
<tr>
<td><code>DontAutoCollapseCategories=(Category, Category, ...)</code></td>
<td>使列出的类别的继承自父类的 <code>AutoCollapseCategories</code> 说明符无效。</td>
</tr>
<tr>
<td><code>DontCollapseCategories</code></td>
<td>使继承自基类的 <code>CollapseCatogories</code> 说明符无效。</td>
</tr>
<tr>
<td><code>EditInlineNew</code></td>
<td>指示可以从虚幻编辑器”属性（Property）”窗口创建此类的对象，而非从现有资源引用。默认行为是仅可通过”属性（Property）”窗口指定对现有对象的引用。此说明符会传播到所有子类；子类可通过 <code>NotEditInlineNew</code> 说明符覆盖它。</td>
</tr>
<tr>
<td><code>HideCategories=(Category1, Category2, ...)</code></td>
<td>列出一个或多个应该对用户完全隐藏的分类。要隐藏未使用类别声明的属性，请使用声明变量的类的名称。此说明符会传播到子类。</td>
</tr>
<tr>
<td><code>HideDropdown</code></td>
<td>阻止此类在属性窗口组合框中显示。</td>
</tr>
<tr>
<td><code>HideFunctions=(Category1, Category2, ...)</code></td>
<td>让指定分类中的所有函数都对用户完全隐藏。</td>
</tr>
<tr>
<td><code>HideFunctions=FunctionName</code></td>
<td>将提到的函数对用户完全隐藏。</td>
</tr>
<tr>
<td><code>Intrinsic</code></td>
<td>指示此类直接在 C++中声明，无 <strong>Unreal Header Tool</strong> 生成的样板。请勿在新类上使用此说明符。</td>
</tr>
<tr>
<td><code>MinimalAPI</code></td>
<td>导致仅导出此类的类型信息，以供其他模块使用。可以以此类为目标进行强制转换，但此类的函数无法被调用（除了使用内联方法）。这可以缩短编译时间，因为没有针对无需从其他模块访问其所有函数的类导出一切。</td>
</tr>
<tr>
<td><code>NoExport</code></td>
<td>指示此类的声明不应包含在由标头生成器自动生成的 C++头文件中。必须在单独的头文件中手动定义该 C++类声明。仅对本地类有效。请勿对新类使用此说明符。</td>
</tr>
<tr>
<td><code>NonTransient</code></td>
<td>使继承自基类的 <code>Transient</code> 说明符无效。</td>
</tr>
<tr>
<td><code>NotBlueprintable</code></td>
<td>指定此类不是可用于创建蓝图的可接受基类。此为默认说明符，将由子类继承。</td>
</tr>
<tr>
<td><code>NotPlaceable</code></td>
<td>使继承自基类的 <code>Placeable</code> 说明符无效。指示不可以在编辑器中将此类的对象放置到关卡、UI 场景或蓝图中。</td>
</tr>
<tr>
<td><code>PerObjectConfig</code></td>
<td>此类的配置信息将按对象存储，在 <code>.ini`文件中，每个对象都有一个分段，根据对象命名，格式为</code> [ObjectName ClassName] &#96;。此说明符会传播到子类。</td>
</tr>
<tr>
<td><code>Placeable</code></td>
<td>指示可在编辑器中创建此类，而且可将此类放置到关卡、UI 场景或蓝图（取决于类类型）中。此标志会传播到所有子类；子类可使用 <code>NotPlaceable</code> 说明符覆盖此标志。</td>
</tr>
<tr>
<td><code>ShowCategories=(Category1, Category2, ...)</code></td>
<td>使列出的类别的继承自基类的 <code>HideCategories</code> 说明符无效。</td>
</tr>
<tr>
<td><code>ShowFunctions=(Category1, Category2, ...)</code></td>
<td>在属性查看器中显示列出的类别中的所有函数。</td>
</tr>
<tr>
<td><code>ShowFunctions=FunctionName</code></td>
<td>在属性查看器中显示指定的函数。</td>
</tr>
<tr>
<td><code>Transient</code></td>
<td>从不将属于此类的对象保存到磁盘。当与播放器或窗口等本质上不持久的特定种类的原生类配合使用时，它非常有用。此说明符会传播到子类，但是可由 <code>NonTransient</code> 说明符覆盖。</td>
</tr>
<tr>
<td><code>Within=OuterClassName</code></td>
<td>此类的对象无法在 <code>OuterClassName</code> 对象的实例之外存在。这意味着，要创建此类的对象，需要提供 <code>OuterClassName</code> 的一个实例作为其 <code>Outer</code> 对象。</td>
</tr>
</tbody></table>
<h2 id="3-TSubclassOf"><a href="#3-TSubclassOf" class="headerlink" title="3 TSubclassOf"></a>3 TSubclassOf</h2><p><strong><code>TSubclassOf</code></strong> 是提供 <code>UClass</code> 类型安全性的模板类。它<strong>在分配从特定类型派生出来的类时很有效</strong>。</p>
<ul>
<li>例如，你可以把这个变量公开给蓝图，设计者可以在蓝图中为玩家角色指定生成的武器类别。</li>
<li>例如您在创建一个投射物类，允许设计者指定伤害类型。您可只创建一个 <code>UClass</code> 类型的 <code>UPROPERTY</code>，让设计者指定派生自 <code>UDamageType</code> 的类（<strong>但选择列表里会出现所有 UClass 类，干扰选择</strong>）；<strong>建议使用 <code>TSubclassOf</code> 模板强制要求此类的选择</strong>。以下示例代码展示了不同之处：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** type of damage */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Damage)</span><br><span class="line">UClass* DamageType;</span><br></pre></td></tr></table></figure>

<p>Vs.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** type of damage */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Damage)</span><br><span class="line">TSubclassOf&lt;UDamageType&gt; DamageType;</span><br></pre></td></tr></table></figure>

<p>在第二个声明中，模板类告知编辑器的属性窗口只列出派生自 UDamageType 的类（作为属性选择）。在第一个声明中可选择任意 UClass。下图对此进行了说明。</p>
<p>![[0373df02883ba7ef2855694b2d997626_MD5.jpg]]</p>
<blockquote>
<p>策略游戏投射物蓝图的范例</p>
</blockquote>
<p>除 <code>UPROPERTY</code> 安全外，您还能获得 C++ 层级上的类型安全。<strong>如尝试进行不兼容 <code>TSubclassOf</code> 类型的相互指定，将出现编译错误。</strong><br>尝试指定泛型 <code>UClass</code> 时，它将执行一个运行时检查，以确定它可执行指定。如运行时检查失败，结果数值为 nullptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UClass* ClassA = UDamageType::<span class="built_in">StaticClass</span>();</span><br><span class="line"></span><br><span class="line">TSubclassOf&lt;UDamageType&gt; ClassB;</span><br><span class="line"></span><br><span class="line">ClassB = ClassA; <span class="comment">// Performs a runtime check</span></span><br><span class="line"></span><br><span class="line">TSubclassOf&lt;UDamageType_Lava&gt; ClassC;</span><br><span class="line"></span><br><span class="line">ClassB = ClassC; <span class="comment">// Performs a compile time check</span></span><br></pre></td></tr></table></figure>

<p>搞清楚：</p>
<h2 id="4-StaticClass-GetClass-ClassDefaultObject（CDO）"><a href="#4-StaticClass-GetClass-ClassDefaultObject（CDO）" class="headerlink" title="4 StaticClass&#x2F;GetClass&#x2F;ClassDefaultObject（CDO）"></a>4 StaticClass&#x2F;GetClass&#x2F;ClassDefaultObject（CDO）</h2><p>搞懂这三个的区别</p>
<h3 id="UClass-和反射"><a href="#UClass-和反射" class="headerlink" title="UClass 和反射"></a>UClass 和反射</h3><p>什么是反射？简单来说，<strong>反射的作用就是在不知道这个类是什么类的情况下获取到它的一些信息。</strong> C++ 是没有反射机制的所以 UE 底层实现了一套反射机制。C# 怎么用反射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;鸡桑大帅逼”；</span></span><br><span class="line"><span class="string">Type t = s.GetType()；</span></span><br></pre></td></tr></table></figure>

<p>Type 里面就包含了 string 这个类的各种信息。接下来请我和大声念三遍：</p>
<ul>
<li><strong>UClass 就是 C# 里的 Type!</strong><br>虽然 UClass 和 C# 里的 Type 的作用并不完全相同，但是这么理解会帮我们弄明白 UE 底层的很多事情。</li>
</ul>
<h3 id="GetClass"><a href="#GetClass" class="headerlink" title="GetClass ()"></a>GetClass ()</h3><p><strong><code>GetClass()</code></strong> 的作用就是我们生成一个 UObject 实例后，去拿这个实例的 UClass，类似 C# 的 **<code>GetType</code>**。</p>
<p>接下来我们做个小实验。新建一个自己的 Actor 就叫 MyActor 好了，写一个方法并且让它蓝图可调用：</p>
<p>![[d5d6733a8dda58a5199ef0087152203c_MD5.jpg]]</p>
<p>建两个蓝图，并拖到场景中，在关卡蓝图里调用 <strong>IsSameUClass</strong>：</p>
<p>![[8843ff51e75527c39334e8d163224d9e_MD5.jpg]]</p>
<p>![[3aec8a80e5a071ec461cf21d1cff9c47_MD5.jpg]]</p>
<p>显示的结果是 0，也就是两个 <strong>MyActor 的 GetClass () 结果不一样</strong>。<br>但是如果场景上的两个 Actor <strong>都是 BP_MyActor 同一个蓝图，它们的 GetClass () 结果是一样的。</strong></p>
<p>先解释第一个结果：<strong>为什么同样 C++ 类型不同蓝图返回的 GetClass () 结果不一样？</strong> 那是因为 UClass 不仅需要记录类型信息，还需要承担<strong>序列化</strong>的工作。同样 C++ 类型，但是蓝图不一样，需要序列化数据是不一样的，所以 UClass 不一样。<br>同样类型，同样蓝图，但是场景中实例不一样，但是这时需要序列化的蓝图数据是一样的（像场景中的位置信息不是记录在蓝图里的），所以它们的 UClass 是一样的，这是第二个结果的原因。</p>
<h3 id="GetStaticClass"><a href="#GetStaticClass" class="headerlink" title="GetStaticClass ()"></a>GetStaticClass ()</h3><p>GetClass 很好很强大。但是有个问题，<strong>它是 UObject 的成员函数</strong>。**我现在没有 UObject 实例，但是我想拿到某个类的 UClass 怎么办？<br>使用 <code>StaticClass()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UClass* myUClass = AMyActor::StaticClass();</span><br></pre></td></tr></table></figure>

<p>这样子我就<strong>不需要有 UObject 实例也能拿到某个类的 UClass 了</strong>。同时因为它是 Static 的所以<strong>每次调用 T:: StaticClass 返回的都是同一个结果。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto static1Class = AMyActor::StaticClass();</span><br><span class="line">auto static2Class = AMyActor::StaticClass();</span><br><span class="line">auto result = static1Class == static2Class;</span><br><span class="line">//结果是1</span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(&quot;Is StaticClass Same: %d&quot;), result);</span><br></pre></td></tr></table></figure>

<p>再讲 <strong><code>StaticClass</code> 的另一个功能</strong>，帮助大家更加理解 StaticClass。先来看 UObject、UClass、Actor 类图：</p>
<p>![[6f4a4c16ca3964e8d81a7f7984fba90b_MD5.jpg]]</p>
<p>现在又有个问题来了，我现在有一个 <strong>UClass，如何知道这个 UClass 和另一个 UClass 是不是继承关系？</strong> 直接转类型判断吗？不对，看上面那张图，UClass 是没有子类的。那怎么办？答案是 <strong><code>UClass</code> 存储了它要描述的类的父类的 <code>StaticClass</code>。</strong> </p>
<p>有点绕，我举例说明一下。我现在有个 MyActor 类的 UClass，想知道 MyActor 是不是 UObject 的子类，我就这么做：</p>
<ul>
<li>调用 <code>UObject::StaticClass()</code></li>
<li>拿到 MyActor 的 UClass 存储的 MyActor 的父类的 StaticClass 也就是 Actor 的 StaticClass</li>
<li>比较 Actor 的 StaticClass 和 UObject 的 StaticClass 是不是相等</li>
<li>发现不相等，这次我拿 Actor 的 StaticClass（因为它也是一个 UClass）里存的 Actor 父类的 StaticClass 也就是 UObject 的 StaticClass，然后比较，发现相等，返回 true</li>
<li>如果我发现不相等，我就一直比，比到最后没有父类，返回 false</li>
</ul>
<p>上面这段逻辑就是 <strong>UClass 的 IsChildOf 的实现原理</strong>。调用 IsChildOf 的时候传入泛型：</p>
<p>![[5cde1608b92f443c7ba603fef61f58c6_MD5.png]]</p>
<p>这是具体实现。<strong>UStruct</strong> 是 UClass 父类。</p>
<p>![[dfbfbc18d7faa479a8bfe0218ef448cf_MD5.jpg]]</p>
<p>GetSuperStruct () 就是返回它存储的父类的 StaticClass。</p>
<p>![[b22a0653c9c4c750ec4aa20b0aeb8e09_MD5.png]]</p>
<p>顺带再讲一下 <strong><code>IsA</code></strong> 这个函数，<strong>功能和 <code>IsChildOf</code> 一样，不同的是 <code>IsChildOf</code> 给 <code>UClass</code> 用的，<code>IsA</code> 是给 <code>UObject</code> 对象实例用的</strong>，比如想知道一个 MyActor 实例是不是 UObject 的子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//myActor是MyAcor*类型</span><br><span class="line">bool result = myActor-&gt;IsA&lt;UObject&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="ClassDefaultObject"><a href="#ClassDefaultObject" class="headerlink" title="ClassDefaultObject"></a>ClassDefaultObject</h3><p><strong>GetClass</strong> 和 <strong>GetStaticClass</strong> 都明白了之后，理解 <strong>ClassDefaultObject</strong> 就简单多了。</p>
<p><code>ClassDefaultObject</code>（简称 CDO），类默认对象。通过 CDO 我可以拿到<strong>一个 <code>UObject</code> 初始化时的值</strong>。虽然 CDO 有个 Default 默认，但是用默认去描述它的功能不是很准确。回到我们创建的类 MyActor，给它添加一个外部可以修改变量 <strong>testIntValue</strong>，默认值 1:</p>
<p>![[a7bc95bbdf6ebca930c9a2914cd1cd7a_MD5.jpg]]</p>
<p>对于两个蓝图分别修改，一个 20，另一个 10：</p>
<p>![[57874a26c52ee95fecabf36963ab8645_MD5.jpg]]</p>
<p>![[d18d08201c2014c335b39b11499ef9f0_MD5.jpg]]</p>
<p>然后在 BeginPlay 写下测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先修改值再获取ClassDefaultObject</span></span><br><span class="line">testIntValue = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">auto</span> defaultInt = <span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>&lt;AMyActor&gt;()-&gt;testIntValue;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;DefaultObject int: %d&quot;</span>), defaultInt);</span><br></pre></td></tr></table></figure>

<p>最后打印的结果是一个 20，一个 10。  </p>
<p><strong>如果想拿到代码里给它设的默认值 1 要用 StaticClass</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> staticDefaultInt = AMyActor::<span class="built_in">StaticClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>&lt;AMyActor&gt;()-&gt;testIntValue;</span><br><span class="line"><span class="comment">//打印1</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;StaticDefaultObject int: %d&quot;</span>), staticDefaultInt);</span><br></pre></td></tr></table></figure>

<h3 id="GetClass-GetClass-GetClass"><a href="#GetClass-GetClass-GetClass" class="headerlink" title="GetClass ()-&gt;GetClass ()-&gt;GetClass ()"></a>GetClass ()-&gt;GetClass ()-&gt;GetClass ()</h3><p>最后来点丧心病狂的东西。上面我画了一张类图，UClass 也是 UObject 的子类。</p>
<p>![[6f4a4c16ca3964e8d81a7f7984fba90b_MD5.jpg]]</p>
<p>一个 UObject 实例可以调用 GetClass () 来获得它的 UClass，那么对 UClass 调用 GetClass () 会出现什么结果呢？在 MyActor 里我这么写：</p>
<p>![[48e4b8c5b43fb016de8c944ed1728c29_MD5.jpg]]</p>
<p>结果如下：</p>
<p>![[561e435fb6760478155967e25821838b_MD5.jpg]]</p>
<p><strong>调用第一次 GetClass 和第二次产生的结果不一样，第三次以后结果是一样的了</strong>。至于为什么会这样我不知道，网上也没查出个所以然来，如果有谁弄懂请告诉我，我这里就先记录下来。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>UClass。存储类信息，用于反射。把它当成 C# 的 Type 来理解。</strong></li>
<li><strong>GetClass ()。获得一个 UObject 实例的 UClass，是 UObject 成员函数。</strong></li>
<li><strong>GetStaticClass ()。不需要有实例就能获得 UClass。是静态的，每次调用返回相同结果。</strong></li>
<li><strong>ClassDefaultObject。类默认对象，可以获得 UObject 初始化时的值。注意 GetClass ()-&gt;GetDefaultObject () 和 T:: StaticClass ()-&gt;GetDefaultObject () 不一样。</strong></li>
</ul>
<h2 id="4-虚幻头文件工具-UHT"><a href="#4-虚幻头文件工具-UHT" class="headerlink" title="4 虚幻头文件工具 UHT"></a>4 虚幻头文件工具 UHT</h2><p>为利用 <code>UObject</code> 派生类型所提供的功能，需要在头文件上为这些类型执行一个预处理步骤，以核对需要的信息。该预处理步骤由 <strong>UnrealHeaderTool（简称 UHT）</strong> 执行。<code>UObject</code> 派生的类型需要遵守特定的结构。</p>
<h3 id="头文件格式"><a href="#头文件格式" class="headerlink" title="头文件格式"></a>头文件格式</h3><p><code>UObject</code> 在源（. cpp）文件中的实现与其他 C++ 类相似，其<strong>在头（. h）文件中的定义必须遵守特定的基础结构</strong>。<br><code>UObject</code> 派生类的基础头文件可能看起来与此相似，假定 UObject 派生物被称为 UMyObject，其创建时所在的项目被称为 MyProject：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;Object.h&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;MyObject.generated.h&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYPROJECT_API</span> UMyObject : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虚幻引擎特定的部分如下：</p>
<ol>
<li>此行预计为此文件中最后一个 <code>#include</code> 指令。如此头文件需要了解其他类，可将它们在文件中的任意位置提前声明，或包括在 MyObject. generated. h 上。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyObject.generated.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>UCLASS</code> 宏使虚幻引擎能识别 <code>UMyObject</code>。此宏支持大量参数<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/class-specifiers">类说明符</a>，参数决定类功能的开或关。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>**如 MyProject 希望将 UMyObject 类公开到其他模块，则需要指定 <code>MYPROJECT_API</code>**。这对游戏项目将包括的模块或插件十分实用。这些模块和插件将故意使类公开，在多个项目间提供可携的自含式功能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MYPROJECT_API</span> UMyObject : <span class="keyword">public</span> UObject</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong><code>GENERATED_BODY</code> 宏不获取参数，但会对类进行设置，以支持引擎要求的基础结构。所有 <code>UCLASS</code> 和 <code>USTRUCT</code> 均有此要求。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GENERATED_BODY</span>() <span class="comment">//GENERATED_BODY()宏必须被放置在类体的最前方。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚幻头文件工具支持最下 C++集。当使用自定义 <code>#ifdefs</code> 宏包裹 UCLASS 的部分时，UHT 会忽略不包含 <code>WITH_EDITOR</code> 或者 <code>WITHEDITORONLY_DATA</code> 宏的宏。</p>
</li>
</ol>
<h3 id="5-头文件包含最佳实践"><a href="#5-头文件包含最佳实践" class="headerlink" title="5 头文件包含最佳实践"></a>5 头文件包含最佳实践</h3><p>假设有两个类 A 和 B，类 A 要将类 B 的对象 (或者指正)作为自己的成员使用，并且类 B 将类 A 的对象 (或者指针)作为自己可以访问的数据，那么这个时候要在a.h 中 include b.h, 同时在b.h 中要 include a.h，但是相互包含是不可以的，这个时候就要用到类的前向声明了。</p>
<p><strong>类的前向声明是利用了编译器的特性，编译器在编译的过程中只需要知道各个元素的名称和相应的大小就可以。而在 c++中每一个类的大小是固定的，这个时候使用前向声明的类就可以通过编译器。</strong></p>
<ol>
<li>前向声明的类不能定义对象。</li>
<li>可以用于定义指向这个类型的指针和引用。</li>
<li>用于申明使用该类型作为形参或返回类型的函数。</li>
</ol>
<h4 id="前向声明作用"><a href="#前向声明作用" class="headerlink" title="前向声明作用"></a>前向声明作用</h4><p>根据其用途，前向声明的主要作用为：<br>（1）避免重复定义变量；<br>（2）避免引入函数定义&#x2F;声明文件，从而函数文件发生更改时不会重新编译依赖文件；<br>（3）解决循环依赖问题。</p>
<p>前两种用途好理解，第三种稍微复杂点，但却是<strong>前向声明最重要的用途</strong>。其解决类 A 包含类 B，同时类 B 包含类 A 的依赖问题。循环依赖一般是设计层面的问题，可通过接口、引入辅助类等手段化解。前向声明也能解决，只是架构上稍微别扭。</p>
<p>不管 A 和 B 是否定义在同一个文件中，c++永远无法解决如下形式的循环依赖（后文解释原因）：</p>
<p>![[8f6b7e7b2036f5566eedbe4acb0acd95_MD5.webp]]</p>
<p>前向声明解决该问题需要与指针配合，转换成另一种形式。要点如下：</p>
<ul>
<li>至少将某类的变量类型转换成指针，例如 A 中将 B 转成 B*；</li>
<li>类 A 中对 B 使用前向声明；</li>
<li>类 A 的定义文件中移除对类 B 文件的包含（做了包含保护则可忽略）。</li>
</ul>
<p>使用前向声明后，以下是一种可行的解决形式（两个类均使用了前向声明）：<br>![[v2-98995fabb527844ea3f831507501d1f0_720w.webp]]</p>
<h4 id="深入前向声明"><a href="#深入前向声明" class="headerlink" title="深入前向声明"></a>深入前向声明</h4><p>如果你有其他编程语言的经验，会发现c++有点怪异：Java&#x2F;C#&#x2F;Python&#x2F;PHP等语言可以轻松做到循环引用，无需使用类似的前向声明技巧。这不禁让人思考：<strong>C++为何必须要用前向声明才能化解？</strong></p>
<p><em><em>原因在于C++定义对象有两种方式：一种是A a形式，a即对象，调用成员变量或函数用.，对象在栈中分配；另一种是A</em> a，a是指针，调用成员变量或函数用-&gt;，其指向地址存储实际对象，对象在堆中分配。</em>*</p>
<p><strong>分配对象需要知道具体的内存大小，但以下形式我们不能确定类A和类B对象的大小：</strong></p>
<p>![[47c2208061f7dc3c5e25c131b851958f_MD5.webp]]</p>
<p>对于这个简单例子，你可以直观认为A和B占用同样的内存，例如1字节，但也可以是2字节，3字节等；根据内存对齐要求，一般是4字节，8字节等。无论哪种情况，<strong>编译器无法确定其对象占用内存，便会报错停止编译</strong>。所以你应该知道为什么C++永远不应该（不能）这样做了吧？</p>
<p>那为何前向声明加指针的组合能解决循环引用问题的呢？因为正常情况下，数据类型指针在同一机器的编译器里占同样的内存。指针一般是4或者8个字节，对应32和64位指针。<strong>用了指针，即使有循环引用，类的大小也能轻易的确定下来</strong>。这也是Java&#x2F;C#&#x2F;Python&#x2F;PHP等可以轻松循环引用的原因:这些语言中，对象变量其实都是指针，也意味着对象变量都是引用传递。</p>
<p>如果不移除文件的相互包含，能否省去前向声明呢？答案是不能，原因如下：</p>
<ol>
<li>C++按照一个个编译单元（translation unit）进行编译，如果两个文件互相包含且没有 #pragma once 等包含保护措施，则会出现递归包含，编译器报错；</li>
<li>如果两个头文件都有文件包含保护，编译 A 时会把 B 包含进来，但因为 B 包含了 A，A 中的包含保护生效，导致 B 文件内的内容实际未引入 A，于是报 B 为未知符号的错误。</li>
</ol>
<p>总的来说，不管是否移除对方的头文件，前向声明都是必须的。实践中为了避免文件变动时重新编译的耗费，移除不必要的头文件是一个好习惯。</p>
<h4 id="前向声明和详细类型说明符"><a href="#前向声明和详细类型说明符" class="headerlink" title="前向声明和详细类型说明符"></a>前向声明和详细类型说明符</h4><p>在 <code>A.h</code> 中使用 class <strong>前向声明或详细类型说明符</strong>，在 <code>A.cpp</code> 中包含其他库的头文件，这样其他文件包含 <code>A.h</code> 时就可以减少引入的代码数量（防止代码膨胀）</p>
<p>![[Pasted image 20230903231808.png]]</p>
<blockquote>
<p>Rider 的智能提示，比如我想声明 USphereComponent ，可以选择 2&#x2F;3 都行</p>
</blockquote>
<p><strong>详细类型说明符：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;Components/CapsuleComponent.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Bird.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTDN_API</span> ABird : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">	<span class="comment">//UCapsuleComponent* Capsule;     这样写，需要引入CapsuleComponent.h头文件</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UCapsuleComponent</span>* Capsule; <span class="comment">//前向声明形式，不需要引入CapsuleComponent.h头文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(推荐)前向声明：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UCapsuleComponent</span>; <span class="comment">//前向声明形式，不需要引入CapsuleComponent.h头文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTDN_API</span> ABird : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">	UCapsuleComponent* Capsule; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 cpp 中引入头文件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProjectDN/Public/Pawns/Bird.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span>  <span class="comment">//在cpp中引入CapsuleComponent.h头文件</span></span></span><br><span class="line"></span><br><span class="line">ABird::<span class="built_in">ABird</span>()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">	Capsule = <span class="built_in">CreateDefaultSubobject</span>&lt;UCapsuleComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CapsuleComponent&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以下类型必须包含在头文件"><a href="#以下类型必须包含在头文件" class="headerlink" title="以下类型必须包含在头文件"></a>以下类型必须包含在头文件</h4><ul>
<li>子类必须将父类的头文件包含在自己的头文件中</li>
<li>当需要类型大小时</li>
<li>需要访问类的成员变量和函数</li>
</ul>
<h1 id="三、结构体-USTRUCT"><a href="#三、结构体-USTRUCT" class="headerlink" title="三、结构体 USTRUCT"></a>三、结构体 USTRUCT</h1><p><strong>结构体（Struct）</strong> 是一种数据结构，帮助你组织和操作相关属性。在虚幻引擎中，结构体会被引擎的反射系统识别为 <strong><code>USTRUCT</code><strong>，但</strong>不属于 <code>UObject</code> 生态圈,且不能在 <code>UClasse</code> 的内部使用。</strong> </p>
<ul>
<li>在相同的数据布局下， <code>USTRUCT</code> 比 <code>UObject</code> 能更快创建。</li>
<li><code>USTRUCT</code>支持<code>UPROPERTY</code>, 但它不由垃圾回收系统管理，不能提供<code>UFUNCTION</code></li>
</ul>
<h2 id="实现USTRUCT"><a href="#实现USTRUCT" class="headerlink" title="实现USTRUCT"></a>实现USTRUCT</h2><p>要把一个结构体变成 <code>USTRUCT</code>，请遵循以下步骤：</p>
<ol>
<li>打开你要定义结构体的 <strong>header (.h)</strong> 文件。</li>
<li>要定义你的C++结构体，请将 <code>USTRUCT</code> 宏放在结构体定义的上方。</li>
<li>将 <code>GENERATED_BODY()</code> 宏作为定义的第一行。</li>
</ol>
<p>其结果应该与下面的的例子一致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>([Specifier, Specifier, ...])</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FStructName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你可以用<code>UPROPERTY</code>来标记结构体的相关变量，使它们在虚幻反射系统和蓝图脚本中可见。</p>
<h2 id="结构体说明符"><a href="#结构体说明符" class="headerlink" title="结构体说明符"></a>结构体说明符</h2><p><strong>结构体说明符</strong> 提供元数据，控制你的结构在引擎和编辑器中各方面的表现。</p>
<ul>
<li><code>Atomic</code> ：表示该结构体应始终被序列化为一个单元。将不会为该类创建自动生成的代码。标头仅用于解析元数据。</li>
<li><code>BlueprintType</code>： 将此结构体作为一种类型公开，可用于蓝图中的变量。</li>
<li><code>NoExport</code> ：将不会为该类创建自动生成的代码。标头仅用于解析元数据。</li>
</ul>
<h2 id="最佳做法与技巧"><a href="#最佳做法与技巧" class="headerlink" title="最佳做法与技巧"></a>最佳做法与技巧</h2><p>下面是一些使用 <code>USTRUCT</code> 时需要记住的有用提示：</p>
<ol>
<li><code>USTRUCT</code> 可以使用虚幻引擎的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/smart-pointers-in-unreal-engine">智能指针</a>和垃圾回收系统来防止垃圾回收删除 <code>UObjects</code>。</li>
<li>结构体最好用于简单数据类型。对于你的项目中更复杂的交互，也许可以使用 <code>UObject</code> 或 <code>AActor</code> 子类来代替。</li>
<li><code>USTRUCTs</code> <strong>不可以</strong> 用于复制。但是 <code>UPROPERTY</code> 变量 <strong>可以</strong> 用于复制。</li>
<li>虚幻引擎可以自动为结构体创建Make和Break函数。<ol>
<li>Make函数出现在任何带有 <code>BlueprintType</code> 标签的 <code>USTRUCT</code> 中。</li>
<li>如果在USTRUCT中至少有一个 <code>BlueprintReadOnly</code> 或 <code>BlueprintReadWrite</code> 属性，Break函数就会出现。</li>
<li>Break 函数创建的纯节点为每个标记为 <code>BlueprintReadOnly</code> 或 <code>BlueprintReadWrite</code> 的资产提供一个输出引脚。</li>
</ol>
</li>
</ol>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><p> 继承 <code>FTableRowBase</code> 之后可以用于 DataTable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInventoryItemInfo</span> : <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        <span class="function">FString ItemName <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;名称&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        <span class="function">int32 index <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;编号&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        <span class="function"><span class="type">bool</span> bCanStaking <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;可否叠加&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        <span class="function">int32 Count <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;数量&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        <span class="function">UTexture2D* Icon <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;图标&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        TSubclassOf&lt;AActor&gt; ItemClass;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">        USkeletalMesh* SkeletalMesh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere,BlueprintReadWrite)</span><br><span class="line">    FInventoryItemInfo EmptyItem;</span><br></pre></td></tr></table></figure>

<p>![[2a910ca10a8e8545b4aadc6ff0026ade_MD5.png]]</p>
<h1 id="四、接口-UINTERFACE"><a href="#四、接口-UINTERFACE" class="headerlink" title="四、接口 UINTERFACE"></a>四、接口 UINTERFACE</h1><p>接口类用于确保一组可能不相关的类实现一组公共的函数。在一些游戏功能可能由原本不相似的大型复杂类共享的情况下，这很有用。</p>
<p>游戏可能有这样一个系统，玩家角色进入触发器体积时可以激活陷阱、提醒敌人或向玩家奖励积分。这可以通过陷阱、敌人或积分奖励上的”ReactToTrigger”函数来实现。但是，陷阱可能派生自<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/actors-in-unreal-engine">AActor</a>，敌人派生自专门的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/pawn-in-unreal-engine">APawn</a>或<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/characters-in-unreal-engine">ACharacter</a>子类，而积分奖励派生自 <code>UDataAsset</code> 。</p>
<p>所有这些类都需要共享的功能，但除了 <code>UObject</code> 之外，没有其他公共的父类。在这种情况下，推荐使用接口。</p>
<h2 id="1-接口声明"><a href="#1-接口声明" class="headerlink" title="1 接口声明"></a>1 接口声明</h2><p>声明接口类与声明普通的虚幻类相似，但仍有两个主要区别。</p>
<ol>
<li>首先，接口类使用 <code>UINTERFACE</code> 宏而不是 <code>UCLASS</code> 宏，继承 <code>UInterface</code> 而不是 <code>UObject</code></li>
</ol>
<p>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINTERFACE</span>([specifier, specifier, ...], [<span class="built_in">meta</span>(key=value, key=value, ...)])</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UClassName</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>其次，<code>UINTERFACE</code> 类不是实际的接口；它是一个空白类，<strong>它的存在只是为了向虚幻引擎反射系统确保可见性</strong>。将由其他类继承的实际接口必须具有相同的类名，但是<strong>开头字母<code>U</code>必须改为<code>I</code>。</strong></li>
</ol>
<figure class="highlight c++"><figcaption><span>title:ReactToTriggerInterface.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReactToTriggerInterface.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//确保反射系统可见性</span></span><br><span class="line"><span class="built_in">UINTERFACE</span>(MinimalAPI, Blueprintable)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UReactToTriggerInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IReactToTriggerInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 在此处添加接口函数声明 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀为 <code>U</code>的类不需要构造函数或任何其他函数</li>
<li>前缀为 <code>I</code>的类将包含所有接口函数，且此类实际上将被你的其他类继承。</li>
</ul>
<h2 id="2-接口说明符"><a href="#2-接口说明符" class="headerlink" title="2 接口说明符"></a>2 接口说明符</h2><p>接口说明符用于向虚幻反射系统公开你的类，详见下表：</p>
<table>
<thead>
<tr>
<th>接口说明符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>⭐ <strong><code>Blueprintable</code></strong></td>
<td>⭐将该类公开为可接受的用于创建蓝图的基类，让蓝图实现此接口</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintType</code></strong></td>
<td>⭐将该类公开为可用于蓝图中的变量的类型。</td>
</tr>
<tr>
<td><code>DependsOn=(ClassName1, ClassName2, ...)</code></td>
<td>所有列出的类都将在该类之前编译。ClassName必须在同一个（或上一个）包中指定一个类。多个依赖性类可以使用以逗号分隔的单个”DependsOn”行来指定，也可以使用单个”DependsOn”行为每个类指定。当一个类使用在另一个类中声明的结构体或枚举时，这一点非常重要，因为编译器只知道它已经编译的类中的内容。</td>
</tr>
<tr>
<td><code>MinimalAPI</code></td>
<td>仅导致该类的类型信息被导出以供其他模块使用。你可以向该类转换，但不能调用该类的函数（内联方法除外）。对于不需要其所有函数在其他模块中均可供访问的类，通过不导出这些类的所有内容，这可以缩短编译时间。</td>
</tr>
</tbody></table>
<h2 id="3-在-C-中实现接口"><a href="#3-在-C-中实现接口" class="headerlink" title="3 在 C++中实现接口"></a>3 在 C++中实现接口</h2><p>若要在一个新的类中使用你的接口，只需从前缀为 <code>I</code> 的接口类继承（除了你正在使用的任何基于 <code>UObject</code>的类）即可。</p>
<figure class="highlight c++"><figcaption><span>title:Trap.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReactToTriggerInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Trap.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(Blueprintable, Category=<span class="string">&quot;MyGame&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ATrap</span> : <span class="keyword">public</span> AActor, <span class="keyword">public</span> IReactToTriggerInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 在此处添加接口函数重载。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-声明接口函数"><a href="#4-声明接口函数" class="headerlink" title="4 声明接口函数"></a>4 声明接口函数</h2><p>有几种方法可以在接口中声明函数，由环境决定能够实现或调用哪种方法。<br>所有方法都必须在前缀为 <code>I</code> 的类中为接口声明，而且必须为 <code>public</code> ，以便对外部的类可见。</p>
<h3 id="仅C-的接口函数"><a href="#仅C-的接口函数" class="headerlink" title="仅C++的接口函数"></a>仅C++的接口函数</h3><p>可以在接口的头文件中声明一个<strong>不带 <code>UFUNCTION</code> 说明</strong>的虚函数。这些函数必须为 virtual，以便在实现接口的类中重载它们。</p>
<figure class="highlight c++"><figcaption><span>title:ReactToTrigger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ReactToTrigger</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后，可以在头文件本身或接口的 <code>.cpp</code> 文件中提供一个默认的实现。</p>
<figure class="highlight c++"><figcaption><span>title:ReactToTrigger.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IReactToTriggerInterface::ReactToTrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在一个Actor类中实现接口后，可以创建并实现一个针对该类的重载。</p>
<figure class="highlight c++"><figcaption><span>title:Trap.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ReactToTrigger</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><figcaption><span>title:Trap.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ATrap::ReactToTrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是，这些C++接口函数对蓝图不可见。</strong></p>
<h3 id="蓝图可调用接口函数"><a href="#蓝图可调用接口函数" class="headerlink" title="蓝图可调用接口函数"></a>蓝图可调用接口函数</h3><p><strong>要创建蓝图可调用的接口函数，必须在带 <code>BlueprintCallable</code> 说明符的函数声明中提供一个 <code>UFUNCTION</code> 宏。还必须使用 <code>BlueprintImplementableEvent</code> 或 <code>BlueprintNativeEvent</code> 说明，而且函数不能为<code>virtual</code>。</strong><br>接口中用 <code>BlueprintImplementableEvent</code> 标记函数也不需要实现为纯虚函数！仍可以正常继承</p>
<figure class="highlight c++"><figcaption><span>title:ReactToTrigger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**只能在蓝图中实现的React To Trigger版本。*/</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintImplementableEvent, Category=Trigger Reaction)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReactToTrigger</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><figcaption><span>title:ReactToTrigger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**可以在C++或蓝图中实现的React To Trigger版本。*/</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintNativeEvent, Category=Trigger Reaction)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReactToTrigger</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>BlueprintCallable</code>：<strong>引用实现接口的对象的 C++或蓝图</strong>可以调用使用 <code>BlueprintCallable</code> 说明符的函数。</p>
<p><code>BlueprintImplementableEvent</code>：使用 <code>BlueprintImplementableEvent</code> 的函数<strong>不能在 C++中被重载，但可以在任何实现或继承接口的蓝图类中被重载。</strong></p>
<p><code>BlueprintNativeEvent</code>：在 C++中，可通过重载一个同名函数来实现使用 <code>BlueprintNativeEvent</code> 的函数，但要在末尾添加上后缀 <code>_Implementation</code> 。该说明符还<strong>允许在蓝图中重载实现</strong>。</p>
<figure class="highlight c++"><figcaption><span>title:Trap.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReactToTrigger_Implementation</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:Trap.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ATrap::ReactToTrigger_Implementation</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-确定类是否实现了接口"><a href="#5-确定类是否实现了接口" class="headerlink" title="5 确定类是否实现了接口"></a>5 确定类是否实现了接口</h2><p>为了与实现接口的C++和蓝图类兼容，可以使用以下任意函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果OriginalObject实现了UReactToTriggerInterface，则bisimplemated将为true。</span></span><br><span class="line"><span class="type">bool</span> bIsImplemented = OriginalObject-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">ImplementsInterface</span>(UReactToTriggerInterface::<span class="built_in">StaticClass</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果OriginalObject实现了UReactToTrigger，bIsImplemented将为true。</span></span><br><span class="line">bIsImplemented = OriginalObject-&gt;<span class="built_in">Implements</span>&lt;UReactToTriggerInterface&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果OriginalObject实现了UReactToTriggerInterface，则ReactingObject将为非空。</span></span><br><span class="line">IReactToTriggerInterface* ReactingObjectA = <span class="built_in">Cast</span>&lt;IReactToTriggerInterface&gt;(OriginalObject); </span><br></pre></td></tr></table></figure>

<p>如果 <strong><code>StaticClass()</code></strong> 函数在前缀为 <code>I</code> 的类中没有实现，尝试在前缀为 <code>U</code> 的类上使用 <code>Cast</code> 将失败，代码将无法编译。</p>
<h2 id="6-转换类型"><a href="#6-转换类型" class="headerlink" title="6 转换类型"></a>6 转换类型</h2><p>虚幻引擎的转换系统支持<strong>从一个接口转换到另一个接口</strong>，或者在适当的情况下，<strong>从一个接口转换到一个虚幻类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IReactToTriggerInterface* ReactingObject = <span class="built_in">Cast</span>&lt;IReactToTriggerInterface&gt;(OriginalObject); <span class="comment">// 如果接口被实现，则ReactingObject将为非空。</span></span><br><span class="line"></span><br><span class="line">ISomeOtherInterface* DifferentInterface = <span class="built_in">Cast</span>&lt;ISomeOtherInterface&gt;(ReactingObject); <span class="comment">// 如果ReactingObject为非空而且还实现了ISomeOtherInterface，则DifferentInterface将为非空。</span></span><br><span class="line"></span><br><span class="line">AActor* Actor = <span class="built_in">Cast</span>&lt;AActor&gt;(ReactingObject); <span class="comment">// 如果ReactingObject为非空且OriginalObject为AActor或AActor派生的类，则Actor将为非空。</span></span><br></pre></td></tr></table></figure>


<h1 id="五、函数-UFUNCTION"><a href="#五、函数-UFUNCTION" class="headerlink" title="五、函数 UFUNCTION"></a>五、函数 UFUNCTION</h1><p><strong><code>UFUNCTION</code></strong> 是一种 C++函数，可以被虚幻引擎（UE）反射系统识别。 <code>UObject</code> 或蓝图函数库可将<strong>成员函数</strong>声明为 <code>UFUNCTION</code>，方法是将 <code>UFUNCTION</code> 宏放在头文件中函数声明上方的行中。</p>
<p>宏将支持 <strong>函数说明符</strong> 更改虚幻引擎解译和使用函数的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>([specifier1=setting1, specifier2, ...], [<span class="built_in">meta</span>(key1=<span class="string">&quot;value1&quot;</span>, key2, ...)])</span><br><span class="line"><span class="function">ReturnType <span class="title">FunctionName</span><span class="params">([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2])</span> [<span class="type">const</span>]</span>;</span><br></pre></td></tr></table></figure>

<p>可利用函数说明符将 <code>UFUNCTION</code> 对蓝图公开，以便开发者从蓝图资源调用或扩展 <code>UFUNCTION</code>，而无需更改 C++代码。</p>
<p>注意：子类继承父类的UFUNCITON 不需要添加 UFUNCITON 宏，否则编译错误</p>
<h2 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h2><p>声明函数时，可以为声明添加 <strong>函数说明符</strong>，以控制函数相对于引擎和编辑器的各个方面的行为方式。</p>
<p><strong>常用：</strong></p>
<ol>
<li><strong><code>BlueprintCallable</code></strong> ：函数可从<strong>蓝图</strong>中调用，但<strong>只能通过 C++代码修改</strong><ul>
<li>码将更改它所调用的对象的某些内容或一些其他全局状态，意味着必须调用它，必须连接白色执行线（调度它）。</li>
<li>BlueprintCallable函数的返回值会在执行这个函数的作用域（或者说执行流）中创建一个局部变量，而BlueprintPure不会</li>
</ul>
</li>
<li><strong><code>BlueprintPure</code><strong>：函数可从</strong>蓝图</strong>中调用，但<strong>只能通过 C++代码修改</strong>。<ul>
<li>不会更改它所调用的对象的任何内容或任何其他全局状态，它只需要输入，然后告诉您输出，类似于数学运算节点，不需要连接白色执行线。![[Pasted image 20230901194721.png]]</li>
<li>每次与其输出相连的节点执行时重新计算其输出,，如果在单个节点内有进行大量计算而且其计算结果会多次使用的话，需要避免使用 BlueprintPure。</li>
</ul>
</li>
<li><strong><code>BlueprintImplementableEvent</code><strong>：函数由其</strong>蓝图</strong>的子类实现，不应该在 C++中给出函数的实现，这会导致链接错误。<ul>
<li>如果没有返回值或输出参数，那么在蓝图中为一个事件</li>
<li>如果它有返回值或任何输出参数，那么在蓝图中为一个函数</li>
</ul>
</li>
<li><strong><code>BlueprintNativeEvent</code></strong> ：函数提供一个 C++的默认实现，同时也可以被蓝图重载。默认实现的函数名为 <code>函数名_Implementation</code> 。<ul>
<li>如果需要，您仍然可以调用默认实现，方法是在事件或函数条目节点上 <strong>右键单击</strong>，并选择”将调用添加到父项（Add call to parent）”。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h中声明</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction</span><span class="params">()</span></span>; <span class="comment">//由蓝图重载</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestFunction_Implementation</span><span class="params">()</span></span>;  <span class="comment">//由cpp实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp中实现</span></span><br><span class="line"><span class="comment">//只需要实现名为_Implementation的默认实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestActor::TestFunction_Implementation</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//功能...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp中调用</span></span><br><span class="line"><span class="comment">//使用Execute_调用</span></span><br><span class="line"><span class="built_in">Execute_TestFunction</span>(); </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数说明符</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>BlueprintAuthorityOnly</code></td>
<td>如果在具有网络权限的机器上运行（服务器、专用服务器或单人游戏），此函数将仅从蓝图代码执行。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintCallable</code></strong></td>
<td>⭐<strong>此函数可在蓝图或关卡蓝图图表中执行。</strong></td>
</tr>
<tr>
<td><code>BlueprintCosmetic</code></td>
<td>此函数为修饰性的，无法在专用服务器上运行。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintImplementableEvent</code></strong></td>
<td>⭐<strong>此函数可在蓝图或关卡蓝图图表中实现。</strong></td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintNativeEvent</code></strong></td>
<td>⭐<strong>此函数旨在被蓝图覆盖掉，但是也具有默认原生实现。</strong> 用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>，是写入代码的位置。如果未找到任何蓝图覆盖，该自动生成的代码将调用<code>_ Implementation</code> 方法。</td>
</tr>
<tr>
<td>⭐ <strong><code>BlueprintPure</code></strong></td>
<td>Pure函数，此函数不对拥有它的对象产生任何影响，可在蓝图或关卡蓝图图表中执行。</td>
</tr>
<tr>
<td>⭐ <strong><code>CallInEditor</code></strong></td>
<td>⭐<strong>可通过细节（Details）面板中的按钮在编辑器中的选定实例上调用此函数。</strong></td>
</tr>
<tr>
<td>⭐ <strong><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></strong></td>
<td>⭐<strong>在蓝图编辑工具中显示时指定函数的类别</strong>。使用 | 运算符定义嵌套类别。</td>
</tr>
<tr>
<td><code>Client</code></td>
<td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用<code>_ Implementation</code> 方法。</td>
</tr>
<tr>
<td><code>CustomThunk</code></td>
<td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td>
</tr>
<tr>
<td><code>Exec</code></td>
<td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td>
</tr>
<tr>
<td><code>NetMulticast</code></td>
<td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td>
</tr>
<tr>
<td><code>Reliable</code></td>
<td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td>
</tr>
<tr>
<td><code>SealedEvent</code></td>
<td>无法在子类中覆盖此函数。<code>SealedEvent`关键词只能用于事件。对于非事件函数，请将它们声明为`static`或`final</code>，以密封它们。</td>
</tr>
<tr>
<td><code>ServiceRequest</code></td>
<td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td>
</tr>
<tr>
<td><code>ServiceResponse</code></td>
<td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td>
</tr>
<tr>
<td><code>Server</code></td>
<td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td>
</tr>
<tr>
<td><code>Unreliable</code></td>
<td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td>
</tr>
<tr>
<td><code>WithValidation</code></td>
<td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td>
</tr>
</tbody></table>
<h2 id="函数参数说明符"><a href="#函数参数说明符" class="headerlink" title="函数参数说明符"></a>函数参数说明符</h2><table>
<thead>
<tr>
<th>参数说明符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Out</td>
<td>声明由引用传递的参数，使函数对其进行修改。</td>
</tr>
<tr>
<td>Optional</td>
<td>通过任选关键词可使部分函数参数变为任选，便于调用。任选参数的数值（调用方未指定）取决于函数。例如， <code>SpawnActor</code> 函数使用任选位置和旋转，默认为生成的 Actor 根组件的位置和旋转。添加 <code>= [value]</code> 参数可指定任选参数的默认值。例如： <code>function myFunc(optional int x = -1)</code> 。在多数情况下，如无数值被传递到任选参数，将使用变量类型的默认值或零（例如 0、false、””、none）。</td>
</tr>
</tbody></table>
<h2 id="Exec-控制台可调用函数"><a href="#Exec-控制台可调用函数" class="headerlink" title="Exec 控制台可调用函数"></a>Exec 控制台可调用函数</h2><p>此函数可从游戏中的控制台中执行。Exec命令仅在特定类中声明时才产生作用。包括：</p>
<ul>
<li>Pawns,</li>
<li>Player Controllers,</li>
<li>Player Input,</li>
<li>Cheat Managers,</li>
<li>Game Modes,</li>
<li>Game Instances,</li>
<li>overriden Game Engine classes,</li>
<li>Huds</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(Exec, Category = <span class="string">&quot;methods&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunExec</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::FunExec</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">1.0f</span>, FColor::Blue, FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;BPNative C++ Call  Value:%f&quot;</span>), Value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![[942fee0c636bb0a81e921eaa99e52bd0_MD5.png]]</p>
<h1 id="六、参数-UPARAM"><a href="#六、参数-UPARAM" class="headerlink" title="六、参数 UPARAM"></a>六、参数 UPARAM</h1><p>主要用于将 C++ 代码公开到蓝图</p>
<p>若要使参数通过<strong>非const引用传递并仍然显示为输入</strong>，请使用 <code>UPARAM(ref)</code> 宏。</p>
<p>![[Pasted image 20230829220832.png]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Example Nodes&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleTargets</span><span class="params">(UPARAM(ref) TArray&lt;FVector&gt;&amp; InputLocations, TArray&lt;FVector&gt;&amp; OutputLocations)</span></span>;</span><br></pre></td></tr></table></figure>

<p>您还可以使用<code>UPARAM()</code>来<strong>更改引脚的显示名称</strong>。例如， MakeRotator 函数使用”<code>UPARAM()</code>和<code>DisplayName</code>关键字来更改绕 Z 轴的旋转、绕 X 轴的旋转、绕 Y 轴的旋转参数在蓝图中的显示方式。</p>
<p>![[54948c4fcd6856e0a406abb1d203171e_MD5.jpg]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根据采用度数的旋转值制作一个旋转体&#123;绕Z轴的旋转、绕X轴的旋转、绕Y轴的旋转&#125; */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">&quot;Math|Rotator&quot;</span>, meta=(Keywords=<span class="string">&quot;construct build rotation rotate rotator makerotator&quot;</span>, NativeMakeFunc))</span><br><span class="line"><span class="function"><span class="type">static</span> FRotator <span class="title">MakeRotator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">UPARAM(DisplayName=<span class="string">&quot;X (Roll)&quot;</span>) <span class="type">float</span> Roll,</span></span></span><br><span class="line"><span class="params"><span class="function">UPARAM(DisplayName=<span class="string">&quot;Y (Pitch)&quot;</span>) <span class="type">float</span> Pitch,</span></span></span><br><span class="line"><span class="params"><span class="function">UPARAM(DisplayName=<span class="string">&quot;Z (Yaw)&quot;</span>) <span class="type">float</span> Yaw)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="七、元数据说明符"><a href="#七、元数据说明符" class="headerlink" title="七、元数据说明符"></a>七、元数据说明符</h1><p>文档：<br><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/metadata-specifiers-in-unreal-engine/">虚幻引擎元数据说明符 | 虚幻引擎5.2文档 (unrealengine.com)</a></p>
<p>声明类、接口、结构体、列举、列举值、函数，或属性时，可添加 <strong>元数据说明符</strong> 来<strong>控制其与引擎和编辑器各方面的交互方式</strong>。<br>每一种类型的数据结构或成员都有自己的元数据说明符列表。</p>
<blockquote>
<p>[!warning]<br>Metadata 只存在于编辑器中。请不要编写能够访问到 Metadata 的游戏逻辑。</p>
</blockquote>
<p><strong>要添加元数据说明符，需使用单词 <code>meta</code>，后接说明符列表</strong>。如有必要，可以将它们的值添加到 <code>UCLASS</code>、<code>UENUM</code>、<code>UINTERFACE</code>、<code>USTRUCT</code>、<code>UFUNCTION</code> 或 <code>UPROPERTY</code> 宏，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;UCLASS/UENUM/UINTERFACE/USTRUCT/UFUNCTION/UPROPERTY&#125;(SpecifierX, meta=(MetaTag1=<span class="string">&quot;Value1&quot;</span>, MetaTag2, ..), SpecifierY)</span><br></pre></td></tr></table></figure>

<h2 id="属性说明符-1"><a href="#属性说明符-1" class="headerlink" title="属性说明符"></a>属性说明符</h2><p><strong><code>DisplayName</code> 别名</strong>，可以便于蓝图变量搜索，如果变量名不好记的话</p>
<p><strong><code>EditCondition</code> 是否可编辑</strong>：支持 bool、比较等条件判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere,BlueprintReadWrite, meta = (DisplayName=<span class="string">&quot;UseOffset1、2 标志位&quot;</span>) )</span><br><span class="line">	<span class="type">bool</span> bUseOffset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, meta = (DisplayName = <span class="string">&quot;ContitionValue 控制 offset3&quot;</span>))</span><br><span class="line">	int32 ContitionValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, meta = (DisplayName = <span class="string">&quot;ContitionColorBits 控制 offset4&quot;</span>))</span><br><span class="line">	EColorBits1 ContitionColorBits;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = <span class="string">&quot;bUseOffset&quot;</span>))</span><br><span class="line">	<span class="type">float</span> Offset1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = <span class="string">&quot;!bUseOffset&quot;</span>))</span><br><span class="line">	<span class="type">float</span> Offset2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = <span class="string">&quot;ContitionValue&gt;0&quot;</span>))</span><br><span class="line">	<span class="type">float</span> Offset3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = <span class="string">&quot;ContitionColorBits==EColorBits1::ECB_Green&quot;</span>))</span><br><span class="line">	<span class="type">float</span> Offset4;</span><br></pre></td></tr></table></figure>

<p>![[9eeca8d2381f93f451dfd5c02844ce29_MD5.png]]</p>
<p>**<code>BindWidget</code>**： 和 UMG 同名同类型控件绑定</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, meta = (BindWidget))</span><br><span class="line">  UImage* TCanvas;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite , meta = (BindWidget))</span><br><span class="line">  UButton* Btn_Mass;</span><br></pre></td></tr></table></figure>

<p><strong><code>UMETA</code></strong> ：扩展宏</p>
<ul>
<li>cpp meta里的中文在蓝图经常会乱码<ul>
<li>解决方法一：高级保存选择 Unicode 65001</li>
<li>解决办法二：使用UMETA中的DisplayName</li>
</ul>
</li>
<li>可用于Enum的元素别名</li>
<li>可用于结构体的元素别名</li>
<li>可用于Datatable的别名</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	<span class="function">FName ChineseName <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;中文名&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	<span class="function"><span class="type">float</span> Weight <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;体重&quot;</span>)</span> </span>= <span class="number">65.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	<span class="function">EColorBits1 FavoriteColorBits <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;最喜欢的颜色&quot;</span>)</span></span>=EColorBits1::ECB_Blue;</span><br></pre></td></tr></table></figure>

<p>![[b8afbd1280f8a8633fc10e17329ba58a_MD5.png]]</p>
<p><code>[AllowPrivateAccess]</code>：允许从蓝图中访问标记为 <code>BluperintReadOnly</code> 或 <code>BlueprintReadWrite</code> 的私有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不加AllowPrivateAccess就会编译错误</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;MyClass|Test&quot;</span>,meta=(AllowPrivateAccess=<span class="literal">true</span>))</span><br><span class="line">int32 TestCPP;</span><br></pre></td></tr></table></figure>
<h3 id="函数说明符-1"><a href="#函数说明符-1" class="headerlink" title="函数说明符"></a>函数说明符</h3><p><code>ExpandEnumAsExecs</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">BranchOutput</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">	Branch0,</span><br><span class="line">	Branch1,</span><br><span class="line">	Branch2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;methods&quot;</span>, Meta = (ExpandEnumAsExecs = <span class="string">&quot;Branches&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunExpandEnumAsExecs</span><span class="params">(int32 Input, BranchOutput&amp; Branches)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::FunExpandEnumAsExecs</span><span class="params">(int32 Input, BranchOutput&amp; Branches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Input == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Branches = BranchOutput::Branch0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Input == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Branches = BranchOutput::Branch1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Branches = BranchOutput::Branch2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![[9d2428a628a890cc0469f887bcfc294e_MD5.png]]</p>
<h1 id="九、断言"><a href="#九、断言" class="headerlink" title="九、断言"></a>九、断言</h1><p><strong><code>assert</code> 的关键特性之一是不存在于发布代码中，这意味着不但不会影响发布产品的性能，也没有任何副作用</strong>。<strong>对 <code>assert</code> 最简单的理解就是：”断言”必须一律为 true，否则程序会停止运行。</strong></p>
<p>虚幻引擎提供 <code>assert</code> 等同项的三个不同族系：<code>check</code>、<code>verify</code> 和 <code>ensure</code>。各个功能的行为略有不同，但它们都是开发期间使用的诊断工具，目标大致相同。</p>
<h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><p>Check 族系最接近基础 <code>assert</code>，因为当第一个参数得出的值为 false 时，此族系的成员会停止执行，且默认不会在发布版本中运行。以下 Check 宏可用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当Expression为以下值时触发断言</span></span><br><span class="line"><span class="comment">//空指针</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="built_in">check</span>(Expression); </span><br><span class="line"><span class="built_in">check</span>(Expression &amp;&amp; <span class="string">&quot;Expression can not be NULL&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//附加报错文本</span></span><br><span class="line"><span class="built_in">checkf</span>(Expression ,<span class="built_in">TEXT</span>(<span class="string">&quot;Expression can not be NULL&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码执行到这一行就触发断言</span></span><br><span class="line"><span class="built_in">checkNoEntry</span>();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>宏</th>
<th>参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>check</code> 或 <code>checkSlow</code></td>
<td><code>Expression</code></td>
<td>若 <code>Expression</code> 为 false，停止执行</td>
</tr>
<tr>
<td><code>checkf</code> 或 <code>checkfSlow</code></td>
<td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td>
<td>若 <code>Expression</code> 为 false，则停止执行并将 <code>FormattedText</code> 输出到日志</td>
</tr>
<tr>
<td><code>checkCode</code></td>
<td><code>Code</code></td>
<td>在运行一次的 do-while 循环结构中执行 <code>Code</code>；主要用于准备另一个 Check 所需的信息</td>
</tr>
<tr>
<td><code>checkNoEntry</code></td>
<td>（无）</td>
<td>若此行被 hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应不可到达的代码路径</td>
</tr>
<tr>
<td><code>checkNoReentry</code></td>
<td>（无）</td>
<td>若此行被 hit 超过一次，则停止执行</td>
</tr>
<tr>
<td><code>checkNoRecursion</code></td>
<td>（无）</td>
<td>若此行被 hit 超过一次而未离开作用域（递归），则停止执行</td>
</tr>
<tr>
<td><code>unimplemented</code></td>
<td>（无）</td>
<td>若此行被 hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应被覆盖而不会被调用的虚拟函数</td>
</tr>
</tbody></table>
<blockquote>
<p>[!NOTE] 此行被 hit 的含义<br>这句话意思就是代码执行到这一行</p>
</blockquote>
<h2 id="Verify"><a href="#Verify" class="headerlink" title="Verify"></a>Verify</h2><p><strong>若某个函数执行操作，然后返回 <code>bool</code> 来说明该操作是否成功，则应使用 Verify 而非 Check 来确保该操作成功。</strong><br>因为在发布版本中 Verify 将忽略返回值，但仍将执行操作。而 Check 在发布版本中根本不调用该函数，所以行为才会有所不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Verify而非Check，因为表达式需要先执行操作———设置网格体。</span></span><br><span class="line"><span class="built_in">verify</span>((Mesh = <span class="built_in">GetRenderMesh</span>()) != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>宏</th>
<th>参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>verify</code> 或 <code>verifySlow</code></td>
<td><code>Expression</code></td>
<td>若 <code>Expression</code> 为 false，停止执行</td>
</tr>
<tr>
<td><code>verifyf</code> 或 <code>verifyfSlow</code></td>
<td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td>
<td>若 <code>Expression</code> 为 false，则停止执行并将 <code>FormattedText</code> 输出到日志</td>
</tr>
</tbody></table>
<h2 id="Ensure"><a href="#Ensure" class="headerlink" title="Ensure"></a>Ensure</h2><p><strong>Ensure 宏的表达式计算得出的值为 false，将报告崩溃，<font color="#ff0000">仍会继续运行（即可以在编辑器点击继续运行）</font>。</strong></p>
<p>为避免崩溃报告器收到太多通知，Ensure 宏在每次引擎或编辑器会话中仅报告一次。若实际情况需要 Ensure 宏在每次表达式计算得值为 false 时都报告一次，则使用”Always”版本的宏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行代码捕获了在产品发布版本中可能出现的小错误。</span></span><br><span class="line"><span class="comment">// 此错误较小，无需停止执行便可解决。</span></span><br><span class="line"><span class="comment">// 虽然该bug已修复，但开发者仍然希望了解之前是否曾经出现过此bug。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::Tick</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaSeconds);</span><br><span class="line">    <span class="comment">// 确保bWasInitialized为true，然后再继续。若为false，则在日志中记录该bug尚未修复。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ensureMsgf</span>(bWasInitialized, <span class="built_in">TEXT</span>(<span class="string">&quot;%s ran Tick() with bWasInitialized == false&quot;</span>), *<span class="built_in">GetActorLabel</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//（执行一些需要已正确初始化AMyActor的操作。)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>宏</th>
<th>参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>ensure</code></td>
<td><code>Expression</code></td>
<td><code>Expression</code> 首次为 false 时通知崩溃报告器</td>
</tr>
<tr>
<td><code>ensureMsgf</code></td>
<td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td>
<td><code>Expression</code> 首次为 false 时通知崩溃报告器并将 <code>FormattedText</code> 输出到日志</td>
</tr>
<tr>
<td><code>ensureAlways</code></td>
<td><code>Expression</code></td>
<td><code>Expression</code> 为 false 时通知崩溃报告器</td>
</tr>
<tr>
<td><code>ensureAlwaysMsgf</code></td>
<td><code>Expression</code>, <code>FormattedText</code>, <code>...</code></td>
<td><code>Expression</code> 为 false 时通知崩溃报告器并将 <code>FormattedText</code> 输出到日志</td>
</tr>
</tbody></table>
<h1 id="创建蓝图-API：提示和技巧"><a href="#创建蓝图-API：提示和技巧" class="headerlink" title="创建蓝图 API：提示和技巧"></a>创建蓝图 API：提示和技巧</h1><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/exposing-cplusplus-to-blueprints-visual-scripting-in-unreal-engine/">在虚幻引擎中将C++暴露给蓝图 | 虚幻引擎5.2文档 (unrealengine.com)</a><br>程序员创建对蓝图公开的 API 时需要考虑以下几点：</p>
<ul>
<li>可选参数便于在蓝图中处理：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串显示到日志中，也可选择显示到屏幕上。</span></span><br><span class="line"><span class="comment"> * 如 Print To Log 为 true，它将显示在 Output Log 窗口中。否则它将被记录为&quot;Verbose&quot;，通常不会显示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   InString        登出字符串</span></span><br><span class="line"><span class="comment"> * @param   bPrintToScreen  是否将输出显示到屏幕上</span></span><br><span class="line"><span class="comment"> * @param   bPrintToLog     是否将输出保存到日志中</span></span><br><span class="line"><span class="comment"> * @param   bPrintToConsole 是否将输出显示到控制台</span></span><br><span class="line"><span class="comment"> * @param   TextColor       是否将输出显示到控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(WorldContext=<span class="string">&quot;WorldContextObject&quot;</span>, CallableWithoutWorldContext, Keywords = <span class="string">&quot;log print&quot;</span>, AdvancedDisplay = <span class="string">&quot;2&quot;</span>), Category=<span class="string">&quot;Utilities|String&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintString</span><span class="params">(UObject* WorldContextObject, <span class="type">const</span> FString&amp; InString = FString(TEXT(<span class="string">&quot;Hello&quot;</span>)), <span class="type">bool</span> bPrintToScreen = <span class="literal">true</span>, <span class="type">bool</span> bPrintToLog = <span class="literal">true</span>, FLinearColor TextColor = FLinearColor(<span class="number">0.0</span>,<span class="number">0.66</span>,<span class="number">1.0</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在带大量返回参数的函数和返回结构体的函数之间优先前者。以下片段显示如何在节点上创建多个输出引脚：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Example Nodes&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MultipleOutputs</span><span class="params">(int32&amp; OutputInteger, FVector&amp; OutputVector)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>可在现有函数上添加新参数，但如果要进行移除或变更，则需要否决原始函数并添加一个新函数。必须使用否决元数据，使新函数的信息显示在蓝图中：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>, meta=(DeprecatedFunction, DeprecationMessage = <span class="string">&quot;Use new CapsuleOverlapActors&quot;</span>, WorldContext=<span class="string">&quot;WorldContextObject&quot;</span>, AutoCreateRefTerm=<span class="string">&quot;ActorsToIgnore&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">static</span> ENGINE_API <span class="type">bool</span> <span class="title">CapsuleOverlapActors_DEPRECATED</span><span class="params">(UObject* WorldContextObject, <span class="type">const</span> FVector CapsulePos, <span class="type">float</span> Radius, <span class="type">float</span> HalfHeight, EOverlapFilterOption Filter, UClass* ActorClassFilter, <span class="type">const</span> TArray&lt;AActor*&gt;&amp; ActorsToIgnore, TArray&lt;<span class="keyword">class</span> AActor*&gt;&amp; OutActors)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果函数需要接受枚举，考虑将”expand enum as execs”用作元数据，可使节点更易于使用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;DataTable&quot;</span>, meta = (ExpandEnumAsExecs=<span class="string">&quot;OutResult&quot;</span>, DataTablePin=<span class="string">&quot;CurveTable&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">EvaluateCurveTableRow</span><span class="params">(UCurveTable* CurveTable, FName RowName, <span class="type">float</span> InXY, TEnumAsByte&lt;EEvaluateCurveTableResult::Type&gt;&amp; OutResult, <span class="type">float</span>&amp; OutXY)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>许多完成耗时较长的操作（如 move here）均为隐藏函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行带延迟的隐藏操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param WorldContext  世界背景。</span></span><br><span class="line"><span class="comment"> * @param Duration      延迟长度。</span></span><br><span class="line"><span class="comment"> * @param LatentInfo    隐藏操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|FlowControl&quot;</span>, meta=(Latent, WorldContext=<span class="string">&quot;WorldContextObject&quot;</span>, LatentInfo=<span class="string">&quot;LatentInfo&quot;</span>, Duration=<span class="string">&quot;0.2&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Delay</span><span class="params">(UObject* WorldContextObject, <span class="type">float</span> Duration, <span class="keyword">struct</span> FLatentActionInfo LatentInfo )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如有可能，考虑将函数放入共享库。便于在多个类之间使用，避开”target”引脚。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DOCUMENTATIONCODE_API</span> UTestBlueprintFunctionLibrary : <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br></pre></td></tr></table></figure>
<ul>
<li>尽可能将节点标记为纯，可避免在节点上使用连线的执行引脚。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 0 和 最大 - 1 之间返回一致分配的随机数 */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">&quot;Math|Random&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">static</span> int32 <span class="title">RandomInteger</span><span class="params">(int32 Max)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将一个函数标记为 <code>const</code> 也可使蓝图节点不带执行引脚：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得 actor 到世界的转换。</span></span><br><span class="line"><span class="comment"> * @return 从 actor 空间转换到世界空间的转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;GetActorTransform&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">FTran</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/19082.html">http://liuke101.github.io/post/19082.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UEC/">UEC++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/1888.html" title="Unity编辑器扩展"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity编辑器扩展</div></div></a></div><div class="next-post pull-right"><a href="/post/19081.html" title="UEC++容器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UEC++容器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/28208.html" title="UE伤害系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UE伤害系统</div></div></a></div><div><a href="/post/28207.html" title="UE输入系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UE输入系统</div></div></a></div><div><a href="/post/8996.html" title="UEC++定时器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UEC++定时器</div></div></a></div><div><a href="/post/40918.html" title="UEC++基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UEC++基础API</div></div></a></div><div><a href="/post/33399.html" title="UEC++委托"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-14</div><div class="title">UEC++委托</div></div></a></div><div><a href="/post/19081.html" title="UEC++容器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">UEC++容器</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B1%9E%E6%80%A7-UPROPERTY"><span class="toc-text">一、属性 UPROPERTY</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E"><span class="toc-text">属性声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">属性说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-text">整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">作为位掩码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%B1%9E%E6%80%A7%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">整数属性位掩码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E6%95%B4%E6%95%B0%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">蓝图整数位掩码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%8D%E6%A0%87%E8%AE%B0%E5%90%8D%E7%A7%B0"><span class="toc-text">自定义位标记名称</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94"><span class="toc-text">布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB-UCLASS"><span class="toc-text">二、类 UCLASS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UCLASS-%E5%AE%8F"><span class="toc-text">1 UCLASS 宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">2 类说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TSubclassOf"><span class="toc-text">3 TSubclassOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-StaticClass-GetClass-ClassDefaultObject%EF%BC%88CDO%EF%BC%89"><span class="toc-text">4 StaticClass&#x2F;GetClass&#x2F;ClassDefaultObject（CDO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UClass-%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-text">UClass 和反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetClass"><span class="toc-text">GetClass ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetStaticClass"><span class="toc-text">GetStaticClass ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassDefaultObject"><span class="toc-text">ClassDefaultObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetClass-GetClass-GetClass"><span class="toc-text">GetClass ()-&gt;GetClass ()-&gt;GetClass ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%99%9A%E5%B9%BB%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7-UHT"><span class="toc-text">4 虚幻头文件工具 UHT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">头文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">5 头文件包含最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%BD%9C%E7%94%A8"><span class="toc-text">前向声明作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-text">深入前向声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E5%92%8C%E8%AF%A6%E7%BB%86%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">前向声明和详细类型说明符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E5%8C%85%E5%90%AB%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">以下类型必须包含在头文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93-USTRUCT"><span class="toc-text">三、结构体 USTRUCT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0USTRUCT"><span class="toc-text">实现USTRUCT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">结构体说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7"><span class="toc-text">最佳做法与技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-text">数据表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A5%E5%8F%A3-UINTERFACE"><span class="toc-text">四、接口 UINTERFACE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-text">1 接口声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">2 接口说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9C%A8-C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">3 在 C++中实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">4 声明接口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%85C-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">仅C++的接口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E5%8F%AF%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">蓝图可调用接口函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%A1%AE%E5%AE%9A%E7%B1%BB%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">5 确定类是否实现了接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-text">6 转换类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0-UFUNCTION"><span class="toc-text">五、函数 UFUNCTION</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">函数说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">函数参数说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exec-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8F%AF%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">Exec 控制台可调用函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8F%82%E6%95%B0-UPARAM"><span class="toc-text">六、参数 UPARAM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">七、元数据说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E7%AC%A6-1"><span class="toc-text">属性说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6-1"><span class="toc-text">函数说明符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%96%AD%E8%A8%80"><span class="toc-text">九、断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Check"><span class="toc-text">Check</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Verify"><span class="toc-text">Verify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ensure"><span class="toc-text">Ensure</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%93%9D%E5%9B%BE-API%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7"><span class="toc-text">创建蓝图 API：提示和技巧</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46645.html" title="GAS精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250017189.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAS精粹"/></a><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>