<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深度法线纹理 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="深度平台差异裁剪空间深度值裁剪空间坐标（也称为投影后空间坐标）在 Direct3D 类和 OpenGL 类平台之间有所不同：  Direct3D ：裁剪空间深度 Z值为 $[1,0]$。  OpenGL：裁剪空间深度 Z 值为 $[-1, 1]$。  在着色器代码内，可使用内置宏 UNITY_NEAR_CLIP_VALUE 来获取基于平台的近平面值。UNITY_NEAR_CLIP_VALUE 定义">
<meta property="og:type" content="article">
<meta property="og:title" content="深度法线纹理">
<meta property="og:url" content="http://liuke101.github.io/post/14314.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="深度平台差异裁剪空间深度值裁剪空间坐标（也称为投影后空间坐标）在 Direct3D 类和 OpenGL 类平台之间有所不同：  Direct3D ：裁剪空间深度 Z值为 $[1,0]$。  OpenGL：裁剪空间深度 Z 值为 $[-1, 1]$。  在着色器代码内，可使用内置宏 UNITY_NEAR_CLIP_VALUE 来获取基于平台的近平面值。UNITY_NEAR_CLIP_VALUE 定义">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-09-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.338Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/14314.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深度法线纹理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深度法线纹理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-27T16:00:00.000Z" title="发表于 2023-09-28 00:00:00">2023-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.338Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深度法线纹理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/14314.html#post-comment"><span class="waline-comment-count" data-path="/post/14314.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="深度平台差异"><a href="#深度平台差异" class="headerlink" title="深度平台差异"></a>深度平台差异</h1><h2 id="裁剪空间深度值"><a href="#裁剪空间深度值" class="headerlink" title="裁剪空间深度值"></a>裁剪空间深度值</h2><p>裁剪空间坐标（也称为投影后空间坐标）在 Direct3D 类和 OpenGL 类平台之间有所不同：</p>
<ul>
<li><p><strong>Direct3D</strong> ：裁剪空间深度 Z值为 $[1,0]$。</p>
</li>
<li><p><strong>OpenGL</strong>：裁剪空间深度 Z 值为 $[-1, 1]$。</p>
</li>
<li><p><strong>在着色器代码内，可使用内置宏 <code>UNITY_NEAR_CLIP_VALUE</code> 来获取基于平台的近平面值。</strong><code>UNITY_NEAR_CLIP_VALUE</code> 定义为近剪裁平面的值。 Direct3D 为 1.0，OpenGL 为–1.0</p>
</li>
<li><p>在脚本代码内，使用 <code>GL.GetGPUProjectionMatrix</code> 将 Unity 的坐标系（遵循 OpenGL 类约定）转换为 Direct3D 类坐标（如果这是平台所期望的）。</p>
</li>
</ul>
<h2 id="深度-Z-方向"><a href="#深度-Z-方向" class="headerlink" title="深度 (Z) 方向"></a>深度 (Z) 方向</h2><blockquote>
<p>[!hint] 现代平台 ：使用了 [[06 深度测试#^9bb785|Reversed direction技术]]，相比传统平台翻转了 Z 值<br><strong>DirectX 11，DirectX12，PS4，Xbox One，和 Metal:</strong> </p>
<ul>
<li>裁剪空间的 Z 值范围是 $[near,0]$（near 表示近平面距离，在远平面处减小到 0.0）。</li>
<li><strong>NDC 的 Z 值范围为 $[1,0]$，对应 ZBuffer 的取值范围也为 $[1,0]$</strong></li>
<li>Unity 定义了 <code>UNITY_REVERSED_Z</code> 宏定义，用于判断是否是使用翻转 z 方向的平台</li>
</ul>
</blockquote>
<blockquote>
<p>[!quote] 传统平台</p>
<ul>
<li>在旧版 Direct3D 类平台上，范围是 $[0,far]$（表示在近平面处为 0.0，在远平面处增加到远平面距离）。<ul>
<li>对应 NDC 的 Z 值值范围为 $[0,1]$</li>
</ul>
</li>
<li><strong>在 OpenGL 类平台上</strong>，裁剪空间的 Z 值范围是 $[-near,far]$。<ul>
<li>对应 NDC 的 Z 值值范围为 $[-1,1]$。</li>
<li>由于深度值应该是 0~1 的数，所以 Unity 对其将其转换为 $[0,1]$ 存入 ZBuffer</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>[!summary] Unity 深度纹理和 NDC 的深度的关系</p>
<ul>
<li>以 Unity OpenGL 平台为例， NDC 的的取值范围为 $[-1, 1]$ ，而深度纹理的取值范围为 $[0,1]$，两者的关系为  $d &#x3D; Z_{ndc} * 0.5 + 0.5$。</li>
<li>以 Unity  DX 平台为例， NDC 经过 Reverse-Z 的取值范围为 $[1, 0]$ ，深度纹理的取值范围为 $[1,0]$，两者的关系其实也符合为  $d &#x3D; Z_{ndc} * 0.5 + 0.5$。</li>
</ul>
</blockquote>
<ul>
<li>我们可以进行跨平台处理： [[#跨平台采样深度纹理]]，让所有平台的 ZBuffer 范围都是 $[0,1]$ 或 $[1,0]$</li>
</ul>
<h3 id="跨平台采样深度纹理"><a href="#跨平台采样深度纹理" class="headerlink" title="跨平台采样深度纹理"></a>跨平台采样深度纹理</h3><p>我们做东西肯定要考虑跨平台，前面提到了不同平台生成的深度图是不同的，如 DirctX 近到远是 1 到 0，OpenGL 近到远是 0 到 1，那么怎么统一采样的值呢？根据前面的介绍我们知道 DirctX 等平台之所以是 1 到 0 是因为 unity 为其做了反转，那么我们再把它们转回来不就得了么。而对于这些进行了深度反转的平台，unity 都定义了名为 <strong>UNITY_REVERSED_Z</strong> 的宏，<br><strong>如果想要各个平台 Zbuffer 都是 $[0,1]$：</strong></p>
<figure class="highlight c"><figcaption><span>title:方法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> depth = tex2D(_CameraDepthTexture, uvSS).r;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(UNITY_REVERSED_Z)</span></span><br><span class="line">    depth = <span class="number">1.0f</span> - depth;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>如果想要各平台 Zbuffer 都是 $[1,0]$：</strong></p>
<figure class="highlight c"><figcaption><span>title:方法二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    <span class="comment">// 具有 REVERSED_Z 的平台（如 D3D）的情况。</span></span><br><span class="line">    real depth = SampleSceneDepth(uvSS);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 没有 REVERSED_Z 的平台（如 OpenGL）的情况。</span></span><br><span class="line">    <span class="comment">// 调整 Z 以匹配 OpenGL 的 NDC</span></span><br><span class="line">    real depth = lerp(UNITY_NEAR_CLIP_VALUE, <span class="number">1</span>, SampleSceneDepth(uvSS));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用裁剪空间"><a href="#使用裁剪空间" class="headerlink" title="使用裁剪空间"></a>使用裁剪空间</h3><p>如果要手动使用裁剪空间 (Z) 深度，则可能还需要使用以下宏来抽象化平台差异：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> clipSpaceRange01 = UNITY_Z_0_FAR_FROM_CLIPSPACE(rawClipSpace);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：此宏不会改变 OpenGL 或 OpenGL ES 平台上的裁剪空间，因此在这些平台上，此宏返回“-near”1（近平面）到 far（远平面）之间的值。</p>
<h3 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h3><p>如果处于深度 (Z) 发生反转的平台上，则 <code>GL.GetGPUProjectionMatrix()</code> 返回一个还原了 z 的矩阵。但是，如果要手动从投影矩阵中进行合成（例如，对于自定义阴影或深度渲染），您需要通过脚本按需自行还原深度 (Z) 方向。</p>
<p>以下是执行此操作的示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowProjection = Matrix4x4.Ortho(...); <span class="comment">//阴影摄像机投影矩阵</span></span><br><span class="line"><span class="keyword">var</span> shadowViewMat = ...     <span class="comment">//阴影摄像机视图矩阵</span></span><br><span class="line"><span class="keyword">var</span> shadowSpaceMatrix = ... <span class="comment">//从裁剪空间到阴影贴图纹理空间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//当引擎通过摄像机投影计算设备投影矩阵时，</span></span><br><span class="line"><span class="comment">//&quot;m_shadowCamera.projectionMatrix&quot;被隐式反转</span></span><br><span class="line">m_shadowCamera.projectionMatrix = shadowProjection; </span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;shadowProjection&quot;在连接到&quot;m_shadowMatrix&quot;之前被手动翻转，</span></span><br><span class="line"><span class="comment">//因为它被视为着色器的其他矩阵。</span></span><br><span class="line"><span class="keyword">if</span>(SystemInfo.usesReversedZBuffer) </span><br><span class="line">&#123;</span><br><span class="line">    shadowProjection[<span class="number">2</span>, <span class="number">0</span>] = -shadowProjection[<span class="number">2</span>, <span class="number">0</span>];</span><br><span class="line">    shadowProjection[<span class="number">2</span>, <span class="number">1</span>] = -shadowProjection[<span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">    shadowProjection[<span class="number">2</span>, <span class="number">2</span>] = -shadowProjection[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    shadowProjection[<span class="number">2</span>, <span class="number">3</span>] = -shadowProjection[<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">    m_shadowMatrix = shadowSpaceMatrix * shadowProjection * shadowViewMat;</span><br></pre></td></tr></table></figure>

<h3 id="深度-Z-方向检查工具"><a href="#深度-Z-方向检查工具" class="headerlink" title="深度 (Z) 方向检查工具"></a>深度 (Z) 方向检查工具</h3><ul>
<li>使用 <code>SystemInfo.usesReversedZBuffer</code> 可确认所在平台是否使用反转深度 (Z)。</li>
</ul>
<h1 id="理论与推导"><a href="#理论与推导" class="headerlink" title="理论与推导"></a>理论与推导</h1><blockquote>
<p>[!note] 深度纹理<br>Depth Texture &#x3D; 深度纹理 &#x3D; 深度图<br>上面保存了深度缓冲区的值，是<strong>非线性深度</strong>，使用时要先转换成线性深度</p>
</blockquote>
<blockquote>
<p>[!note]  约定<br>本节采用 OpenGL 标准进行推导</p>
<ol>
<li>列向量</li>
<li>模型空间、世界空间、观察空间是右手坐标系，而裁剪空间与 NDC 是左手坐标系</li>
<li>Camera 的 LookAt （Forward）方向为 $- z$ 轴方向</li>
<li><strong>NDC 空间范围</strong> $[-1,1]^3$ </li>
<li>OpenGL 使用<strong>距离值</strong>表示 $n、f$。$n$ 被映射到 $-1$，$f$ 被映射到 $1$</li>
</ol>
</blockquote>
<p>深度是指像素到摄像机的距离，观察空间的深度为<strong>线性深度</strong>，NDC 空间的深度为<strong>非线性深度</strong>。</p>
<p><strong>当我们想要精确表达物体的深度差异或者重建像素世界坐标位置，就需要使用将非线性深度转化为线性深度。</strong></p>
<h2 id="非线性深度"><a href="#非线性深度" class="headerlink" title="非线性深度"></a>非线性深度</h2><p>假如在 MV 变换后，<strong>观察空间（View Space）</strong> 下的某个点对应的齐次坐标为 $(x,y,z,1)$，那么经过透视投影变换和 GPU 裁剪后转换到<strong>齐次裁剪空间（Clip Space）</strong>，变换过程如下：（该变换同样适用于 Unity，Unity 与 OpenGL 投影矩阵相同）</p>
<p>![[02 空间变换#^bgahra]]</p>
<p>我们只关注深度，即 $\displaystyle z’&#x3D;-(\frac{f+n}{f-n})z-\frac{2fn}{f-n}$</p>
<p>然后进行<strong>齐次除法</strong>转换到<strong>NDC 空间</strong><br>$$ z’’&#x3D;\frac{z’}{w’}&#x3D;(\frac{f+n}{f-n})+\frac{2fn}{(f-n)z}\tag{1}$$<br>$z’’$ 值范围为 $[-1,1]$ ，而 ZBuffer 中存储的值应该为 $[0,1]$，所以我们将 <strong>NDC 空间深度值（$z’’$ ）</strong> 的范围转换到 $[0,1]$：（$NonLinearDepth$ 与 $\displaystyle \frac{1}{z}$ 相关，是非线性的，即<strong>非线性深度</strong>）<br>$$NonLinearDepth &#x3D; z’’\times0.5+0.5&#x3D;\frac f{f-n}+\frac{2fn}{(f-n)\color\red{z}}\tag{2}$$<br>带入 $z&#x3D;n, z&#x3D;f$ 可得近平面 $NonLinearDepth$ 为 $1$，远平面 $NonLinearDepth$ 为 $0$</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359594.png" alt="Pasted image 20230708123806"></p>
<blockquote>
<p>范围转换前后对比，横轴为 z 值。可以看出靠近摄像机的十个单位占了 90%的深度缓冲区精度，故离摄像机越远的值精度越低</p>
</blockquote>
<h2 id="线性深度"><a href="#线性深度" class="headerlink" title="线性深度"></a>线性深度</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359595.png" alt="Pasted image 20230708110316"></p>
<blockquote>
<p>观察空间的深度为<strong>线性深度</strong></p>
</blockquote>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359596.png" alt="Pasted image 20230708152129"></p>
<blockquote>
<p>线性深度受 far 的影响</p>
</blockquote>
<p><strong>线性深度分为两种：</strong></p>
<ol>
<li>$LinearEyeDepth$：观察空间下的线性深度值，取值范围$[n, f]$</li>
<li>$Linear01Depth$：把线性深度归一化到$[0,1]$，我们通常会使用这个线性深度<br>$$<br>\begin{aligned}&amp;LinearEyeDepth&#x3D;-Pview.z\\&amp;Linear01Depth&#x3D;\frac{-Pview.z-n}{f-n}or\frac{-Pview.z}{f}\end{aligned}<br>$$</li>
</ol>
<p>由上一节方程（1）（2）可得：<br>$$ \begin{cases}z’’&#x3D;(\frac{f+n}{f-n})+\frac{2fn}{(f-n)z}  \<br>z’’ &#x3D; NonLinearDepth\times2-1\end{cases}$$<br>联立可以求出<br>$$z&#x3D;\frac1{(\frac{f-n}{fn}*NonlinearDepth-\frac1n)}$$<br>由于世界空间以 $-Z$ 为正方向，所以求深度需要取反得到正数：<br>$$LinearEyeDepth&#x3D;\frac{1}{(\frac{n-f}{fn}*NonlinearDepth+\frac1n)}$$</p>
<p>然后将 $LinearEyeDepth$ 除以 $f$ 即可得到归一化的线性深度 $Linear01Depth$<br>$$<br>\begin{aligned}Linear01Depth&amp;&#x3D;(\frac{1}{(\frac{n-f}{fn}*NonlinearDepth+\frac{1}{n})}\text{-n})&#x2F;(f\text{-n})\\or&amp;&#x3D;\frac{1}{(\frac{n-f}{n}*NonlinearDepth+\frac{f}{n})}\end{aligned}<br>$$ </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359597.png" alt="Pasted image 20230708152153"></p>
<blockquote>
<p>曲线对比图</p>
</blockquote>
<h2 id="深度纹理重建像素的世界空间坐标"><a href="#深度纹理重建像素的世界空间坐标" class="headerlink" title="深度纹理重建像素的世界空间坐标"></a>深度纹理重建像素的世界空间坐标</h2><h3 id="使用-VP-逆矩阵重建"><a href="#使用-VP-逆矩阵重建" class="headerlink" title="使用 VP 逆矩阵重建"></a>使用 VP 逆矩阵重建</h3><p>设 NDC 空间上的点 $P_{ndc}$ 映射到屏幕空间上为点 $P(x, y)$，$P (x, y)$ 点对应的<strong>屏幕 uv</strong> 为 $(u, v)$。<br>设 ${P.x&#x3D;u}<em>{Width}, {P.y&#x3D;v}</em>{Height}$</p>
<p>⭐<strong>1.  由屏幕空间转换到 NDC 空间</strong><br>从 NDC 空间到屏幕空间，点 P 相对于左下角坐标的比例是不变的，可以列出等式：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359598.png" alt="Pasted image 20230708152930"></p>
<p>$P_{ndc}. z$ 是 NDC 空间的深度，由前文， $P_{ndc}.z&#x3D;2*NonlinearDepth-1$</p>
<p><mark style="background: #FF5582A6;">则：</mark><br>$$<br>\begin{array}{lcr}P_{ndc}.x&#x3D;2<em>u-1\ P_{ndc}.y&#x3D;2</em>v-1\ P_{ndc}.z&#x3D;2*NonlinearDepth-1\ P_{ndc}.w&#x3D;1.0\end{array}<br>$$</p>
<p>⭐<strong>2. 由 NDC 空间转换到齐次裁剪空间</strong><br>由<mark style="background: #ADCCFFA6;">齐次除法</mark>可知 $\displaystyle \frac{Pclip}{Pclip.w}&#x3D;Pndc$，则<br>$$\displaystyle P_{clip}&#x3D;P_{ndc}*P_{clip}.w \tag{1}$$<br>⭐3. <strong>由齐次裁剪空间转换到世界空间</strong><br>因为 $P_{clip}$ 是由 $P_{world}$ 经过 $VP$ 矩阵变换得来，我们将 $VP$ 矩阵写作 $M$ ，则 $MP_{world} &#x3D; P_{clip}$，带入（1）<br>$$P_{world}&#x3D;M^{-1}P_{clip}&#x3D;M^{-1}P_{ndc}*P_{clip}.w\tag{2}$$</p>
<p>因为 $P_{world}&#x3D;(x,y,z,1)$ ，我们将其 $w$ 分量分量带入（2）<br>$$P_{world}.w&#x3D;({M^{-1}}P_{ndc}).w*P_{clip}.w&#x3D;1$$</p>
<p>$$P_{clip}.w&#x3D;{\frac1{(M^{-1}P_{ndc}).w}}\tag{3}$$</p>
<p>将（3）带入（2）即可得出世界空间坐标：<br>$$P_{world}&#x3D;\frac{M^{-1}P_{ndc}}{(M^{-1}P_{ndc}).w}$$<br>代码实现红线标记处即可： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 脚本获取VP逆矩阵</span></span><br><span class="line">Matrix4x4 ViewProjectionMatrix = renderingData.cameraData.camera.projectionMatrix * renderingData.cameraData.camera.worldToCameraMatrix;  </span><br><span class="line"></span><br><span class="line">Matrix4x4 ViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;  </span><br><span class="line">m_blitMaterial.SetMatrix(<span class="string">&quot;_ViewProjectionInverseMatrix&quot;</span>, ViewProjectionInverseMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 片元着色器中计算</span></span><br><span class="line"><span class="comment">//获取屏幕空间UV</span></span><br><span class="line">float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用屏幕UV采样屏幕深度纹理得到像素的非线性深度</span></span><br><span class="line"><span class="type">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, ScreenUV).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NDC空间坐标</span></span><br><span class="line">float4 currentPosNDC = float4(ScreenUV.x * <span class="number">2</span> - <span class="number">1</span>, ScreenUV.y * <span class="number">2</span> - <span class="number">1</span>, depth * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到世界空间坐标</span></span><br><span class="line">float4 D = mul(_ViewProjectionInverseMatrix, currentPosNDC);</span><br><span class="line">float4 currentPosWS = D / D.w;</span><br></pre></td></tr></table></figure>

<h3 id="使用摄像机射线构建"><a href="#使用摄像机射线构建" class="headerlink" title="使用摄像机射线构建"></a>使用摄像机射线构建</h3><p><strong>使用 VP 逆矩阵的方法需要在片元着色器中进行矩阵乘法，通常会影响性能。本节介绍的方法性能更好。</strong><br>首先对图像空间下的视锥体射线（从摄像机出发，指向图像上某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后把该射线和线性化后的观察空间下的深度相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_25415095/article/details/124764443"> Unity3D Shader系列之深度纹理重建世界坐标_textrue3d unity 切片重建</a><br>在某些情况下，我们需要<strong>屏幕后处理阶段</strong>得到像素点对应的世界坐标。如下图，我们在屏幕后处理阶段，想要知道屏幕空间中 $A1$ 点对应的世界坐标 $A$ 点。那么 $A$ 点该怎么求呢？<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359599.png" alt="Pasted image 20230709122334"></p>
<ul>
<li><p>@ <strong>已知条件：</strong></p>
<ol>
<li>$O$ 点的世界坐标（即相机的世界坐标）：<code>_WorldSpaceCameraPos</code> </li>
<li>$OD$ 的长度（观察空间的线性深度值 <code>linearEyeDepth</code>） ：可以采样深度纹理得到</li>
<li>透视相机的各项参数：<ul>
<li>近、远裁剪平面的值</li>
<li>视口角度 $FOV$</li>
<li>横纵比 $Aspect$</li>
</ul>
</li>
</ol>
</li>
<li><p>! $A$ 点的世界坐标 &#x3D; $O$ 点的世界坐标 + $\overrightarrow{OA}$，<strong>我们要做的就是求</strong> $\overrightarrow{OA}$ </p>
</li>
<li><p>% 主要步骤如下：</p>
</li>
</ul>
<ol>
<li>求 $\mathrm{\overrightarrow{OLT},\overrightarrow{OLB},\overrightarrow{ORT},\overrightarrow{ORB}}$（ $\overrightarrow {OLT}$ 即从相机指向 $LT$ 的向量）<ul>
<li>当顶点为 $LT$ 点（即屏幕左上角）时将 $\overrightarrow {OLT}$ 向量的值放置在顶点着色器输出结构体中</li>
<li>当顶点为 $LB$ 点（即在屏幕左下角）时将  $\overrightarrow {OLB}$ 放置在顶点着色器输出结构体中</li>
<li>当顶点为 $RT$ 点（即在屏幕右上角）时将  $\overrightarrow {ORT}$ 放置在顶点着色器输出结构体中</li>
<li>当顶点为 $RB$ 点（即在屏幕右下角）时将  $\overrightarrow {ORB}$  放置在顶点着色器输出结构体中<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359600.png" alt="Pasted image 20230709123140|500"></li>
</ul>
</li>
<li>利用 GPU 硬件的插值（顶点着色器的输出结构体会在三角形遍历阶段进行重心坐标插值，然后将插值后的值传递给片元着色器使用），得到 $\overrightarrow {OA1}$ </li>
<li>利用三角形的相似关系，可以得到 $\overrightarrow {OA}$</li>
</ol>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><ul>
<li>@ 求 $\mathrm{\overrightarrow{OLT},\overrightarrow{OLB},\overrightarrow{ORT},\overrightarrow{ORB}}$</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359601.png" alt="Pasted image 20230709121439"></p>
<p>为了方便计算，我们可以先计算两个向量——$toTop$ 和 $toRight$, 它们是<strong>起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量</strong>。它们的计算公式如下:<br>$$<br>halfHeight&#x3D;Near\times\tan\biggl(\frac{FOV}2\biggr)<br>$$<br>$$<br>to Top &#x3D; camera.up \times halfHeight<br>$$<br>$$<br>toRight &#x3D;camera.right \times halfHeight \cdot aspect<br>$$</p>
<blockquote>
<p>$camera.up$ 是单位向量，指向摄像机正上方，只是用来确定向量方向</p>
</blockquote>
<p>得到这两个辅助向量后，就可以计算 4 个角（图中的 TL、TR、BL、BR）相对于摄像机的方向了，只需要简单的向量运算：<br>$$<br>\begin{gathered}<br>\overrightarrow{OLT}&#x3D;camera.forward \cdot Near+to Top-to Right\<br>\overrightarrow{OLB}&#x3D;camera.forward·Near-toTop-toRight \<br>\overrightarrow{ORT}&#x3D;camera.forward·Near+toTop+toRight \<br>\overrightarrow{ORB}&#x3D;camera,forward\cdot Near-toTop+toRight<br>\end{gathered}<br>$$<br>注意这四个向量不仅包含了方向信息，它们的模对应了四个点到摄像机的距离。</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><ul>
<li>@ 利用 GPU 硬件的插值，得到 $\overrightarrow {OA1}$</li>
</ul>
<p>这一步是这种方法的核心。只有真正理解了这一步，才可以说是真正理解了这种方法。<br>我们先要明白什么是屏幕后处理。相机渲染完场景中所有物体后会得到一张渲染纹理，但是我们不直接把这张渲染纹理显示在屏幕上，而是额外对这张渲染纹理的每一个像素点进行处理一遍（这个过程就叫做屏幕后处理），然后将屏幕后处理的结果递到屏幕上。<br>屏幕后处理一般是通过额外渲染一个与屏幕大小相同的矩形网格来实现的。该网格只有 2 个三角面，共 4 个顶点，如下图。对每个像素的额外处理则会放到片元着色器中，具体处理的是哪一个像素用 uv 坐标来得到。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359602.png" alt="Pasted image 20230709124035"></p>
<p>我们知道，在渲染流水线中，GPU 会在三角形设置阶段对顶点着色器输出结构体中的值进行重心坐标插值，然后再传递给片元着色器，就像下图这样。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359603.png" alt="Pasted image 20230709124046"><br>也就是说，我们在步骤 1 中传递的 $\mathrm{\overrightarrow{OLT},\overrightarrow{OLB},\overrightarrow{ORT},\overrightarrow{ORB}}$ 经过 GPU 硬件的插值后，在片元着色器中将会得到（方向和长度通过重心坐标插值都能得到）。<br>这一步根本不用写代码，GPU 硬件已经实现了。</p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><ul>
<li>@ 利用三角形的相似关系，可以得到 $\overrightarrow {OA}$</li>
</ul>
<p>我们得到的线性深度值 <code>linearEyeDepth</code> 并非是摄像机的欧氏距离，而是在 $z$ 方向的距离。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359604.png" alt="Pasted image 20230709124513"></p>
<p>如图，以世界空间中的的 $A$ 点为例<br>$|OA|$ 是 A 点到摄像机的距离<br>$|OD|$ 为 A 点在观察空间的线性深度<br>$|OD1|$ 是相机的近裁剪平面距离</p>
<p>$\overrightarrow {OA1}$ 在第二步插值得到 ，用图中公式即可求得 $\overrightarrow {OA}$ </p>
<h4 id="代码（待验证）"><a href="#代码（待验证）" class="headerlink" title="代码（待验证）"></a>代码（待验证）</h4><p>首先在 C #中传递需要用到的向量 。（这里是用 RendererFeature 写的后处理）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCameraSetup</span>(<span class="params">CommandBuffer cmd, <span class="keyword">ref</span> RenderingData renderingData</span>)</span> &#123;  </span><br><span class="line">    Matrix4x4 view = renderingData.cameraData.GetViewMatrix();  </span><br><span class="line">    Matrix4x4 proj = renderingData.cameraData.GetProjectionMatrix();  </span><br><span class="line">    Matrix4x4 vp = proj * view;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将camera view space 的平移置为0，用来计算world space下相对于相机的vector  </span></span><br><span class="line">    Matrix4x4 cview = view;  </span><br><span class="line">    cview.SetColumn(<span class="number">3</span>, <span class="keyword">new</span> Vector4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));  </span><br><span class="line">    Matrix4x4 cviewProj = proj * cview;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算viewProj逆矩阵，即从裁剪空间变换到世界空间  </span></span><br><span class="line">    Matrix4x4 cviewProjInv = cviewProj.inverse;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算世界空间下，近平面四个角的坐标  </span></span><br><span class="line">    <span class="keyword">var</span> near = renderingData.cameraData.camera.nearClipPlane;  </span><br><span class="line">    <span class="comment">// Vector4 topLeftCorner = cviewProjInv * new Vector4(-near, near, -near, near);  </span></span><br><span class="line">    <span class="comment">// Vector4 topRightCorner = cviewProjInv * new Vector4(near, near, -near, near);    // Vector4 bottomLeftCorner = cviewProjInv * new Vector4(-near, -near, -near, near);    Vector4 topLeftCorner = cviewProjInv.MultiplyPoint(new Vector4(-1.0f, 1.0f, -1.0f, 1.0f));  </span></span><br><span class="line">    Vector4 topRightCorner = cviewProjInv.MultiplyPoint(<span class="keyword">new</span> Vector4(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>));  </span><br><span class="line">    Vector4 bottomLeftCorner = cviewProjInv.MultiplyPoint(<span class="keyword">new</span> Vector4(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算相机近平面上方向向量  </span></span><br><span class="line">    Vector4 cameraXExtent = topRightCorner - topLeftCorner;  </span><br><span class="line">    Vector4 cameraYExtent = bottomLeftCorner - topLeftCorner;  </span><br><span class="line"></span><br><span class="line">    near = renderingData.cameraData.camera.nearClipPlane;  </span><br><span class="line"></span><br><span class="line">    mMaterial.SetVector(mCameraViewTopLeftCornerID, topLeftCorner);  </span><br><span class="line">    mMaterial.SetVector(mCameraViewXExtentID, cameraXExtent);  </span><br><span class="line">    mMaterial.SetVector(mCameraViewYExtentID, cameraYExtent);  </span><br><span class="line">    mMaterial.SetVector(mProjectionParams2ID, <span class="keyword">new</span> Vector4(<span class="number">1.0f</span> / near, renderingData.cameraData.worldSpaceCameraPos.x, renderingData.cameraData.worldSpaceCameraPos.y, renderingData.cameraData.worldSpaceCameraPos.z));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Shader 中，进行还原。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据线性深度值和屏幕UV，还原世界空间下，相机到顶点的位置偏移向量</span></span><br><span class="line"><span class="function">half3 <span class="title">ReconstructViewPos</span>(<span class="params">float2 uv, <span class="built_in">float</span> linearEyeDepth</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Screen is y-inverted</span></span><br><span class="line">    uv.y = <span class="number">1.0</span> - uv.y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> zScale = linearEyeDepth * _ProjectionParams2.x; <span class="comment">// divide by near plane</span></span><br><span class="line">    float3 viewPos = _CameraViewTopLeftCorner.xyz + _CameraViewXExtent.xyz * uv.x + _CameraViewYExtent.xyz * uv.y;</span><br><span class="line">    viewPos *= zScale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">half4 <span class="title">Fragment</span>(<span class="params">Varyings input</span>) : SV_Target</span> &#123;</span><br><span class="line">    <span class="comment">// 采样深度缓冲区</span></span><br><span class="line">    <span class="built_in">float</span> rawDepth = SampleSceneDepth(input.uv);</span><br><span class="line">    <span class="comment">// 得到线性深度 [n, f]</span></span><br><span class="line">    <span class="built_in">float</span> linearDepth = LinearEyeDepth(rawDepth, _ZBufferParams);</span><br><span class="line">    <span class="comment">// 还原偏移向量</span></span><br><span class="line">    float3 vpos = ReconstructViewPos(input.uv, linearDepth);</span><br><span class="line">    <span class="comment">// 计算世界空间坐标</span></span><br><span class="line">    float3 wpos = _WorldSpaceCameraPos + vpos;</span><br><span class="line"></span><br><span class="line">    half3 color = wpos;</span><br><span class="line">    <span class="keyword">return</span> half4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Unity-深度法线纹理"><a href="#Unity-深度法线纹理" class="headerlink" title="Unity 深度法线纹理"></a>Unity 深度法线纹理</h1><h2 id="获取深度纹理"><a href="#获取深度纹理" class="headerlink" title="获取深度纹理"></a>获取深度纹理</h2><p>Unity 深度纹理存储了高精度的深度值，范围是 $[1,0]$，是非线性深度。</p>
<ul>
<li><p>@ 1 首先要开启 URP Asset -&gt;Depth Texture 并设置 Depth Texture Mode 为 Force Prepass 或 Depth Priming Mode 设置为 Auto 或Force<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359605.png" alt="Pasted image 20230707140918|450"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359606.png" alt="Pasted image 20230717212059|500"><br><strong>⭐方法二</strong>：RenderFeature 的 SetupRenderPasses 中设置 ConfigureInput，这样就可以采样到深度纹理了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_renderPass.ConfigureInput(ScriptableRenderPassInput.Depth);</span><br></pre></td></tr></table></figure>
</li>
<li><p>@ 2 采样深度纹理，计算线性深度<br><code>_CameraDepthTexture</code>：深度纹理<br><code>_ZBufferParams</code>：用于线性化 Z 缓冲区值。<code>x</code> 是 (1-near&#x2F;far)，<code>y</code> 是 (far&#x2F;near)，<code>z</code> 是 (x&#x2F;far)，<code>w</code> 是 (y&#x2F;far)。<br><code>LinearViewDepth</code>: 把深度纹理的采样结果转换成观察空间下的深度值，返回范围在 $[near, far]$ 的线性深度值<br><code>Linear01Depth</code>：返回范围在 $[0,1]$ 的线性深度值</p>
</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:手写</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明深度纹理</span></span><br><span class="line">TEXTURE2D(_CameraDepthTexture);  </span><br><span class="line">SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取屏幕空间UV</span></span><br><span class="line">float2 ScreenUV = i.positionCS.xy / _ScreenParams.xy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用屏幕UV采样屏幕深度纹理得到非线性深度，转换成0-1线性深度图</span></span><br><span class="line"><span class="built_in">float</span> depthColor = SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, ScreenUV).r;</span><br><span class="line"><span class="built_in">float</span> linearDepthColor = Linear01Depth(depthColor,_ZBufferParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算模型深度，转换成线性深度图</span></span><br><span class="line"><span class="built_in">float</span> depth = i.positionCS.z;</span><br><span class="line"><span class="built_in">float</span> linearDepth = Linear01Depth(depth,_ZBufferParams);</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:⭐直接调用api</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部声明了深度纹理_CameraDepthTexture</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取屏幕UV</span></span><br><span class="line"><span class="comment">//深度纹理是一个全屏（full-screen）纹理，它的尺寸和我们的屏幕相同,所以用屏幕UV采样，其他全屏纹理同理</span></span><br><span class="line">float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从深度纹理中采样深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    <span class="comment">// 具有 REVERSED_Z 的平台（如 D3D）的情况。</span></span><br><span class="line">    <span class="built_in">float</span> depth = SampleSceneDepth(ScreenUV); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 没有 REVERSED_Z 的平台（如 OpenGL）的情况。</span></span><br><span class="line">    <span class="built_in">float</span> depth = lerp(UNITY_NEAR_CLIP_VALUE, <span class="number">1</span>, SampleSceneDepth(uvSS));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成线性深度图</span></span><br><span class="line"><span class="built_in">float</span> linearDepthColor = Linear01Depth(depth,_ZBufferParams);</span><br></pre></td></tr></table></figure>

<ul>
<li>@ 3 深度图内对象添加 pass<br><strong>要想对象在深度纹理中显示，对象的 shader 需要加一个 pass：</strong><br>可以直接添加 Lit 内置的 pass，这种方法会打破 SRPBatcher 的，可以自己写一个来匹配 SRPBatcher 条件<figure class="highlight cs"><figcaption><span>fold title:Lit-DepthOnly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Name <span class="string">&quot;DepthOnly&quot;</span></span><br><span class="line">    Tags</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;DepthOnly&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Render State Commands</span></span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask R</span><br><span class="line">    Cull[_Cull]</span><br><span class="line"></span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> target 2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Shader Stages</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex DepthOnlyVertex</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment DepthOnlyFragment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Material Keywords</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local_fragment _ALPHATEST_ON</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Unity defined keywords</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_fragment _ LOD_FADE_CROSSFADE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------</span></span><br><span class="line">    <span class="comment">// GPU Instancing</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_instancing</span></span><br><span class="line">    <span class="meta">#include_with_pragmas &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Includes</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl&quot;</span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cs"><figcaption><span>fold title:手写-DepthOnly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//景深Pass</span></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Pass名称</span></span><br><span class="line">        Name <span class="string">&quot;DepthOnly&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//渲染目标</span></span><br><span class="line">        Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;DepthOnly&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启深度写入</span></span><br><span class="line">        ZWrite On</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试 正向前后排序</span></span><br><span class="line">        ZTest LEqual      </span><br><span class="line">        <span class="comment">//Greater &gt; , GEqual &gt;= , Less &lt; , LEqual &lt;= , Equal == , NotEqual != ,Always(永远渲染), Never(从不渲染);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只输出深度数据，以节省带宽</span></span><br><span class="line">        ColorMask <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HLSLPROGRAM  <span class="comment">//URP 程序块开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向顶点函数</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向面渲染函数</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//URP函数命令库</span></span><br><span class="line">        <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//源数据</span></span><br><span class="line">        <span class="keyword">struct</span> VertexInput</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原始物体空间顶点数据</span></span><br><span class="line">            float4 positionOS : POSITION;<span class="comment">//数据来源于（寄存器POSITION）</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点输出</span></span><br><span class="line">        <span class="keyword">struct</span> VertexOutput</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//物体裁切空间坐标</span></span><br><span class="line">            float4 positionCS : SV_POSITION;<span class="comment">//数据目标（寄存器SV_POSITION）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//世界空间顶点</span></span><br><span class="line">            float3 positionWS :  TEXCOORD0;<span class="comment">//数据目标（寄存器TEXCOORD0~7）</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顶点函数</span></span><br><span class="line">        <span class="function">VertexOutput <span class="title">vert</span>(<span class="params">VertexInput v</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//声明输出变量o</span></span><br><span class="line">            VertexOutput o;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输入物体空间顶点数据</span></span><br><span class="line">            VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS.xyz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取裁切空间顶点</span></span><br><span class="line">            o.positionCS = positionInputs.positionCS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取世界空间顶点</span></span><br><span class="line">            o.positionWS = positionInputs.positionWS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面渲染函数</span></span><br><span class="line">        <span class="function">float4 <span class="title">frag</span>(<span class="params">VertexOutput i</span>) : SV_Target</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出物体的世界空间顶点到摄像机距离</span></span><br><span class="line">            <span class="keyword">return</span> distance(i.positionWS.xyz , _WorldSpaceCameraPos.xyz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取深度-法线纹理"><a href="#获取深度-法线纹理" class="headerlink" title="获取深度+法线纹理"></a>获取深度+法线纹理</h2><ul>
<li>@ 1 开启深度法线纹理<br>方法一：（不推荐，消耗大）首先添加 SSAO RenderFeature，Source-&gt;Depth Normals<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359607.png" alt="Pasted image 20230717212229|500"><blockquote>
<p>这里也可单选 depth，来实现获取深度纹理</p>
</blockquote>
</li>
</ul>
<p><strong>⭐方法二</strong>：RenderFeature 的 SetupRenderPasses 中设置 ConfigureInput，这样就可以采样到法线纹理了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_renderPass.ConfigureInput(ScriptableRenderPassInput.Normal);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@ 2 采样深度+法线纹理</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在shader脚本中定义</span></span><br><span class="line">TEXTURE2D(_CameraDepthTexture);       SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line">TEXTURE2D(_CameraNormalsTexture);       SAMPLER(sampler_CameraNormalsTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接引用，内部声明了纹理和采样器</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐深度使用方法和上节一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐法线使用方法：</span></span><br><span class="line"><span class="comment">//屏幕空间uv  </span></span><br><span class="line">float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);</span><br><span class="line"><span class="comment">//采样即可</span></span><br><span class="line">float3 normal = SampleSceneNormals(ScreenUV);</span><br></pre></td></tr></table></figure>
</li>
<li><p>@ 3 法线图内对象添加 pass<br><strong>要想对象在法线纹理中显示，对象的 shader 需要加一个 pass：</strong><br>可以直接添加 Lit 内置的 pass，这种方法会打破 SRPBatcher 的，可以自己写一个来匹配 SRPBatcher 条件</p>
<figure class="highlight cs"><figcaption><span>fold title:DepthNormals</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This pass is used when drawing to a _CameraNormalsTexture texture</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Name <span class="string">&quot;DepthNormals&quot;</span></span><br><span class="line">    Tags</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;DepthNormals&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Render State Commands</span></span><br><span class="line">    ZWrite On</span><br><span class="line">    Cull[_Cull]</span><br><span class="line"></span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> target 2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Shader Stages</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex DepthNormalsVertex</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment DepthNormalsFragment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Material Keywords</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local _NORMALMAP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local _PARALLAXMAP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local_fragment _ALPHATEST_ON</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Unity defined keywords</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_fragment _ LOD_FADE_CROSSFADE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Universal Pipeline keywords</span></span><br><span class="line">    <span class="meta">#include_with_pragmas &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------</span></span><br><span class="line">    <span class="comment">// GPU Instancing</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_instancing</span></span><br><span class="line">    <span class="meta">#include_with_pragmas &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// Includes</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/LitDepthNormalsPass.hlsl&quot;</span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cs"><figcaption><span>fold title:手写-DepthNormals</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度法线Pass</span></span><br><span class="line">  Pass</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//Pass名字</span></span><br><span class="line">      Name <span class="string">&quot;DepthNormals&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//渲染目标深度法线</span></span><br><span class="line">      Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;DepthNormals&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//开启深度写入，这样就可以在模型渲染种获得正确层Mask</span></span><br><span class="line">      ZWrite On</span><br><span class="line"></span><br><span class="line">      <span class="comment">//深度测试 正向前后排序</span></span><br><span class="line">      ZTest LEqual</span><br><span class="line"></span><br><span class="line">      HLSLPROGRAM  <span class="comment">//URP 程序块开始</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//指向顶点函数</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//指向面渲染函数</span></span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//URP函数命令库</span></span><br><span class="line">      <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//源数据</span></span><br><span class="line">      <span class="keyword">struct</span> VertexInput</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//原始物体空间顶点数据</span></span><br><span class="line">          float4 positionOS : POSITION;<span class="comment">//数据来源于（寄存器POSITION）</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//顶点中的物体空间法线数据</span></span><br><span class="line">          float4 normalOS  : NORMAL;<span class="comment">//数据来源于（寄存器NORMAL）</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//顶点中的物体空间切线数据</span></span><br><span class="line">          float4 tangentOS  : TANGENT;<span class="comment">//数据来源于（寄存器TANGENT）</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//顶点输出</span></span><br><span class="line">      <span class="keyword">struct</span> VertexOutput</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//物体裁切空间坐标</span></span><br><span class="line">          float4 positionCS : SV_POSITION;<span class="comment">//数据目标（寄存器SV_POSITION）</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//世界空间顶点</span></span><br><span class="line">          float3 normalWS :  TEXCOORD0;<span class="comment">//数据目标（寄存器TEXCOORD0~7）</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//顶点函数</span></span><br><span class="line">      <span class="function">VertexOutput <span class="title">vert</span>(<span class="params">VertexInput v</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//声明输出变量o</span></span><br><span class="line">          VertexOutput o;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//输入物体空间顶点数据</span></span><br><span class="line">          VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS.xyz);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//获取裁切空间顶点</span></span><br><span class="line">          o.positionCS = positionInputs.positionCS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">//输入物体空间法线数据</span></span><br><span class="line">          VertexNormalInputs normalInputs = GetVertexNormalInputs(v.normalOS.xyz, v.tangentOS);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//获取世界空间法线</span></span><br><span class="line">          o.normalWS = normalInputs.normalWS;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//面渲染函数</span></span><br><span class="line">      <span class="function">float4 <span class="title">frag</span>(<span class="params">VertexOutput i</span>) : SV_Target</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//输出世界法线</span></span><br><span class="line">          <span class="keyword">return</span>  float4 (i.normalWS,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ENDHLSL  <span class="comment">//URP 程序块结束</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h1 id="深度纹理重建像素的世界空间位置"><a href="#深度纹理重建像素的世界空间位置" class="headerlink" title="深度纹理重建像素的世界空间位置"></a>深度纹理重建像素的世界空间位置</h1><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359608.gif" alt="202377141633"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>[[03 深度法线纹理#^hl5tio|原理手算]]<br>运用内置 API 更方便！</p>
<figure class="highlight c"><figcaption><span>title:使用深度纹理和屏幕空间UV坐标来重建像素的世界空间位置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用深度纹理和屏幕空间uv重建像素的世界空间位置</span></span><br><span class="line"><span class="comment">//屏幕空间uv</span></span><br><span class="line">float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);</span><br><span class="line"><span class="comment">//float2 ScreenUV = i.positionCS.xy / _ScaledScreenParams.xy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从深度纹理中采样深度，跨平台统一返回[1,0]深度值</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    <span class="comment">// 具有 REVERSED_Z 的平台（如 D3D）的情况。</span></span><br><span class="line">    <span class="type">float</span> depth = SampleSceneDepth (ScreenUV);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 没有 REVERSED_Z 的平台（如 OpenGL）的情况。</span></span><br><span class="line">    <span class="type">float</span> depth = lerp(UNITY_NEAR_CLIP_VALUE, <span class="number">1</span>, SampleSceneDepth(ScreenUV));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重建世界空间位置，注意，这里的深度为非线性深度</span></span><br><span class="line">float3 rebuildPosWS = ComputeWorldSpacePosition(ScreenUV, depth, UNITY_MATRIX_I_VP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在远裁剪面附近将颜色设置为黑色。</span></span><br><span class="line"><span class="comment">// #if UNITY_REVERSED_Z</span></span><br><span class="line"><span class="comment">//     if(depth &lt; 0.0001)</span></span><br><span class="line"><span class="comment">//         return half4(0,0,0,1);</span></span><br><span class="line"><span class="comment">// #else</span></span><br><span class="line"><span class="comment">//     if(depth &gt; 0.9999)</span></span><br><span class="line"><span class="comment">//         return half4(0,0,0,1);</span></span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>包含文件：DeclareDepthTexture. hlsl 文件包含用于对摄像机深度纹理进行采样的实用程序： <code>SampleSceneDepth</code> 返回 <code>[0, 1]</code> 范围内的 $Z$ 值。</p>
<figure class="highlight cs"><figcaption><span>title:包含文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含如下：已经声明了相机深度纹理，我们只需要传入屏幕空间uv调用采样函数</span></span><br><span class="line">TEXTURE2D_X_FLOAT(_CameraDepthTexture);  </span><br><span class="line">SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">SampleSceneDepth</span>(<span class="params">float2 uv</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoTransformScreenSpaceTex(uv)).r;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">LoadSceneDepth</span>(<span class="params">uint2 uv</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> LOAD_TEXTURE2D_X(_CameraDepthTexture, uv).r;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在片元着色器中计算用于采样深度纹理的屏幕空间 UV 坐标，像素位置除以渲染目标分辨率 <code>_ScaledScreenParams</code>。<code>_ScaledScreenParams.xy</code> 属性会考虑渲染目标的任何缩放，例如动态分辨率。</p>
<figure class="highlight c"><figcaption><span>title:用深度纹理和屏幕空间uv重建像素的世界空间位置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕空间uv  </span></span><br><span class="line">float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);</span><br><span class="line"><span class="comment">//float2 ScreenUV = i.positionCS.xy / _ScaledScreenParams.xy; 等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在片元着色器中，使用 <code>SampleSceneDepth</code> 函数对深度缓冲区进行采样。</p>
<figure class="highlight c"><figcaption><span>title:从深度纹理中采样深度</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    <span class="comment">// 具有 REVERSED_Z 的平台（如 D3D）的情况。</span></span><br><span class="line">    <span class="comment">//返回[1,0]的深度值</span></span><br><span class="line">    real depth = SampleSceneDepth(ScreenUV);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 没有 REVERSED_Z 的平台（如 OpenGL）的情况。</span></span><br><span class="line">    <span class="comment">// 调整 Z 以匹配 OpenGL 的 NDC([-1, 1])</span></span><br><span class="line">    real depth = lerp(UNITY_NEAR_CLIP_VALUE, <span class="number">1</span>, SampleSceneDepth(ScreenUV));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用像素的 UV 和 Z 坐标重建世界空间位置。</p>
<figure class="highlight c"><figcaption><span>title:重建世界空间位置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 rebuildPosWS = ComputeWorldSpacePosition(ScreenUV, depth, UNITY_MATRIX_I_VP);</span><br></pre></td></tr></table></figure>
<p><code>ComputeWorldSpacePosition</code> ：根据屏幕空间 UV 和深度 ($Z$) 值计算世界空间位置<br><code>UNITY_MATRIX_I_VP</code> 是一个逆观察投影矩阵，可将点从裁剪空间变换为世界空间。</p>
</li>
<li><p>对于未渲染几何图形的区域，深度缓冲区可能没有任何有效值。以下代码会在这些区域绘制黑色。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在远裁剪面附近将颜色设置为黑色。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    <span class="keyword">if</span>(depth &lt; <span class="number">0.0001</span>)</span><br><span class="line">        <span class="keyword">return</span> half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt; <span class="number">0.9999</span>)</span><br><span class="line">        <span class="keyword">return</span> half4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>不同的平台对远裁剪面使用不同的 Z 值（0 &#x3D;&#x3D; far，或 1 &#x3D;&#x3D; far）。<code>UNITY_REVERSED_Z</code> 常量让代码可以正确处理所有平台。</p>
</li>
<li><p><strong>对象要在重建的世界坐标中显示，需要添加深度法线纹理pass</strong></p>
</li>
</ol>
<h1 id="深度纹理重建法线"><a href="#深度纹理重建法线" class="headerlink" title="深度纹理重建法线"></a>深度纹理重建法线</h1><p>在了解如何用深度还原位置信息之后还原法线就非常容易了，其实对于一个着色点，<strong>只需要求出他的上下左右的位置信息，然后利用叉乘来近似计算该点的法线即可</strong>，伪代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 P  = GetViewPos(v2f_TexCoords);</span><br><span class="line">vec3 Pl = GetViewPos(v2f_TexCoords + vec2(-xOffset,<span class="number">0</span>));</span><br><span class="line">vec3 Pr = GetViewPos(v2f_TexCoords + vec2(xOffset,<span class="number">0</span>));</span><br><span class="line">vec3 Pu = GetViewPos(v2f_TexCoords + vec2(<span class="number">0</span>,yOffset));</span><br><span class="line">vec3 Pd = GetViewPos(v2f_TexCoords + vec2(<span class="number">0</span>,-yOffset));</span><br><span class="line">vec3 leftDir = min(P - Pl, Pr - P) ? P - Pl : Pr - P<span class="comment">//求出最小的变换量</span></span><br><span class="line">vec3 upDir   = min(P - Pd, Pu - P) ? P - Pd : Pu - P<span class="comment">//求出最小的变换量</span></span><br><span class="line">vec3 normal = normalize(cross(leftDir,upDir))</span><br></pre></td></tr></table></figure>

<p>求最小的变换向量是为了让法线的变换根据平滑一点，如果觉得采样太多也只需要采用x,y方向各一个点即可。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="深度相交高亮"><a href="#深度相交高亮" class="headerlink" title="深度相交高亮"></a>深度相交高亮</h2><h3 id="世界空间位置差"><a href="#世界空间位置差" class="headerlink" title="世界空间位置差"></a>世界空间位置差</h3><p>做交接边的思路：通过深度重建世界坐标，<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359609.png" alt="Pasted image 20230731225948"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359610.png" alt="Pasted image 20230801143415|500"></p>
<blockquote>
<p>要求深度图只渲染不透明物体，这样深度图记录的是 B 点的深度，进而重建出 B 点的世界坐标。</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 posDistance = saturate(distance(rebuildPosWS, i.positionWS) / _MaxDepth);</span><br></pre></td></tr></table></figure>

<h3 id="观察空间深度差"><a href="#观察空间深度差" class="headerlink" title="观察空间深度差"></a>观察空间深度差</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> DepthDifference = saturate(linearEyeDepth - i.positionCS.w / _MaxDepth);</span><br></pre></td></tr></table></figure>

<h2 id="护盾-能量场"><a href="#护盾-能量场" class="headerlink" title="护盾&#x2F;能量场"></a>护盾&#x2F;能量场</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359611.jpg" alt="TA101_作业_温斯顿的能量盾_3"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度交接出白边</span></span><br><span class="line"><span class="comment">//rebuildPosWS一般来说&gt;=i.positionWS</span></span><br><span class="line">float3 posDistance = saturate(distance(rebuildPosWS, i.positionWS) / _DepthFadeDistance);</span><br><span class="line"></span><br><span class="line">float3 whiteEdge = <span class="number">1</span> - posDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算过渡颜色</span></span><br><span class="line">float3 FadeColor = <span class="built_in">pow</span>(whiteEdge, _DepthFadePower) * _DepthFadeScale * _DepthFadeColor.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算边颜色</span></span><br><span class="line">float3 edge = step(_WhiteEdgeWidth, whiteEdge); <span class="comment">//Step得出离地近的边</span></span><br><span class="line">float3 edgeColor = edge * _WhiteEdgeColor.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//混合颜色</span></span><br><span class="line">float3 DepthEdgeColor = lerp(FadeColor, edgeColor, edge);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//护盾外部菲涅尔,内部无菲涅尔</span></span><br><span class="line"><span class="keyword">if</span> (facing &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> float4(DepthEdgeColor + fresnelColor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> float4(DepthEdgeColor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局雾效"><a href="#全局雾效" class="headerlink" title="全局雾效"></a>全局雾效</h2><p>思路是让雾的浓度随着深度值的增大而增大，然后进行的原图颜色和雾颜色的插值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">    float depth = UNITY_SAMPLE_DEPTH(tex2D(_CameraDepthTexture, i.uv.zw));</span><br><span class="line">    float linearDepth = Linear01Depth(depth);</span><br><span class="line">    float fogDensity = saturate(linearDepth * _FogDensity);</span><br><span class="line">    fixed4 finalColor = lerp(col, _FogColor, fogDensity);</span><br><span class="line">    return finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Depth/Shaders/Fog.shader">完整代码点这里</a></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359612.webp" alt="aa8f778ba81f5d48c2e06800891e7134_MD5"></p>
<p>Fog 场景</p>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><h3 id="深度扫线"><a href="#深度扫线" class="headerlink" title="深度扫线"></a>深度扫线</h3><ol>
<li><p>深度图中存的是深度值，减去一个对应的扫描线深度（整个深度图都的深度都减去这个值）。这样小于等于这个扫描线深度的部分值小于等于 0：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359613.png" alt="Pasted image 20230802161949|450"></p>
</li>
<li><p>取绝对值，扫描线位置就会变黑。加一个 saturate 防止过曝<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359614.png" alt="Pasted image 20230802162032"></p>
</li>
<li><p>除以 <code>_LineWidth</code>，<code>_LineWidth</code> &lt;1 时候越小，扫描线越细</p>
</li>
<li><p>最后 lerp 混合原图：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> linearEyeDepth = LinearEyeDepth(depth,_ZBufferParams);</span><br><span class="line"><span class="built_in">float</span> v = saturate(abs(linearEyeDepth-_ScanDepth)/_LineWidth);</span><br><span class="line"><span class="keyword">return</span> lerp(_ScanLineColor_,color,v);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359615.webp" alt="8a5f6b329c528a4a855e12d23f41a880_MD5"></p>
<h3 id="重建世界坐标画线"><a href="#重建世界坐标画线" class="headerlink" title="重建世界坐标画线"></a>重建世界坐标画线</h3><p>重建的世界坐标取小数+取余数，即可</p>
<p>得到世界坐标后，因为我们的坐标轴取值范围是从 -∞到 +∞，而颜色的范围只是 0-1 之间，如果对世界坐标使用 frac 取小数就可以得到只在 0-0.99 的值了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> float4(frac(rebuildPosWS),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359616.webp" alt="61fb3efd59dc2c6cf9b00ff81ee5c9b4_MD5"></p>
<p>取余数</p>
<p>对于在 0-1 之间均匀变换的我们想得到它的边界位置，所以直接来个 step 函数，我们只取 0.98 到 1.0 之间的值为 1，其他的值为 0，我们把它输出出来。是不是有那味了，线框就直接出来了。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359617.webp" alt="89da9b0159e843562f581518306b433d_MD5"></p>
<p>但是这个线框的颜色红蓝绿（为什么是红蓝绿？是因为它对应 XYZ 三个轴向）很乱而且不好看，我们想要自由控制颜色，我们定义三个颜色，去分别控制 XYZ 方向的线框颜色，并把它输出。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359618.webp" alt="248dd835198f5ef05b6c64552a6603ca_MD5"></p>
<h3 id="重建世界坐标扫线"><a href="#重建世界坐标扫线" class="headerlink" title="重建世界坐标扫线"></a>重建世界坐标扫线</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359619.webp" alt="042402eab80e213473b1cba5fbad412b_MD5"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x方向</span></span><br><span class="line"><span class="built_in">float</span> mask = saturate(pow(abs(frac(rebuildPosWS.x*_ScanSpace-_Time.y*_TimeSpeed)),_ScanPower))*_ScanScale;</span><br><span class="line"><span class="comment">//y方向</span></span><br><span class="line"><span class="built_in">float</span> mask = saturate(pow(abs(frac(rebuildPosWS.y*_ScanSpace-_Time.y*_TimeSpeed)),_ScanPower))*_ScanScale;</span><br><span class="line"><span class="comment">//z方向</span></span><br><span class="line"><span class="built_in">float</span> mask = saturate(pow(abs(frac(rebuildPosWS.z*_ScanSpace-_Time.y*_TimeSpeed)),_ScanPower))*_ScanScale;</span><br></pre></td></tr></table></figure>

<h2 id="水淹"><a href="#水淹" class="headerlink" title="水淹"></a>水淹</h2><p>利用上面提到的第二种重建世界空间坐标的方法得到世界空间坐标，判断该坐标的 Y 值是否在给定阈值下，如果是则混合原图颜色和水的颜色：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float3 rebuildPosWS = ComputeWorldSpacePosition(ScreenUV, depth, UNITY_MATRIX_I_VP);</span><br><span class="line"><span class="keyword">if</span>(rebuildPosWS.y&lt;_WaterHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lerp(finalColor,_WaterColor,_WaterColor.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405182359620.webp" alt="f72d713427cce38f7905b4f065e792dc_MD5"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/14314.html">http://liuke101.github.io/post/14314.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/42467.html" title="HLSL ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HLSL ShaderLab</div></div></a></div><div class="next-post pull-right"><a href="/post/62230.html" title="【图形系统10】色彩"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292341510.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【图形系统10】色彩</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/42466.html" title="CG ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">CG ShaderLab</div></div></a></div><div><a href="/post/17861.html" title="Renderer Feature"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-14</div><div class="title">Renderer Feature</div></div></a></div><div><a href="/post/42467.html" title="HLSL ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">HLSL ShaderLab</div></div></a></div><div><a href="/post/19285.html" title="材质脚本控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="title">材质脚本控制</div></div></a></div><div><a href="/post/56280.html" title="Shader Trick"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Shader Trick</div></div></a></div><div><a href="/post/32635.html" title="UV操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">UV操作</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82"><span class="toc-text">深度平台差异</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E5%80%BC"><span class="toc-text">裁剪空间深度值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6-Z-%E6%96%B9%E5%90%91"><span class="toc-text">深度 (Z) 方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%87%87%E6%A0%B7%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86"><span class="toc-text">跨平台采样深度纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4"><span class="toc-text">使用裁剪空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="toc-text">投影矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6-Z-%E6%96%B9%E5%90%91%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7"><span class="toc-text">深度 (Z) 方向检查工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8E%A8%E5%AF%BC"><span class="toc-text">理论与推导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">非线性深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">线性深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%E9%87%8D%E5%BB%BA%E5%83%8F%E7%B4%A0%E7%9A%84%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87"><span class="toc-text">深度纹理重建像素的世界空间坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-VP-%E9%80%86%E7%9F%A9%E9%98%B5%E9%87%8D%E5%BB%BA"><span class="toc-text">使用 VP 逆矩阵重建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E6%9C%BA%E5%B0%84%E7%BA%BF%E6%9E%84%E5%BB%BA"><span class="toc-text">使用摄像机射线构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">步骤 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="toc-text">步骤 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="toc-text">步骤 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%88%E5%BE%85%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="toc-text">代码（待验证）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity-%E6%B7%B1%E5%BA%A6%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-text">Unity 深度法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86"><span class="toc-text">获取深度纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6-%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-text">获取深度+法线纹理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%E9%87%8D%E5%BB%BA%E5%83%8F%E7%B4%A0%E7%9A%84%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E4%BD%8D%E7%BD%AE"><span class="toc-text">深度纹理重建像素的世界空间位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%E9%87%8D%E5%BB%BA%E6%B3%95%E7%BA%BF"><span class="toc-text">深度纹理重建法线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%9B%B8%E4%BA%A4%E9%AB%98%E4%BA%AE"><span class="toc-text">深度相交高亮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E4%BD%8D%E7%BD%AE%E5%B7%AE"><span class="toc-text">世界空间位置差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E5%B7%AE"><span class="toc-text">观察空间深度差</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A4%E7%9B%BE-%E8%83%BD%E9%87%8F%E5%9C%BA"><span class="toc-text">护盾&#x2F;能量场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%9B%BE%E6%95%88"><span class="toc-text">全局雾效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="toc-text">扫描线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%89%AB%E7%BA%BF"><span class="toc-text">深度扫线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%94%BB%E7%BA%BF"><span class="toc-text">重建世界坐标画线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E6%89%AB%E7%BA%BF"><span class="toc-text">重建世界坐标扫线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E6%B7%B9"><span class="toc-text">水淹</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46645.html" title="GAS精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250017189.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAS精粹"/></a><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/24808.html" title="蓝图精粹"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070002240.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝图精粹"/></a><div class="content"><a class="title" href="/post/24808.html" title="蓝图精粹">蓝图精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>