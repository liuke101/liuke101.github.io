<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UEC++指针 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1 ObjectPtr [!bug] Title  声明 UObject 指针的地方都可以用 TObjectPtr 替换 但是函数返回类型仍然要使用原始指针！   在 UE5 中，新增了对象指针类型 FObjectPtr&#x2F;TObjectPtr，以提供编辑器下动态解析和访问追踪功能。很多引擎类的 UPROPERTY 的 UObject* 的裸指针也被替换成了 TObjectPtr&lt;UObjec">
<meta property="og:type" content="article">
<meta property="og:title" content="UEC++指针">
<meta property="og:url" content="http://liuke101.github.io/post/3180.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="1 ObjectPtr [!bug] Title  声明 UObject 指针的地方都可以用 TObjectPtr 替换 但是函数返回类型仍然要使用原始指针！   在 UE5 中，新增了对象指针类型 FObjectPtr&#x2F;TObjectPtr，以提供编辑器下动态解析和访问追踪功能。很多引擎类的 UPROPERTY 的 UObject* 的裸指针也被替换成了 TObjectPtr&lt;UObjec">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-09-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-24T16:20:43.852Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="UEC++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/3180.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UEC++指针',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-25 00:20:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UEC++指针</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-07T16:00:00.000Z" title="发表于 2023-09-08 00:00:00">2023-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-24T16:20:43.852Z" title="更新于 2024-08-25 00:20:43">2024-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/">虚幻引擎</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UEC++指针"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/3180.html#post-comment"><span class="waline-comment-count" data-path="/post/3180.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-ObjectPtr"><a href="#1-ObjectPtr" class="headerlink" title="1 ObjectPtr"></a>1 ObjectPtr</h1><blockquote>
<p>[!bug] Title</p>
<ul>
<li>声明 UObject 指针的地方都可以用 TObjectPtr 替换</li>
<li>但是函数返回类型仍然要使用原始指针！</li>
</ul>
</blockquote>
<p>在 UE5 中，新增了对象指针类型 <code>FObjectPtr/TObjectPtr</code>，以提供编辑器下动态解析和访问追踪功能。很多引擎类的 UPROPERTY 的 <code>UObject*</code> 的裸指针也被替换成了 <code>TObjectPtr&lt;UObject&gt;</code>（例如 AActor 的 RootComponent 成员）。<br>而在非编辑器下，<code>TObjectPtr&lt;UObject &gt;</code> 会退化为 <code>UObject*</code>，从而避免额外的运行时开销。</p>
<p>本文将从源码的角度对 FObjectPtr&#x2F;TObjectPtr 对象指针的原理做一些简要的分析，并提供使用建议以及示例代码。</p>
<h2 id="动机：为什么要引入-FObjectPtr-TObjectPtr-对象指针类"><a href="#动机：为什么要引入-FObjectPtr-TObjectPtr-对象指针类" class="headerlink" title="动机：为什么要引入 FObjectPtr&#x2F;TObjectPtr 对象指针类"></a>动机：为什么要引入 FObjectPtr&#x2F;TObjectPtr 对象指针类</h2><p>在 UE4 中，很多引擎类型的成员是 UObject* 裸指针，其中只记录内存地址。由于内存地址在每次运行时都会发生变化，这就给编辑器下的序列化静态保存、延迟加载等带来了不便。此外，裸指针也不能提供访问追踪功能，这会在对 UObject 进行访问 Debug 时带来极大的不便：需要事先封装 Getter&#x2F;Setter 函数（若在出现 Bug 后再封装则需要涉及代码重构，成本很大），且不能追踪反射等非直接的访问。</p>
<p>由于 UE5 放弃了对 32 位系统的支持，从而只考虑 64 位的指针。而在现有的硬件条件下，寻址空间不可能将指针的 64 位全部用完。因此，这 64 位就可以用来存储额外的信息：这样就可以把 UObject 的静态引用关系编码到这 64 位中，运行时再解析为内存地址。同时，在这种封装中，就可以在访问变量等需要 Debug 的时机加入 Hook 点，这样就可以很方便的通过注册 Hook 函数进行 Debug。</p>
<p>而在另一方面，在不需要 Debug 的情况下（如 Release 版本），这些封装与 Hook 等新引入的特性不应带来额外的性能开销，它们的效用应该与 UObject * 裸指针没有区别。</p>
<p><strong>由此，FObjectPtr 的特性应该包含以下方面：</strong></p>
<ol>
<li><strong>信息封装</strong>：将 Object 的静态信息封装到 64 位中，以便序列化静态保存、延迟加载等。</li>
<li><strong>动态解析</strong>：将封装的 64 位信息可以在运行时解析为<code> UObject*</code> 指针。</li>
<li><strong>Debug 追踪</strong>：在对 <code>FObjectPtr</code> 进行访问和动态解析时，可以通过 Hook 的方式获取此次访问 &#x2F; 解析的信息以供 Debug。</li>
<li><strong>还原</strong>：在如 Release 等不需要上述功能的情况下，FObjectPtr 应退化为 UObject* 裸指针，不应增加额外性能开销。</li>
</ol>
<ul>
<li><strong>此外，根据当前 UE5.0 release 版的源码，<code>TObjectPtr&lt;&gt;</code>只保留了 “Debug 追踪” 和“还原”功能的对象指针，而不再直接提供 “信息封装” 和“动态解析”功能</strong>，原因见后文<strong>信息封装</strong>中 <strong>“FObjectPtr 与 TObjectPtr”</strong> 部分。</li>
</ul>
<p>按目前 UE5 的引擎设计，“信息封装”、“动态解析”、“Debug 追踪”功能仅在编辑器下启用，即表示启用信息封装 &#x2F; 动态解析的宏 UE_WITH_OBJECT_HANDLE_LATE_RESOLVE 以及启用 Debug 追踪的宏 UE_WITH_OBJECT_HANDLE_TRACKING 均被定义为 WITH_EDITORONLY_DATA。因此，后文中用 “编辑器下” 表示启用 FObjectPtr&#x2F;TObjectPtr 的额外功能，而 “非编辑器下” 表示其被还原为 UObject * 裸指针。</p>
<h2 id="信息封装"><a href="#信息封装" class="headerlink" title="信息封装"></a>信息封装</h2><p>FObjectPtr&#x2F;TObjectPtr 中，可以封装有 UObject 的静态信息（主要是所在 Package 的名字，以及自身的名字 Path 等），从而提供序列化静态保存、延迟加载等方面的功能。<br>可以看到，TObjectPtr 对象指针 private 继承自 FObjectPtr，没有自己的数据成员；而 FObjectPtr 唯一的成员仅有 FObjectHandle 类型的 Handle，且 FObjectHandle 在编辑器下也仅有一个 UPTRINT 类型的成员 PointerOrRef（UPTRINT 可以看作是 uint64 的一个别名），而在非编辑器下直接定义为 UObject * 裸指针：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007101.png"></p>
<p>↑ <strong>正因如此，<code>FObjectPtr/TObjectPtr</code> 在编辑器下不再像<code> UObject*</code> 裸指针一样，仅仅只持有 <code>UObject</code> 对象的内存地址，而是根据指针值的最低位进行区分</strong>：如果最低位不是 1，则其表示真实的内存地址，此时与 <code>UObject* </code>裸指针没有区别；反之其中保存编码后的 <code>UObject</code> 的静态信息，如所属 Package 的 FName、引用关系（即 UObject 的 Path 等）。而封装这些信息的方式也较为直接，即使用 “<strong>全局容器中存储这些信息数据</strong>”+“<strong>将信息在全局容器中的索引编码到 64 位</strong>” 的方式。</p>
<h3 id="UObject-中信息封装到-FObjectPtr-TObjectPtr-的过程"><a href="#UObject-中信息封装到-FObjectPtr-TObjectPtr-的过程" class="headerlink" title="UObject 中信息封装到 FObjectPtr&#x2F;TObjectPtr 的过程"></a>UObject 中信息封装到 FObjectPtr&#x2F;TObjectPtr 的过程</h3><p>UObject 中信息封装到 FObjectPtr&#x2F;TObjectPtr 的过程如下图所示：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007102.png"></p>
<p><em><em>_UObject</em> → FObjectRef：提取并封装名字等静态信息_</em>*</p>
<p>将 UObject * 中信息封装到 FObjectRef 由 MakeObjectRef () 函数实现，FObjectRef 中包含了 UObject 对象及其所在 Package 的名字信息等：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007103.png"></p>
<p>↑ 这里会使用 Object-&gt;GetOutermost ()、Object-&gt;GetClass ()-&gt;ClassGeneratedBy 等函数提取 UObject 的信息，而其引用关系则保存在 FObjectPathId 类型的 ObjectPath 中。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007104.png"></p>
<p>↑ FObjectPathId 的构造器中会调用 StoreObjectPathId () 函数，其中会向上遍历引用链，并将引用链上每一个对象的 Name 存储到全局数组 GComplexPaths 中，然后将其在 GComplexPaths 中的索引移位后存入 FObjectPathId 唯一的数据成员 PathId。</p>
<p>当然，由于 FObjectRef 所需的信息均是字符串，在已知 UObject 静态信息的情况下也可以<strong>手动构建 FObjectRef</strong>，示例可见 \ Engine\Source\Runtime\CoreUObject\Private\Tests\ObjectPtrTest. cpp：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007105.png"></p>
<p><strong><em>FObjectRef → FPackedObjectRef：将名字信息编码到 64 位</em></strong></p>
<p>可以看到，编码同样是使用 “全局容器存储数据 + index 索引” 的方法，其原理简单来说，就是全局容器 GObjectHandleIndex 中保存各个 Package 的信息，而 Package 信息中保存着 UObject 的信息。这样一来，使用 32 位 PackageID 即可快速找到 UObject 所在 Package 对应的容器，然后使用用 32 位 ObjectID 从 Package 对应容器中找到对象信息。</p>
<p>从源码实现可知，将 FObjectRef 中的名字信息编码到 64 位，并保存到 FPackedObjectRef:: EncodedRef 中是通过 MakePackedObjectRef () 函数实现，而 MakePackedObjectRef () 会调用到 ObjectHandle_Private:: MakeReferenceIds ()，将 FObjectRef 中的信息编码为 FPackageId 和 FObjectId。具体数据结构可以从下面的代码与图中看到，FObjectRef 中的信息可以映射为 FObjectHandlePackageData，所有 FObjectHandlePackageData 保存在 GObjectHandleIndex 的数组成员 <code>TArray&lt;FObjectHandlePackageData&gt; </code>PackageData 中。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007106.png"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007108.png"></p>
<p>此外，GObjectHandleIndex 还有另一个 TMap&lt;&gt; 成员 NameToPackageId，可以将 PackageName 映射为 PackageId。调用 ObjectHandle_Private:: MakeReferenceIds () 时会先去 NameToPackageId 中找是否已经添加过，若未添加则根据 FObjectRef 中的中的 Package 信息创建 FObjectHandlePackageData 并添入 GObjectHandleIndex. PackageData 并获得 OutPackageId；之后也是同样的方式，在获得的 FObjectHandlePackageData 的 TMap&lt;&gt; PathToObjectId 中查找是否已经将 UObject 的信息添入（若没有则添入），并获得 OutObjectId。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007109.png"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007110.png"></p>
<p>最后，调用 Pack () 函数将 32 位的 OutPackageId 和 OutObjectId 调用 Pack () 合并放入 FPackedObjectRef:: EncodedRef 成员，即完成了编码过程。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007111.png"></p>
<p><strong><em>FPackedObjectRef → FObjectHandle → FObjectPtr&#x2F;TObjectPtr：仅拷贝 64 位值信息</em></strong></p>
<p>此时，在 FPackedObjectRef 中已经获得了 64 位的信息编码，之后从 FPackedObjectRef 到 FObjectHandle 以及 FObjectPtr&#x2F;TObjectPtr 仅是用对应的函数拷贝数据即可。这样一来，UObject 中的信息就已经封装在了 FObjectPtr&#x2F;TObjectPtr 中。</p>
<h3 id="FObjectPtr-与-TObjectPtr"><a href="#FObjectPtr-与-TObjectPtr" class="headerlink" title="FObjectPtr 与 TObjectPtr"></a>FObjectPtr 与 TObjectPtr</h3><p>根据源码，TObjectPtr&lt;&gt;对象指针 private 继承自 FObjectPtr，但只允许从 UObject * 和其他 TObjectPtr&lt;&gt;进行赋值 &#x2F; 初始化，且没有提供 “信息封装” 和“动态解析”功能的相关接口函数（FObjectPtr 向 TObjectPtr&lt;&gt;的转换函数 FObjectPtr:: ToTObjectPtr ()已被标注为已废弃 DEPRECATED）—— 也就是说，正常情况下 TObjectPtr&lt;&gt;在初始化时获得的只可能是 UObject * 指针信息，而不是封装后的名字索引 Handle。因此<strong>可以将 <code>TObjectPtr&lt;&gt;</code>视为只保留了 “Debug 追踪” 和“还原”功能的对象指针。</strong></p>
<p>此外，若需要用 FObjectPtr 中已封装的信息初始化 TObjectPtr&lt;&gt;，则应手动完成动态解析 FObjectPtr 后获取 UObject * 指针，然后用 UObject * 裸指针对 TObjectPtr&lt;&gt; 进行初始化。动态解析 FObjectPtr 的过程见下一节。</p>
<h2 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h2><p>对 <code>FObjectPtr/TObjectPtr</code> 进行<strong>解引用</strong>时，会通过运算符重载调用到其 <code>Get()</code>函数。在此过程中，会通过 IsObjectHandleResolved () 函数判断其最低位是否为 1：如果不是则说明其中 Handle 保存的是 UObject * 裸指针，直接返回使用；如果不是则需要执行解析 Resolve 过程，将编码的 64 位信息还原为 UObject * 裸指针。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007112.png"></p>
<p>动态解析基本过程为 “<strong>HandleId → 名字 &#x2F; Path → UObject * 指针</strong>”，其调用栈如下所示：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007113.png"></p>
<ul>
<li>动态解析过程由 ResolvePackedObjectRef () 函数完成，其将 FPackedObjectRef 的 64 位编码信息解析为 UObject * 裸指针并返回，其由 MakeObjectRef () 和 ResolveObjectRef () 两个部分组成。</li>
<li>MakeObjectRef () 将 FPackedObjectRef 的 64 位编码解析为 FObjectRef，主要通过内部调用 ObjectHandle_Private:: MakeObjectRef () 函数完成。其过程基本就是上文信息封装中 FObjectRef 编码为 FPackedObjectRef 的逆过程，即通过 ID 从全局容器 GObjectHandleIndex 中获取 Package 和 Object 的名字信息等。</li>
<li>ResolveObjectRef () 则是通过 ObjectPath.Resolve () 从 GComplexPaths 获取对象的名字数组，并使用 UObjectHash 引擎对象管理的接口 FindOrLoadPackage () 及 StaticFindObjectFastInternal () 通过名字找到 UObject 及其 Package，然后将获得的 UObject * 裸指针返回。</li>
<li>最后，使用获得的 UObject * 裸指针替换 FObjectPtr&#x2F;TObjectPtr 的 Handle，这样下次访问时就无需再次解析。</li>
</ul>
<h2 id="访问追踪-动态解析追踪"><a href="#访问追踪-动态解析追踪" class="headerlink" title="访问追踪 &#x2F; 动态解析追踪"></a>访问追踪 &#x2F; 动态解析追踪</h2><p>FObjectPtr&#x2F;TObjectPtr 在编辑器下提供了 Hook 接口，使得可以很方便地在 FObjectPtr&#x2F;TObjectPtr 每次访问和动态解析时进行输出日志等 Debug 操作。</p>
<h3 id="访问追踪"><a href="#访问追踪" class="headerlink" title="访问追踪"></a>访问追踪</h3><p>访问追踪可以在每次 FObjectPtr&#x2F;TObjectPtr 进行 Get ()（包含 -&gt;、* 运算符重载，其都会调用 Get () 函数）时时获取 Debug 信息。</p>
<p>可以通过 SetObjectHandleReadCallback () 接口注册 Hook 函数：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007114.png"></p>
<p>在编辑器下调用 FObjectPtr&#x2F;TObjectPtr 的 Get () 时，会通过 ResolveObjectHandle () 调用 ObjectHandle_Private:: OnHandleRead ()。其中会调用已注册的 Hook 函数，并将访问的 UObject 作为参数透传：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007115.png"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007116.png"></p>
<p>↑ 具体示例可以参考 \ Engine\Source\Editor\UnrealEd\Private\Cooker\PackageBuildDependencyTracker. cpp 中的 FPackageBuildDependencyTracker:: StaticOnObjectHandleRead (UObject* ReadObject) 函数。</p>
<h3 id="动态解析追踪"><a href="#动态解析追踪" class="headerlink" title="动态解析追踪"></a>动态解析追踪</h3><p>同样的，在对 Class 和 Object 进行 Resolve 时，也可以通过 SetObjectHandleClassResolvedCallback () 和 SetObjectHandleReferenceResolvedCallback () 注册 Hook 函数，例如：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007117.png"></p>
<h2 id="非编辑器下-FObjectPtr-TObjectPtr-的还原"><a href="#非编辑器下-FObjectPtr-TObjectPtr-的还原" class="headerlink" title="非编辑器下 FObjectPtr&#x2F;TObjectPtr 的还原"></a>非编辑器下 FObjectPtr&#x2F;TObjectPtr 的还原</h2><p>在非编辑器下，UE_WITH_OBJECT_HANDLE_LATE_RESOLVE 和 UE_WITH_OBJECT_HANDLE_TRACKING 宏会被置 0。此时 FObjectPtr&#x2F;TObjectPtr 中唯一数据成员 FObjectHandle 被 using 为 UObject<em>，此时其退化为对应类型 UObject</em> 的裸指针，从而避免额外的运行时开销。以下是 Get () 函数的展开写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FORCEINLINE UObject* Get () const &#123;</span><br><span class="line">	return ResolveObjectHandle (Handle)</span><br><span class="line">	&#123;</span><br><span class="line">		return ReadObjectHandlePointerNoCheck (Handle)</span><br><span class="line">		&#123;</span><br><span class="line">			&#123; return Handle; &#125;	//此时 using FObjectHandle = UObject*;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>↑ 可以看到，在函数内联编译后，其效用与裸指针无异。</p>
<p>此外，一些其他相关函数也会在非编辑器下由变化，如 IsObjectHandleResolved () 会始终返回 true（理所应当，因为 FObjectPtr&#x2F;TObjectPtr 只保存裸指针），ResolveObjectHandleNoRead () 也会直接调用 ReadObjectHandlePointerNoCheck () 等。</p>
<h2 id="对反射的影响"><a href="#对反射的影响" class="headerlink" title="对反射的影响"></a>对反射的影响</h2><h3 id="对于生成代码和类型注册：生成特殊的-FProperty-子类型"><a href="#对于生成代码和类型注册：生成特殊的-FProperty-子类型" class="headerlink" title="对于生成代码和类型注册：生成特殊的 FProperty 子类型"></a>对于生成代码和类型注册：生成特殊的 FProperty 子类型</h3><p>我们在类中声明以下两个 UPROPERTY：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span> (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">UStaticMeshComponent* rawPtrComponent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span> (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">TObjectPtr&lt;UStaticMeshComponent&gt; objPtrComponent;</span><br></pre></td></tr></table></figure>

<p>启动 UHT 后，在其 gen. cpp 中生成的，用于创建其 FProperty 的参数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UECodeGen_Private:: FObjectPropertyParams Z_Construct_UClass_ATryTObjPtr_Statics:: NewProp_rawPtrComponent = &#123; <span class="string">&quot;rawPtrComponent&quot;</span>, <span class="literal">nullptr</span>, (EPropertyFlags) <span class="number">0x001000000008000d</span>, UECodeGen_Private::EPropertyGenFlags:: Object, RF_Public|RF_Transient|RF_MarkAsNative, <span class="number">1</span>, <span class="built_in">STRUCT_OFFSET</span> (ATryTObjPtr, rawPtrComponent), Z_Construct_UClass_UStaticMeshComponent_NoRegister, <span class="built_in">METADATA_PARAMS</span> (Z_Construct_UClass_ATryTObjPtr_Statics:: NewProp_rawPtrComponent_MetaData, <span class="built_in">UE_ARRAY_COUNT</span> (Z_Construct_UClass_ATryTObjPtr_Statics::NewProp_rawPtrComponent_MetaData)) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> UECodeGen_Private:: FObjectPtrPropertyParams Z_Construct_UClass_ATryTObjPtr_Statics:: NewProp_objPtrComponent = &#123; <span class="string">&quot;objPtrComponent&quot;</span>, <span class="literal">nullptr</span>, (EPropertyFlags) <span class="number">0x001400000008000d</span>, UECodeGen_Private::EPropertyGenFlags:: Object | UECodeGen_Private::EPropertyGenFlags:: ObjectPtr, RF_Public|RF_Transient|RF_MarkAsNative, <span class="number">1</span>, <span class="built_in">STRUCT_OFFSET</span> (ATryTObjPtr, objPtrComponent), Z_Construct_UClass_UStaticMeshComponent_NoRegister, <span class="built_in">METADATA_PARAMS</span> (Z_Construct_UClass_ATryTObjPtr_Statics:: NewProp_objPtrComponent_MetaData, <span class="built_in">UE_ARRAY_COUNT</span> (Z_Construct_UClass_ATryTObjPtr_Statics::NewProp_objPtrComponent_MetaData)) &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>除了变量名之外，唯一的区别</strong>就是在初始化 FObjectPropertyParams 的第四个成员 EPropertyGenFlags Flags 时，使用或运算添加了 UECodeGen_Private::EPropertyGenFlags:: ObjectPtr 标记。在为这些 UPROPERTY 构建 FProperty 对象时，则会为其生成 FObjectPtrProperty 子类而不是 FObjectProperty（如果是 <code>TObjectPtr&lt;UClass&gt;</code> 则会生成 FClassPtrProperty 而不是 FClassProperty）。FObjectPtrProperty 继承自 FObjectProperty（FClassPtrProperty 也同样继承自 FClassProperty），其中覆写了一些接口函数，如 SerializeItem () 等。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070007118.png"></p>
<h3 id="对于-Cast-类型转换：可以直接当作裸指针使用"><a href="#对于-Cast-类型转换：可以直接当作裸指针使用" class="headerlink" title="对于 Cast&lt;&gt;() 类型转换：可以直接当作裸指针使用"></a>对于 Cast&lt;&gt;() 类型转换：可以直接当作裸指针使用</h3><p>在 \ Engine\Source\Runtime\CoreUObject\Public\Templates\Casts. h 中可以看到，<code>Cast&lt;&gt;()</code> 类型转换函数为 <code>TObjectPtr&lt;&gt;</code> 创建了单独的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class U&gt; </span><br><span class="line">FORCEINLINE T* Cast (const TObjectPtr&lt;U&gt;&amp; Src) </span><br><span class="line">&#123; </span><br><span class="line">    return TCastImpl&lt;U, T&gt;:: DoCast ((const FObjectPtr&amp;) Src); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在其 DoCast 的实现版本中，则是将 TObjectPtr&lt;&gt; 通过 ResolveObjectHandleNoRead () 解析为 UObject * 裸指针，然后再按照裸指针的逻辑进行 Cast 类型转换，如 ECastType:: UObjectToUObject 版本的类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FORCEINLINE static To* DoCast ( UObject* Src ) //UObject*裸指针版本 &#123;</span><br><span class="line">	return Src &amp;&amp; Src-&gt;IsA&lt;To&gt;() ? (To*) Src : nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEINLINE static To* DoCast ( const FObjectPtr&amp; Src ) //FObjectPtr&amp;TObjectPtr&lt;&gt;版本 &#123;</span><br><span class="line">	UObject* SrcObj = ResolveObjectHandleNoRead (Src.GetHandleRef ());</span><br><span class="line">	if (SrcObj &amp;&amp; SrcObj-&gt;IsA&lt;To&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		ObjectHandle_Private:: OnHandleRead (SrcObj);</span><br><span class="line">		return (To*) SrcObj;</span><br><span class="line">	&#125;</span><br><span class="line">	return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在捕获 <code>Cast&lt;&gt;</code> 返回值时，用裸指针和 <code>TObjectPtr&lt;&gt;</code> 均可</strong>，因为 Cast 返回裸指针，而 <code>TObjectPtr&lt;&gt;</code> 可以由 <code>UObject*</code> 隐式转换得到。</p>
<h3 id="对于通过字符串获取-FProperty-并访问成员变量：应使用-TObjectPtr-获取反射解析后的指针，而不是-T-二级指针"><a href="#对于通过字符串获取-FProperty-并访问成员变量：应使用-TObjectPtr-获取反射解析后的指针，而不是-T-二级指针" class="headerlink" title="对于通过字符串获取 FProperty 并访问成员变量：应使用 TObjectPtr&lt;T&gt;* 获取反射解析后的指针，而不是 T** 二级指针"></a>对于通过字符串获取 FProperty 并访问成员变量：应使用 <code>TObjectPtr&lt;T&gt;* </code>获取反射解析后的指针，而不是 <code>T**</code> 二级指针</h3><p>如果 <code>TObjectPtr&lt;T&gt; </code>成员对象是 IsResolved 的，则其中信息与 <code>UObject*</code> 裸指针没有区别，此时即使使用 <code>T**</code> 二级指针也不会有问题；但如果是没有 Resolve 的，则会触发断言崩溃。示例代码（完整的示例代码见文章最后）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">FObjectRef ObjRef = MakeObjectRef (objPtrComponent.Get ());</span><br><span class="line">FObjectPtr fObjPtr (ObjRef);</span><br><span class="line">oriObjPtrComponent = fObjPtr.ToTObjectPtr ();</span><br><span class="line"></span><br><span class="line">//&#123;	//反射 TObjectPtr（二级指针）: 崩溃！！！</span><br><span class="line">//	FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;oriObjPtrComponent&quot;));</span><br><span class="line">//	UObject** reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;UObject*&gt;(this);</span><br><span class="line">//	if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">//	&#123;</span><br><span class="line">//		UE_LOG (LogTemp, Log, TEXT (&quot;This is objPtrComponent: %s %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">//	&#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">&#123;	//反射 TObjectPtr（TObjectPtr&lt;UStaticMeshComponent&gt;）</span><br><span class="line">	FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;oriObjPtrComponent&quot;));</span><br><span class="line">	TObjectPtr&lt;UObject&gt;* reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;TObjectPtr&lt;UObject&gt;&gt;(this);</span><br><span class="line">	if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">	&#123;</span><br><span class="line">		UE_LOG (LogTemp, Log, TEXT (&quot;This is TObjectPtr&lt;UStaticMeshComponent&gt;: %s  %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objPtrComponent = Cast&lt;UStaticMeshComponent&gt;(oriObjPtrComponent);</span><br><span class="line"></span><br><span class="line">&#123;	//反射 TObjectPtr（二级指针）此时已经 Resolve 过，不会崩溃</span><br><span class="line">	FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;objPtrComponent&quot;));</span><br><span class="line">	UStaticMeshComponent** reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;UStaticMeshComponent*&gt;(this);</span><br><span class="line">	if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">	&#123;</span><br><span class="line">	UE_LOG (LogTemp, Log, TEXT (&quot;This is objPtrComponent: %s %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;	//反射 TObjectPtr（TObjectPtr&lt;UStaticMeshComponent&gt;）</span><br><span class="line">	FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;objPtrComponent&quot;));</span><br><span class="line">	TObjectPtr&lt;UStaticMeshComponent&gt;* reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;TObjectPtr&lt;UStaticMeshComponent&gt;&gt;(this);</span><br><span class="line">	if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">	&#123;</span><br><span class="line">		UE_LOG (LogTemp, Log, TEXT (&quot;This is TObjectPtr&lt;UStaticMeshComponent&gt;: %s  %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对于-TMap-等容器类及委托函数的影响"><a href="#对于-TMap-等容器类及委托函数的影响" class="headerlink" title="对于 TMap&lt;&gt; 等容器类及委托函数的影响"></a>对于 TMap&lt;&gt; 等容器类及委托函数的影响</h3><p>如官方文档 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/en-US/unreal-engine-5-migration-guide/">https://docs.unrealengine.com/5.0/en-US/unreal-engine-5-migration-guide/</a> 所说，类似于 <code>TMap&lt;int32,TObjectPtr&lt;UStaticMeshComponent&gt;&gt;</code> 类型的容器类使用 Find () 函数时，catch 返回值的局部变量应与容器声明中的类型一致，即 <code>TObjectPtr&lt;UStaticMeshComponent&gt;*</code> 而非 <code>UStaticMeshComponent**</code>，否则编译报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//UStaticMeshComponent** foundComp = ObjPtrMap.Find (1); //无法通过编译</span><br><span class="line">TObjectPtr&lt;UStaticMeshComponent&gt;* foundComp = ObjPtrMap.Find (1);</span><br><span class="line">if (foundComp &amp;&amp; *foundComp)</span><br><span class="line">&#123;</span><br><span class="line">	UE_LOG (LogTemp, Log, TEXT (&quot;This is ObjPtrMap.Find (1): %s&quot;), *(*foundComp)-&gt;GetPathName ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于原先声明参数为裸指针类型的委托，则需要像官方文档示例那样修改参数类型，或者重新写一个包装函数并透传参数（来自官方文档）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Original function signature, using raw pointers, which we will use in most cases:</span><br><span class="line">static bool MyFunction (UObject* FirstParameter);</span><br><span class="line"></span><br><span class="line">// In rare cases where implicit conversion is not available, use this pass-through function.</span><br><span class="line">// Pass-through function signature, using TObjectPtr:</span><br><span class="line">static bool MyFunction (TObjectPtr&lt;UObject&gt; FirstParameter);</span><br><span class="line"></span><br><span class="line">// Pass-through function body (in the source file):</span><br><span class="line">bool UMyClass:: MyFunction (TObjectPtr&lt;UObject&gt; FirstParameter)</span><br><span class="line">&#123;</span><br><span class="line">    return ShouldShowResetToDefault (FirstParameter.Get ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul>
<li><strong>对于需要进行访问追踪的 UPROPERTY 成员变量，可以使用 <code>TObjectPtr&lt;T&gt;</code> 替换裸指针；</strong></li>
<li><strong>对于函数参数、局部指针变量等，则建议使用 <code>UObject*</code> 裸指针。</strong></li>
<li>在进行容器 Find 时、反射访问变量时，捕获类型应与变量声明的类型保持一致，不宜混用 <code>TObjectPtr&lt;T&gt;*</code> 和<code> T**</code>。</li>
<li>注册的 Hook 函数由于访问频次通常会很高，应保证在大多数情况下的低开销。</li>
</ul>
<h2 id="附：完整测试示例代码"><a href="#附：完整测试示例代码" class="headerlink" title="附：完整测试示例代码"></a>附：完整测试示例代码</h2><h3 id="TryTObjPtr-h"><a href="#TryTObjPtr-h" class="headerlink" title="TryTObjPtr. h"></a>TryTObjPtr. h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal. h&quot;</span><br><span class="line">#include &quot;GameFramework/Actor. h&quot;</span><br><span class="line">#include &quot;TryTObjPtr. generated. h&quot;</span><br><span class="line"></span><br><span class="line">UCLASS ()</span><br><span class="line">class MYFPS_API ATryTObjPtr : public AActor</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_BODY ()</span><br><span class="line">	</span><br><span class="line">public:	</span><br><span class="line">	// Sets default values for this actor&#x27;s properties</span><br><span class="line">	ATryTObjPtr ();</span><br><span class="line"></span><br><span class="line">	UPROPERTY (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	UStaticMeshComponent* rawPtrComponent;</span><br><span class="line"></span><br><span class="line">	UPROPERTY (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UStaticMeshComponent&gt; objPtrComponent;</span><br><span class="line"></span><br><span class="line">	UPROPERTY (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	TMap&lt;int32,TObjectPtr&lt;UStaticMeshComponent&gt;&gt; ObjPtrMap;</span><br><span class="line"></span><br><span class="line">	UPROPERTY (EditAnywhere, BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UObject&gt; oriObjPtrComponent;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	// Called when the game starts or when spawned</span><br><span class="line">	virtual void BeginPlay () override;</span><br><span class="line"></span><br><span class="line">public:	</span><br><span class="line">	// Called every frame</span><br><span class="line">	virtual void Tick (float DeltaTime) override;</span><br><span class="line"></span><br><span class="line">	UFUNCTION (BlueprintCallable)</span><br><span class="line">	void TryReflectionPtr ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TryTObjPtr-cpp"><a href="#TryTObjPtr-cpp" class="headerlink" title="TryTObjPtr. cpp"></a>TryTObjPtr. cpp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="line"></span><br><span class="line">#include &quot;TryTObjPtr. h&quot;</span><br><span class="line">#include &quot;Kismet/GameplayStatics. h&quot;</span><br><span class="line"></span><br><span class="line">ATryTObjPtr:: ATryTObjPtr ()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick. bCanEverTick = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ATryTObjPtr:: BeginPlay ()</span><br><span class="line">&#123;</span><br><span class="line">	Super:: BeginPlay ();</span><br><span class="line">	UGameplayStatics:: GetPlayerController (this, 0)-&gt;EnableInput (nullptr);	//启用键盘事件，方便调用入口函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ATryTObjPtr:: Tick (float DeltaTime)</span><br><span class="line">&#123;</span><br><span class="line">	Super:: Tick (DeltaTime);</span><br><span class="line"></span><br><span class="line">	if (UGameplayStatics:: GetPlayerController (this, 0)-&gt;WasInputKeyJustPressed (EKeys::C))	//按下键盘 C 键时调用测试代码入口函数</span><br><span class="line">	&#123;</span><br><span class="line">		TryReflectionPtr ();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ATryTObjPtr:: TryReflectionPtr ()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;	//反射原始指针</span><br><span class="line">		FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;rawPtrComponent&quot;));</span><br><span class="line">		UStaticMeshComponent** reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;UStaticMeshComponent*&gt;(this);</span><br><span class="line">		if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">		&#123;			</span><br><span class="line">			UE_LOG (LogTemp, Log, TEXT (&quot;This is TryReflectionPtr: %s&quot;), *(*reflectComp)-&gt;GetPathName ());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//测试 FObjectRef 动态解析功能</span><br><span class="line">	FObjectRef ObjRef = MakeObjectRef (objPtrComponent.Get ());</span><br><span class="line">	FObjectPtr fObjPtr (ObjRef);</span><br><span class="line">	oriObjPtrComponent = fObjPtr.ToTObjectPtr ();</span><br><span class="line"></span><br><span class="line">	//&#123;	//反射 TObjectPtr（二级指针）: 崩溃！！！</span><br><span class="line">	//	FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;oriObjPtrComponent&quot;));</span><br><span class="line">	//	UObject** reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;UObject*&gt;(this);</span><br><span class="line">	//	if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">	//	&#123;</span><br><span class="line">	//		UE_LOG (LogTemp, Log, TEXT (&quot;This is objPtrComponent: %s %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">	//	&#125;</span><br><span class="line">	//&#125;</span><br><span class="line"></span><br><span class="line">	&#123;	//反射 TObjectPtr（TObjectPtr&lt;UStaticMeshComponent&gt;）</span><br><span class="line">		FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;oriObjPtrComponent&quot;));</span><br><span class="line">		TObjectPtr&lt;UObject&gt;* reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;TObjectPtr&lt;UObject&gt;&gt;(this);</span><br><span class="line">		if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">		&#123;</span><br><span class="line">			UE_LOG (LogTemp, Log, TEXT (&quot;This is TObjectPtr&lt;UStaticMeshComponent&gt;: %s  %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	objPtrComponent = Cast&lt;UStaticMeshComponent&gt;(oriObjPtrComponent);</span><br><span class="line"></span><br><span class="line">	&#123;	//反射 TObjectPtr（二级指针）此时已经 Resolve 过，不会崩溃</span><br><span class="line">		FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;objPtrComponent&quot;));</span><br><span class="line">		UStaticMeshComponent** reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;UStaticMeshComponent*&gt;(this);</span><br><span class="line">		if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">		&#123;</span><br><span class="line">			UE_LOG (LogTemp, Log, TEXT (&quot;This is objPtrComponent: %s %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;	//反射 TObjectPtr（TObjectPtr&lt;UStaticMeshComponent&gt;）</span><br><span class="line">		FProperty* reflectVar = this-&gt;GetClass ()-&gt;FindPropertyByName (TEXT (&quot;objPtrComponent&quot;));</span><br><span class="line">		TObjectPtr&lt;UStaticMeshComponent&gt;* reflectComp = reflectVar-&gt;ContainerPtrToValuePtr&lt;TObjectPtr&lt;UStaticMeshComponent&gt;&gt;(this);</span><br><span class="line">		if (reflectComp &amp;&amp; *reflectComp)</span><br><span class="line">		&#123;</span><br><span class="line">			UE_LOG (LogTemp, Log, TEXT (&quot;This is TObjectPtr&lt;UStaticMeshComponent&gt;: %s  %p %p&quot;), *(*reflectComp)-&gt;GetPathName (), reflectComp, *reflectComp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		//UStaticMeshComponent** foundComp = ObjPtrMap.Find (1); //无法通过编译</span><br><span class="line">		TObjectPtr&lt;UStaticMeshComponent&gt;* foundComp = ObjPtrMap.Find (1);</span><br><span class="line">		if (foundComp &amp;&amp; *foundComp)</span><br><span class="line">		&#123;</span><br><span class="line">			UE_LOG (LogTemp, Log, TEXT (&quot;This is ObjPtrMap.Find (1): %s&quot;), *(*foundComp)-&gt;GetPathName ());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		UE_LOG (LogTemp, Log, TEXT (&quot;This is objPtrComponent.GetPath (): %s&quot;), *objPtrComponent.GetPath ());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UE 智能指针不能用于 <code>UObject</code> 及其派生类。<strong>常用于 <code>Uobject</code> 系统外的数据对象（比如自己创建的类）</strong><br>引擎具有 <code>UObject</code> 管理的单独内存管理系统（<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/unreal-object-handling-in-unreal-engine">对象处理</a>文档），两个系统未互相重叠。</p>
<h3 id="智能指针类型"><a href="#智能指针类型" class="headerlink" title="智能指针类型"></a>智能指针类型</h3><p>智能指针可影响其包含或引用对象的寿命。不同智能指针对对象有不同的限制和影响。下表可用于协助决定各类型智能指针的适用情况：</p>
<p>共享指针：最常用的指针, 用来存储。</p>
<p>共享引用</p>
<ul>
<li>共享引用永远不会为 null，且总是可以进行解引用。</li>
<li>共享指针的性能消耗最小。所有操作所占时间都是固定的。</li>
</ul>
<p>弱指针</p>
<ol>
<li>弱指针允许您安全地检查一个对象是否已经被销毁。</li>
<li>使用弱引用来断开引用循环。<br>缺点: 最慢</li>
</ol>
<h3 id="智能指针优点"><a href="#智能指针优点" class="headerlink" title="智能指针优点"></a>智能指针优点</h3><p><strong>为什么原则使用 UE 智能指针：</strong></p>
<ol>
<li>C++原生智能指针不是在所有平台上都可用。UE 智能指针可以跨平台。</li>
<li>可以和其他虚客器及类型无缝地协作。</li>
<li>更好地控制平台特性、包括线程处理和优化。</li>
<li>我们想提供线程安全的功能以获得好的性能。</li>
<li>我们想在性能方面有更多的控制权 (内联函数、内存、虚函数的应用等)。</li>
<li>在不需要的时候倾向于不引入新的第三方依赖。</li>
</ol>
<table>
<thead>
<tr>
<th>优点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>防止内存泄漏</strong></td>
<td>共享引用不存在时，智能指针（弱指针除外）会自动删除对象。</td>
</tr>
<tr>
<td><strong>弱引用</strong></td>
<td>弱指针会中断引用循环并阻止悬挂指针。</td>
</tr>
<tr>
<td><strong>可选择的线程安全</strong>）</td>
<td>虚幻智能指针库包括线程安全代码，可跨线程管理引用计数。如无需线程安全，可用其换取更好性能。</td>
</tr>
<tr>
<td><strong>运行时安全</strong></td>
<td>共享引用从不为空，可固定随时取消引用。</td>
</tr>
<tr>
<td><strong>授予意图</strong></td>
<td>可轻松区分对象所有者和观察者。</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>智能指针在 64 位下仅为 C++指针大小的两倍（加上共享的 16 字节引用控制器）。唯一指针除外，其与 C++指针大小相同。</td>
</tr>
</tbody></table>
<p><strong>在性能上的优势</strong></p>
<ol>
<li>所有运算均为常量时间。</li>
<li>共享指针解引用的速度和 C+指针一样快。</li>
<li>复制共享指针永远不会分配内存。</li>
<li>线程安全的版本是无锁的。</li>
<li>和 STL 相比，其实现更快。</li>
</ol>
<p><strong>劣势</strong></p>
<ol>
<li>创建和复制智能指针比创建和复制原始 C++指针需要更多开销</li>
<li>保持引用计数增加基本运算的周期</li>
<li>共享指针使用的内存比 C++指针多</li>
<li>引用控制器有两个堆分配。使用 <code>MakeShared</code> 代替 <code>MakeShareable</code> 可避免二次分配，并可提高性能。</li>
<li>由多个共享指针引用的每个独立对象都有性能消耗。</li>
<li>弱指针访问速度比共享指针访问速度略慢。</li>
</ol>
<p><strong>内存使用情况（在 32 位操作系统）</strong></p>
<ol>
<li>所有的共享指针 (TSharedPtr，TSharedRef，TWeakPtr)都占 8 个字节当针对 32 一位系统编译时)</li>
<li>C 指针 (无符号 32 位整型)</li>
<li>引用控制器指针无符号 32 位整型)</li>
<li>TSharedFromThis 也占 8 个字节, 因为它内嵌了弱指针&#x2F;</li>
</ol>
<p><strong>引用控制器（当针对 32-位系统编译时）</strong></p>
<ol>
<li>引用控制器对象占 12 个字节</li>
<li>C+指针无符号 32 位整型)</li>
<li>共享引用计数 (无符号 32 位整型)</li>
<li>弱引]用计数 (无符号 32 位整型)<br>注意: 无论有多少个共享指针&#x2F;弱指针引用一个对象，都仅为每个对象创建一个引用控制器。.</li>
</ol>
<h2 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h2><blockquote>
<p>[!NOTE] 共享指针（强指针）<br><strong>共享指针（Shared Pointers）</strong> 是指既健壮、又能为空指针的智能指针。<strong>共享指针沿袭了普通智能指针的所有优点</strong>，它能避免出现内存泄漏、悬挂指针，还能避免指针指向未初始化的内存。</p>
<p><strong>还有一些其他特点</strong>：</p>
<ul>
<li><strong>共享所有权（Shared Ownership）：</strong> 引用计数支持多个共享指针，以确保它们引用的数据对象永远不被删除，前提是它们中的任意一个仍指向数据对象。</li>
<li><strong>自动失效（Automatic Invalidation）：</strong> 你可安全引用易变对象，无需担心出现悬挂指针。</li>
<li><strong>弱引用：</strong> 弱指针可中断引用循环。</li>
<li><strong>意向指示（Indication of Intent）：</strong> 区分拥有者（参见<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.2/zh-CN/shared-references-in-unreal-engine">共享引用</a>）和观察者，并提供不可为空的引用。</li>
</ul>
<p><strong>共享指针有一些值得注意的基本特性，包括：</strong></p>
<ul>
<li>语法非常健壮</li>
<li>非侵入性（但能反射）</li>
<li>线程安全（视情况而定）</li>
<li>性能佳，占用内存少</li>
</ul>
<blockquote>
<p>[!NOTE] 非侵入性<br><strong>共享指针是非侵入性的，即对象不知道其是否为智能指针拥有</strong>。</p>
</blockquote>
</blockquote>
<p><strong>共享指针类似于共享引用，<font color="#ff0000">主要区别在于共享指针可以指向空对象，共享引用不可为空</font>。</strong><br>除非需要空对象或可为空的对象，否则建议你<strong>优先选择共享引用</strong>。</p>
<h3 id="1-声明和初始化"><a href="#1-声明和初始化" class="headerlink" title="1 声明和初始化"></a>1 声明和初始化</h3><p><strong>共享指针可为空</strong>，所以无论有无数据对象，都可以对它们进行初始化。</p>
<ul>
<li>**<code>MakeShared&lt;T&gt;() / MakeShareable() </code> ：创建共享指针</li>
<li>MakeShared：在单个内存块中分配新的对象实例和引用控制器，但要求对象提供公共构造函数。</li>
<li>MakeShareable：效率较低，但即使对象的构造函数是私有的也可以工作，使您能够获得不是您创建的对象的所有权，并在删除对象时支持自定义行为。</li>
<li>注意<strong>只能用于动态分配内存！<code>new</code></strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空白的共享指针</span></span><br><span class="line">TSharedPtr&lt;FMyObjectType&gt; EmptyPointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为新对象创建共享指针</span></span><br><span class="line"><span class="function">TSharedPtr&lt;FMyObjectType&gt; <span class="title">NewPointer</span><span class="params">(<span class="keyword">new</span> FMyObjectType())</span></span>; </span><br><span class="line">TSharedPtr&lt;FMyObjectType&gt; NewPointer = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FMyObjectType</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从共享引用创建共享指针</span></span><br><span class="line"><span class="function">TSharedRef&lt;FMyObjectType&gt; <span class="title">NewReference</span><span class="params">(<span class="keyword">new</span> FMyObjectType())</span></span>;</span><br><span class="line">TSharedPtr&lt;FMyObjectType&gt; PointerFromReference = NewReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程安全的共享指针</span></span><br><span class="line">TSharedPtr&lt;FMyObjectType, ESPMode::ThreadSafe&gt; NewThreadsafePointer = <span class="built_in">MakeShared</span>&lt;FMyObjectType, ESPMode::ThreadSafe&gt;(MyArgs);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-复制-转移"><a href="#2-复制-转移" class="headerlink" title="2 复制&#x2F;转移"></a>2 复制&#x2F;转移</h3><p><strong>复制共享指针时，系统将向它引用的对象添加一个引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加对象ExistingSharedPointer引用的引用数。</span></span><br><span class="line">TSharedPtr&lt;FMyObjectType&gt; AnotherPointer = ExistingSharedPointer;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>使用 <code>MoveTemp</code>（或 <code>MoveTempIfPossible</code>）函数将一个共享指针的内容转移到另一个共享指针，将原始的共享指针保留为空：</strong>（对应 C++的 std::move）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将PointerOne的内容移至PointerTwo。在此之后，PointerOne将引用nullptr。</span></span><br><span class="line">PointerTwo = <span class="built_in">MoveTemp</span>(PointerOne);</span><br><span class="line"><span class="comment">// 将PointerTwo的内容移至PointerOne。在此之后，PointerTwo将引用nullptr。</span></span><br><span class="line">PointerOne = <span class="built_in">MoveTempIfPossible</span>(PointerTwo);</span><br></pre></td></tr></table></figure>

<p><code>MoveTemp</code> 和 <code>MoveTempIfPossible</code> 的唯一不同之处在于 <code>MoveTemp</code> 包含静态断言，强制其只能在非常量左值（lvalue）上执行。</p>
<h3 id="3-重置"><a href="#3-重置" class="headerlink" title="3 重置"></a>3 重置</h3><p>**使用 <code>Reset</code> 函数、或分配一个空指针来重置共享指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PointerOne.<span class="built_in">Reset</span>();</span><br><span class="line">PointerTwo = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// PointerOne和PointerTwo现在都引用nullptr。</span></span><br></pre></td></tr></table></figure>

<h3 id="5-比较-有效性"><a href="#5-比较-有效性" class="headerlink" title="5 比较 &#x2F; 有效性"></a>5 比较 &#x2F; 有效性</h3><p><code>==</code> <code>!=</code>：共享指针是否相等<br>相等被定义为两个共享指针引用同一对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FTreeNode&gt; NodeA, NodeB;</span><br><span class="line"><span class="keyword">if</span> (NodeA == NodeB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>IsValid</code> 函数（是否为有效的）和 <code>bool</code> 运算符有助于判断共享指针是否引用了有效对象。</li>
<li> <strong><code>Get</code><strong>：</strong>返回对象的原生 C++指针，若为空返回 null</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Node.<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Node.<span class="built_in">Get</span>() != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更严格的检查</span></span><br><span class="line"><span class="keyword">if</span> (Node.<span class="built_in">IsValid</span>() &amp;&amp; Node.<span class="built_in">Get</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-解引用和访问"><a href="#6-解引用和访问" class="headerlink" title="6 解引用和访问"></a>6 解引用和访问</h3><p>你可以像使用普通 C++指针那样解引用，调用方法和访问成员。你也可以像使用其他 C++指针那样，通过调用 <strong><code>IsValid</code></strong> 函数或使用重载的 <code>bool</code> 运算符，在取消引用之前执行空检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在解引用前，检查节点是否引用了一个有效对象。</span></span><br><span class="line"><span class="keyword">if</span> (Node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 以下三行代码中的任意一行都能解引用节点，并且对它的对象调用ListChildren：</span></span><br><span class="line">    Node-&gt;<span class="built_in">ListChildren</span>();</span><br><span class="line">    Node.<span class="built_in">Get</span>()-&gt;<span class="built_in">ListChildren</span>();  <span class="comment">//推荐</span></span><br><span class="line">    (*Node).<span class="built_in">ListChildren</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TSharedRef"><a href="#TSharedRef" class="headerlink" title="TSharedRef"></a>TSharedRef</h2><p>共享引用（强引用）</p>
<ul>
<li><strong>不可为空</strong>，初始化必须有数据对象</li>
<li>无法重置 <code>Reset</code> 共享引用、向其指定空对象，或创建空白引用。因此<strong>固定包含有效对象</strong>，甚至<strong>没有 <code>IsValid</code> 方法</strong>。</li>
<li>**与标准的 C++引用不同，可在创建后将共享引用重新指定到另一对象。</li>
</ul>
<p><strong>在共享引用和共享指针之间进行选择时，除非需要空对象或可为空的对象，否则建议你优先选择共享引用。</strong></p>
<p>避免将数据作为 <code>TSharedRef</code> 或 <code>TSharedPtr</code> 参数传到函数，此操作将因取消引用和引用计数而产生开销。相反，<strong>建议将引用对象作为 <code>const &amp;</code> 进行传递。</strong></p>
<h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><ul>
<li>**<code>MakeShared&lt;T&gt;() / MakeShareable() </code> ：创建共享引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建共享引用</span></span><br><span class="line"><span class="function">TSharedRef&lt;FMyObjectType&gt; <span class="title">NewReference</span><span class="params">(<span class="keyword">new</span> FMyObjectType())</span></span>;</span><br><span class="line">TSharedRef&lt;FMyObjectType&gt; NewReference = <span class="built_in">MakeShared</span>&lt;FMyObjectType&gt;();</span><br></pre></td></tr></table></figure>

<p>在无有效对象的情况下尝试创建的共享引用将不会编译，并尝试将共享引用初始化为空指针变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两者均不会编译：</span></span><br><span class="line">TSharedRef&lt;FMyObjectType&gt; UnassignedReference; </span><br><span class="line">TSharedRef&lt;FMyObjectType&gt; NullAssignedReference = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//以下会编译，但如NullObject实际为空则断言。</span></span><br><span class="line">TSharedRef&lt;FMyObjectType&gt; NullAssignedReference = NullObject;</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><code>==</code> <code>!=</code>：共享引用是否相等<br>相等表示引用相同对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TSharedRef&lt;FMyObjectType&gt; ReferenceA, ReferenceB;</span><br><span class="line"><span class="keyword">if</span> (ReferenceA == ReferenceB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TWeakPtr"><a href="#TWeakPtr" class="headerlink" title="TWeakPtr"></a>TWeakPtr</h2><ul>
<li><strong>弱指针</strong>存储对象的弱引用，不参与引用计数。</li>
<li><strong>在访问弱指针引用的对象前，应使用 <code>Pin</code> 函数生成共享指针。此操作确保使用该对象时其将继续存在。</strong></li>
<li>如只需要确定弱指针是否引用对象，可将其与 <code>nullptr</code> 比较，或在之上调用 <code>IsValid</code>。</li>
</ul>
<h3 id="声明、初始化"><a href="#声明、初始化" class="headerlink" title="声明、初始化"></a>声明、初始化</h3><p>**可创建空白弱指针，或通过共享指针和共享引用创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建共享引用。</span></span><br><span class="line">TSharedRef&lt;FMyObjectType&gt; ObjectOwner = <span class="built_in">MakeShared</span>&lt;FMyObjectType&gt;();</span><br><span class="line"><span class="comment">//创建指向对象的弱指针。</span></span><br><span class="line"><span class="function">TWeakPtr&lt;FMyObjectType&gt; <span class="title">ObjectObserver</span><span class="params">(ObjectOwner)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>与共享指针相同，弱指针是否引用有效对象，均可进行安全复制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TWeakPtr&lt;FMyObjectType&gt; AnotherObjectObserver = ObjectObserver;</span><br></pre></td></tr></table></figure>

<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p><code>Reset ()</code> 或 <code>nullptr</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可通过将弱指针设为nullptr进行重置。</span></span><br><span class="line">ObjectObserver = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//也可使用重置函数。</span></span><br><span class="line">AnotherObjectObserver.<span class="built_in">Reset</span>();</span><br></pre></td></tr></table></figure>

<h3 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h3><ul>
<li>**<code>IsValid</code> 函数（是否为有效的）和 <code>bool</code> 运算符有助于判断共享指针是否引用了有效对象。</li>
<li> **<code>Get</code>**：返回对象指针，若为空返回 null</li>
</ul>
<h3 id="转换为共享指针"><a href="#转换为共享指针" class="headerlink" title="转换为共享指针"></a>转换为共享指针</h3><p><strong><code>Pin</code> 函数将创建指向弱指针对象的共享指针。</strong> </p>
<p>共享指针（包括由 <code>Pin</code> 函数返回的指针）可在条件句中作为 <code>bool</code> 类型进行求值，其中 <code>true</code> 表示有效对象。</p>
<p>以下代码检查弱指针是否引用有效对象。如是，至少在共享指针（由 <code>Pin</code> 函数创建）超出范围或被显式清除前，将保证其持续有效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取弱指针中的共享指针，并检查其是否引用有效对象。</span></span><br><span class="line"><span class="keyword">if</span> (TSharedPtr&lt;FMyObjectType&gt; LockedObserver = ObjectObserver.<span class="built_in">Pin</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//共享指针仅在此范围内有效。</span></span><br><span class="line">    <span class="comment">//该对象已被验证为存在，而共享指针阻止其被删除。</span></span><br><span class="line">    LockedObserver-&gt;<span class="built_in">SomeFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h3><ol>
<li>首先使用 <strong><code>Pin</code></strong> 函数，将其转换为共享指针。</li>
<li>然后通过共享指针或弱指针上的 <strong><code>Get</code></strong> 函数进行访问。此方法可确保使用该对象时，其将持续有效。</li>
</ol>
<h3 id="打破引用循环"><a href="#打破引用循环" class="headerlink" title="打破引用循环"></a>打破引用循环</h3><p>两个或多个对象使用智能指针保持彼此间的强引用时，将出现引用循环。在此类情况下，对象间会相互保护以免被删除。各对象固定被另一对象引用，因此对象无法在另一对象存在时被删除。如外部对象未对引用循环中对象进行引用，其实际上将出现内存泄漏。</p>
<p><strong>弱指针不会保留自身引用的对象，因此其可中断此类引用循环。要在未拥有对象时对其进行引用，并延长其寿命时，可使用弱指针。</strong></p>
<h3 id="使用警告"><a href="#使用警告" class="headerlink" title="使用警告"></a>使用警告</h3><p>在以下情况中请谨慎使用弱指针：</p>
<ul>
<li>**在 Set 或 Map 中用作键。弱指针可能会在未通知容器的情况下随时无效，因此共享指针或共享引用更适用于充当键。可安全地将弱指针用作数值。</li>
<li>虽然弱指针提供 <code>IsValid</code> 函数，但是检查 <code>IsValid</code> 无法保证对象在任何时间长度内均可持续有效。线程安全共享指针可能会因另一线程上的活动而随时无效，因此使用线程安全共享指针应尤其注意。<code>Pin</code> 返回的共享指针将使对象在代码将其清除或其超出范围前保持活跃状态，<strong>因此 <code>Pin</code> 函数是用于检查的首选方法，此类检查会导致取消引用或访问存储对象。</strong></li>
</ul>
<h2 id="TUniquePtr"><a href="#TUniquePtr" class="headerlink" title="TUniquePtr"></a>TUniquePtr</h2><ul>
<li>唯一指针仅会显式拥有其引用的对象。</li>
<li>唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。</li>
<li>唯一指针超出范围时，其将自动删除其所引用的对象。</li>
<li>不要为共享指针或共享引用引用的对象创建唯一指针</li>
</ul>
<h3 id="创建-初始化-判断-解引用-重置"><a href="#创建-初始化-判断-解引用-重置" class="headerlink" title="创建 &#x2F; 初始化 &#x2F; 判断 &#x2F; 解引用 &#x2F; 重置"></a>创建 &#x2F; 初始化 &#x2F; 判断 &#x2F; 解引用 &#x2F; 重置</h3><ul>
<li><code>MakeUnique ()</code> 创建唯一指针</li>
<li><code>IsValid ()</code></li>
<li><code>-&gt;</code> 运算符</li>
<li><code>Get()</code> 函数</li>
<li><strong><code>Release()</code></strong> <strong>释放并移交所有权</strong></li>
<li><code>Reset()</code> 或 <code>nullptr</code> 重置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建唯一指针</span></span><br><span class="line">TUniquePtr&lt;SimpleObject&gt; ObjUniquePtr = <span class="built_in">MakeUnique</span>&lt;SimpleObject&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断有效性</span></span><br><span class="line"><span class="keyword">if</span> (ObjUniquePtr.<span class="built_in">IsValid</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    ObjUniquePtr-&gt;<span class="built_in">ExeFun</span>(); <span class="comment">// 解引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针，移交</span></span><br><span class="line"><span class="function">TUniquePtr&lt;SimpleObject&gt; <span class="title">ObjUniquePtr2</span><span class="params">(ObjUniquePtr.Release())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置</span></span><br><span class="line">ObjUniquePtr.<span class="built_in">Reset</span>();		</span><br><span class="line">ObjUniquePtr2 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<h2 id="智能指针类型转换"><a href="#智能指针类型转换" class="headerlink" title="智能指针类型转换"></a>智能指针类型转换</h2><h3 id="引用转指针"><a href="#引用转指针" class="headerlink" title="引用转指针"></a>引用转指针</h3><p><strong>共享引用隐式转换为共享指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FMyObjectType&gt; MySharedPointer = MySharedReference;</span><br></pre></td></tr></table></figure>

<h3 id="指针转引用"><a href="#指针转引用" class="headerlink" title="指针转引用"></a>指针转引用</h3><p><strong><code>ToSharedRef</code><strong>：</strong>从共享指针创建共享引用</strong></p>
<ul>
<li>要求共享指针引用了一个非空对象</li>
<li>从空共享指针创建共享引用将触发断言。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在解引用之前，请确保共享指针有效，以避免可能出现的断言。</span></span><br><span class="line"><span class="keyword">if</span> (MySharedPointer.<span class="built_in">IsValid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    MySharedReference = MySharedPointer.<span class="built_in">ToSharedRef</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱指针转强指针"><a href="#弱指针转强指针" class="headerlink" title="弱指针转强指针"></a>弱指针转强指针</h3><p><strong><code>Pin</code> 函数将创建指向弱指针对象的共享指针。</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectObserver为弱指针</span></span><br><span class="line">TSharedPtr&lt;FMyObjectType&gt; LockedObserver = ObjectObserver.<span class="built_in">Pin</span>()</span><br></pre></td></tr></table></figure>


<h3 id="子类转父类"><a href="#子类转父类" class="headerlink" title="子类转父类"></a>子类转父类</h3><p>隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleObject是ComplexObject的父类</span></span><br><span class="line">TSharedPtr&lt;SimpleObject&gt; simpleObj;</span><br><span class="line">TSharedPtr&lt;ComplexObject&gt; complexObj = <span class="built_in">MakeShared</span>&lt;ComplexObject&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类转基类</span></span><br><span class="line">simpleObj = complexObj;</span><br></pre></td></tr></table></figure>

<h3 id="父类转子类"><a href="#父类转子类" class="headerlink" title="父类转子类"></a>父类转子类</h3><p><code>StaticCastSharedRef</code> 和 <code>StaticCastSharedPtr</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleObject是ComplexObject的父类</span></span><br><span class="line"><span class="comment">// 基类转派生类</span></span><br><span class="line">TSharedPtr&lt;ComplexObject&gt; complexObj2 = <span class="built_in">StaticCastSharedPtr</span>&lt;ComplexObject&gt;(simpleObj);</span><br></pre></td></tr></table></figure>

<h3 id="const-转-mutable"><a href="#const-转-mutable" class="headerlink" title="const 转 mutable"></a><code>const</code> 转 <code>mutable</code></h3><p>[[1 C++ Primer#mutable关键字]]：简单理解就是把 const 转换成非 const</p>
<p><code>ConstCastSharedRef</code> 和 <code>ConstCastSharedPtr</code> ：将 <code>const</code> 智能引用或智能指针分别转换为 <code>mutable</code> 智能引用或智能指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建常量指针</span></span><br><span class="line"><span class="function"><span class="type">const</span> TSharedPtr&lt;SimpleObject&gt; <span class="title">simpleObj_const</span><span class="params">(<span class="keyword">new</span> SimpleObject())</span></span>;</span><br><span class="line"><span class="comment">//常量指针转非常量指针</span></span><br><span class="line">TSharedPtr&lt;SimpleObject&gt; simpleObj_mutable = <span class="built_in">ConstCastSharedPtr</span>&lt;SimpleObject&gt;(simpleObj_const);</span><br></pre></td></tr></table></figure>

<h2 id="TSharedFromThis"><a href="#TSharedFromThis" class="headerlink" title="TSharedFromThis"></a>TSharedFromThis</h2><p>共享指针是非侵入性的，意味对象不知道其是否为智能指针拥有。<br>有些函数的参数为共享引用或共享指针，我们就需要传进去一个对象，但<strong>如何让对象知道自己就是智能指针？</strong><br>将一个类继承自 <code>TSharedFromThis</code> 后，那么这个类的对象就会知道自己是属于哪一个共享指针。</p>
<blockquote>
<p>对标的是原生 C++的 <code>std::enable_shared_from_this</code>。用法也非常相似?? 存疑</p>
</blockquote>
<p><strong><code>TSharedFromThis</code> 意思就使用 <code>this</code> 指针来构造一个共享指针，通过这个共享指针可以安全的使用 this 指针。</strong><br>其内部有一个弱指针，若要获取类实例的 this 指针，它提供两类接口 <strong>AsShared ()</strong> 和 **SharedThis ()<strong>，它们会</strong>通过 <code>TWeakPtr</code> 返回一个共享引用；</p>
<ul>
<li>自定义类继承 <code>TSharedFromThis</code> 模板类</li>
<li><code>AsShared()</code> 将 C++原生指针转换为共享引用，如果需要，我们可以再隐式转为共享指针</li>
<li><code>SharedThis(this)</code> 会返回具备 “this” 类型的共享引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> : <span class="keyword">public</span> TSharedFromThis&lt;BaseClass&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建共享指针访问成员函数</span></span><br><span class="line">    TSharedPtr&lt;BaseClass&gt; sharePtr = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">BaseClass</span>());</span><br><span class="line">    sharePtr-&gt;<span class="built_in">printf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过.Get()将共享指针解引用, 我们将可以通过智能指针获得原生C++指针</span></span><br><span class="line">    <span class="comment">//原生C++指针ptr指向sharePtr所指的对象</span></span><br><span class="line">    BaseClass* ptr = sharePtr.<span class="built_in">Get</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于普通的类，我们如果想把ptr在转换为共享指针，需要再次调用MakeShareable创建新的共享指针</span></span><br><span class="line">    <span class="comment">//⭐对于继承了TSharedFromThis的类，类对象知道自己是共享指针</span></span><br><span class="line">    <span class="comment">//因此我们可以直接使用AsShared()将指向BaseClass的C++原生指针ptr转换为共享引用</span></span><br><span class="line">    <span class="comment">//然后隐式转换为共享指针</span></span><br><span class="line">    <span class="keyword">if</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">         TSharedPtr&lt;BaseClass&gt; sharePtr2 = ptr-&gt;<span class="built_in">AsShared</span>();    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong><br>① <strong>调用 AsShared () 的对象必须是一个智能指针</strong>，否则仍然不能保证使用 this 裸指针或对内存重复释放，在 UE4 中会触发断言；<br>② 在**类外部调用静态方法 <code>SharedThis()</code> 时，当前操作模块的类也必须公有继承其自身的 <code>TSharedFromThis</code>**；<br>③ <code>AsShared()</code> 和 <code>SharedThis()</code> <strong>不能在构造函数内部使用</strong>，共享引用此时并未初始化，将导致崩溃或断言。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> TSharedFromThis&lt;MyClass&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TSharedRef&lt;MyClass&gt; <span class="title">SharedMyself</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SharedThis</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通指针或对象，使用TSharedFromThis内的方法会触发断言 </span></span><br><span class="line">TSharedPtr&lt;MyClass&gt; ptr = <span class="built_in">MakeShared</span>&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过接口获取类实例的智能引用，维护的是同一块内存，同一个计数器 </span></span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef1 = ptr-&gt;<span class="built_in">AsShared</span>();</span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef2 = ptr-&gt;<span class="built_in">SharedMyself</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外部使用该接口，那么操作模块的类也必须继承其自身的TSharedFromThis </span></span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef3 = <span class="built_in">SharedThis</span>(ptr.<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>

<h2 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h2><p><strong>共享指针和共享引用支持对它们引用的对象使用自定义删除器</strong>。如需运行自定义删除代码，请<strong>提供 lambda 函数</strong>，作为创建智能指针时使用的参数，就像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyMyObjectType</span><span class="params">(FMyObjectType* ObjectAboutToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处添加删除代码。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这些函数使用自定义删除器创建指南指针。</span></span><br><span class="line"><span class="function">TSharedRef&lt;FMyObjectType&gt; <span class="title">NewReference</span><span class="params">(<span class="keyword">new</span> FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TSharedPtr&lt;FMyObjectType&gt; <span class="title">NewPointer</span><span class="params">(<span class="keyword">new</span> FMyObjectType(), [](FMyObjectType* Obj)&#123; DestroyMyObjectType(Obj); &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><strong>通常仅在单线程上访问智能指针的操作才是安全的。</strong></p>
<p><strong>如需访问多线程，请使用智能指针类的线程安全版本：</strong></p>
<ul>
<li><code>TSharedPtr&lt;T, ESPMode::ThreadSafe&gt;</code></li>
<li><code>TSharedRef&lt;T, ESPMode::ThreadSafe&gt;</code></li>
<li><code>TWeakPtr&lt;T, ESPMode::ThreadSafe&gt;</code></li>
<li><code>TSharedFromThis&lt;T, ESPMode::ThreadSafe&gt;</code></li>
</ul>
<p><strong>由于原子引用计数，此类线程安全版本比默认版本稍慢，但其行为与常规 C++指针一致：</strong></p>
<ul>
<li>读取和复制固定为线程安全。</li>
<li>写入和重置须同步后才安全。</li>
</ul>
<p>如了解多线程永不访问指针，可通过避免使用线程安全版本获得更好性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/3180.html">http://liuke101.github.io/post/3180.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UEC/">UEC++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">模板与泛型编程</div></div></a></div><div class="next-post pull-right"><a href="/post/1888.html" title="Unity编辑器扩展"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity编辑器扩展</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/28208.html" title="UE伤害系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UE伤害系统</div></div></a></div><div><a href="/post/28207.html" title="UE输入系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UE输入系统</div></div></a></div><div><a href="/post/8996.html" title="UEC++定时器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UEC++定时器</div></div></a></div><div><a href="/post/40918.html" title="UEC++基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">UEC++基础API</div></div></a></div><div><a href="/post/33399.html" title="UEC++委托"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-14</div><div class="title">UEC++委托</div></div></a></div><div><a href="/post/19081.html" title="UEC++容器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">UEC++容器</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-ObjectPtr"><span class="toc-text">1 ObjectPtr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5-FObjectPtr-TObjectPtr-%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E7%B1%BB"><span class="toc-text">动机：为什么要引入 FObjectPtr&#x2F;TObjectPtr 对象指针类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%B0%81%E8%A3%85"><span class="toc-text">信息封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UObject-%E4%B8%AD%E4%BF%A1%E6%81%AF%E5%B0%81%E8%A3%85%E5%88%B0-FObjectPtr-TObjectPtr-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">UObject 中信息封装到 FObjectPtr&#x2F;TObjectPtr 的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FObjectPtr-%E4%B8%8E-TObjectPtr"><span class="toc-text">FObjectPtr 与 TObjectPtr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90"><span class="toc-text">动态解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%BD%E8%B8%AA-%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90%E8%BF%BD%E8%B8%AA"><span class="toc-text">访问追踪 &#x2F; 动态解析追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%BD%E8%B8%AA"><span class="toc-text">访问追踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90%E8%BF%BD%E8%B8%AA"><span class="toc-text">动态解析追踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B-FObjectPtr-TObjectPtr-%E7%9A%84%E8%BF%98%E5%8E%9F"><span class="toc-text">非编辑器下 FObjectPtr&#x2F;TObjectPtr 的还原</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">对反射的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C%EF%BC%9A%E7%94%9F%E6%88%90%E7%89%B9%E6%AE%8A%E7%9A%84-FProperty-%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">对于生成代码和类型注册：生成特殊的 FProperty 子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E-Cast-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%BD%93%E4%BD%9C%E8%A3%B8%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8"><span class="toc-text">对于 Cast&lt;&gt;() 类型转换：可以直接当作裸指针使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%8E%B7%E5%8F%96-FProperty-%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9A%E5%BA%94%E4%BD%BF%E7%94%A8-TObjectPtr-%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-T-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-text">对于通过字符串获取 FProperty 并访问成员变量：应使用 TObjectPtr&lt;T&gt;* 获取反射解析后的指针，而不是 T** 二级指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E-TMap-%E7%AD%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%8F%8A%E5%A7%94%E6%89%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">对于 TMap&lt;&gt; 等容器类及委托函数的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">使用建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">附：完整测试示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TryTObjPtr-h"><span class="toc-text">TryTObjPtr. h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TryTObjPtr-cpp"><span class="toc-text">TryTObjPtr. cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">2 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">智能指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%98%E7%82%B9"><span class="toc-text">智能指针优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSharedPtr"><span class="toc-text">TSharedPtr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1 声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6-%E8%BD%AC%E7%A7%BB"><span class="toc-text">2 复制&#x2F;转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E7%BD%AE"><span class="toc-text">3 重置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%AF%94%E8%BE%83-%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">5 比较 &#x2F; 有效性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-text">6 解引用和访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSharedRef"><span class="toc-text">TSharedRef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TWeakPtr"><span class="toc-text">TWeakPtr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">声明、初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-text">复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE"><span class="toc-text">重置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">有效性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88"><span class="toc-text">转换为共享指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">访问对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF"><span class="toc-text">打破引用循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AD%A6%E5%91%8A"><span class="toc-text">使用警告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TUniquePtr"><span class="toc-text">TUniquePtr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%88%A4%E6%96%AD-%E8%A7%A3%E5%BC%95%E7%94%A8-%E9%87%8D%E7%BD%AE"><span class="toc-text">创建 &#x2F; 初始化 &#x2F; 判断 &#x2F; 解引用 &#x2F; 重置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">智能指针类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8C%87%E9%92%88"><span class="toc-text">引用转指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BD%AC%E5%BC%95%E7%94%A8"><span class="toc-text">指针转引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E6%8C%87%E9%92%88%E8%BD%AC%E5%BC%BA%E6%8C%87%E9%92%88"><span class="toc-text">弱指针转强指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E8%BD%AC%E7%88%B6%E7%B1%BB"><span class="toc-text">子类转父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E8%BD%AC%E5%AD%90%E7%B1%BB"><span class="toc-text">父类转子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E8%BD%AC-mutable"><span class="toc-text">const 转 mutable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSharedFromThis"><span class="toc-text">TSharedFromThis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">自定义删除器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">线程安全</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46645.html" title="GAS精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250017189.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAS精粹"/></a><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>