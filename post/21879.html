<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Primer | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="零、工作原理反射机制 [!NOTE] 反射  程序正在运行时，可以查看其它程序集或者自身的元数据。一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射 在程序运行时，通过反射可以得到其它程序集或者自己程序集中代码的各种信息，比如类，函数，变量，对象等等我们可以实例化它们，执行它们，操作它们   Unity 开发的本质就是在 Unity 引擎的基础上，利用反射和引擎提供的各种功能进行的拓展开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Primer">
<meta property="og:url" content="http://liuke101.github.io/post/21879.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="零、工作原理反射机制 [!NOTE] 反射  程序正在运行时，可以查看其它程序集或者自身的元数据。一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射 在程序运行时，通过反射可以得到其它程序集或者自己程序集中代码的各种信息，比如类，函数，变量，对象等等我们可以实例化它们，执行它们，操作它们   Unity 开发的本质就是在 Unity 引擎的基础上，利用反射和引擎提供的各种功能进行的拓展开发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png">
<meta property="article:published_time" content="2023-08-21T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-06T15:37:36.109Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/21879.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Primer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 23:37:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Primer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-21T16:00:00.000Z" title="发表于 2023-08-22 00:00:00">2023-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T15:37:36.109Z" title="更新于 2024-08-06 23:37:36">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Primer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/21879.html#post-comment"><span class="waline-comment-count" data-path="/post/21879.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零、工作原理"><a href="#零、工作原理" class="headerlink" title="零、工作原理"></a>零、工作原理</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><blockquote>
<p>[!NOTE] 反射</p>
<ol>
<li>程序正在运行时，可以查看其它程序集或者自身的元数据。一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射</li>
<li>在程序运行时，通过反射可以得到其它程序集或者自己程序集中代码的各种信息，比如类，函数，变量，对象等等我们可以实例化它们，执行它们，操作它们</li>
</ol>
</blockquote>
<p><strong>Unity 开发的本质就是在 Unity 引擎的基础上，利用反射和引擎提供的各种功能进行的拓展开发。</strong></p>
<p><strong>场景中对象的本质是什么？</strong><br>GameObject 类对象是 Unity 引擎提供给我们的，作为场景中所有对象的根本。<br>在游戏场景中出现一个对象，不管是图片、模型、音效、摄像机等等都是依附于 GameObject 对象。<br>拟人化记忆: GameObject 就是没有剧本的演员。</p>
<p>除了 <strong>Transform</strong> 这个表示位置的<strong>标配脚本</strong>外，我们可以为这个演员 (GameObject）关联各种剧本（脚本 )，让它按照我们剧本中 (代码逻辑中)的命令来处理事情<br><strong>而为演员添加剧本的这个过程，就是在利用反射 new 一个新的剧本对象和演员 (GameObject)对象进行关联，让其按我们的命令做事。</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036016.png" alt="Pasted image 20230603122307"></p>
<p>Unity 场景文件（. unity）它的本质就是一个配置文件<br>Unity 有一套自己识别处理它的机制，本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036018.png" alt="Pasted image 20230603123624|650"></p>
<h2 id="预制体（Prefab）和资源包导入导出"><a href="#预制体（Prefab）和资源包导入导出" class="headerlink" title="预制体（Prefab）和资源包导入导出"></a>预制体（Prefab）和资源包导入导出</h2><p>预制体和资源包用于保存数据，方便数据管理，如果更改预制资源，则任何场景中的所有预制资源实例都将以相同的方式更改。<br>在播放模式下，预制体和实例之间的关系已断开。</p>
<h1 id="一、脚本基础"><a href="#一、脚本基础" class="headerlink" title="一、脚本基础"></a>一、脚本基础</h1><h2 id="1-创建规则"><a href="#1-创建规则" class="headerlink" title="1 创建规则"></a>1 创建规则</h2><ol>
<li>类名和文件名必须一致, 不然不能挂载 (因为反射机制创建对象，会通过文件名去找 Type)</li>
<li>建议不要使用中文名命名</li>
<li>没有特殊需求不用管命名空间</li>
<li>创建的脚本默认继承 MonoBehavior</li>
</ol>
<p>默认脚本内容路径：<code>Editor\DataResources\ScriptTemplates</code></p>
<ol start="7">
<li>脚本之间的关系：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036019.png" alt="Pasted image 20230604101859|700"></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036020.png" alt="Pasted image 20230604101922"></p>
<h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h2><p>特性可以组合在一个 <code>[]</code> 中，逗号分隔</p>
<p><code>[ExecuteAlways]</code>：令脚本在编辑模式下运行<br><code>[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]</code>：自动添加需要的组件作为依赖项。<br><code>[CreateAssetMenu (menuName =&quot;Rendering/CreateCustomRenderPipeline&quot;)]</code>：该标签会让你在 Project 下右键-&gt;Create 菜单中添加一个新的子菜单<br><code>[DisallowMultipleComponent]</code>：不允许在一个对象上挂相同组件</p>
<h2 id="3-Inspector-窗口"><a href="#3-Inspector-窗口" class="headerlink" title="3 Inspector 窗口"></a>3 Inspector 窗口</h2><h3 id="可编辑的变量"><a href="#可编辑的变量" class="headerlink" title="可编辑的变量"></a>可编辑的变量</h3><blockquote>
<p>[!NOTE] </p>
<ol>
<li>Inspector 窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量 </li>
<li>拖拽到 Gameobject 对象后，再改变脚本代码中变量默认值，界面上不会改变 </li>
<li>运行中修改的信息不会保存</li>
</ol>
</blockquote>
<ol>
<li><p>Inspector 显示的可编辑内容就是脚本的成员变量</p>
</li>
<li><p><strong>public 成员变量可直接显示编辑</strong><br>加上特性 <code>[HideInInspector]</code> 后不可显示编辑</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HideInInspector</span>]  </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> i;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>private 和 protected 成员变量无法显示和编辑</strong><br>加上<strong>强制序列化字段特性 <code>[serializeField]</code></strong> 后可以编辑。所谓序列化就是把一个对象保存到一个文件或数据库字段中去。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> z;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>[!NOTE] 序列化与反序列化</p>
<ol>
<li>序列化是将对象转换为二进制流的过程。把内存中的数据（类的对象数据）存储到硬盘上。</li>
<li>反序列化是将二进制流转换为对象的过程。把硬盘上的数据读取到内存（类的对象数据）中</li>
<li>序列化主要解决对象的传输问题。</li>
</ol>
</blockquote>
<ol start="4">
<li>大部分类型都能显示编辑，<strong>不支持字典 Dictionary 和自定义类类型变量。</strong><br>加上序列化 <code>[Serializable]</code> 特性后可以显示自定义类类型<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="窗口排版"><a href="#窗口排版" class="headerlink" title="窗口排版"></a>窗口排版</h3><ol>
<li>分组说明特性 Header：为成员分组<br><code>[Header (&quot;分组说明&quot;)]</code></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> [<span class="meta">Header(<span class="string">&quot;基础属性&quot;</span>)</span>] </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Header(<span class="string">&quot;进阶属性&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> height;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> weight;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036021.png" alt="Pasted image 20230603143748"></p>
<ol start="2">
<li><p>鼠标悬停注释 Tooltip ：为变量添加说明<br>&#96;Tooltip (“说明内容”)]</p>
</li>
<li><p>间隔特性 Space：让两个字段间出现间隔<br><code>[Space ()]</code></p>
</li>
<li><p>修饰数值的滑条范围 Range<br><code>[Range (最小值, 最大值)]</code></p>
</li>
<li><p>多行显示字符串，默认不写参数显示 3 行，写参数就是对应行<br><code>[Multiline (行数)]</code></p>
</li>
<li><p>滚动条显示多行 字符串，默认不写参数就是超过 3 行显示滚动条<br><code>[TextArea (3，4)]</code>：最少显示 3 行，最多 4 行，超过 4 行就显示滚动条</p>
</li>
<li><p>为变量添加快捷方法 contextMenuItem </p>
<ul>
<li>参数 1 显示按钮名</li>
<li>参数 2 方法名不能有参数<br><code>[contextMenuItem (&quot;显示按钮名&quot;，“方法名&quot;)]</code><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ContextMenuItem(<span class="string">&quot;重置钱&quot;</span>,<span class="string">&quot;ResetMoney&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetMoney</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    money = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 右键可以查看方法：  <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036022.png" alt="Pasted image 20230603144613"></li>
</ul>
</li>
<li><p>为方法添加特性能够在 Inspector 中执行 ContextMenu<br><code>[ContextMenu (&quot;测试函数&quot;)]</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ContextMenu(<span class="string">&quot;哈哈哈哈&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   print(<span class="string">&quot;哈哈哈哈&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在脚本上可以调用该方法：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036023.png" alt="Pasted image 20230603144922"></p>
</li>
</ol>
<h2 id="4-生命周期函数"><a href="#4-生命周期函数" class="headerlink" title="4 生命周期函数"></a>4 生命周期函数</h2><p>游戏的本质就是一个死循环（Tick），每一次循环处理游戏逻辑就会更新一次画面，一帧就是执行一次循环。<br>Unity 底层已经帮助我们做好了死循环，我们需要学习 Unity 的生命周期函数，利用它做好的规则来执行我们的游戏逻辑就行了。</p>
<blockquote>
<p>[!NOTE] 生命周期函数的概念</p>
<ul>
<li>所有继承 MonoBehavior 的脚本最终都会挂载到 Gameobject 游戏对象上</li>
<li>生命周期函数就是该脚本对象依附的 Gameobject 对象从出生到消亡整个生命周期中会<strong>通过反射自动调用的一些特殊函数</strong></li>
<li>Unity 帮助我们记录了一个 Gameobject 对象依附了哪些脚本，会自动的得到这些对象，通过反射去执行生命周期函数</li>
<li>生命周期函数并不是 MonoBehavio 基类中的成员，Unity 帮助我们记录了场景上的所有 GameObjgct 对象以及各个关联的脚本对象，在游戏执行的特定时机 (对象创建时，失活激活时，帧更新时)它会通过函数名反射得到脚本对象中对应的生命周期函数，然后再这些特定时机执行他们</li>
</ul>
</blockquote>
<ul>
<li>生命周期函数的访问修饰符一般为 private 和 protected（默认为private）</li>
<li>因为不需要再外部自己调用生命周期函数都是 Unity 自己帮助我们调用的 </li>
<li>支持继承多态</li>
</ul>
<blockquote>
<p>常用的生命周期函数：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036024.png" alt="Pasted image 20230603132450"> </p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当对象(自己找个类对象)被创建时，才会调用该生命周期函数</span></span><br><span class="line"><span class="comment">//类似构造函数，一个对象只会调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//依附的GameObject对象每次激活时调用（打勾）</span></span></span><br><span class="line"><span class="function"><span class="comment">//想要当一个对象被激活时进行一些逻辑处理,就可以写在这个函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 对象Awake后，第一次帧更新之前调用，一个对象只会调用一次</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//进行物理帧更新  </span></span></span><br><span class="line"><span class="function"><span class="comment">//固定间隔执行，间隔时间可以设置  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()C</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 逻辑帧执行，每帧执行</span></span></span><br><span class="line"><span class="function"><span class="comment">// 处理游戏核心逻辑更新</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 每帧执行，于Update之后执行（速度相同）</span></span></span><br><span class="line"><span class="function"><span class="comment">//一般用来处理摄像机位置更新相关内容的</span></span></span><br><span class="line"><span class="function"><span class="comment">//Update和LateUpdate之间，Unity会处理动画相关的更新，如果将摄像机放在Update中更新，可能会造成渲染上的问题</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//依附的GameObject对象每次失活时调用（去掉勾）</span></span></span><br><span class="line"><span class="function"><span class="comment">//想要当一个对象失活时进行一些逻辑处理,就可以写在这个函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//当对象被销毁时调用(衣服的GameObject对象被删除时调用)</span></span></span><br><span class="line"><span class="function"><span class="comment">//一般用来做一些资源的释放</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br></pre></td></tr></table></figure>

<p><strong>激活对象</strong>：<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036025.png" alt="Pasted image 20230603133828"><br>&#96;<br><strong>设置物理帧固定时间步长：</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036026.png" alt="Pasted image 20230603134654"></p>
<h2 id="5-随机数"><a href="#5-随机数" class="headerlink" title="5 随机数"></a>5 随机数</h2><p>Unity 当中的 Random 类和 cs 中的 Random 类不同。<br>使用 cs 自带随机数加上 System. 就可以  </p>
<figure class="highlight cs"><figcaption><span>title:Unity中的随机数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机数 int 重载规则是左包含，右不包含 [)</span></span><br><span class="line"><span class="built_in">int</span> randomNum = Random.Range(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//float 重载规则是左右都包含 []</span></span><br><span class="line"><span class="built_in">float</span> randomNum = Random.Range(<span class="number">0.0f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:cs中的随机数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.Random r = <span class="keyword">new</span> System.Random();  </span><br><span class="line">r.Next(); <span class="comment">//生成一个非负的随机数  </span></span><br><span class="line">r.Next(<span class="number">100</span>); <span class="comment">//生成[0,99)的随机数 </span></span><br></pre></td></tr></table></figure>

<h2 id="6-委托-事件"><a href="#6-委托-事件" class="headerlink" title="6 委托&#x2F;事件"></a>6 委托&#x2F;事件</h2><p>[[《CS Primer》#八、委托 delegate]]<br>Unity 的委托和 cs 的 Action 委托使用方法类似</p>
<figure class="highlight cs"><figcaption><span>title:Unity自带委托</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnityAction ac1 = () =&gt; &#123; print(<span class="string">&quot;test1&quot;</span>); &#125;;  <span class="comment">//无参无返回值  </span></span><br><span class="line">  </span><br><span class="line">UnityAction&lt;<span class="built_in">string</span>&gt; ac2 = (str) =&gt; &#123; print(<span class="string">&quot;test2&quot;</span>);&#125;;<span class="comment">//有参无返回值</span></span><br></pre></td></tr></table></figure>

<p>使用 cs 自带委托加上 System. 就可以  </p>
<figure class="highlight cs"><figcaption><span>title:cs自带委托</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.Action ac1 = () =&gt; &#123; print(<span class="string">&quot;test1&quot;</span>); &#125;; <span class="comment">//无参无返回值  </span></span><br><span class="line">System.Action&lt;<span class="built_in">int</span>,<span class="built_in">float</span>&gt; ac2 = (i,f)=&gt; &#123; print(<span class="string">&quot;test2&quot;</span>); &#125;;<span class="comment">//有参无返回值  </span></span><br><span class="line">  </span><br><span class="line">System.Func&lt;<span class="built_in">string</span>&gt; ac3 = () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;test3&quot;</span>; &#125;;<span class="comment">//无参有返回值  </span></span><br><span class="line">System.Func&lt;<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">string</span>&gt; ac4 = (i, f) =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;test3&quot;</span>; &#125;;<span class="comment">//有参有返回值</span></span><br></pre></td></tr></table></figure>

<p>事件：和 cs 一样</p>
<figure class="highlight cs"><figcaption><span>title:事件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> UnityAction clickEvent;</span><br></pre></td></tr></table></figure>

<p>自定义事件类继承 <code>UnityEvent</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventVector3</span> : <span class="title">UnityEvent</span>&lt;<span class="title">Vector3</span>&gt;  <span class="comment">//&lt;Vector3&gt; 是该事件的参数</span></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036027.png" alt="Pasted image 20230725105715"></p>
<h2 id="7-数学-Mathf"><a href="#7-数学-Mathf" class="headerlink" title="7 数学 Mathf"></a>7 数学 Mathf</h2><p>Math 是中封装好的用于数学计算的工具<strong>类</strong>，位于 system 命名空间中<br><strong>Mathf</strong> 是 unity 中封装好的用于数学计算的工具<strong>结构体</strong>，位于 UnityEngine 命名空间中，Mathf 更适合游戏开发，功能更多</p>
<h3 id="常用运算函数"><a href="#常用运算函数" class="headerlink" title="常用运算函数"></a>常用运算函数</h3><p><code>PI</code><br><code>Abs</code> 取绝对值<br><code>CeilToInt</code>  向上取整<br><code>FloorToInt</code> 向下取整<br><code>RoundToInt</code> 四舍五入<br><code>Clamp</code> 钳制<br><code>Max</code> 最大值<br><code>Min</code> 最小值<br><code>Pow</code> 幂<br><code>Sqrt</code> 平方根<br><code>IsPowerOfTwo</code> 判断一个数是否是 2 的 n 次方<br><code>Sign</code> 判断正负数，返回 1&#x2F;-1</p>
<p><code>Lerp</code> 线性插值<br><code>Vector3.SLerp</code> 球形插值</p>
<figure class="highlight cs"><figcaption><span>lerp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lerp原理</span></span><br><span class="line">result = （<span class="number">1</span>-t）start + t * end; <span class="comment">//t为插值系数，取值范围为0~1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法</span></span><br><span class="line">result  = Mathf.Lerp(start,end,t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每帧改变 start 的值—变化速度先快后慢，位置无限接近，但是不会得到 end 位置 </span></span><br><span class="line">start = Mathf.Lerp ( start，<span class="number">10</span>，Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每帧改变 t 的值—变化速度匀速，位置每帧接近，当 t&gt;=1 时，得到结果</span></span><br><span class="line">time += Time.deltaTime;</span><br><span class="line">result = Mathf.Lerp(start,<span class="number">10</span>,time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Slerp，让物体围绕一个点旋转</span></span><br><span class="line">C.position = Vector3.slerp(Vector3.right * <span class="number">10</span>，Vector3.forward * <span class="number">10</span>,time);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弧度转角度  </span></span><br><span class="line"><span class="built_in">float</span> radian = Mathf.PI;  </span><br><span class="line"><span class="built_in">float</span> angle = radian * Mathf.Rad2Deg; <span class="comment">//Deg:degree 度  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//角度转弧度  </span></span><br><span class="line">radian = angle * Mathf.Deg2Rad;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mathf中的三角函数，传入的参数需要是弧度</span></span><br><span class="line"><span class="built_in">float</span> sinValue = Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad); <span class="comment">//注意角度转成弧度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反三角函数得到的结果也是弧度</span></span><br><span class="line"><span class="built_in">float</span> arcSinValue = Mathf.Asin(<span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>

<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><figure class="highlight cs"><figcaption><span>title:Vector3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vector3的初始化</span></span><br><span class="line">Vector3 v1 = <span class="keyword">new</span> Vector3();</span><br><span class="line">v1.x = <span class="number">10</span>;</span><br><span class="line">v1.y = <span class="number">10</span>;</span><br><span class="line">v1.z = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Vector3 v2 = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应世界空间位置</span></span><br><span class="line">Vector3 v3 = Vector3.zero; <span class="comment">// (0, 0, 0)</span></span><br><span class="line">Vector3 v4 = Vector3.one; <span class="comment">// (1, 1, 1)</span></span><br><span class="line">Vector3 v5 = Vector3.right; <span class="comment">// (1, 0, 0)</span></span><br><span class="line">Vector3 v6 = Vector3.left; <span class="comment">// (-1, 0, 0)</span></span><br><span class="line">Vector3 v7 = Vector3.up; <span class="comment">// (0, 1, 0)</span></span><br><span class="line">Vector3 v8 = Vector3.down; <span class="comment">// (0, -1, 0)</span></span><br><span class="line">Vector3 v9 = Vector3.forward; <span class="comment">// (0, 0, 1)</span></span><br><span class="line">Vector3 v10 = Vector3.back; <span class="comment">// (0, 0, -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算点之间的距离</span></span><br><span class="line">Vector3.Distance(v1, v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量模长</span></span><br><span class="line">v1.magnitude</span><br><span class="line"></span><br><span class="line"><span class="comment">//单位向量</span></span><br><span class="line">v1.normalized</span><br><span class="line"></span><br><span class="line"><span class="comment">//点乘</span></span><br><span class="line">Vector3.Dot  <span class="comment">//gameplay中点乘可以用来判断目标物体的前后方向</span></span><br><span class="line"><span class="comment">//叉乘</span></span><br><span class="line">Vector3.Cross <span class="comment">//gameplay中点乘可以用来得到两个向量之间的左右位置关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性插值</span></span><br><span class="line">Vector3.Lerp</span><br><span class="line"><span class="comment">//球形插值</span></span><br><span class="line">Vector3.SLerp </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036028.png" alt="Pasted image 20230610205842|700"></p>
<h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>[[01 三维旋转#欧拉角]]</p>
<p><strong>一共有 3 种欧拉角：俯仰角 (Pitch)、偏航角 (Yaw)和滚转角 (Roll)</strong><br>inspector 界面上显示的 Rotation 的 XYZ 值都是欧拉角<br>Untiy 欧拉角常用顺规：YXZ（Yaw-pitch-Roll）</p>
<p><strong>使用欧拉角的两个缺点：</strong></p>
<ol>
<li>同一旋转表示不唯一，即欧拉角绕一个轴旋转 90° 和 450°结果是一样的</li>
<li>X 轴达到 90 度时会产生万向节死锁<br><strong>使用四元数可以解决这两个问题，四元数的旋转转换为欧拉角后可以发现对应的欧拉角范围为（-180~180），不会出现欧拉角的缺点一。</strong></li>
</ol>
<h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>[[01 三维旋转#四元数]]<br><strong>四元数构成</strong><br>一个四元数包含一个标量和一个 3D 向量 $[ v,w]$<br>其中 $v$  为 3D 向量, $w$ 为标量，即 $[(x, y, z),w]$</p>
<p><strong>对于给定的任意一个四元数: 表示 3D 空间中的一个旋转量</strong></p>
<blockquote>
<p>[!NOTE] 轴-角对<br>在 3D 空间中，任意旋转都可以表示绕着某个轴旋转一个旋转角得到<br>注意: 该轴是<strong>局部空间</strong>中的<strong>任意一个轴</strong></p>
</blockquote>
<p>对于给定旋转，假设为绕着 $n$ 轴，旋转$β$度，$n$ 轴为$(x, y, z)$那么可以构成四元数为<br>四元数 $Q&#x3D; [\sin (β&#x2F;2)*n,\cos (β&#x2F;2)]$<br>四元数 $Q&#x3D; [ \sin (β&#x2F;2) *x, \sin (β&#x2F;2) *y, \sin (β&#x2F;2) *z,\cos (β&#x2F;2)]$<br><strong>四元数 $Q$ 则表示绕着轴 $n$，旋转$β$度的旋转量</strong></p>
<h4 id="Unity-中的四元数"><a href="#Unity-中的四元数" class="headerlink" title="Unity 中的四元数"></a>Unity 中的四元数</h4><figure class="highlight cs"><figcaption><span>title:Unity中的四元数初始化方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">//绕轴（3，4，5）旋转30度，注意要转弧度</span></span><br><span class="line">Quaternion q = <span class="keyword">new</span> Quaternion(Mathf.Sin(<span class="number">30</span>/<span class="number">2</span> * Mathf.Deg2Rad)*<span class="number">3</span>, Mathf.Sin(<span class="number">30</span>/<span class="number">2</span> * Mathf.Deg2Rad)*<span class="number">4</span>, Mathf.Sin(<span class="number">30</span>/<span class="number">2</span> * Mathf.Deg2Rad)*<span class="number">5</span>,Mathf.Cos(<span class="number">30</span>/<span class="number">2</span> * Mathf.Deg2Rad));  </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：更方便！推荐！</span></span><br><span class="line"><span class="comment">//绕轴（3，4，5）旋转30度  </span></span><br><span class="line">Quaternion q2 = Quaternion.AngleAxis(<span class="number">30</span>, <span class="keyword">new</span> Vector3(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个立方体  </span></span><br><span class="line">GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);  </span><br><span class="line">obj.transform.rotation = q;  <span class="comment">//结果可直接赋给rotation</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>我们一般不会直接通过四元数的 w, x, y, z 进行修改，直接赋值给 <code>.transform.rotation</code> 即可 </p>
</blockquote>
<h4 id="四元数-欧拉角转换"><a href="#四元数-欧拉角转换" class="headerlink" title="四元数&#x2F;欧拉角转换"></a>四元数&#x2F;欧拉角转换</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//欧拉角转四元数</span></span><br><span class="line">Quaternion.Euler(x,y,z)</span><br><span class="line"></span><br><span class="line"><span class="comment">//四元数转欧拉角</span></span><br><span class="line">Quaternion q;</span><br><span class="line">q.eulerAngles</span><br></pre></td></tr></table></figure>
<h4 id="四元数常用方法"><a href="#四元数常用方法" class="headerlink" title="四元数常用方法"></a>四元数常用方法</h4><h5 id="单位四元数"><a href="#单位四元数" class="headerlink" title="单位四元数"></a>单位四元数</h5><p>单位四元数表示没有旋转量（角位移）<br>当角度为 0 或者 360 度时对于给定轴都会得到单位四元数<br>$[(0, 0,0),1]$ 和 $[(0, 0, 0),1]$ 都是单位四元数，表示没有旋转量</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将rotation改为了（0，0，0）</span></span><br><span class="line">obj.transform.rotation = Quaternion.identity; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个位置和角度都为0的对象</span></span><br><span class="line">GameObject objClone = Instantiate(obj, Vector3.zero, Quaternion.identity);</span><br></pre></td></tr></table></figure>

<h5 id="四元数插值"><a href="#四元数插值" class="headerlink" title="四元数插值"></a>四元数插值</h5><p>四元数中同样提供如同 Vector3 的插值运算 <code>Lerp</code> 和 <code>Slerp</code><br>在四元数中 <code>Lerp</code> 和 <code>Slerp</code> 只有一些细微差别由于算法不同</p>
<ul>
<li><code>Slerp</code> 的效果会好一些</li>
<li><code>Lerp</code> 的效果相比 <code>Slerp</code> 更快但是如果，旋转范围较大则效果较差，所以<strong>建议使用 Slerp 进行插值运算</strong><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;  <span class="comment">//目标位置</span></span><br><span class="line"><span class="keyword">public</span> Transform A;  </span><br><span class="line"><span class="keyword">public</span> Transform B;  </span><br><span class="line"><span class="keyword">public</span> Quaternion start;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> time;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    start = B.transform.rotation;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//无限接近目标的旋转状态，先快后慢  </span></span><br><span class="line">    A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);  </span><br><span class="line">    print(Time.deltaTime);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//匀速变化，time&gt;=1到达目标  </span></span><br><span class="line">    time += Time.deltaTime;  </span><br><span class="line">    B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="向量方向转四元数"><a href="#向量方向转四元数" class="headerlink" title="向量方向转四元数"></a>向量方向转四元数</h5><p><code>LookRoataion</code> 方法可以将传入的<strong>面朝向量</strong>转换为对应的四元数角度信息</p>
<p>举例: 当人物面朝向（图中 A 的面朝向上方）想要改变时，只需要把目标面朝向（$\vec{AB}$）传入该函数，便可以得到目标四元数角度信息，之后将人物四元数角度信息改为得到的信息即可完成到转向。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036029.png" alt="Pasted image 20230610221358"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A看向B</span></span><br><span class="line">Quaternion q = Quaternion.LookRotation(B.position - A.position);</span><br><span class="line">A.rotation = q;</span><br></pre></td></tr></table></figure>

<h4 id="四元数相乘"><a href="#四元数相乘" class="headerlink" title="四元数相乘"></a>四元数相乘</h4><p><strong>四元数相乘代表旋转四元数</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//绕y轴转30</span></span><br><span class="line"> <span class="comment">//注意旋转轴是局部空间的！</span></span><br><span class="line">Quaternion q = Quaternion.AngleAxis(<span class="number">30</span>,Vector3.up);</span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每帧绕 Vector3.forward 旋转 1 度</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= Quaternion.AngleAxis(<span class="number">1</span>，Vector3.forward); </span><br></pre></td></tr></table></figure>
<h4 id="向量左乘四元数"><a href="#向量左乘四元数" class="headerlink" title="向量左乘四元数"></a>向量左乘四元数</h4><p><strong>向量左乘四元数返回一个新向量</strong><br>可以将指定向量旋转对应四元数的旋转量，相当于<strong>旋转向量</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v = Vector3.forward;  </span><br><span class="line">v = Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up) * v;</span><br></pre></td></tr></table></figure>

<p>应用：比如在游戏中我们的技能向四周发射，只需要知道人物的面向向量，然后左乘四元数，就可以得到不同角度的向量。</p>
<h2 id="8-坐标转换"><a href="#8-坐标转换" class="headerlink" title="8 坐标转换"></a>8 坐标转换</h2><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p><strong>世界坐标系</strong></p>
<figure class="highlight cs"><figcaption><span>title:常用的世界空间坐标</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.position;</span><br><span class="line"><span class="keyword">this</span>.transform.rotation;</span><br><span class="line"><span class="keyword">this</span>.transform.eulerAngles;</span><br><span class="line"><span class="keyword">this</span>.transform.lossyScale;</span><br></pre></td></tr></table></figure>

<p><strong>局部坐标系</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对父对象的物体坐标系的位置本地坐标相对坐标T/</span></span><br><span class="line"><span class="keyword">this</span>.transform.localposition;</span><br><span class="line"><span class="keyword">this</span>.transform.localEulerAngles;</span><br><span class="line"><span class="keyword">this</span>.transform.localRotation;</span><br><span class="line"><span class="keyword">this</span>.transform.localscale;</span><br><span class="line"><span class="comment">//修改他们会是相对父对象物体坐标系的变化</span></span><br></pre></td></tr></table></figure>

<p><strong>屏幕坐标系</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input.mousePosition</span><br><span class="line">Screen.width</span><br><span class="line">Screen.height</span><br></pre></td></tr></table></figure>

<p><strong>视口坐标系</strong><br>视口坐标系是与屏幕坐标系息息相关的，它是将 Game 视图的屏幕坐标系单位化，即左下角为 (0, 0)，右上角为 (1, 1)，z 轴坐标是相机的世界坐标中 z 轴坐标的负值。<br>注意这和观察坐标系（以摄像机为原点）不同！</p>
<h3 id="局部-世界"><a href="#局部-世界" class="headerlink" title="局部&#x2F;世界"></a>局部&#x2F;世界</h3><figure class="highlight cs"><figcaption><span>title:世界坐标转局部坐标</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界坐标系的点转换为局部坐标系点（会受缩放影响）</span></span><br><span class="line"><span class="comment">//上图中的P即为Vector3.forward</span></span><br><span class="line"><span class="keyword">this</span>.transform.InverseTransformPoint(Vector3.forward);</span><br><span class="line"></span><br><span class="line"><span class="comment">//世界坐标系的向量转换为局部坐标系的向量</span></span><br><span class="line"><span class="comment">//不受缩放影响</span></span><br><span class="line"><span class="keyword">this</span>.transform.InverseTransformDirection(Vector3.forward);</span><br><span class="line"><span class="comment">//受缩放影响</span></span><br><span class="line"><span class="keyword">this</span>.transform.InverseTransformVector(Vector3.forward);</span><br></pre></td></tr></table></figure>
<p>以下是从正 Y 轴向下看的视角，中间有一个 Cube 模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036030.svg" alt="Diagram"></p>
<p>世界坐标系的点 P (0，0，1)转换到局部空间，则 P 点坐标的 x，z 在局部空间为负数。<br>世界坐标系的向量 P（0，0，1）转换为局部空间，将左边的向量平移到右边，可以观察到该方向向量的 x 为负数，z 为证书</p>
<figure class="highlight cs"><figcaption><span>title:局部坐标转世界坐标</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⭐点（受缩放影响）</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.TransformPoint(Vector3.forward));  </span><br><span class="line"></span><br><span class="line"><span class="comment">//向量</span></span><br><span class="line"><span class="comment">//不受缩放影响</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.TransformDirection(Vector3.forward));</span><br><span class="line"><span class="comment">//受缩放影响</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.TransformDirection(Vector3.up));</span><br></pre></td></tr></table></figure>
<p>其中<strong>最重要的就是局部坐标系的点转世界坐标系的点</strong><br>比如现在玩家要在自己面前的 n 个单位前放一团火，这个时候我不用关心世界坐标系<br>通过相对于本地坐标系的位置转换为世界坐标系的点，进行特效的创建或者攻击范围的判断,</p>
<h3 id="世界-屏幕"><a href="#世界-屏幕" class="headerlink" title="世界&#x2F;屏幕"></a>世界&#x2F;屏幕</h3><figure class="highlight cs"><figcaption><span>title:坐标转换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界坐标转屏幕坐标</span></span><br><span class="line">Vector3 screenPos = Camera.main.WorldToScreenPoint(<span class="keyword">this</span>.transform.position);  <span class="comment">//XY是屏幕坐标，Z轴是深度</span></span><br><span class="line">print(screenPos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕坐标转世界坐标</span></span><br><span class="line">Vector3 worldPos = Camera.main.ScreenToWorldPoint(screenPos);</span><br><span class="line">print(worldPos);</span><br></pre></td></tr></table></figure>

<h3 id="世界-视口"><a href="#世界-视口" class="headerlink" title="世界&#x2F;视口"></a>世界&#x2F;视口</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界坐标转视口坐标</span></span><br><span class="line">Camera.main.worldToViewportPoint</span><br><span class="line"></span><br><span class="line"><span class="comment">//视口转世界</span></span><br><span class="line">Camera.main.ViewportToworldPoint </span><br></pre></td></tr></table></figure>

<p>视口空间是标准化的、相对于摄像机的空间。视口左下角为 (0,0)，右上角为 (1,1)。z 位置为与摄像机的距离，采用世界单位。</p>
<h3 id="视口-屏幕"><a href="#视口-屏幕" class="headerlink" title="视口&#x2F;屏幕"></a>视口&#x2F;屏幕</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视口转屏幕</span></span><br><span class="line">Camera.main.ViewportToScreenPoint</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕转视口</span></span><br><span class="line">Camera.main.screenToViewportPoint</span><br></pre></td></tr></table></figure>

<h1 id="二、重要组件和-API"><a href="#二、重要组件和-API" class="headerlink" title="二、重要组件和 API"></a>二、重要组件和 API</h1><h2 id="0-MonoBehavior-基类"><a href="#0-MonoBehavior-基类" class="headerlink" title="0 MonoBehavior 基类"></a>0 MonoBehavior 基类</h2><ol>
<li>创建的脚本默认都<strong>继承 MonoBehaviour</strong>，继承了它才能够挂载在 GameObject <blockquote>
<p>当我们把脚本拖到 GameObject 上时，引擎会根据文件名通过反射得到对应的类，如果该类继承了 MonoBehaviour，则允许挂载。</p>
</blockquote>
</li>
<li>继承了 MonoBehavior 的脚本不能 new ，<strong>只能挂载</strong>！</li>
<li>继承了 MonnBehavior 的脚本不要去写构造函数，因为我们不会去 new 它，写构造函数没有任何意义</li>
<li>继承了 MonoBehavior 的脚本可以在一个对象上挂多个 (如果没有加 <code>DisallowMultipleComponent</code> 特性)<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036031.png" alt="Pasted image 20230603130352"></li>
<li>继承 MonoBehavior 的类也可以再次被继承，遵循面向对象继承多态的规则</li>
</ol>
<p><strong>不继承 MonoBehaviour 的类：</strong></p>
<ol>
<li>不能挂载在 GameObject 上</li>
<li>想怎么写怎么写，如果要使用需要自己 new</li>
<li><strong>一般是单例模式的类（用于管理模块）或者数据结构类（ 用于存储数据）</strong></li>
<li>不用保留默认出现的几个函数</li>
</ol>
<blockquote>
<p>[!info] this<br>this 代表脚本对象<br>this.gameobject 代表脚本挂载的 GameObject<br>this.transform 代表脚本挂载的 GameObject 的位置信息<br>等价写法：this. gameobject.transform</p>
</blockquote>
<h3 id="调试打印"><a href="#调试打印" class="headerlink" title="调试打印"></a>调试打印</h3><p>在 Unity 中打印信息的两种方式</p>
<figure class="highlight cs"><figcaption><span>title:打印</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.没有继承MonoBehaviour的类的时候，可以使用Debug.Log</span></span><br><span class="line">Debug.Log(<span class="string">&quot;Awake Hello!&quot;</span>);</span><br><span class="line">Debug.LogError(<span class="string">&quot;Awake Error&quot;</span>);</span><br><span class="line">Debug.LogWarning(<span class="string">&quot;Awake Warning&quot;</span>);  </span><br><span class="line"><span class="comment">//2. 继承了MonoBehaviour的类，可以使用线程方法print</span></span><br><span class="line">print(<span class="string">&quot;Awake Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:调试画线</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画线段</span></span><br><span class="line"><span class="comment">//前两个参数为起点、终点</span></span><br><span class="line"><span class="comment">//向前方画一条线段：</span></span><br><span class="line">Debug.DrawLine(<span class="keyword">this</span>.transform.position,</span><br><span class="line">               <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward,</span><br><span class="line">               Color.red);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画射线</span></span><br><span class="line"><span class="comment">//前两个参数为起点、方向</span></span><br><span class="line">Debug.DrawRay(<span class="keyword">this</span>.transform.position,</span><br><span class="line">               <span class="keyword">this</span>.transform.forward,</span><br><span class="line">               Color.red);</span><br></pre></td></tr></table></figure>


<h3 id="获取脚本挂载的对象"><a href="#获取脚本挂载的对象" class="headerlink" title="获取脚本挂载的对象"></a>获取脚本挂载的对象</h3><ol>
<li>获取依附的 Gameobject</li>
<li>获取依附的 Gameobject 的位置信息</li>
<li>获取脚本是否激活<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TestScript testScript;  <span class="comment">//其他脚本</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 获取依附的GameObject</span></span><br><span class="line">    print(<span class="keyword">this</span>.gameObject.name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取依附的GameObject的位置信息</span></span><br><span class="line">    <span class="comment">//得到对象位置信息</span></span><br><span class="line">    print(<span class="keyword">this</span>.transform.position);  <span class="comment">//位置</span></span><br><span class="line">    print(<span class="keyword">this</span>.transform.eulerAngles);  <span class="comment">//角度</span></span><br><span class="line">    print(<span class="keyword">this</span>.transform.lossyScale);  <span class="comment">//缩放大小</span></span><br><span class="line">    <span class="comment">//等价写法：this.gameObject.transform</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取脚本是否激活</span></span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="literal">true</span>;   <span class="comment">//激活脚本</span></span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="literal">false</span>;  <span class="comment">//禁用脚本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取别的脚本对象依附的gameobject和transfrom位置信息</span></span><br><span class="line">    print(testScript.gameObject.name);</span><br><span class="line">    print(testScript.transform.position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="获取对象挂载的脚本"><a href="#获取对象挂载的脚本" class="headerlink" title="获取对象挂载的脚本"></a>获取对象挂载的脚本</h3><p>如何得到依附的 GameObject 对象上挂载的其它脚本?</p>
<ol>
<li><strong>得到 GameObject 挂载的单个脚本</strong><figure class="highlight cs"><figcaption><span>title:得到自己挂载的单个脚本 h:8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据脚本名获取，较少使用</span></span><br><span class="line">TestScript t1 = <span class="keyword">this</span>.GetComponent(<span class="string">&quot;TestScript&quot;</span>) <span class="keyword">as</span> TestScript; </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Type获取</span></span><br><span class="line">TestScript t2 = <span class="keyword">this</span>.GetComponent(<span class="keyword">typeof</span>(TestScript)) <span class="keyword">as</span> TestScript;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐根据泛型获取，建议使用，不用as</span></span><br><span class="line">TestScript t3 = <span class="keyword">this</span>.GetComponent&lt;TestScript&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//只要你能得到场景中对象或者对象依附的脚本，那你就可以获取到它所有信息</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>安全的获取脚本</strong>，加一个判断：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">MyScript s1 = <span class="keyword">this</span>.GetComponent&lt;MyScript&gt;();</span><br><span class="line"><span class="keyword">if</span> (s1 != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s1.dosomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">MyScript s2;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.TryGetComponent&lt;MyScript&gt;(<span class="keyword">out</span> s2))</span><br><span class="line">&#123;</span><br><span class="line">    s2.dosomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价，这样写更简便</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.TryGetComponent&lt;MyScript&gt;(<span class="keyword">out</span> MyScript s2))</span><br><span class="line">&#123;</span><br><span class="line">    s2.dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>得到 GameObject 挂载的多个脚本</strong> (不常用，通常我们不会将同一个脚本挂载两次在同一个 GameObject 上)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">MyScript[] scripts = <span class="keyword">this</span>.GetComponents&lt;MyScript&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">List&lt;MyScript&gt; scriptList = <span class="keyword">new</span> List&lt;MyScript&gt;(); <span class="comment">//定义一个存放MyScript类型的List</span></span><br><span class="line"><span class="keyword">this</span>.GetComponents&lt;MyScript&gt;(scriptList); <span class="comment">//将找到的结果存在List中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>得到 GameObject 子孙对象挂载的脚本</strong>（默认会先找本 GameObject 对象是否挂载该脚本）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到子孙对象挂载的单个脚本：</span></span><br><span class="line">MyScript s1 = <span class="keyword">this</span>.GetComponentInChildren&lt;MyScript&gt;(); <span class="comment">//如果脚本失活，则无法找到</span></span><br><span class="line">MyScript s2 = <span class="keyword">this</span>.GetComponentInChildren&lt;MyScript&gt;(<span class="literal">true</span>); <span class="comment">//true表示即使脚本失活，也可以找到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到子孙对象挂载的多个脚本：</span></span><br><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">MyScript[] ss1 =  <span class="keyword">this</span>.GetComponentsInChildren&lt;MyScript&gt;(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">List&lt;MyScript&gt; ss2 = <span class="keyword">new</span> List&lt;MyScript&gt;();</span><br><span class="line"><span class="keyword">this</span>.GetComponentsInChildren&lt;MyScript&gt;(<span class="literal">true</span>, ss2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>得到 GameObject 长辈（包括父，爷爷…）对象挂载的脚本</strong>（默认会先找本 GameObject 对象是否挂载该脚本）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到单个脚本</span></span><br><span class="line">MyScript s3 = <span class="keyword">this</span>.GetComponentInParent&lt;MyScript&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到多个脚本</span></span><br><span class="line">MyScript[] ss3 = <span class="keyword">this</span>.GetComponentsInParent&lt;MyScript&gt;(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><p>延迟函数就是<strong>会延时执行的函数</strong>，是 MonoBehaviour 基类中实现好的方法<br>我们可以<strong>自己设定延时要执行的函数</strong>和具体<strong>延时的时间</strong></p>
<p><strong><code>Invoke</code> 延迟执行函数</strong><br>参数一: 函数名字符串<br>参数二: 延迟时间以秒为单位</p>
<p><strong><code>InvokeRepeating</code> 延迟重复执行函数</strong><br>参数一: 函数名字符串<br>参数二: 第一次执行的延迟时间<br>参数三: 之后每次执行的间隔时间</p>
<p><strong>注意:</strong></p>
<ol>
<li>延迟函数第一个参数传入的是函数名字符串</li>
<li>延迟函数<strong>不能直接执行有参数的函数（无法传参）</strong>，可以包裹一层来执行（即在一个延迟函数中调用目标有参函数）。</li>
<li>函数名<strong>必须是该脚本上申明的函数</strong>，可以包裹一层来执行</li>
<li>脚本依附对象<strong>失活</strong>，延迟函数<strong>可以继续执行</strong></li>
<li>脚本依附对象<strong>销毁</strong>或者脚本移除，延迟函数<strong>无法继续执行</strong></li>
<li>可以配合 OnEnable 和 OnDIsable 生命周期函数使用</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Invoke(<span class="string">&quot;TestFunc&quot;</span>, <span class="number">5.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;延时执行&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    paramFunc(<span class="number">2</span>); <span class="comment">//通过包裹一层来延迟执行paramFunc函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paramFunc</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;参数为&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5s后输出</span></span><br><span class="line"><span class="comment">//延时执行</span></span><br><span class="line"><span class="comment">//参数为2</span></span><br></pre></td></tr></table></figure>

<p>配合周期函数使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">QnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对象激活的生命周期函数中开启延迟(重复执行的延迟)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">QnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对象失活的生命周期函数中停止延迟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>取消延迟函数</strong></p>
<ol>
<li>取消该脚本上所有延迟函数 <code>CancelInVoke()</code></li>
<li>取消指定延迟函数 <code>CancelInVoke(&quot;函数名&quot;)</code></li>
</ol>
<p><strong>判断是否有延迟函数</strong><br><code>if(IsInVoking())</code>：针对所有延迟函数<br><code>if(IsInVoking(&quot;函数名&quot;))</code>：针对指定延迟函数</p>
<h2 id="1-Object-类"><a href="#1-Object-类" class="headerlink" title="1 Object 类"></a>1 Object 类</h2><p><strong>Object 是 Gameobject 的父类</strong> </p>
<ul>
<li>unity 里面的 Object 不是指的 cs 中的万物之父 object（cs 中的 object 命名空间是 system ）</li>
<li>unity 里的 Object 命名空间是 UnityEngine ，也是继承万物之父的一个自定义类</li>
</ul>
<h2 id="2-GameObject-类"><a href="#2-GameObject-类" class="headerlink" title="2 GameObject 类"></a>2 GameObject 类</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名字</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否激活</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.activeSelf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//static</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.isStatic);</span><br><span class="line"></span><br><span class="line"><span class="comment">//层级</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标签</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.tag);</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.position);</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><blockquote>
<p>[!warning]<br>如果是继承 MonoBehaviour 的类，可以不加 <code>.GameObject</code> 前缀</p>
</blockquote>
<h4 id="查找对象"><a href="#查找对象" class="headerlink" title="查找对象"></a>查找对象</h4><p>得到某一个单个对象目前有 2 种方式</p>
<ol>
<li>是 public 从外部面板拖进行关联（推荐）</li>
<li>通过 API 去找</li>
</ol>
<p>以下方法通过 API 去找：</p>
<ul>
<li>只能找到被激活的对象</li>
<li>如果场景中存在多个满足条件的对象 (比如同名、同 tag)，无法准确找到是谁</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建几何体</span></span><br><span class="line"><span class="comment">//只要得到了一个Gameobject 对象我就可以得到它身上挂在的任何脚本信息</span></span><br><span class="line"><span class="comment">//通过obj.GetComponent来得到脚本信息</span></span><br><span class="line">GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere);</span><br><span class="line">obj.name = <span class="string">&quot;球体&quot;</span>;</span><br><span class="line">obj.tag = <span class="string">&quot;Player&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 查找单个对象</span></span><br><span class="line"><span class="comment">//通过对象名查找，效率低，需要遍历所有对象</span></span><br><span class="line">GameObject obj2 = GameObject.Find(<span class="string">&quot;球体&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (obj2 != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    print(obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过tag查找象，需要遍历所有对象</span></span><br><span class="line">GameObject obj3 = GameObject.FindWithTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (obj3 != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    print(obj3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到场景中挂载的某一个脚本对象 ，效率太低，需要遍历所有对象，还要便利对象上挂载的脚本 </span></span><br><span class="line">TestScript ts = GameObject.FindObjectOfType&lt;TestScript&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查找多个对象（只能通过tag）</span></span><br><span class="line">GameObject[] objs = GameObject.FindGameObjectsWithTag(<span class="string">&quot;Player&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="实例化对象（Clone）"><a href="#实例化对象（Clone）" class="headerlink" title="实例化对象（Clone）"></a>实例化对象（Clone）</h4><p>实例化对象 (克隆对象)的方法<br>作用：根据一个对象创建出一个和它一模一样的对象</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备克隆的GameObject</span></span><br><span class="line"><span class="keyword">public</span> GameObject obj;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//准备用来克隆的对象</span></span><br><span class="line">    <span class="comment">//1.直接是场景上的某个对象</span></span><br><span class="line">    <span class="comment">//2.可以是一个预设体对象</span></span><br><span class="line">    GameObject objClone = GameObject.Instantiate(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在调用 Instantiate()方法创建对象时，<strong>接收 Instantiate()方法返回值的变量类型必须和传入参数的类型一致</strong>，否则接收变量的值会为 null.</li>
<li>这是一个重载函数，支持任何 Object 类及其子类，可以传多个参数来设置初始的位置和父对象</li>
</ul>
<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><p><code>Destroy</code> 方法不会马上移除对象，一般情况下它会在下一帧时把这个对象移除并从内存中移除</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除GameObject对象 </span></span><br><span class="line">GameObject.Destroy(obj, <span class="number">5</span>);  <span class="comment">//第二个参数可选，表示延迟几秒删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除脚本对象</span></span><br><span class="line">GameObject.Destroy(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//立即移除</span></span><br><span class="line"><span class="comment">//如果没有特殊需求，不用该方法，因为该方法不是异步的，可能会卡顿</span></span><br><span class="line">GameObject.DestroyImmediate(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过场景不移除</span></span><br><span class="line"><span class="comment">//默认情况在切换场景时场景中对象都会被自动删除掉</span></span><br><span class="line"><span class="comment">//如果你希望某个对象过场景不被移除就使用该方法</span></span><br><span class="line"><span class="comment">//一般都是传依附的Gameobject对象</span></span><br><span class="line"><span class="comment">//比如下面这句代码的意思就是自己依附的Gameobject对象过场景不被删除</span></span><br><span class="line">GameObject.DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="创建GameObject"><a href="#创建GameObject" class="headerlink" title="创建GameObject"></a>创建GameObject</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建空GameObject</span></span><br><span class="line">GameObject obj1 = <span class="keyword">new</span> GameObject(); <span class="comment">//默认名字New Game Object</span></span><br><span class="line">GameObject obj2 = <span class="keyword">new</span> GameObject(<span class="string">&quot;物体&quot;</span>); <span class="comment">//自定义名字</span></span><br><span class="line">GameObject obj3 = <span class="keyword">new</span> GameObject(<span class="string">&quot;物体&quot;</span>, <span class="keyword">typeof</span>(TestScript)); <span class="comment">//自定义名字，添加脚本，可以添加多个</span></span><br></pre></td></tr></table></figure>

<h4 id="添加-获取脚本"><a href="#添加-获取脚本" class="headerlink" title="添加&#x2F;获取脚本"></a>添加&#x2F;获取脚本</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为对象添加脚本</span></span><br><span class="line"><span class="comment">//继承MonoBehaviour的脚本是无法new的</span></span><br><span class="line"><span class="comment">//如果给GameObject对象动态添加继承MonoBehaviour的脚本，需要使用AddComponent方法</span></span><br><span class="line">TestScript ts1 = obj1.AddComponent(<span class="keyword">typeof</span>(TestScript)) <span class="keyword">as</span> TestScript;</span><br><span class="line"><span class="comment">//⭐用泛型更方便，推荐！</span></span><br><span class="line">TestScript script = obj1.AddComponent&lt;TestScript&gt;();</span><br><span class="line"><span class="comment">//通过返回值，可以得到脚本的信息，来进行一些处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取脚本</span></span><br><span class="line">TestScript ts2 = obj1.GetComponent&lt;TestScript&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="标签比较"><a href="#标签比较" class="headerlink" title="标签比较"></a>标签比较</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//标签比较</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显式字符串比较效率低下，建议改用‘CompareTag&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.gameObject.tag == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="激活失活"><a href="#激活失活" class="headerlink" title="激活失活"></a>激活失活</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置激活失活</span></span><br><span class="line">obj1.SetActive(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>以下方法不建议使用，效率比较低</p>
<p>通过广播或者发送消息的形式，让自己或者别人执行某些行为</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通知自己执行什么行为</span></span><br><span class="line">    <span class="comment">//命令自己去执行这个Test这个函数 会在自己身上挂载的所有脚本去找这个名字的函数</span></span><br><span class="line">    <span class="comment">//它会去找到自己身上所有的脚本有这个名字的函数去执行</span></span><br><span class="line">    <span class="keyword">this</span>.gameObject.SendMessage(<span class="string">&quot;TestFunc&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SendMessage(<span class="string">&quot;TestFunc1&quot;</span>,<span class="number">10</span>); <span class="comment">//第二个参数可以传参</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//广播，让自己和自己的子对象执行函数</span></span><br><span class="line">    <span class="keyword">this</span>.gameObject.BroadcastMessage(<span class="string">&quot;TestFunc&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向父对象和自己发送消息并执行</span></span><br><span class="line">    <span class="keyword">this</span>.gameObject.SendMessageUpwards(<span class="string">&quot;TestFunc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunc1</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Hello World!&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Time-类"><a href="#3-Time-类" class="headerlink" title="3 Time 类"></a>3 Time 类</h2><figure class="highlight cs"><figcaption><span>title:游戏时间</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//时间缩放比例 </span></span><br><span class="line">    Time.timeScale = <span class="number">0</span>; <span class="comment">//时间停止</span></span><br><span class="line">    Time.timeScale = <span class="number">1</span>; <span class="comment">//时间正常</span></span><br><span class="line">    Time.timeScale = <span class="number">2</span>; <span class="comment">//2倍速 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//帧间隔时间（最近的两帧之间的时间间隔）主要用于计算位移</span></span><br><span class="line">    <span class="comment">//路程=速度*时间</span></span><br><span class="line">    <span class="comment">//受Scale影响的帧间隔时间</span></span><br><span class="line">    print(Time.deltaTime);   <span class="comment">//如果希望游戏暂停时就不动的，就是用deltaTime</span></span><br><span class="line">    <span class="comment">//不受Scale影响的帧间隔时间</span></span><br><span class="line">    print(Time.unscaledDeltaTime); <span class="comment">//如果希望游戏暂停时还能动的，就是用unscaledDeltaTime</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏开始到现在的时间</span></span><br><span class="line">    <span class="comment">//受Scale影响</span></span><br><span class="line">    print(Time.time);</span><br><span class="line">    <span class="comment">//不受Scale影响</span></span><br><span class="line">    print(Time.unscaledTime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏开始到现在跑了多少帧</span></span><br><span class="line">    print(Time.frameCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:物理时间</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//物理帧间隔时间</span></span><br><span class="line">    <span class="comment">//受Scale影响</span></span><br><span class="line">    print(Time.fixedTime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不受Scale影响</span></span><br><span class="line">    print(Time.fixedUnscaledTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Transform-类"><a href="#4-Transform-类" class="headerlink" title="4 Transform 类"></a>4 Transform 类</h2><p>游戏对象（Gameobject）位移、旋转、缩放、父子关系、坐标转换等相关操作都由它处理，它是 unity 提供的极其重要的类</p>
<h3 id="Transform-和-GameObject-的区别"><a href="#Transform-和-GameObject-的区别" class="headerlink" title="Transform 和 GameObject 的区别"></a>Transform 和 GameObject 的区别</h3><p>当我们使用 <code>Instantiate()</code> 创建 prefab 对象时，有如下两种方法，都可以创建出对象。区别在哪？</p>
<ol>
<li><strong>使用 GameObject</strong><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036032.png" alt="Pasted image 20230723222136"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Gameobject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectTransformTesting</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">serializeField</span>] <span class="keyword">private</span> Gameobject prefab;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"> </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( 工nput.GetKeyDown( Keycode.T)) </span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(prefab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><strong>使用 Transfrom</strong><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036033.png" alt="Pasted image 20230723222217"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Transform</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectTransformTesting</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">serializeField</span>] <span class="keyword">private</span> Transform prefab;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"> </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( 工nput.GetKeyDown( Keycode.T)) </span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(prefab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：</p>
<ol>
<li>任何对象都必须有 Transform 组件</li>
<li>⭐<strong>我们可以使用 transform. gameobject 来获取 Gameobject 对象，也可以用 gameobject. transform 来获取 Transfrom 组件</strong></li>
<li><code>Instantiate ()</code> 是泛型函数，参数填什么类型就返回什么类型 <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036034.png" alt="Pasted image 20230723222635"><br><strong>从第二点就可以看出来，它门可以相互转换，所以实际上用谁区别不大，都可以拿到我们想要的数据。</strong><br>通常我们会对对象进行位置变换，可以优先使用 Transfrom，这样就可以避免 gameobject. transfrom 这一步。<br>涉及对对象本身的设置，如激活、销毁，就优先用 gameobject。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectTransformTesting</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">serializeField</span>] <span class="keyword">private</span> Transform prefab;</span><br><span class="line">    <span class="comment">//[serializeField] private Gameobject prefab;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"> </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( 工nput.GetKeyDown( Keycode.T)) </span><br><span class="line">        &#123;</span><br><span class="line">            Transform prefabTransform = Instantiate(prefab);</span><br><span class="line">            <span class="comment">//Gameobject prefabGameobject = Instantiate(prefab);</span></span><br><span class="line">            prefabTransform.position = Vector3.zero;</span><br><span class="line">            <span class="comment">//prefabGameobject.transform.position = Vector3.zero;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><blockquote>
<p>[!NOTE] Inspector 面板上的 Transfrom 信息<br>对于父对象来说，positon 是世界空间位置<br>对于子对象来说，position 是相对于父对象的位置，即在父对象为原点的局部空间中位置</p>
</blockquote>
<figure class="highlight cs"><figcaption><span>title:position</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//世界空间位置</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.position);</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部空间位置</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.localPosition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//position的赋值不能单独改变x,y,z，只能整体改变</span></span><br><span class="line"><span class="comment">//this.transform.position.x = 1; error！</span></span><br><span class="line"><span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="keyword">this</span>.transform.position.x+<span class="number">100</span>, <span class="keyword">this</span>.transform.position.y, <span class="keyword">this</span>.transform.position.z);</span><br><span class="line"></span><br><span class="line">print(<span class="keyword">this</span>.transform.forward); <span class="comment">//局部空间的z轴方向，注意和Vector3.forward区分</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.right);   <span class="comment">//局部空间的x轴方向</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.up);      <span class="comment">//局部空间的y轴方向</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 理解 this.transform.forward 和 Vector3.forward 的区别<br>现在新建一个物体，假设它的世界坐标系是这样的：（刚刚创建的物体本地坐标系也和世界坐标系重合）</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036035.png" alt="Pasted image 20230717115734"><br>现在将物体绕 y 轴顺时针旋转一定角度。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036036.png" alt="Pasted image 20230717115742"><br><strong>现在黑色坐标系是世界坐标系，红色坐标系是物体旋转后的本地坐标系</strong>（因为是绕 y 轴转所以 y 轴不动，就不标红了）。</p>
<blockquote>
</blockquote>
<p><code>this.transform.forward</code> 是指对象局部空间的朝向，即图中红 <code>Z</code><br><code>Vector3.forward</code> 是指向量 $(0,0,1)$，和图中黑 <code>Z</code> 方向一致<br><strong>这两个向量虽然指向的相对位置不同，但是得到的数值都是相对于世界坐标下的！</strong><code>this.transform.forward</code> 虽然是指对象局部空间的朝向，红 <code>Z</code> 在局部空间为 $(0,0,1)$，但我们得到的数值是转换到世界空间的数值！</p>
<h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>实现位移的四种方式：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036037.png" alt="Pasted image 20230605154644"></p>
<p>需要联动 [[《Unity Primer》#5 Input 类]]</p>
<figure class="highlight cs"><figcaption><span>title:位移 h:11,12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理解坐标系下的位移计算公式</span></span><br><span class="line"><span class="comment">//路程–方向*速度*时间</span></span><br><span class="line"><span class="comment">//方式一：自己计算</span></span><br><span class="line"><span class="comment">//想要变化的就是 position</span></span><br><span class="line"><span class="keyword">this</span>.transform.position += <span class="keyword">this</span>.transform.forward * (<span class="number">1</span> * Time.deltaTime);  <span class="comment">//朝对象局部空间的z轴前进</span></span><br><span class="line"><span class="keyword">this</span>.transform.position += Vector3.forward * (<span class="number">1</span> * Time.deltaTime);  <span class="comment">//朝世界空间Z轴前进</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：API,一般使用前两种</span></span><br><span class="line"><span class="comment">//参数一:表示位移多少路程=方向*速度*时间</span></span><br><span class="line"><span class="comment">//参数二:表示相对哪个坐标系移动 ,默认该参数是自身局部空间Space.Self</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward*(<span class="number">1</span> * Time.deltaTime),Space.Self);  <span class="comment">//始终朝向局部空间Z轴移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="keyword">this</span>.transform.forward*(<span class="number">1</span> * Time.deltaTime), Space.World); <span class="comment">//始终朝向局部空间Z轴移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward*(<span class="number">1</span> * Time.deltaTime), Space.World); <span class="comment">//始终朝向世界空间Z轴移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="keyword">this</span>.transform.forward(<span class="number">1</span> * Time.deltaTime), Space.Self);  <span class="comment">//方向错误，因为this.transform.forward的值是世界空间下的，并不是(0,0,1)</span></span><br></pre></td></tr></table></figure>
<h3 id="角度和旋转"><a href="#角度和旋转" class="headerlink" title="角度和旋转"></a>角度和旋转</h3><figure class="highlight cs"><figcaption><span>title:角度</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和角度设置一样，不能单独设置x,y,z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inspector界面上显示的Rotation是欧拉角</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.eulerAngles); <span class="comment">//该方法返回欧拉角,</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.localEulerAngles);</span><br><span class="line"></span><br><span class="line">print(<span class="keyword">this</span>.transform.rotation);  <span class="comment">//该方法返回四元数</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.localRotation); </span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:旋转</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//绕轴自转</span></span><br><span class="line">    <span class="comment">//方法一：</span></span><br><span class="line">    <span class="comment">//参数一：每帧旋转的角度</span></span><br><span class="line">    <span class="comment">//参数二：默认Space.Self</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>) * Time.deltaTime,Space.World);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法二：</span></span><br><span class="line">    <span class="comment">//参数一：绕哪个轴旋转</span></span><br><span class="line">    <span class="comment">//参数二：是每帧转动的角度</span></span><br><span class="line">    <span class="comment">//参数三：默认Space.Self</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Rotate(Vector3.up, <span class="number">10</span> * Time.deltaTime, Space.World);</span><br><span class="line">    <span class="keyword">this</span>.transform.Rotate(Vector3.up, <span class="number">10</span> * Time.deltaTime, Space.Self); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//绕点转</span></span><br><span class="line">    <span class="comment">//点，轴，旋转速度</span></span><br><span class="line">    <span class="keyword">this</span>.transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">10</span> * Time.deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩放和LookAt"><a href="#缩放和LookAt" class="headerlink" title="缩放和LookAt"></a>缩放和LookAt</h3><figure class="highlight cs"><figcaption><span>title:缩放</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对世界坐标系的缩放大小只能得，不能改</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.lossyScale); </span><br><span class="line"></span><br><span class="line"><span class="comment">//相对局部坐标系(父对象)</span></span><br><span class="line"><span class="keyword">this</span>.transform.localScale  = <span class="keyword">new</span> Vector3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">//和角度设置一样，不能单独设置x,y,z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Unity没有提供关于缩放的API，只能自己修改localScale</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:LookAt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.LookAt(Vector3.zero); <span class="comment">//看向点</span></span><br><span class="line"><span class="keyword">this</span>.transform.LookAt(obj); <span class="comment">//看向一个对象，参数为对象的Transform</span></span><br></pre></td></tr></table></figure>

<h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><h4 id="获取和设置父对象"><a href="#获取和设置父对象" class="headerlink" title="获取和设置父对象"></a>获取和设置父对象</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取父对象</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.parent.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断绝父子关系</span></span><br><span class="line"><span class="keyword">this</span>.transform.parent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置父对象</span></span><br><span class="line"><span class="keyword">this</span>.transform.parent = GameObject.Find(<span class="string">&quot;FatherObject&quot;</span>).transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过API设置，差别主要是多了一个参数二</span></span><br><span class="line"><span class="comment">//参数一:我的父亲</span></span><br><span class="line"><span class="comment">//参数二:是否保留世界坐标的位置角度缩放信息</span></span><br><span class="line"><span class="comment">//true会保留世界，坐标下的状态和父对象进行计算得到本地坐标系的信息</span></span><br><span class="line"><span class="comment">//false不会保留，会直接把世界坐标系下的位置角度缩放直接赋值到本地坐标系下,通常会改变原位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.SetParent(<span class="literal">null</span>); <span class="comment">//断绝父子关系</span></span><br><span class="line"><span class="keyword">this</span>.transform.SetParent(GameObject.Find(<span class="string">&quot;FatherObject&quot;</span>).transform,<span class="literal">false</span>); <span class="comment">//设置父对象</span></span><br><span class="line"><span class="keyword">this</span>.transform.DetachChildren(); <span class="comment">//和自己的所有儿子断绝关系，不会影响儿子和孙子的关系</span></span><br></pre></td></tr></table></figure>

<h4 id="获取子对象"><a href="#获取子对象" class="headerlink" title="获取子对象"></a>获取子对象</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按名字查找儿子</span></span><br><span class="line"><span class="comment">//只能找儿子，不能找孙子</span></span><br><span class="line"><span class="comment">//Find方法效率比GameObject.Find()高，前提要知道父亲是谁</span></span><br><span class="line"><span class="comment">//Find方法是能够找到失活的对象的! Gameobject相关的查找是不能找到失活对象的</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.Find(<span class="string">&quot;Son&quot;</span>).name);</span><br><span class="line"></span><br><span class="line">print(<span class="keyword">this</span>.transform.Find(<span class="string">&quot;Son/grandson&quot;</span>).name);  <span class="comment">//找到子对象的子对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历儿子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.transform.childCount; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过索引号找到特定的儿子</span></span><br><span class="line">    print(<span class="keyword">this</span>.transform.GetChild(i).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="儿子的操作"><a href="#儿子的操作" class="headerlink" title="儿子的操作"></a>儿子的操作</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是我的儿子</span></span><br><span class="line"><span class="keyword">if</span> (son.IsChildOf(<span class="keyword">this</span>.transform))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到自己作为儿子的编号  sibling:兄弟姐妹</span></span><br><span class="line">print(son.GetSiblingIndex());</span><br><span class="line"></span><br><span class="line"><span class="comment">//把自己设置为第一个儿子</span></span><br><span class="line">son.SetAsFirstSibling();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把自己设置为最后一个儿子</span></span><br><span class="line">son.SetAsLastSibling();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把自己设置为指定索引号的儿子，编号超出范围不会报错，自动设置会最后一个编号</span></span><br><span class="line">son.SetSiblingIndex(<span class="number">5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义拓展方法"><a href="#自定义拓展方法" class="headerlink" title="自定义拓展方法"></a>自定义拓展方法</h3><ol>
<li><p>为 Transform 写一个<strong>拓展方法</strong>，可以将它的子对象按名字的长短进行排序改变他们的顺序名字短的在前面，名字长的在后面。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036038.png" alt="Pasted image 20230604162029"></p>
<figure class="highlight cs"><figcaption><span>title:tool.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个Transfrom类的拓展方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为Transform添加一个拓展方法</span></span><br><span class="line">    <span class="comment">//可以将它的子对象按名字的长短进行排序改变他们的顺序，名字短的在前面，名字长的在后面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="keyword">this</span> Transform obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Transform&gt; list = <span class="keyword">new</span> List&lt;Transform&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; obj.childCount; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(obj.GetChild(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是根据名字长短进行排序利用的是list的排序</span></span><br><span class="line">        list.Sort((a, b) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.name.Length &lt; b.name.Length)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.name.Length &gt; b.name.Length)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据list中的排序结果重新设置每一个对象的索引编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list[i].SetSiblingIndex(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在父对象挂载的脚本中调用即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.transform.Sort();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>请为 Transform 写一个拓展方法，传入一个名字查找子对象，即使是子对象的子对象也能查找到</p>
<figure class="highlight cs"><figcaption><span>title:tool.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transform <span class="title">CustomFind</span>(<span class="params"><span class="keyword">this</span> Transform father, <span class="built_in">string</span> childName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//要找的子对象</span></span><br><span class="line">    Transform target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//先从自己身上的子对象找</span></span><br><span class="line">    target = father.Find(childName);</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果自己身上没有，就从自己的子对象的子对象找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; father.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        target = father.GetChild(i).CustomFind(childName);</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在父对象挂载的脚本中调用即可</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.CustomFind(<span class="string">&quot;aaa&quot;</span>).name);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-Input-类"><a href="#5-Input-类" class="headerlink" title="5 Input 类"></a>5 Input 类</h2><p>输入相关内容都写在 Update 中</p>
<h3 id="鼠标键盘输入"><a href="#鼠标键盘输入" class="headerlink" title="鼠标键盘输入"></a>鼠标键盘输入</h3><figure class="highlight cs"><figcaption><span>title:鼠标输入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标在屏幕上的位置</span></span><br><span class="line"><span class="comment">//屏幕坐标的原点是在屏幕的左下角，往右是x轴正方向，往上是Y轴正方向</span></span><br><span class="line"><span class="comment">//返回值是Vector3，但是只有x和y有值，z一直是0是，因为屏幕本来就是2D的不存在z轴</span></span><br><span class="line">Input.mousePosition</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测鼠标输入</span></span><br><span class="line"><span class="comment">//0左键 1右键 2中键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按下Down</span></span><br><span class="line">Input.GetMouseButtonDown(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//抬起Up</span></span><br><span class="line">Input.GetMouseButtonUp(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//按住</span></span><br><span class="line">Input.GetMouseButton(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//中键滚动</span></span><br><span class="line"><span class="comment">//它的返回值是（0，Y），返回值的Y -1往下滚  0没有滚  1往上滚</span></span><br><span class="line">Input.mouseScrollDelta</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:键盘输入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘按下</span></span><br><span class="line"><span class="comment">//方法一(推荐)</span></span><br><span class="line">Input.GetKeyDown(KeyCode.W) <span class="comment">//本质上是按W时返回true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：传入字符串的重载</span></span><br><span class="line"><span class="comment">//只能传入小写字符串</span></span><br><span class="line">Input.GetKeyDown(<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘抬起</span></span><br><span class="line">Input.GetKeyUp(KeyCode.W)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//键盘按住</span></span><br><span class="line">Input.GetKey(KeyCode.W)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:任意键</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意键 按下</span></span><br><span class="line">Input.anyKeyDown</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意键 抬起</span></span><br><span class="line">Input.anyKeyUp</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意键 按下</span></span><br><span class="line">Input.anyKey</span><br></pre></td></tr></table></figure>

<h3 id="默认轴输入"><a href="#默认轴输入" class="headerlink" title="默认轴输入"></a>默认轴输入</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036039.png" alt="Pasted image 20230604213230"><br>我们学习鼠标键盘输入主要是用来控制玩家，比如旋转位移等等，所以 unity 提供了更方便的方法来帮助我们控制对象的位移和旋转。</p>
<figure class="highlight cs"><figcaption><span>title:默认轴输入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标AD按下时，返回-1到1之间的浮点值</span></span><br><span class="line"><span class="comment">//相当于得到这个值，就是我们的左右方向，用于控制左右移、旋转</span></span><br><span class="line">Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标WS按下时，返回-1到1之间的浮点值</span></span><br><span class="line"><span class="comment">//相当于得到这个值，就是我们的上下方向，用于控制上下移、旋转</span></span><br><span class="line">Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标横向移动时，返回-1到1之间的浮点值</span></span><br><span class="line">Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标纵向移动时，返回-1到1之间的浮点值</span></span><br><span class="line">Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GetAxisRaw方法和GetAxis使用方式相同</span></span><br><span class="line"><span class="comment">//只不过它的返回值只会是-1,0,1不会有中间值</span></span><br></pre></td></tr></table></figure>

<h3 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a>移动设备</h3><figure class="highlight cs"><figcaption><span>title:移动设备</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动设备触摸相关</span></span><br><span class="line"><span class="keyword">if</span> (Input.touchCount &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Touch t1 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//位置</span></span><br><span class="line">    print(t1.position);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相对上次位置的变化</span></span><br><span class="line">    print(t1.deltaPosition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否启用多点触控</span></span><br><span class="line">Input.multiTouchEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪</span></span><br><span class="line"><span class="comment">//是否启用陀螺仪</span></span><br><span class="line">Input.gyro.enabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪的旋转速度 </span></span><br><span class="line">print(Input.gyro.rotationRate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪的重力加速度向量</span></span><br><span class="line">print(Input.gyro.gravity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪 当前的旋转四元数</span></span><br><span class="line"><span class="comment">//比如用这个角度信息来控制场景上的一个3D物体受到重力影响</span></span><br><span class="line"><span class="comment">//手机怎么动它怎么动</span></span><br><span class="line">print(Input.gyro.attitude);</span><br></pre></td></tr></table></figure>
<h3 id="手柄输入"><a href="#手柄输入" class="headerlink" title="手柄输入"></a>手柄输入</h3><figure class="highlight cs"><figcaption><span>title:手柄输入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到连接的手柄的所有按钮名字</span></span><br><span class="line"><span class="built_in">string</span>[] strs = Input.GetJoystickNames();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//某一个手柄键按下</span></span><br><span class="line">Input. GetButtonDown(<span class="string">&quot;Jump&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//某一个手柄键抬起</span></span><br><span class="line">Input.GetButtonup(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//某一个手柄键长按</span></span><br><span class="line">Input.GetButton(<span class="string">&quot;Jump&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="6-Screen-类"><a href="#6-Screen-类" class="headerlink" title="6 Screen 类"></a>6 Screen 类</h2><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前设备屏幕分辨率</span></span><br><span class="line">Resolution r = Screen.currentResolution;</span><br><span class="line">print(r.width);</span><br><span class="line">print(r.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Game窗口宽高</span></span><br><span class="line">print(Screen.width);</span><br><span class="line">print(Screen.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕睡眠模式</span></span><br><span class="line">Screen.sleepTimeout = SleepTimeout.NeverSleep;</span><br><span class="line">Screen.sleepTimeout = SleepTimeout.SystemSetting;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行时是否全屏模式</span></span><br><span class="line">Screen.fullScreen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口模式</span></span><br><span class="line"><span class="comment">//独占全屏FullscreenMode.ExclusiveFullscreen</span></span><br><span class="line"><span class="comment">//全屏窗口FullscreenMode.Fullscreenwindow</span></span><br><span class="line"><span class="comment">//最大化窗口FullscreenMode. Maximizedwindow</span></span><br><span class="line"><span class="comment">//窗口模式FullscreenMode.windowed</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.Windowed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动设备屏幕转向相关</span></span><br><span class="line"><span class="comment">//允许自动旋转为左横向 Home键在左</span></span><br><span class="line">Screen.autorotateToLandscapeLeft = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//允许自动旋转为右横向 Home键在右</span></span><br><span class="line">Screen.autorotateToLandscapeRight = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//允许自动旋转到纵向 Home键在下</span></span><br><span class="line">Screen.autorotateToPortrait = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//允许自动旋转到纵向倒着看 Home键在上</span></span><br><span class="line">Screen.autorotateToPortraitUpsideDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定屏幕显示方向</span></span><br><span class="line">Screen.orientation = ScreenOrientation.LandscapeLeft;</span><br></pre></td></tr></table></figure>
<h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置分辨率</span></span><br><span class="line">Screen.SetResolution(<span class="number">1920</span>, <span class="number">1080</span>, <span class="literal">true</span>); <span class="comment">//第三个参数是是否全屏</span></span><br></pre></td></tr></table></figure>

<h2 id="8-场景"><a href="#8-场景" class="headerlink" title="8 场景"></a>8 场景</h2><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036040.png" alt="Pasted image 20230609131650|500"></p>
<h3 id="场景同步切换"><a href="#场景同步切换" class="headerlink" title="场景同步切换"></a>场景同步切换</h3><figure class="highlight cs"><figcaption><span>title:场景同步切换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景切换，指定的场景必须先在构建设置中加入</span></span><br><span class="line">SceneManager.LoadScene(<span class="string">&quot;GameScene&quot;</span>);</span><br><span class="line"><span class="comment">//旧版本代码</span></span><br><span class="line"><span class="comment">//Application.LoadIevel(&quot;GameScene&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//过场景不移除</span></span><br><span class="line"><span class="comment">//默认情况在切换场景时场景中对象都会被自动删除掉</span></span><br><span class="line"><span class="comment">//如果你希望某个对象过场景不被移除就使用该方法</span></span><br><span class="line"><span class="comment">//一般都是传依附的Gameobject对象</span></span><br><span class="line"><span class="comment">//比如下面这句代码的意思就是自己依附的Gameobject对象过场景不被删除</span></span><br><span class="line">GameObject.DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出游戏</span></span><br><span class="line"><span class="keyword">if</span>( Input.GetKeyDown( Keycode.Escape) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//游戏打包后才起作用</span></span><br><span class="line">    Application.Quit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前场景判断</span></span><br><span class="line"><span class="keyword">if</span> (SceneManager.GetActiveScene().name == <span class="string">&quot;StartMenu&quot;</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//让开始面板显示  </span></span><br><span class="line">    BeginPanel.Instance.ShowMe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景异步切换"><a href="#场景异步切换" class="headerlink" title="场景异步切换"></a>场景异步切换</h3><p>在切换场景时，Unity 会删除当前场景上所有对象，并且去加载下一个场景的相关信息<br>如果当前场景对象过多或者下一个场景对象过多，这个过程会非常的耗时会让玩家感受到卡顿，异步切换就是来解决该问题的，开一个子线程去加载，加载好后存入公共容器。</p>
<p>场景异步加载和资源异步加载几乎一致，有两种方式：</p>
<ol>
<li><p><strong>通过事件回调函数异步加载</strong></p>
<figure class="highlight cs"><figcaption><span>title:通过事件回调函数异步加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncOperation ao =  SceneManager.LoadSceneAsync(<span class="string">&quot;Scenename&quot;</span>);</span><br><span class="line">    <span class="comment">//当场景异步加载结束后就会自动调用该事件函数，我们如果希望在加载结束后做一些事情，那么就可以在该函数中，写处理逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通形式</span></span><br><span class="line">    ao.completed += LoadOver;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等价，lambda表达式形式</span></span><br><span class="line">    ao.completed += (a) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadOver</span>(<span class="params">AsyncOperation ao</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>通过协程异步加载</strong><br>需要注意的是加载场景会把当前场景没有特别处理的对象都删除了，所以协程中的部分逻辑可能是执行不了的<br>解决思路：使用 <code>GameObject.DontDestroyOnLoad()</code> 方法让处理场景加载的脚本依附的对象过场景时不被移除</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject.DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    </span><br><span class="line">    StartCoroutine(LoadScene(<span class="string">&quot;Scenename&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(sceneName);</span><br><span class="line">    </span><br><span class="line">    GameObject.DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> ao; <span class="comment">//Unity自己知道该返回值意味着你在异步加载资源</span></span><br><span class="line">    <span class="comment">//Unity 会自己判断该场景是否加载完毕了,加载完毕过后才会继续执行后面的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加载完毕后执行其他逻辑</span></span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>); <span class="comment">//无法执行，因为切换场景后，上一场景中的所有对象都会被删除，该脚本自然无法继续执行。</span></span><br><span class="line">                   </span><br><span class="line">    <span class="comment">//我们可以在Start()函数中使用GameObject.DontDestroyOnLoad方法，让该脚本依附的对象过场景不被删除!这样就可以正常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>协程的优点</strong>是异步加载场景时我可以在加载的同时做一些别的逻辑 （写在 <code>yield return</code> 上面，通过事件回调函数异步加载的方法只能在加载结束后执行其他逻辑），<strong>比如我们可以在异步加载过程中去更新进度条。</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!ao.isDone)</span><br><span class="line">&#123;</span><br><span class="line">    print(ao.progress);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离开循环后就会认为场景加载结束</span></span><br><span class="line"><span class="comment">//可以把进度条顶满然后隐藏进度条</span></span><br></pre></td></tr></table></figure>

<p>当然不是说必须用异步方法更新进度条（这种方法实际不准确），要根据你游戏的规则自己定义进度条变化的条件，根据需求选择，没有谁好谁坏：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> ao;</span><br><span class="line"><span class="comment">//场景加载结束更新 20%进度</span></span><br><span class="line"><span class="comment">//接着去加载场景中的其它信息</span></span><br><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="comment">//动态加载怪物</span></span><br><span class="line"><span class="comment">//这时进度条再更新 20%</span></span><br><span class="line"><span class="comment">//动态加载场景模型</span></span><br><span class="line"><span class="comment">//这时就认为加载结束了进度条顶满</span></span><br><span class="line"><span class="comment">//隐藏进度条</span></span><br></pre></td></tr></table></figure>

<p>他们的优缺点表现和资源异步加载也是一样的</p>
<ol>
<li>事件回调函数<br>优点: 写法简单，逻辑清晰<br>缺点: 只能加载完场景做一些事情不能再加载过程中处理逻辑</li>
<li>协程异步加载<br>优点: 可以在加载过程中处理逻辑，比如进度条更新等<br>缺点: 写法较为麻烦，要通过协程</li>
</ol>
<h2 id="9-鼠标Cursor"><a href="#9-鼠标Cursor" class="headerlink" title="9 鼠标Cursor"></a>9 鼠标Cursor</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示/隐藏鼠标</span></span><br><span class="line">Cursor.visible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁定鼠标，按ESC键解锁</span></span><br><span class="line"><span class="comment">// None 不锁定</span></span><br><span class="line"><span class="comment">// Locked 锁定鼠标会被限制在屏幕的中心点，并且会隐藏鼠标</span></span><br><span class="line"><span class="comment">// Confined 限制在窗口范围内</span></span><br><span class="line">Cursor.lockState = CursorLockMode.Confined;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一:光标图片</span></span><br><span class="line"><span class="comment">//参数二:偏移位置相对图片左上角</span></span><br><span class="line"><span class="comment">//参数三:平台支持的光标模式(硬件或软件)</span></span><br><span class="line">Cursor.SetCursor(texture, <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>), CursorMode.Auto);</span><br></pre></td></tr></table></figure>
<h2 id="10-LineRenderer"><a href="#10-LineRenderer" class="headerlink" title="10 LineRenderer"></a>10 LineRenderer</h2><p>LineRenderer 是 Unity 提供的一个用于<strong>画线</strong>的组件，使用它我们可以在场景中绘制线段<br>一般可以用于</p>
<ol>
<li>绘制攻击范围 </li>
<li>武器红外线 </li>
<li>辅助功能 </li>
<li>其它画线功能</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036041.png" alt="Pasted image 20230611160618|450"></p>
<h3 id="组件功能"><a href="#组件功能" class="headerlink" title="组件功能"></a>组件功能</h3><p>编辑模式：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036042.png" alt="Pasted image 20230611161700"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036043.png" alt="Pasted image 20230611160703|450"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036044.png" alt="Pasted image 20230611161227|450"><br>使用受光影响的材质时，勾选 Generate Lighting Data<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036045.png" alt="Pasted image 20230611161306|600"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036046.png" alt="Pasted image 20230611161632"></p>
<h3 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h3><p>所有参数都可以通过代码控制</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态添加一个线段</span></span><br><span class="line">GameObject line = <span class="keyword">new</span> GameObject();</span><br><span class="line">line.name = <span class="string">&quot;Line&quot;</span>;</span><br><span class="line">LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//首尾相连</span></span><br><span class="line">lineRenderer.loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始结束宽度</span></span><br><span class="line">lineRenderer.startWidth = <span class="number">1.0f</span>;</span><br><span class="line">lineRenderer.endWidth = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始结束颜色</span></span><br><span class="line">lineRenderer.startColor = Color.white;</span><br><span class="line">lineRenderer.endColor = Color.red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置材质</span></span><br><span class="line">lineRenderer.material = material;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置点，注意要先设置点的个数</span></span><br><span class="line">lineRenderer.positionCount = <span class="number">4</span>;</span><br><span class="line">lineRenderer.SetPosition(<span class="number">0</span>, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">lineRenderer.SetPosition(<span class="number">1</span>, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">lineRenderer.SetPosition(<span class="number">2</span>, <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">lineRenderer.SetPosition(<span class="number">3</span>, <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否使用世界坐标</span></span><br><span class="line">lineRenderer.useWorldSpace = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h1 id="三、核心系统"><a href="#三、核心系统" class="headerlink" title="三、核心系统"></a>三、核心系统</h1><h2 id="2-音频系统"><a href="#2-音频系统" class="headerlink" title="2 音频系统"></a>2 音频系统</h2><p>常用格式：wav，mp3，ogg，aiff</p>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036047.png" alt="Pasted image 20230605155215|450"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036048.png" alt="Pasted image 20230605155225"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036049.png" alt="Pasted image 20230605155456"></p>
<h3 id="音频源-Audio-Source"><a href="#音频源-Audio-Source" class="headerlink" title="音频源 Audio Source"></a>音频源 Audio Source</h3><ul>
<li>一个 Scene 内 Audio Source 只能有一个</li>
<li>一个 Gameobject 可以挂载多个音效源脚本 AudioSource</li>
<li>使用时要注意如果要挂载多个，那一定要自己管理他们，控制他们的播放停止，不然我们没有办法准确的获取谁是谁<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036050.png" alt="Pasted image 20230605155715|500"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036051.png" alt="Pasted image 20230605155803|450"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036052.png" alt="Pasted image 20230605160059"></li>
</ul>
<p><strong>Spatial Blend</strong>：设置 3D 音效，默认为 2D<br><strong>Volume Rolloff</strong>：声音距离衰减</p>
<figure class="highlight cs"><figcaption><span>title:代码控制</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">AudioSource audioSource;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    audioSource = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制播放停止</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.P))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        audioSource.Play();</span><br><span class="line">        <span class="comment">//audioSource.PlayDelayed(5); //延迟几秒后播放</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//停止</span></span><br><span class="line">        audioSource.Stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停</span></span><br><span class="line">        audioSource.Pause();</span><br><span class="line">        <span class="comment">//audioSource.UnPause(); //关闭暂停，实际上再执行一次Pause方法也会关闭暂停</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测音效播放完毕</span></span><br><span class="line">    <span class="keyword">if</span>(audioSource.isPlaying)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;正在播放&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;播放结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何动态控制音效播放</strong></p>
<ol>
<li>直接在要播放音效的对象上挂载脚本控制播放</li>
<li>实例化挂载了音效源脚本的对象</li>
<li>用一个 Audio Clip 来控制播放不同的音效<figure class="highlight cs"><figcaption><span>title:动态控制音效播放</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AudioClip clip;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    AudioSource audioSource = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;();</span><br><span class="line">    audioSource.clip = clip;</span><br><span class="line">    audioSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="麦克风设备"><a href="#麦克风设备" class="headerlink" title="麦克风设备"></a>麦克风设备</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取设备麦克风信息</span></span><br><span class="line"><span class="built_in">string</span>[] strs = Microphone.devices;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i++) </span><br><span class="line">&#123;</span><br><span class="line">    print(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始录音</span></span><br><span class="line"><span class="comment">//参数一:设备名，传null使用默认设备</span></span><br><span class="line"><span class="comment">//参数二:超过录制长度后是否重头录制</span></span><br><span class="line"><span class="comment">//参数三:录制时长</span></span><br><span class="line"><span class="comment">//参数四:采样率</span></span><br><span class="line">audioClip = Microphone.Start(<span class="literal">null</span>, <span class="literal">false</span>, <span class="number">10</span>, <span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束录音</span></span><br><span class="line">Microphone.End(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//播放录制音频</span></span><br><span class="line">AudioSource s = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s = <span class="keyword">this</span>.gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">&#125;</span><br><span class="line">s.clip = audioClip;</span><br><span class="line">s.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取音频数据用于存储或者传输  </span></span><br><span class="line"><span class="comment">//用于存储数组数据的长度=声道数*剪辑长度  </span></span><br><span class="line"><span class="built_in">float</span>[] f = <span class="keyword">new</span> <span class="built_in">float</span>[audioClip.channels * audioClip.samples];  </span><br><span class="line">audioClip.GetData(f, <span class="number">0</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="3-物理系统"><a href="#3-物理系统" class="headerlink" title="3 物理系统"></a>3 物理系统</h2><h3 id="1-碰撞检测"><a href="#1-碰撞检测" class="headerlink" title="(1) 碰撞检测"></a>(1) 碰撞检测</h3><p>物理信息的更新和 FixedTime 相关</p>
<blockquote>
<p>[!bug]  碰撞产生的必要条件：</p>
<ul>
<li>两个物体都有碰撞器 Collider</li>
<li>至少一个物体有刚体 Rigidbody</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036053.png" alt="Pasted image 20230605124248"></p>
<h4 id="刚体-Rigidbody"><a href="#刚体-Rigidbody" class="headerlink" title="刚体 Rigidbody"></a>刚体 Rigidbody</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036054.png" alt="Pasted image 20230605124429"></p>
<p><strong>插值运算：</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036055.png" alt="Pasted image 20230605125014|400"></p>
<p><strong>碰撞检测：</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036056.png" alt="Pasted image 20230605125251"><br>性能消耗关系<br>Continuous Dynamic &gt; Continuous Speculativec &gt; Continuous &gt; Discrete</p>
<p><strong>约束：</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036057.png" alt="Pasted image 20230605125531"><br>游戏中防止物体乱飞，可以这样设置：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036058.png" alt="Pasted image 20230610161032"></p>
<h4 id="碰撞器-Collider"><a href="#碰撞器-Collider" class="headerlink" title="碰撞器 Collider"></a>碰撞器 Collider</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036059.png" alt="Pasted image 20230605125839"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036060.png" alt="Pasted image 20230605130129"></p>
<p><strong>异形物体使用多种碰撞器组合，刚体对象的子对象碰撞器信息参与碰撞检测（即我们可以给父对象添加刚体，碰撞器则添加到每个子对象上）</strong></p>
<p><strong>不常用的碰撞器：</strong><br>Mesh Colider网格碰撞器，根据网格生成碰撞体，消耗较大，较为精确<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036061.png" alt="Pasted image 20230605131446"></p>
<p>Wheel Colider 车轮碰撞器，用于汽车<br>Terrain Colider：地形碰撞器</p>
<h4 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h4><p>让两个物体之间碰撞时表现出不同效果<br>右键 Create<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036062.png" alt="Pasted image 20230605132408|500"></p>
<h4 id="碰撞检测函数"><a href="#碰撞检测函数" class="headerlink" title="碰撞检测函数"></a>碰撞检测函数</h4><ul>
<li><strong>碰撞和触发响应函数属于特殊的生命周期函数，位于 FixedUpdate 和 Update 之间，也是通过反射调用</strong></li>
<li>如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的必须挂载到这个刚体父对象上才行。</li>
<li>碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036063.png" alt="Pasted image 20230605132917|350"></p>
<h4 id="物理碰撞检测响应函数"><a href="#物理碰撞检测响应函数" class="headerlink" title="物理碰撞检测响应函数"></a>物理碰撞检测响应函数</h4><figure class="highlight cs"><figcaption><span>title:Collision类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collision类型的参数包含了碰到自己的对象的相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞到的对象的碰撞器信息</span></span><br><span class="line">collision.collider;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞对象的依附对象（GameObject）</span></span><br><span class="line">collision.gameObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞对象的依附对象的位置信息</span></span><br><span class="line">collision.transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接触点点数量</span></span><br><span class="line">collision.contactCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接触点 坐标</span></span><br><span class="line">ContactPoint[] pos = collision.contacts;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只要得到碰撞道德对象的任意一个信息，就可以得到所有信息</span></span><br><span class="line">collision.gameObject.GetComponent&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:碰撞相关的生命周期函数(检测响应函数)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//碰撞触发接触时会自动执行这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;碰撞到了&quot;</span> + collision.gameObject.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个物体相互接触摩擦时会不停的调用该函数</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">this</span>.name+<span class="string">&quot;正在摩擦&quot;</span>+collision.gameObject.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//碰撞结束分离时会自动执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="触发器检测响应函数"><a href="#触发器检测响应函数" class="headerlink" title="触发器检测响应函数"></a>触发器检测响应函数</h4><p>勾选 IS Trigger<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036064.png" alt="Pasted image 20230605134638"></p>
<p>用法类似物理碰撞检测函数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次接触时</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接触过程中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接触结束</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="刚体加力"><a href="#刚体加力" class="headerlink" title="刚体加力"></a>刚体加力</h4><p>给刚体加力的目标就是让其有一个速度朝向某一个方向移动</p>
<h5 id="刚体添加力"><a href="#刚体添加力" class="headerlink" title="刚体添加力"></a>刚体添加力</h5><figure class="highlight cs"><figcaption><span>title:刚体添加力的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先应该获取刚体组件</span></span><br><span class="line">rigidBody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加力</span></span><br><span class="line"><span class="comment">//加力过后对象是否停止移动是由阻力决定的，没有阻力就不会停</span></span><br><span class="line"><span class="comment">//相对世界坐标</span></span><br><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>,ForceMode.Acceleration); <span class="comment">//力的模式</span></span><br><span class="line"><span class="comment">//相对本地坐标</span></span><br><span class="line">rigidBody.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加扭矩力，让其旋转</span></span><br><span class="line"><span class="comment">//相对世界坐标</span></span><br><span class="line">rigidBody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"><span class="comment">//相对本地坐标</span></span><br><span class="line">rigidBody.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.直接改变速度</span></span><br><span class="line"><span class="comment">//这个速度方向是相对于世界坐标系的</span></span><br><span class="line">rigidBody.velocity = Vector3.forward * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.模拟爆炸冲击波，只对该脚本挂载的对象起作用</span></span><br><span class="line"><span class="comment">//第一个参数是爆炸的中心点</span></span><br><span class="line"><span class="comment">//第二个参数是爆炸的半径</span></span><br><span class="line"><span class="comment">//第三个参数是爆炸的力</span></span><br><span class="line"><span class="comment">//第四个参数是爆炸的作用范围</span></span><br><span class="line">rigidBody.AddExplosionForce(<span class="number">100</span>,Vector3.zero,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h5 id="力的模式"><a href="#力的模式" class="headerlink" title="力的模式"></a>力的模式</h5><p>上面添加力的方法其实有第二个参数，用来指定计算力的模式 <code>ForceMode</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>,ForceMode.Acceleration); </span><br></pre></td></tr></table></figure>

<p>动量定理 ：<br>Ft &#x3D;mv<br>V&#x3D;Ft&#x2F;m;<br>F：力<br>t：时间<br>m：质量<br>v：速度</p>
<p>四种模式：第二种模式比较符合真实<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036065.png" alt="Pasted image 20230605153729"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036066.png" alt="Pasted image 20230605153747"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036067.png" alt="Pasted image 20230605153852"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036068.png" alt="Pasted image 20230605153903"></p>
<h4 id="刚体休眠"><a href="#刚体休眠" class="headerlink" title="刚体休眠"></a>刚体休眠</h4><p>比如运行游戏后，Cube 落到平面上发生碰撞停下，此时编辑平面的角度，发现 Cube 并没有下落，因为此时 Cube 的刚体休眠了。再移动一下，才会唤醒<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036069.png" alt="Pasted image 20230605154414"></p>
<figure class="highlight cs"><figcaption><span>title:主动唤醒</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="力场脚本-Constant-Force"><a href="#力场脚本-Constant-Force" class="headerlink" title="力场脚本 Constant Force"></a>力场脚本 Constant Force</h4><p>更方便的添加力<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036070.png" alt="Pasted image 20230605154007"></p>
<h3 id="2-范围检测"><a href="#2-范围检测" class="headerlink" title="(2) 范围检测"></a>(2) 范围检测</h3><p>游戏中<strong>瞬时的攻击范围判断一般会使用范围检测</strong></p>
<ol>
<li>玩家在前方 5m 处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害 </li>
<li>玩家攻击，在前方 1 米圆形范围内对象都受到伤害</li>
</ol>
<p>类似这种并没有实体物体只想要检测在指定某一范围是否让敌方受到伤害时，便可以使用范围判断。<br>简而言之，在指定位置进行范围判断我们可以得到处于指定范围内的对象，目的是对对象进行处理，比如受伤减血等等</p>
<blockquote>
<p>[!bug] 范围检测必备条件<br><strong>想要被范围检测到的对象必须具备碰撞器</strong></p>
</blockquote>
<p>注意点：</p>
<ol>
<li>范围检测相关 API 只有当执行该句代码时进行一次范围检测，它是瞬时的 </li>
<li>范围检测相关 API 并不会真正产生个碰撞器，只是碰撞判断计算而已</li>
</ol>
<h4 id="盒状范围检测"><a href="#盒状范围检测" class="headerlink" title="盒状范围检测"></a>盒状范围检测</h4><ul>
<li><strong>参数一：</strong> 立方体中心点</li>
<li><strong>参数二：</strong> 立方体三边大小</li>
<li><strong>参数三：</strong> 立方体角度</li>
<li><strong>参数四：</strong> 检测指定 Layer （不填检测所有层)</li>
<li><strong>参数五：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置<ul>
<li>全局设置根据 Physics 中的设置来决定 <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036071.png" alt="Pasted image 20230611164957|700"></li>
</ul>
</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> <strong>在该范围内的触发器 (得到了对象触发器就可以得到对象的所有信息)</strong></li>
</ul>
<figure class="highlight cs"><figcaption><span>title:Physics.OverlapBox</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = Physics.OverlapBox(</span><br><span class="line">    Vector3.zero,</span><br><span class="line">    Vector3.one, </span><br><span class="line">    Quaternion.AngleAxis(<span class="number">45</span>,Vector3.up), </span><br><span class="line">    <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) | <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;Water&quot;</span>),</span><br><span class="line">    <span class="comment">//第四个参数用 | 继续添加就可以了</span></span><br><span class="line">     QueryTriggerInteraction.UseGlobal);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;colliders.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(colliders[i].gameObject.name); <span class="comment">//打印触发器挂载的对象信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 API：<code>Physics.OverlapBoxNonAlloc</code><br>参数区别：第三个参数传入一个<code>Collider[]</code>数组进行存储<br>返回值回值：碰撞到的碰撞器数量</p>
<figure class="highlight cs"><figcaption><span>title:Physics.OverlapBoxNonAlloc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = <span class="keyword">new</span> Collider[<span class="number">10</span>]; <span class="comment">//数组数量必须等于检测到的碰撞体数量  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞到的碰撞器数量</span></span><br><span class="line"><span class="built_in">int</span> num = Physics.OverlapBoxNonAlloc(</span><br><span class="line">    Vector3.zero,</span><br><span class="line">    Vector3.one,</span><br><span class="line">    colliders,</span><br><span class="line">    Quaternion.AngleAxis(<span class="number">45</span>,Vector3.up), </span><br><span class="line">    <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) | <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;Water&quot;</span>),</span><br><span class="line">     QueryTriggerInteraction.UseGlobal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果碰撞到的碰撞器数量不为0，则执行代码</span></span><br><span class="line"><span class="keyword">if</span>(num != <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; num;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Debug.Log(colliders[i].gameObject.name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 关于 Layer 编号<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036072.png" alt="Pasted image 20230611164625|400"></p>
<ul>
<li>通过名字得到层级编号可以使用 <code>LayerMask.NameToLayer</code> 方法</li>
<li>我们需要通过编号左移 <code>&lt;&lt;</code> 构建二进制数，这样每一个编号的层级都是对应位为 1 的 2 进制数，我们通过位运算可以选择想要检测层级</li>
<li>好处：一个 int 就可以表示所有想要检测的层级信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036073.png" alt="Pasted image 20230611164535|700"><br><strong>也可以直接声明一个 LayerMask 类型的变量，可以开放到 inspector 方便方便调整，但使用位掩码方法更好。为什么？</strong></p>
</blockquote>
<h4 id="球体范围检测"><a href="#球体范围检测" class="headerlink" title="球体范围检测"></a>球体范围检测</h4><ul>
<li><strong>参数一：</strong> 球体中心点</li>
<li><strong>参数二：</strong> 球半径</li>
<li><strong>参数三：</strong> 检测指定 Layer （不填检测所有层)</li>
<li><strong>参数四：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> <strong>在该范围内的触发器 (得到了对象触发器就可以得到对象的所有信息)</strong></li>
</ul>
<figure class="highlight cs"><figcaption><span>title:Physics.OverlapSphere</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = Physics.OverlapSphere(</span><br><span class="line">            Vector3.zero,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>), </span><br><span class="line">            QueryTriggerInteraction.UseGlobal);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;colliders.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(colliders[i].gameObject.name); <span class="comment">//打印触发器挂载的对象信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 API: <code>Physics.OverlapSphereNonAlloc</code><br>返回值: 碰撞到的碰撞器数量<br>参数: 传入一个数组进行存储</p>
<figure class="highlight cs"><figcaption><span>title:Physics.OverlapSphereNonAlloc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = <span class="keyword">new</span> Collider[<span class="number">10</span>]; <span class="comment">//数组数量必须等于检测到的碰撞体数量  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//碰撞到的碰撞器数量  </span></span><br><span class="line"><span class="built_in">int</span> num = Physics.OverlapSphereNonAlloc(  </span><br><span class="line">    Vector3.zero,  </span><br><span class="line">    <span class="number">5</span>,  </span><br><span class="line">    colliders,  </span><br><span class="line">    <span class="number">1</span>&lt;&lt;LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>),  </span><br><span class="line">    QueryTriggerInteraction.UseGlobal);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果碰撞到的碰撞器数量不为0，则执行代码  </span></span><br><span class="line"><span class="keyword">if</span>(num != <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; num;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            Debug.Log(colliders[i].gameObject.name);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="胶囊范围检测"><a href="#胶囊范围检测" class="headerlink" title="胶囊范围检测"></a>胶囊范围检测</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036074.png" alt="Pasted image 20230611172957|193"></p>
<ul>
<li><strong>参数一：</strong> 上半圆中心点（两个中心点确定胶囊体的位置）</li>
<li><strong>参数二：</strong> 下半圆中心点</li>
<li><strong>参数三：</strong> 半圆半径</li>
<li><strong>参数四：</strong> 检测指定 Layer （不填检测所有层)</li>
<li><strong>参数五：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> **在该范围内的触发器 (得到了对象触发器就可以得到对象的所有信息)<figure class="highlight cs"><figcaption><span>title:Physics.OverlapCapsule</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = Physics.OverlapCapsule(</span><br><span class="line">            Vector3.zero,</span><br><span class="line">            Vector3.up, </span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>), </span><br><span class="line">            QueryTriggerInteraction.UseGlobal);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;colliders.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(colliders[i].gameObject.name); <span class="comment">//打印触发器挂载的对象信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>另一个 API</strong>：<code>Physics.OverlapCapsuleNonAlloc</code><br>返回值：碰撞到的碰撞器数量<br>参数：传入一个数组进行存储</p>
<figure class="highlight cs"><figcaption><span>title:Physics.OverlapCapsuleNonAlloc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Collider[] colliders = <span class="keyword">new</span> Collider[<span class="number">10</span>]; <span class="comment">//数组数量必须等于检测到的碰撞体数量  </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//碰撞到的碰撞器数量</span></span><br><span class="line"><span class="built_in">int</span> num = Physics.OverlapCapsuleNonAlloc(</span><br><span class="line">    Vector3.zero,</span><br><span class="line">    Vector3.up,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    colliders,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.UseGlobal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果碰撞到的碰撞器数量不为0，则执行代码</span></span><br><span class="line"><span class="keyword">if</span>(num != <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; num;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Debug.Log(colliders[i].gameObject.name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-射线检测"><a href="#3-射线检测" class="headerlink" title="(3) 射线检测"></a>(3) 射线检测</h3><p>射线检测通过在指定点发射一个指定方向的射线，判断该射线与哪些碰撞器相交，得到对应对象。</p>
<h4 id="声明射线"><a href="#声明射线" class="headerlink" title="声明射线"></a>声明射线</h4><ul>
<li>@ <strong>指定起点方向的射线</strong><br>参数一： 起点 <code>ray.origin</code><br>参数二：方向 <code>ray.direction</code> (<strong>不是两点决定射线方向，第二个参数直接就代表方向向量</strong>)</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:指定起点方向的射线</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明射线</span></span><br><span class="line"><span class="comment">//起点为坐标 (1,0,0)</span></span><br><span class="line"><span class="comment">//方向为世界坐标 z 轴正方向的射线 </span></span><br><span class="line">Ray ray = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br><span class="line">print(ray.origin); <span class="comment">//起点</span></span><br><span class="line">print(ray.direction); <span class="comment">//方向</span></span><br></pre></td></tr></table></figure>

<ul>
<li>@ <strong>摄像机发出的射线</strong><figure class="highlight cs"><figcaption><span>title:摄像机射线</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Physics 类中提供了很多进行射线检测的静态函数<br>他们有很多种重载类型我们只需要掌握核心的几个函数其它函数自然就明白什么意思了注意:<br><strong>射线检测也是瞬时的了执行代码时进行一次射线检测</strong></p>
<h4 id="检测是否相交"><a href="#检测是否相交" class="headerlink" title="检测是否相交"></a>检测是否相交</h4><p><code>Raycast</code> 射线投射</p>
<p><strong>进行射线检测如果碰撞到对象返回 true（只检测是否碰撞，得不到信息）</strong></p>
<ul>
<li><strong>参数一：</strong> 射线（或直接传入射线起点和方向）</li>
<li><strong>参数二：</strong> 检测的最大距离，超出这个距离不检测</li>
<li><strong>参数三：</strong> 检测指定层级 (不填检测所有层)</li>
<li><strong>参数四：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> bool 当碰撞到对象时返回 true，没有返回 false<figure class="highlight cs"><figcaption><span>title:Physics.Raycast</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明射线</span></span><br><span class="line"> Ray ray = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (Physics.Raycast(</span><br><span class="line">     ray,</span><br><span class="line">     <span class="number">1000</span>,</span><br><span class="line">     <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">     QueryTriggerInteraction.Ignore))</span><br><span class="line"> &#123;</span><br><span class="line">     print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不声明直接传参</span></span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(</span><br><span class="line">         Vector3.right,</span><br><span class="line">         Vector3.forward,</span><br><span class="line">         <span class="number">1000</span>,</span><br><span class="line">         <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">         QueryTriggerInteraction.Ignore))</span><br><span class="line"> &#123;</span><br><span class="line">     print(<span class="string">&quot;碰撞到了对象&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取相交的单个物体信息"><a href="#获取相交的单个物体信息" class="headerlink" title="获取相交的单个物体信息"></a>获取相交的单个物体信息</h4><p>**物体信息类 <code>RaycastHit</code>**：射线投射命中<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190036075.png" alt="Pasted image 20230611204141|500"></p>
<ul>
<li><strong>参数一：</strong> 射线（或直接传入射线起点和方向）</li>
<li><strong>参数二：</strong> <code>RaycastHit</code> 是结构体，是值类型。 unity 会通过 <code>out</code> 关键字，在函数内部处理得到的碰撞数据并返回到该参数中</li>
<li><strong>参数三：</strong> 距离</li>
<li><strong>参数四：</strong> 检测指定层级（不填检测所有层)</li>
<li><strong>参数五：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> bool 当碰撞到对象时返回 true，没有返回 false<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明射线</span></span><br><span class="line">Ray ray = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(</span><br><span class="line">    ray,</span><br><span class="line">    <span class="keyword">out</span> RaycastHit hit,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.Ignore))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//碰撞器信息，得到了碰撞器就可以获取物体所有信息</span></span><br><span class="line">    print(hit.collider.gameObject.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞到的对象的位置</span></span><br><span class="line">    print(hit.transform.position);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//碰撞到对象离射线起点的距离</span></span><br><span class="line">    print(hit.distance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//碰撞点，射线与物体相交的点</span></span><br><span class="line">    print(hit.point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞点法线，射线与物体相交的点的法线</span></span><br><span class="line">    print(hit.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞点uv坐标，射线与物体相交的点的uv坐标</span></span><br><span class="line">    print(hit.textureCoord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不声明直接传参</span></span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(</span><br><span class="line">    Vector3.right,</span><br><span class="line">    Vector3.forward,</span><br><span class="line">    <span class="keyword">out</span> RaycastHit hit,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.Ignore))</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取相交的多个物体"><a href="#获取相交的多个物体" class="headerlink" title="获取相交的多个物体"></a>获取相交的多个物体</h4><p>可以得到碰撞到的多个对象，如果没有就是容量为 0 的数组</p>
<ul>
<li><strong>参数一：</strong> 射线（或直接传入射线起点和方向）</li>
<li><strong>参数二：</strong> 检测的最大距离，超出这个距离不检测</li>
<li><strong>参数三：</strong> 检测指定层级 (不填检测所有层)</li>
<li><strong>参数四：</strong> 是否忽略触发器 <ul>
<li>UseGlobal 使用全局设置</li>
<li>Collide 检测触发器</li>
<li>Ignore 忽略触发器</li>
<li>不填默认使用 UseGlobal</li>
</ul>
</li>
<li><strong>返回值：</strong> bool 当碰撞到对象时返回 true，没有返回 false</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:Physics.RaycastAll</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明射线</span></span><br><span class="line">Ray ray = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br><span class="line"></span><br><span class="line">RaycastHit[] hits = Physics.RaycastAll(</span><br><span class="line">    ray,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.Ignore);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不声明直接传参</span></span><br><span class="line">RaycastHit[] hits = Physics.RaycastAll(</span><br><span class="line">    Vector3.right,</span><br><span class="line">    Vector3.forward,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.Ignore);</span><br></pre></td></tr></table></figure>

<h4 id="获取相交物体的数量"><a href="#获取相交物体的数量" class="headerlink" title="获取相交物体的数量"></a>获取相交物体的数量</h4><figure class="highlight cs"><figcaption><span>title:Physics.RaycastNonAlloc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = <span class="keyword">new</span> RaycastHit[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line"><span class="built_in">int</span> num = Physics.RaycastNonAlloc(</span><br><span class="line">    ray,</span><br><span class="line">    hits,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">    QueryTriggerInteraction.Ignore);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++) </span><br><span class="line">&#123;</span><br><span class="line">    print(hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、协同程序"><a href="#四、协同程序" class="headerlink" title="四、协同程序"></a>四、协同程序</h1><h2 id="1-Unity-多线程"><a href="#1-Unity-多线程" class="headerlink" title="1 Unity 多线程"></a>1 Unity 多线程</h2><p>Unity 是支持多线程的，只是线程是无法调用 Unity 主线程的 API（不常用）<br>注意: Unity 中的多线程要记得关闭（即便停止运行，线程仍会执行）</p>
<p>子线程可以执行一些可能导致主线程卡顿的算法计算（寻路、网络等算法），将结果放入公共容器，主线程取出使用。相反，主线程也可以将数据放入公共容器，子线程取出使用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个子线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="comment">//公共容器</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Vector3&gt; queue = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="keyword">new</span> Thread(Test); <span class="comment">//调用子线程函数</span></span><br><span class="line">        t.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取公共容器的内容</span></span><br><span class="line">            <span class="keyword">this</span>.transform.Translate(queue.Dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Unity中的多线程要记得关闭</span></span><br><span class="line">        t.Abort();</span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//this.transform.Translate(Vector3.forward * Time.deltaTime);  //报错，因为子线程是无法调用Unity主线程的API的</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将计算结果存入公共容器</span></span><br><span class="line">            queue.Enqueue(<span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            print(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Unity-协程"><a href="#2-Unity-协程" class="headerlink" title="2 Unity 协程"></a>2 Unity 协程</h2><p><strong>协同程序（Coroutine）简称协程</strong>，继承 MonoBehavior 的类都可以开启协程函数<br>它是“假”的多线程，它<strong>不是多线程</strong><br><strong>主要作用</strong>：将代码分时执行，不卡主线程。简单理解，是把可能会让主线程卡顿的耗时的逻辑<strong>分时分步执行</strong></p>
<p><strong>主要使用场景</strong></p>
<ul>
<li>异步加载文件</li>
<li>异步下载文件</li>
<li>场景异步加载</li>
<li>批量创建时防止卡顿</li>
</ul>
<p><strong>协程和线程的区别：</strong></p>
<ul>
<li>子线程是独立的一个管道，和主线程并行执行</li>
<li>协程是在原线程之上开启，进行逻辑分时分步执行</li>
</ul>
<p><strong>协程开启后</strong></p>
<ul>
<li>组件和物体销毁，协程<strong>不执行</strong></li>
<li>物体失活，协程<strong>不执行</strong></li>
<li>脚本组件失活，协程<strong>执行</strong></li>
</ul>
<figure class="highlight cs"><figcaption><span>title:协程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第二步:启动协程函数</span></span><br><span class="line">    <span class="comment">//可以同时执行多个协程函数</span></span><br><span class="line">    Coroutine c1 = StartCoroutine(MyCoroutine(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    Coroutine c2 = StartCoroutine(MyCoroutine(<span class="number">3</span>,<span class="string">&quot;test&quot;</span>));  </span><br><span class="line">    Coroutine c3 = StartCoroutine(MyCoroutine(<span class="number">4</span>,<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步:关闭协程函数</span></span><br><span class="line">    StopAllCoroutines(); <span class="comment">//关闭所有携程</span></span><br><span class="line">    StopCoroutine(c1); <span class="comment">//关闭指定携程</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步:声明协程函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>/协程函数2个关键点</span></span><br><span class="line"><span class="comment">//1-1 返回值为IEnumerator类型及其子类</span></span><br><span class="line"><span class="comment">//1-2 通过yield return返回值;</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">int</span> i,<span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        print(i);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5.0f</span></span>)</span>; <span class="comment">//等待5秒执行下面的代码，从而将代码分块执行</span></span><br><span class="line">        print(str);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3.0f</span></span>)</span>; <span class="comment">//等待5秒执行下面的代码</span></span><br><span class="line">        print(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程里是可以写死循环协程的，不会卡死，等待时间继续Tick</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;routine&quot;</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">10.0f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[[《CS Primer》#用 yield return 语法糖实现迭代器]]</p>
<figure class="highlight cs"><figcaption><span>title:yieldreturn不同内容的含义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.下一帧执行</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> 数字;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//在Update和LateUpdate之间执行后面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.等待指定秒后执行</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">waitForSeconds</span>(<span class="params">秒</span>)</span>;</span><br><span class="line"><span class="comment">//在update和LateUpdate之间执行后面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.等待下一个固定物理帧更新时执行</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">waitForFixedUpdate</span>()</span>;</span><br><span class="line"><span class="comment">//在FixedUpdate和碰撞检测相关函数之后执行后面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.等待摄像机和GUI渲染完成后执行</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">waitForEndOfFrame</span>()</span>; </span><br><span class="line"><span class="comment">//在LateUpdate之后的渲染相关处理完毕后之后执行后面的代码（主要会用来实现截图功能）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.一些特殊类型的对象比如异步加载相关函数返回的对象</span></span><br><span class="line"><span class="comment">//之后讲解异步加载资源异步加载场景网络加载时再讲解</span></span><br><span class="line"><span class="comment">//一般在update和LateUpdate之间执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.跳出协程</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span> ;</span><br></pre></td></tr></table></figure>
<h2 id="3-协程原理"><a href="#3-协程原理" class="headerlink" title="3 协程原理"></a>3 协程原理</h2><p>协程可以分成两部分</p>
<ol>
<li>协程函数本体 </li>
<li>协程调度器</li>
</ol>
<ul>
<li>协程本体就是一个能够中间暂停返回的函数</li>
<li>协程调度器是 unity 内部实现的，会在对应的时机帮助我们继续执行协程函数</li>
<li><strong>Unity 只实现了协程调度部分</strong></li>
<li><strong>协程的本体本质上就是一个 cs 的迭代器方法</strong></li>
</ul>
<p><strong>协程调度器</strong><br>继承 MonoBehavior 后开启协程<br>相当于是把一个协程函数（迭代器)放入 Unity 的协程调度器中帮助我们管理<br>具体的 yield return 后面的规则也是 Unity 定义的一些规则</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 协程函数本体</span></span><br><span class="line"><span class="comment">//如果我们不通过开启协程方法执行协程</span></span><br><span class="line"><span class="comment">//Unity 的协程调度器是不会帮助我们管理协程函数的 </span></span><br><span class="line"><span class="comment">//Test(); //不会执行</span></span><br><span class="line"><span class="comment">//Coroutine c = StartCoroutine(Test()); //会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是我们可以自己执行迭代器函数内容,起到相同效果</span></span><br><span class="line">IEnumerator ie = Test();</span><br><span class="line">ie.MoveNext(); <span class="comment">//会执行函数中内容遇到yield return为止的逻辑</span></span><br><span class="line">print(ie.Current); <span class="comment">//返回yield return返回值</span></span><br><span class="line"></span><br><span class="line">ie.MoveNext();</span><br><span class="line">print(ie.Current);</span><br><span class="line"></span><br><span class="line">ie.MoveNext();</span><br><span class="line">print(ie.Current);</span><br><span class="line"></span><br><span class="line">ie.MoveNext();</span><br><span class="line">print(ie.Current);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用一个循环执行所有协程函数内容</span></span><br><span class="line"><span class="comment">//MoveNext 返回bool值代表着是否到了结尾(这个迭代器函数是否执行完毕)</span></span><br><span class="line"><span class="keyword">while</span> (ie.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    print(ie.Current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：你可以简化理解迭代器函数</p>
<ul>
<li>cs 看到迭代器函数和 yield return 语法糖就会把原本是一个的函数变成”几部分”</li>
<li>我们可以通过迭代器，从上到下遍历这“几部分”进行执行</li>
<li>就达到了将一个函数中的逻辑分时执行的目的</li>
</ul>
<p><strong>而协程调度器就是利用迭代器函数返回的内容来进行之后的处理</strong><br>比如 unity 中的协程调度器<br>根据 yield return 返回的内容决定了下一次在何时继续执行迭代器函数中的“下一部分”</p>
<p><strong>理论上来说我们可以利用迭代器函数的特点自己实现协程调度器来取代 unity 自带的调度器（一般自己不需要实现，唐老师课程作业中讲了具体做法）</strong></p>
<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4 应用"></a>4 应用</h2><h3 id="协程计时器"><a href="#协程计时器" class="headerlink" title="协程计时器"></a>协程计时器</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Coroutine c = StartCoroutine(MyCoroutine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(time+<span class="string">&quot;s&quot;</span>);</span><br><span class="line">        ++time;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1.0f</span></span>)</span>; <span class="comment">//按s计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分时创建对象，防止批量处理卡顿"><a href="#分时创建对象，防止批量处理卡顿" class="headerlink" title="分时创建对象，防止批量处理卡顿"></a>分时创建对象，防止批量处理卡顿</h3><p>创建 100000 个 Cube，直接创建直接卡死，使用协程每帧生产 1000 个</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(CreateCube(<span class="number">100000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">CreateCube</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">        obj.transform.position = <span class="keyword">new</span> Vector3(UnityEngine.Random.Range(<span class="number">-100</span>, <span class="number">100</span>), UnityEngine.Random.Range(<span class="number">-100</span>, <span class="number">100</span>), UnityEngine.Random.Range(<span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每创建1000个Cube，就等下一帧</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、资源动态加载"><a href="#五、资源动态加载" class="headerlink" title="五、资源动态加载"></a>五、资源动态加载</h1><h2 id="1-文件夹路径获取"><a href="#1-文件夹路径获取" class="headerlink" title="1 文件夹路径获取"></a>1 文件夹路径获取</h2><ul>
<li>@ <strong>Assets 工程文件夹</strong></li>
</ul>
<figure class="highlight cs"><figcaption><span>title:路径获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application.dataPath  <span class="comment">//获取到Assets文件夹的路径</span></span><br><span class="line"><span class="comment">//注意该方式获取到的路径一般情况下只在编辑模式下使用</span></span><br><span class="line"><span class="comment">//我们不会在实际发布游戏后还使用该路径，游戏发布过后该路径就不存在了│</span></span><br></pre></td></tr></table></figure>

<ul>
<li>@ <strong>Resources 资源文件夹</strong><blockquote>
<p>[!attention]<br>需要在 Assets 下手动创建名为 Resources 的文件夹</p>
</blockquote>
</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:路径获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般不获取，只能使用 Resources 相关 API 进行加载</span></span><br><span class="line"><span class="comment">//如果硬要获取可以用工程路径拼接(只在编辑模式下使用)</span></span><br><span class="line">Application.dataPath + <span class="string">&quot;/Resources&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：资源文件夹</p>
<ul>
<li><p><strong>需要通过 Resources 相关 API 动态加载的资源需要放在其中</strong></p>
</li>
<li><p>该文件夹下所有文件都会被打包出去</p>
</li>
<li><p>打包时 unity 会对其压缩加密</p>
</li>
<li><p>该文件夹打包后只读，只能通过 Resources 相关 API 加载</p>
</li>
<li><p>在一个工程当中  Resources 文件夹可以有多个（子文件夹中也可以有），通过 API 加载时，它会自己去这些同名的 Resources 文件夹中找资源。打包时所有 Resources 文件夹打包在一起</p>
</li>
<li><p>@ <strong>StreamingAssets 流动资源文件夹</strong></p>
<blockquote>
<p>[!attention]<br>需要在 Assets 下手动创建名为 StreamingAssets 的文件夹</p>
</blockquote>
</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:路径获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.streamingAssetsPath</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：流文件夹</p>
<ul>
<li><p>打包出去不会被压缩加密，可以任由我们摆布</p>
</li>
<li><p><strong>移动平台只读</strong>，PC 平台可读可写</p>
</li>
<li><p>可以<strong>放入一些需要自定义动态加载的初始资源</strong></p>
</li>
<li><p>@ <strong>persistentDataPath 持久数据文件夹</strong></p>
</li>
</ul>
<blockquote>
<p>[!attention]<br>不需要自己创建</p>
</blockquote>
<figure class="highlight cs"><figcaption><span>title:路径获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.persistentDataPath</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：固定数据文件夹</p>
<ul>
<li><p>所有平台都可读可写</p>
</li>
<li><p><strong>一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中</strong></p>
</li>
<li><p>常用来保存玩家数据和热更新</p>
</li>
<li><p>@ Plugins 插件文件夹</p>
<blockquote>
<p>[!attention]<br>需要在 Assets 下手动创建名为 Plugins 的文件夹</p>
</blockquote>
</li>
</ul>
<p>路径获取: 一般不获取</p>
<p>作用：插件文件夹<br>不同平台的插件相关文件放在其中，比如 ios 和 Android 平台 </p>
<ul>
<li>@ Editor 编辑器文件夹<blockquote>
<p>[!attention]<br>需要在 Assets 下手动创建名为 Editor 的文件夹</p>
</blockquote>
</li>
</ul>
<figure class="highlight cs"><figcaption><span>title:路径获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般不获取</span></span><br><span class="line"><span class="comment">//如果硬要获取可以用工程路径拼接</span></span><br><span class="line">Application.dataPath + <span class="string">&quot;/Editor&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：编辑器文件夹</p>
<ul>
<li><p>开发 unity 编辑器时，编辑器相关脚本放在该文件夹中</p>
</li>
<li><p>该文件夹中内容<strong>不会被打包出去</strong></p>
</li>
<li><p>@  Standard Assets 默认资源文件夹<br>高版本 Unity 没有这个文件夹了。</p>
</li>
</ul>
<p>作用:<br>默认资源文件夹<br>一般 unity 自带资源都放在这个文件夹下<br>代码和资源优先被编译</p>
<h2 id="2-Resources-资源同步加载"><a href="#2-Resources-资源同步加载" class="headerlink" title="2 Resources 资源同步加载"></a>2 Resources 资源同步加载</h2><ol>
<li>通过代码动态加载 Resources 文件夹下指定路径资源 </li>
<li><strong>避免繁琐的拖拽操作</strong></li>
</ol>
<p>常用资源类型</p>
<ol>
<li>预设体对象 GameObject </li>
<li>音效文件 AudioClip </li>
<li>文本文件  TextAsset </li>
<li>图片文件 Texture</li>
<li>其它类型 2D 图片、动画文件、材质文件等等</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>预设体对象加载需要实例化</li>
<li>其它资源加载一般直接用</li>
</ul>
<h3 id="加载文件资源"><a href="#加载文件资源" class="headerlink" title="加载文件资源"></a>加载文件资源</h3><figure class="highlight cs"><figcaption><span>title:加载资源 h:7,13,20,33</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> AudioSource audioSource;</span><br><span class="line">    <span class="keyword">public</span> Texture texture;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 预设体对象，想要创建在场景上，记得实例化</span></span><br><span class="line">        <span class="comment">//第一步：加载预设体的资源文件(本质上就是加载配置数据在内存中)</span></span><br><span class="line">        Object obj1 = Resources.Load(<span class="string">&quot;filename&quot;</span>); <span class="comment">//&quot;&quot;中是预设体在Resources文件夹下的相对路径,不需要写拓展名后缀</span></span><br><span class="line">        <span class="comment">//第二步：实例化</span></span><br><span class="line">        Instantiate(obj1); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 音效文件</span></span><br><span class="line">        <span class="comment">//第一步：加载资源文件</span></span><br><span class="line">        Object obj2 = Resources.Load(<span class="string">&quot;Music/filename&quot;</span>);</span><br><span class="line">        <span class="comment">//第二步：使用数据，我们不需要实例化音效切片，我们只需要把数据赋值到正确的脚本上即可</span></span><br><span class="line">        audioSource.clip = obj2 <span class="keyword">as</span> AudioClip;</span><br><span class="line">        audioSource.Play();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 文本文件</span></span><br><span class="line">        <span class="comment">//文本资源支持的格式</span></span><br><span class="line">        <span class="comment">//.txt</span></span><br><span class="line">        <span class="comment">//.xml</span></span><br><span class="line">        <span class="comment">//.bytes</span></span><br><span class="line">        <span class="comment">//.json</span></span><br><span class="line">        <span class="comment">//.html</span></span><br><span class="line">        <span class="comment">//.csv</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        TextAsset ta = Resources.Load(<span class="string">&quot;Text/filename&quot;</span>) <span class="keyword">as</span> TextAsset;</span><br><span class="line">        print(ta.text); <span class="comment">//文本内容</span></span><br><span class="line">        print(ta.bytes); <span class="comment">//字节数据组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 图片文件</span></span><br><span class="line">        texture = Resources.Load(<span class="string">&quot;Texture/filename&quot;</span>) <span class="keyword">as</span> Texture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在GUI中绘制图片</span></span><br><span class="line">        GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), texture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载同名文件"><a href="#加载同名文件" class="headerlink" title="加载同名文件"></a>加载同名文件</h3><p><code>Resources. Load</code> 加载同名资源时无法准确（比如两个同名但是拓展名后缀（文件类型）不一样的文件，该方法无法区分），可以使用其他方法：</p>
<figure class="highlight cs"><figcaption><span>ffile:加载指定文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填写第二个参数，指定类型</span></span><br><span class="line">Resources.Load(<span class="string">&quot;filename&quot;</span>, <span class="keyword">typeof</span>(TextAsset)) <span class="keyword">as</span> TextAsset;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>title:加载指定名字的所有资源</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs = Resources.LoadAll(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (Object item <span class="keyword">in</span> objs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (item <span class="keyword">is</span> Texture)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> TextAsset)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法（推荐！）"><a href="#泛型方法（推荐！）" class="headerlink" title="泛型方法（推荐！）"></a>泛型方法（推荐！）</h3><p>方便快捷，指定了类型</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Text/Test&quot;</span>); <span class="comment">//指定TextAsset类型</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Resources-资源异步加载"><a href="#3-Resources-资源异步加载" class="headerlink" title="3 Resources 资源异步加载"></a>3 Resources 资源异步加载</h2><p>同步加载中，如果我们加载过大的资源可能会造成程序卡顿<br>卡顿的原因就是从硬盘上把数据读取到内存中是需要进行计算的，越大的资源耗时越长，就会造成掉帧卡顿<br>异步加载就是<strong>内部新开一个子线程进行资源加载（加载完后存入公共容器）</strong>，不会造成主线程卡顿</p>
<blockquote>
<p>[!attention]<br>异步加载不能马上得到加载的资源，至少要等一帧</p>
</blockquote>
<p><strong>方法一：完成事件监听异步加载</strong><br>好处: 写法简单<br>坏处: 只能在资源加载结束后进行处理<br>“线性加载”</p>
<figure class="highlight cs"><figcaption><span>title:通过异步加载中的完成事件监听使用加载的资源</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Texture  texture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 通过异步加载中的完成事件监听 使用加载的资源</span></span><br><span class="line">    <span class="comment">//这句代码你可以理解Unity 在内部就会去开一个线程进行资源下载</span></span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">    <span class="comment">//马上进行一个资源下载结束的一个事件函数监听</span></span><br><span class="line">    resourceRequest.completed += LoadOver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能在这里直接使用resourceRequest.asset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadOver</span>(<span class="params">AsyncOperation obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">    <span class="comment">//asset是资源对象，加载完毕后就能得到它</span></span><br><span class="line">    texture = (obj <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (texture != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), texture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：协程异步加载</strong><br>好处: 可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新<br>坏处: 写法稍麻烦<br>“并行加载”</p>
<figure class="highlight cs"><figcaption><span>title:通过协程使用加载的资源</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Texture  texture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.通过协程使用加载的资源</span></span><br><span class="line">    StartCoroutine(Load());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Load</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> resourceRequest; <span class="comment">//Unity自己知道该返回值意味着你在异步加载资源</span></span><br><span class="line">    <span class="comment">//Unity 会自己判断该资源是否加载完毕了,加载完毕过后才会继续执行后面的代码</span></span><br><span class="line">    </span><br><span class="line">    texture = resourceRequest.asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (texture != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), texture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Resources-资源卸载"><a href="#4-Resources-资源卸载" class="headerlink" title="4 Resources 资源卸载"></a>4 Resources 资源卸载</h2><p><strong>Resources 重复加载资源会浪费内存吗 ?</strong></p>
<ol>
<li>Resources 加载一次资源过后，该资源就一直存放在内存中作为缓存</li>
<li>第二次加载时发现缓存中存在该资源，会直接取出来进行使用，所以多次重复加载不会浪费内存</li>
<li>但是会浪费性熊 (每次加载都会去查找取出，始终伴随一些性能消耗)</li>
</ol>
<p><strong>卸载指定资源</strong>：<code>Resources. UnloadAsset()</code><br><strong>注意:</strong></p>
<ul>
<li>该方法<strong>不能释放 Gameobject 对象</strong>，因为它会用于实例化对象（即使是没有实例化的 Gameobject 对象也不能使用该方法卸载）</li>
<li>它<strong>只能用于一些不需要实例化的内容</strong>，比如图片和音效文本等等</li>
<li>一般情况下我们很少单独使用它<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tex = Resources.Load&lt;Texture&gt;(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"></span><br><span class="line">Resources.UnloadAsset(tex); <span class="comment">//卸载资源</span></span><br><span class="line">tex = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>卸载未使用的资源</strong>：<code>Resources.UnloadUnusedAssets()</code><br>一般在过场景时和 GC 一起使用</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure>


</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/21879.html">http://liuke101.github.io/post/21879.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/60549.html" title="C++精粹"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++精粹</div></div></a></div><div class="next-post pull-right"><a href="/post/23284.html" title="C#精粹"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029681.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C#精粹</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/62114.html" title="Unity数据持久化"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190020794.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Unity数据持久化</div></div></a></div><div><a href="/post/64623.html" title="Unity GUI"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-28</div><div class="title">Unity GUI</div></div></a></div><div><a href="/post/1888.html" title="Unity编辑器扩展"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">Unity编辑器扩展</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">零、工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%88%B6%E4%BD%93%EF%BC%88Prefab%EF%BC%89%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">预制体（Prefab）和资源包导入导出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80"><span class="toc-text">一、脚本基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A7%84%E5%88%99"><span class="toc-text">1 创建规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%89%B9%E6%80%A7"><span class="toc-text">2 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Inspector-%E7%AA%97%E5%8F%A3"><span class="toc-text">3 Inspector 窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">可编辑的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E6%8E%92%E7%89%88"><span class="toc-text">窗口排版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">4 生命周期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">5 随机数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A7%94%E6%89%98-%E4%BA%8B%E4%BB%B6"><span class="toc-text">6 委托&#x2F;事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E5%AD%A6-Mathf"><span class="toc-text">7 数学 Mathf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-text">常用运算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="toc-text">三角函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-text">向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%A7%92"><span class="toc-text">欧拉角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">四元数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity-%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">Unity 中的四元数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0-%E6%AC%A7%E6%8B%89%E8%A7%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">四元数&#x2F;欧拉角转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">四元数常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">单位四元数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E6%8F%92%E5%80%BC"><span class="toc-text">四元数插值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%96%B9%E5%90%91%E8%BD%AC%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">向量方向转四元数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-text">四元数相乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E5%B7%A6%E4%B9%98%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">向量左乘四元数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2"><span class="toc-text">8 坐标转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8-%E4%B8%96%E7%95%8C"><span class="toc-text">局部&#x2F;世界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C-%E5%B1%8F%E5%B9%95"><span class="toc-text">世界&#x2F;屏幕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C-%E8%A7%86%E5%8F%A3"><span class="toc-text">世界&#x2F;视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3-%E5%B1%8F%E5%B9%95"><span class="toc-text">视口&#x2F;屏幕</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8C-API"><span class="toc-text">二、重要组件和 API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-MonoBehavior-%E5%9F%BA%E7%B1%BB"><span class="toc-text">0 MonoBehavior 基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%89%93%E5%8D%B0"><span class="toc-text">调试打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC%E6%8C%82%E8%BD%BD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取脚本挂载的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E6%8C%82%E8%BD%BD%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-text">获取对象挂载的脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0"><span class="toc-text">延迟函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Object-%E7%B1%BB"><span class="toc-text">1 Object 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GameObject-%E7%B1%BB"><span class="toc-text">2 GameObject 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1"><span class="toc-text">查找对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%88Clone%EF%BC%89"><span class="toc-text">实例化对象（Clone）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1"><span class="toc-text">删除对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAGameObject"><span class="toc-text">创建GameObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC"><span class="toc-text">添加&#x2F;获取脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E6%AF%94%E8%BE%83"><span class="toc-text">标签比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%A4%B1%E6%B4%BB"><span class="toc-text">激活失活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">发送消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Time-%E7%B1%BB"><span class="toc-text">3 Time 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Transform-%E7%B1%BB"><span class="toc-text">4 Transform 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform-%E5%92%8C-GameObject-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Transform 和 GameObject 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-text">位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB"><span class="toc-text">位移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC"><span class="toc-text">角度和旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E5%92%8CLookAt"><span class="toc-text">缩放和LookAt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-text">父子关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取和设置父对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取子对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%84%BF%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">儿子的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-text">自定义拓展方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Input-%E7%B1%BB"><span class="toc-text">5 Input 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-text">鼠标键盘输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%BD%B4%E8%BE%93%E5%85%A5"><span class="toc-text">默认轴输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="toc-text">移动设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E6%9F%84%E8%BE%93%E5%85%A5"><span class="toc-text">手柄输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Screen-%E7%B1%BB"><span class="toc-text">6 Screen 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-1"><span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%BA%E6%99%AF"><span class="toc-text">8 场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%90%8C%E6%AD%A5%E5%88%87%E6%8D%A2"><span class="toc-text">场景同步切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%BC%82%E6%AD%A5%E5%88%87%E6%8D%A2"><span class="toc-text">场景异步切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%BC%A0%E6%A0%87Cursor"><span class="toc-text">9 鼠标Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-LineRenderer"><span class="toc-text">10 LineRenderer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-text">组件功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-text">代码相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F"><span class="toc-text">三、核心系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F"><span class="toc-text">2 音频系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-text">属性设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%BA%90-Audio-Source"><span class="toc-text">音频源 Audio Source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BA%A6%E5%85%8B%E9%A3%8E%E8%AE%BE%E5%A4%87"><span class="toc-text">麦克风设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">3 物理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-text">(1) 碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9A%E4%BD%93-Rigidbody"><span class="toc-text">刚体 Rigidbody</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%99%A8-Collider"><span class="toc-text">碰撞器 Collider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8"><span class="toc-text">物理材质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0"><span class="toc-text">碰撞检测函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-text">物理碰撞检测响应函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E6%A3%80%E6%B5%8B%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-text">触发器检测响应函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B"><span class="toc-text">刚体加力</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9A%E4%BD%93%E6%B7%BB%E5%8A%A0%E5%8A%9B"><span class="toc-text">刚体添加力</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9B%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">力的模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9A%E4%BD%93%E4%BC%91%E7%9C%A0"><span class="toc-text">刚体休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9B%E5%9C%BA%E8%84%9A%E6%9C%AC-Constant-Force"><span class="toc-text">力场脚本 Constant Force</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B"><span class="toc-text">(2) 范围检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E7%8A%B6%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B"><span class="toc-text">盒状范围检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%83%E4%BD%93%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B"><span class="toc-text">球体范围检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%B6%E5%9B%8A%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B"><span class="toc-text">胶囊范围检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-text">(3) 射线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%B0%84%E7%BA%BF"><span class="toc-text">声明射线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-text">检测是否相交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%8D%95%E4%B8%AA%E7%89%A9%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="toc-text">获取相交的单个物体信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%89%A9%E4%BD%93"><span class="toc-text">获取相交的多个物体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%B8%E4%BA%A4%E7%89%A9%E4%BD%93%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">获取相交物体的数量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text">四、协同程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Unity-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1 Unity 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Unity-%E5%8D%8F%E7%A8%8B"><span class="toc-text">2 Unity 协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-text">3 协程原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8"><span class="toc-text">4 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">协程计时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%8D%A1%E9%A1%BF"><span class="toc-text">分时创建对象，防止批量处理卡顿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%B5%84%E6%BA%90%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">五、资源动态加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E5%A4%B9%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96"><span class="toc-text">1 文件夹路径获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Resources-%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD"><span class="toc-text">2 Resources 资源同步加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="toc-text">加载文件资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%90%8C%E5%90%8D%E6%96%87%E4%BB%B6"><span class="toc-text">加载同名文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%81%EF%BC%89"><span class="toc-text">泛型方法（推荐！）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Resources-%E8%B5%84%E6%BA%90%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD"><span class="toc-text">3 Resources 资源异步加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Resources-%E8%B5%84%E6%BA%90%E5%8D%B8%E8%BD%BD"><span class="toc-text">4 Resources 资源卸载</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28207.html" title="UE输入系统">UE输入系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/8996.html" title="UEC++定时器">UEC++定时器</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>