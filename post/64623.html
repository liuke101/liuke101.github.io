<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity GUI | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="九宫格 UI 理论相对屏幕位置 ScreenPos：widgetPos. x &#x3D; ScreenPos + widgetCenterPos + offsetPos; 控件中心点位置 widgetCenterPos：cw 是控件自身的宽度ch 是控件自身的高度 最后通过操作偏移位置 offset 来摆放 UI GUI1 原理及作用IMGUI  （Immediate Mode Graphica">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity GUI">
<meta property="og:url" content="http://liuke101.github.io/post/64623.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="九宫格 UI 理论相对屏幕位置 ScreenPos：widgetPos. x &#x3D; ScreenPos + widgetCenterPos + offsetPos; 控件中心点位置 widgetCenterPos：cw 是控件自身的宽度ch 是控件自身的高度 最后通过操作偏移位置 offset 来摆放 UI GUI1 原理及作用IMGUI  （Immediate Mode Graphica">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png">
<meta property="article:published_time" content="2023-09-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.381Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/64623.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity GUI',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity GUI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-27T16:00:00.000Z" title="发表于 2023-09-28 00:00:00">2023-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.381Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity GUI"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/64623.html#post-comment"><span class="waline-comment-count" data-path="/post/64623.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="九宫格-UI-理论"><a href="#九宫格-UI-理论" class="headerlink" title="九宫格 UI 理论"></a>九宫格 UI 理论</h1><p><strong>相对屏幕位置 ScreenPos：</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030608.png" alt="Pasted image 20230607232730"><br>widgetPos. x &#x3D; ScreenPos + widgetCenterPos + offsetPos;</p>
<p><strong>控件中心点位置 widgetCenterPos：</strong><br>cw 是控件自身的宽度<br>ch 是控件自身的高度<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030609.png" alt="Pasted image 20230608080527|850"></p>
<p>最后通过操作偏移位置 offset 来摆放 UI</p>
<h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="1-原理及作用"><a href="#1-原理及作用" class="headerlink" title="1 原理及作用"></a>1 原理及作用</h2><p><strong>IMGUI</strong>  （Immediate Mode Graphical User Interface）即时模式图形化交互界面<br>IMGUI 在 Unity 中一般简称为 GUI，它是一个代码驱动的 UI 系统</p>
<p>作用：</p>
<ol>
<li>作为程序员的调试工具，创建游戏内调试工具</li>
<li>为脚本组件创建自定义检视面板</li>
<li>创建新的编辑器窗口和工具以拓展 Unity 本身（一般用作内置游戏工具）</li>
<li>用于进行 Unity 内置编辑器，调试工具编辑工具等等相关开发，<strong>不适合用它为玩家制作 UI 功能</strong></li>
</ol>
<p><strong>GUI 的工作原理</strong>：在继承 MonoBehaviour 的脚本中的特殊函数里，调用 GUI 提供的方法，类似生命周期函数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>它<strong>每帧执行</strong>相当于是用于专门绘制 GUI 界面的函数 </li>
<li>一般只在其中执行 GUI 相关界面绘制和操作逻辑 </li>
<li>该函数<strong>在 OnDisable 之前 LateUpdate 之后执行</strong> </li>
<li>只要是继承 Mono 的脚本都可以在 OnGUI 中绘制 GUI</li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>重复工作量繁多</li>
<li>控件（widget）绘制相关代码很多</li>
<li>最大缺点: 必须运行时才能去查看结果（不能所见即所得，通过 <code>[ExecuteAlways]</code> 特性解决），不支持分辨率自适应</li>
</ul>
<h2 id="2-重要参数"><a href="#2-重要参数" class="headerlink" title="2 重要参数"></a>2 重要参数</h2><blockquote>
<p>[!warning]<br>GUI 的屏幕原点是左上角</p>
</blockquote>
<p><strong>GUI 控件绘制的共同点：</strong></p>
<ol>
<li>他们都是 GUI 公共类中提供的静态函数直接调用即可 </li>
<li>他们的参数都大同小异<ul>
<li>位置参数: Rect  （xy 位置 wh 尺寸）</li>
<li>显示文本: string </li>
<li>图片信息: Texture </li>
<li>参数综合信息: GUIContent </li>
<li>参数自定义样式: GUIStyle</li>
</ul>
</li>
<li><strong>每一种控件都有多种重载，都是各个参数的排列组合必备的参数内容，是位置信息和显示信息</strong></li>
</ol>
<h2 id="3-Label-标签"><a href="#3-Label-标签" class="headerlink" title="3 Label 标签"></a>3 Label 标签</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030610.png" alt="Pasted image 20230607151421|700"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030611.png" alt="Pasted image 20230607151337|450"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Texture texture;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//骷髅</span></span><br><span class="line"><span class="keyword">public</span> Rect rect1;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//小黄脸</span></span><br><span class="line"><span class="keyword">public</span> Rect rect2;  </span><br><span class="line"><span class="keyword">public</span> GUIContent content2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GUIStyle style;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.文本</span></span><br><span class="line">    GUI.Label(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>),<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//text，传位置信息也可以直接声明公共变量Rect，如下：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.图片</span></span><br><span class="line">    GUI.Label(rect1, texture);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.文本+图片</span></span><br><span class="line">    <span class="comment">//GUIContent可以控制text,image,tooltip</span></span><br><span class="line">    GUI.Label(rect2,content2);</span><br><span class="line">    Debug.Log(GUI.tooltip);  <span class="comment">//获取当前鼠标或者键盘选中的GUI控件对应的tooltip信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.自定义格式，第三个参数传入GUIStyle</span></span><br><span class="line">    GUI.Label(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>),<span class="string">&quot;Hello World&quot;</span>,style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-Button-按钮"><a href="#4-Button-按钮" class="headerlink" title="4 Button 按钮"></a>4 Button 按钮</h2><p>自定义格式：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030612.png" alt="Pasted image 20230607151820|450"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rect rect;  </span><br><span class="line"><span class="keyword">public</span> GUIContent content;  </span><br><span class="line"><span class="keyword">public</span> GUIStyle style;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//鼠标按下松开为一次点击</span></span><br><span class="line">    <span class="comment">//无style参数时，使用默认style</span></span><br><span class="line">    <span class="keyword">if</span> (GUI.Button(rect, content, style))  <span class="comment">//判断是否点击</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//处理按钮点击逻辑</span></span><br><span class="line">        print(<span class="string">&quot;Button Clicked&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//鼠标长按</span></span><br><span class="line">    <span class="keyword">if</span>(GUI.RepeatButton(rect, content, style))  </span><br><span class="line">    &#123;  </span><br><span class="line">        print(<span class="string">&quot;Button Clicked&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Toggle-开关"><a href="#5-Toggle-开关" class="headerlink" title="5 Toggle 开关"></a>5 Toggle 开关</h2><p>Toggle 意为（两种状态之间）切换</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置方法类似上面的按钮，多一个点击选中的判断，我们要自己声明一个bool值</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isSelect;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> Rect rect;  </span><br><span class="line"><span class="keyword">public</span> GUIContent content;  </span><br><span class="line"><span class="keyword">public</span> GUIStyle style;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span>  </span><br><span class="line">&#123;</span><br><span class="line">    isSelect = GUI.Toggle(rect, isSelect, <span class="string">&quot;Toggle&quot;</span>);</span><br><span class="line">    isSelect = GUI.Toggle(rect, isSelect, content,style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排版攻略：</p>
<ol>
<li>修改固定宽高 fixedwidth 和 fixedHeight</li>
<li>修改从 GUIStyle 边缘到内容起始处的空间 padding</li>
</ol>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030613.gif" alt="2022306071646"></p>
<figure class="highlight cs"><figcaption><span>title: 基于 Toggle 实现多选框</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isSelect;  </span><br><span class="line"><span class="keyword">public</span> Rect rect;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> nowSelIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//基于Toggle实现多选框</span></span><br><span class="line">    <span class="keyword">if</span> (GUI.Toggle(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">30</span>), nowSelIndex == <span class="number">1</span>, <span class="string">&quot;选项一&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nowSelIndex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">if</span> (GUI.Toggle(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">30</span>), nowSelIndex == <span class="number">2</span>, <span class="string">&quot;选项二&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nowSelIndex = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GUI.Toggle(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">120</span>, <span class="number">100</span>, <span class="number">30</span>), nowSelIndex == <span class="number">3</span>, <span class="string">&quot;选项三&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nowSelIndex = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="6-输入框和拖动条"><a href="#6-输入框和拖动条" class="headerlink" title="6 输入框和拖动条"></a>6 输入框和拖动条</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030614.png" alt="Pasted image 20230607210356"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> inputStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> password = <span class="string">&quot;&quot;</span>;   </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> nowValue = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">public</span> GUIStyle thumbStyle; <span class="comment">//滑块样式</span></span><br><span class="line"><span class="comment">//输入框</span></span><br><span class="line"><span class="comment">//比较特别是的第三个参数，最大输入长度</span></span><br><span class="line">inputStr = GUI.TextField (<span class="keyword">new</span> Rect (<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">50</span>), inputStr, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//密码输入,输入全被*遮盖</span></span><br><span class="line">password = GUI.PasswordField(<span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">50</span>), password, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//水平拖动条</span></span><br><span class="line">nowValue = GUI.HorizontalSlider(<span class="keyword">new</span> Rect(<span class="number">200</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), nowValue,<span class="number">0.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">//带风格的拖动条，多一个style参数</span></span><br><span class="line">nowvalue = GUI.HorizontalSlider(<span class="keyword">new</span> Rect(<span class="number">200</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>),, nowvalue, minValue, maxValue,style,thumbStyle); <span class="comment">//默认的style时滑动条的style，滑块style要自己声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//竖直拖动条GUI.VerticalSlider()</span></span><br></pre></td></tr></table></figure>

<h2 id="7-图片绘制和-Box-框"><a href="#7-图片绘制和-Box-框" class="headerlink" title="7 图片绘制和 Box 框"></a>7 图片绘制和 Box 框</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030615.png" alt="Pasted image 20230607212445"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.DrawTexture</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rect texPos;</span><br><span class="line"><span class="keyword">public</span> Texture texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScaleMode scaleMode; <span class="comment">//可切换三种缩放模式</span></span><br><span class="line"><span class="comment">//scaleAndCrop:通过宽高比来计算图片，但是会进行裁剪</span></span><br><span class="line"><span class="comment">//ScaleToFit:会自动根据宽高比进行计算，不会拉变形，会一直保持图片完全显示的状态</span></span><br><span class="line"><span class="comment">//stretchToFill:始终填充满你传入的 Rect范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> alphaBlend ;    <span class="comment">//默认为true使用alpha透明通道</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GUI.DrawTexture(texPos, texture,scaleMode,alphaBlend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的 Box 边框，没特殊功能<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030616.png" alt="Pasted image 20230607212756"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.Box</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GUI.Box(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>),<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-工具栏和选择网格"><a href="#8-工具栏和选择网格" class="headerlink" title="8 工具栏和选择网格"></a>8 工具栏和选择网格</h2><p>工具栏特点，多个按钮只能同时选择一个<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030617.png" alt="Pasted image 20230607215332"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.Toolbar</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> toolbarIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] toolbarInfos = &#123;<span class="string">&quot;选项一&quot;</span>, <span class="string">&quot;选项二&quot;</span>, <span class="string">&quot;选项三&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    toolbarIndex = GUI.Toolbar(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">30</span>),toolbarIndex,toolbarInfos);</span><br><span class="line">    <span class="keyword">switch</span> (toolbarIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择网格和工具栏具有相同的特点，相对 toolbar 多了一个参数 xCount，<strong>代表水平方向最多显示的按钮数量。</strong></p>
<p>当 xCount 为 3 时，和上面 toolbar 绘制的 ui 一样。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030617.png" alt="Pasted image 20230607215332"><br>当 xCount 为 2 时：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030619.png" alt="Pasted image 20230607215701"><br>当 xCount 为 1 时：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030620.png" alt="Pasted image 20230607215722"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.SelectionGrid</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> selGridIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] selGridInfos = &#123;<span class="string">&quot;选项一&quot;</span>, <span class="string">&quot;选项二&quot;</span>, <span class="string">&quot;选项三&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    selGridIndex = GUI.SelectionGrid(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">30</span>), selGridIndex, selGridInfos,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-滚动视图和分组"><a href="#9-滚动视图和分组" class="headerlink" title="9 滚动视图和分组"></a>9 滚动视图和分组</h2><p><strong>分组</strong></p>
<ul>
<li>用于批量控制控件位置</li>
<li>可以理解为包裹着的控件加了一个父对象</li>
<li>可以通过控制分组来控制包裹控件的位置<figure class="highlight cs"><figcaption><span>title:GUI.BeginGroup</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rect groupPos;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//批量控制控件位置</span></span><br><span class="line">    GUI.BeginGroup(groupPos);</span><br><span class="line">    GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">50</span>),<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>),<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    GUI.EndGroup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>滚动视图：</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030621.png" alt="Pasted image 20230607222051"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.BeginScrollView</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rect uiPos;</span><br><span class="line"><span class="keyword">public</span> Vector2 scrollPos;</span><br><span class="line"><span class="keyword">public</span> Rect viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GUI.BeginScrollView(uiPos, scrollPos, viewPos);</span><br><span class="line">    GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">50</span>),<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>),<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    GUI.EndScrollView ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-窗口"><a href="#10-窗口" class="headerlink" title="10 窗口"></a>10 窗口</h2><p>就是单独的一个窗口，在绘制窗口的函数中写 UI 代码，以窗口的左上角为原点<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030622.gif" alt="202306072241"></p>
<figure class="highlight cs"><figcaption><span>title:GUI.Window</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rect windowPos;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//参数一：窗口唯一ID，</span></span><br><span class="line">   <span class="comment">//委托参数是用于绘制窗口用的函数，传入即可</span></span><br><span class="line">   GUI.Window(<span class="number">1</span>,<span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">150</span>),DrawWindow,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">   GUI.Window (<span class="number">2</span>, <span class="keyword">new</span> Rect (<span class="number">400</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">150</span>), DrawWindow,<span class="string">&quot;窗口 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可拖动窗口</span></span><br><span class="line">   <span class="comment">//1.位置赋值</span></span><br><span class="line">   <span class="comment">//2.绘制函数调用GUI.DragWindow();</span></span><br><span class="line">   windowPos = GUI.Window(<span class="number">3</span>,windowPos,DrawWindow,<span class="string">&quot;拖动窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawWindow</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">switch</span> (id)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">           GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>),<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">           GUI.Box(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>),<span class="string">&quot;123&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">           <span class="comment">//传入Rect参数的重载作用</span></span><br><span class="line">           <span class="comment">//决定窗口中哪一部分位置可以被拖动</span></span><br><span class="line">           <span class="comment">//默认不填,就是无参重载,默认窗口的所有位置都能被拖动</span></span><br><span class="line">           GUI.DragWindow();  </span><br><span class="line">           </span><br><span class="line">           <span class="comment">//传参限制可拖动位置，可以实现只能通过拖动顶栏移动窗口</span></span><br><span class="line">           <span class="comment">//GUI.DragWindow(new Rect(0,0,100,20));  </span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模态窗口</strong></p>
<ul>
<li>可以让窗口外的其它控件无法点击</li>
<li>你可以理解该窗口在最上层，其它按钮都点击不到了，只能点击该窗口上控件<figure class="highlight cs"><figcaption><span>title:GUI.ModalWindow</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GUI.ModalWindow(<span class="number">2</span>,<span class="keyword">new</span> Rect(<span class="number">400</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">150</span>),DrawWindow,<span class="string">&quot;模态窗口&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-颜色和皮肤"><a href="#11-颜色和皮肤" class="headerlink" title="11 颜色和皮肤"></a>11 颜色和皮肤</h2><figure class="highlight cs"><figcaption><span>title:设置颜色</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局着色，同时影响背景和字体，不常用</span></span><br><span class="line">GUI.color = Color.blue;</span><br><span class="line">      </span><br><span class="line">GUI.contentColor = Color.green;     <span class="comment">//文本颜色</span></span><br><span class="line">GUI.backgroundColor = Color.yellow; <span class="comment">//背景颜色</span></span><br><span class="line">GUI.Button(<span class="keyword">new</span> Rect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>), <span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">      </span><br><span class="line">GUI.contentColor = Color.white;  <span class="comment">//设置白色就可以恢复原色</span></span><br><span class="line">GUI.backgroundColor = Color.white;</span><br><span class="line">GUI.Button(<span class="keyword">new</span> Rect(<span class="number">300</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">100</span>), <span class="string">&quot;按钮2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>右键创建 GUI Skin，相当于 GUI style 的集合体，支持修改所有控件样式。<br>可以在这里面修改，通过代码传给 UI 控件。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030623.png" alt="Pasted image 20230607225608|400"></p>
<figure class="highlight cs"><figcaption><span>title:设置皮肤</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GUISkin guiSkin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  GUI.skin = guiSkin;</span><br><span class="line">  GUI.Button(<span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>),<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  GUI.skin = <span class="literal">null</span>;  <span class="comment">//恢复默认皮肤</span></span><br><span class="line">  GUI.Button(<span class="keyword">new</span> Rect(<span class="number">300</span>,<span class="number">300</span>,<span class="number">100</span>,<span class="number">100</span>),<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-布局-GUILayout"><a href="#12-布局-GUILayout" class="headerlink" title="12 布局 GUILayout"></a>12 布局 GUILayout</h2><p>不需要传 Rect 位置参数，自动布局，主要用于编辑器开发（编辑器 UI 排列比较整齐简单）, 不适合作为游戏 UI</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030624.png" alt="Pasted image 20230607230430"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUILayout.BeginArea(<span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>));   <span class="comment">//也可以使用group等统一管理位置</span></span><br><span class="line">GUILayout.Button(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">GUILayout.Button(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">GUILayout.Button(<span class="string">&quot;123142&quot;</span>);</span><br><span class="line">GUILayout.Button(<span class="string">&quot;阿斯顿123142&quot;</span>);</span><br><span class="line">GUILayout.EndArea();</span><br></pre></td></tr></table></figure>

<p>使用布局选项：</p>
<figure class="highlight cs"><figcaption><span>title:布局选项</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GUILayout.Button(<span class="string">&quot;123&quot;</span>,GUILayout.Width(<span class="number">300</span>)); <span class="comment">//布局选项作为第二个参数传入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//布局选项：</span></span><br><span class="line"><span class="comment">//控件的固定宽高</span></span><br><span class="line">GUILayout.Width(<span class="number">300</span>);</span><br><span class="line">GUILayout.Height(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//允许控件的最小宽高</span></span><br><span class="line">GUILayout.MinWidth(<span class="number">50</span>);</span><br><span class="line">GUILayout.MinHeight(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//允许控件的最大宽高</span></span><br><span class="line">GUILayout.MaxWidth(<span class="number">100</span>);</span><br><span class="line">GUILayout.MaxHeight(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//允许或禁止水平拓展</span></span><br><span class="line">GUILayout.ExpandWidth(<span class="literal">true</span>);    <span class="comment">//允许</span></span><br><span class="line">GUILayout.ExpandHeight(<span class="literal">false</span>);  <span class="comment">//禁止</span></span><br></pre></td></tr></table></figure>

<h2 id="13-自适应"><a href="#13-自适应" class="headerlink" title="13 自适应"></a>13 自适应</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030625.png" alt="Pasted image 20230608080626|350"></p>
<h1 id="UGUI"><a href="#UGUI" class="headerlink" title="UGUI"></a>UGUI</h1><p>UGUI 是 Unity 引擎内自带的 UI 系统官方称之为: Unity Ul<br>是目前 Unity 商业游戏开发中使用最广泛的 UI 系统开发解决方案<br>它是基于 Unity 游戏对象的 UI 系统，<strong>只能用来做游戏 UI 功能，不能用于开发 Unity 编辑器中内置的用户界面</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030626.png" alt="Pasted image 20230616154516"></p>
<h2 id="1-六大基础组件"><a href="#1-六大基础组件" class="headerlink" title="1 六大基础组件"></a>1 六大基础组件</h2><p><strong>Canvas 对象上依附的:</strong><br><code>Rect Transform</code>：UI 对象位置锚点控制组件，主要用于控制位置和对其方式<br><code>Canvas</code>：画布组件，主要用于渲染 UI 控件<br><code>Canvas Scaler</code>：画布分辨率自适应组件，主要用于分辨率自适应<br><code>Graphic Raycaster</code>：射线事件交互组件，主要用于控制射线响应相关  </p>
<p><strong>EventSystem 对象上依附的:</strong><br><code>Event System</code> ：玩家输入事件响应系统，主要用于监听玩家操作<br><code>Standalone Input Module</code> ：独立输入模块组件，主要用于监听玩家操作 </p>
<h3 id="Rect-Transform"><a href="#Rect-Transform" class="headerlink" title="Rect Transform"></a>Rect Transform</h3><p><strong>UI 对象位置锚点控制组件，主要用于控制位置和对其方式</strong> </p>
<p>Rect Transform 意思是矩形变换<br><strong>是专门用于处理 UI 元素位置大小相关的组件</strong></p>
<ul>
<li><strong>RectTransform 继承于 Transform</strong>，Transform 组件只处理位置、角度、缩放</li>
<li><strong>RectTransform 在此基础上加入了矩形相关，将 UI 元素当做一个矩形来处理加入了中心点、锚点、长宽等属性</strong>，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应。</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030627.png" alt="Pasted image 20230616211120"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030628.png" alt="Pasted image 20230616210849"></p>
<ul>
<li><p>@ Pivot：Pivot 轴心点默认为（0.5，0.5）</p>
</li>
<li><p>轴心点是旋转的中心（通过调节 Rotation. z 来旋转控件）</p>
</li>
<li><p>和锚点配合控制位置<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030629.png" alt="Pasted image 20230616204627"></p>
</li>
<li><p>@ Anchors：Anchors 轴心点默认为（0.5，0.5）<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030630.png" alt="Pasted image 20230616205128"></p>
</li>
</ul>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p><strong>画布组件，主要用于渲染 UI 控件</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030631.png" alt="Pasted image 20230616160418"></p>
<ul>
<li>它是 UGUI 中所有 UI 元素能够被显示的根本</li>
<li>它主要负责渲染自己的所有 UI 子对象</li>
<li>如果 UI 控件对象不是 Canvas 的子对象，那么控件将不能被渲染</li>
<li>我们可以通过修改 Canvas 组件上的参数修改渲染方式</li>
<li>场景中可以有多个 Canvas 对象，可以分别管理不同画布的渲染方式，分辨率适应方式等等参数。<strong>如果没有特殊需求，—般情况场景上一个 Canvas 即可。</strong></li>
</ul>
<h4 id="RenderMode-渲染模式"><a href="#RenderMode-渲染模式" class="headerlink" title="RenderMode 渲染模式"></a>RenderMode 渲染模式</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030632.png" alt="Pasted image 20230616160333"></p>
<h5 id="Screen-Space-Overlay"><a href="#Screen-Space-Overlay" class="headerlink" title="Screen Space - Overlay"></a>Screen Space - Overlay</h5><p>覆盖模式，UI 始终显示在场景内容前方</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030633.png" alt="Pasted image 20230616160500"></p>
<h5 id="Screen-Space-Camera"><a href="#Screen-Space-Camera" class="headerlink" title="Screen Space - Camera"></a>Screen Space - Camera</h5><p>摄像机模式，3D 物体可以显示在 UI 之前</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030634.png" alt="Pasted image 20230616160834|700"></p>
<ol>
<li>不建议使用 Main Camera，避免场景模型遮挡 UI。</li>
<li><strong>使用一个单独的 Camera（后文称之为 UI Camera） 负责渲染 UI。</strong><ul>
<li>主摄像机 Depth 保持默认的-1，UI Camera 的 Depth 要大于-1（深度较大的绘制在深度较小的上方）</li>
<li>主摄像机 Culling Mask 取消勾选 UI</li>
<li>UI Camera 的 Culling Mask 只选择 UI，<strong>Clear Flags</strong>设置为 Depth Only（只画该层，背景透明，这样才不会让 UI 遮挡后面的内容）</li>
</ul>
</li>
<li>如果需要在 UI 上显示 3D 模型，直接在 Canvas 上创建即可，Layer 要设置成 UI</li>
<li>通过设置 Sorting Layer，也可以对 Canvas 进行排序，后面的层覆盖前面的层。</li>
<li>Order in Layer，适用于相同 Layer 中进行排序</li>
</ol>
<h5 id="Screen-Space-Camera-1"><a href="#Screen-Space-Camera-1" class="headerlink" title="Screen Space - Camera"></a>Screen Space - Camera</h5><p>3D 模式，可以把 UI 对象像 3D 物体一样处理，常用于 VR 或者 AR<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030635.png" alt="Pasted image 20230616163024|350"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030636.png" alt="Pasted image 20230616162932"></p>
<p><strong>Event Camera</strong>：用于处理 UI 事件的摄像机（ 如果不设置，不能正常注册 UI 事件）</p>
<h3 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h3><p>**画布缩放控制器，用于画布分辨率自适应的组件  </p>
<p>它主要负责在不同分辨率下 UI 控件大小自适应<br><strong>它并不负责位置，位置由之后的 Rect Transform 组件负责</strong></p>
<p><strong>提供了三种用于分辨率自适应的模式</strong>（按需选择）</p>
<ol>
<li><p>Constant Pixel Size（恒定像素模式)∶<br>无论屏幕大小如何，U 始终保持相同像素大小</p>
</li>
<li><p><mark style="background: #ADCCFFA6;">Scale With Screen Size (随屏幕尺寸缩放模式)∶</mark><br>根据屏幕尺寸进行缩放，随着屏幕尺寸放大缩小</p>
</li>
<li><p>Constant Physical Size（恒定物理模式)：<br>无论屏幕大小和分辨率如何，UI 元素始终保持相同物理大小</p>
</li>
</ol>
<h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><ol>
<li><p><strong>屏幕分辨率</strong>——当前设备的分辨率，编辑器下 Game 窗口中 Stats 可以查看到<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030637.png" alt="Pasted image 20230616164340"></p>
</li>
<li><p><strong>参考分辨率</strong> Reference Resolution——在 Scale With Screen Size 缩放模式中出现的关键参数，参与分辨率自适应的计算</p>
</li>
<li><p><strong>画布宽高和缩放系数</strong>——分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来。选中 Canvas 对象后在 Rect Transform 组件中看到的宽高和缩放系数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//分辨率为（x,y）,则：</span><br><span class="line">Width * Scale. x = 分辨率x</span><br><span class="line">Height * Scale. y = 分辨率y</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分辨率大小自适应</strong>——通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数该结果会影响所有 UI 控件的缩放大小</p>
</li>
</ol>
<h4 id="UI-Scale-Mode-UI-缩放模式"><a href="#UI-Scale-Mode-UI-缩放模式" class="headerlink" title="UI Scale Mode UI 缩放模式"></a>UI Scale Mode UI 缩放模式</h4><p>重点：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030638.png" alt="Pasted image 20230616172357"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030639.png" alt="Pasted image 20230616171748"></p>
<h5 id="Constant-Pixel-Size-恒定像素模式"><a href="#Constant-Pixel-Size-恒定像素模式" class="headerlink" title="Constant Pixel Size 恒定像素模式"></a>Constant Pixel Size 恒定像素模式</h5><p><strong>无论屏幕大小如何，U 始终保持相同像素大小</strong><br>它不会让 UI 控件进行分辨率大小自适应<br>会让 UI 控件始终保持设置的尺寸大小显示<br><strong>一般在进行游戏开发<mark style="background: #FF5582A6;">极少使用这种模式</mark>，除非通过代码计算来设置缩放系数</strong></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030640.png" alt="Pasted image 20230616163416"></p>
<ul>
<li><strong>Scale Factor: 缩放系数</strong>，按此系数缩放画布中的所有 UI 元素 </li>
<li><strong>Reference Pixels Per Unit：单位参考像素</strong>，多少像素对应 Unity 中的一个单位（<strong>默认一个单位为 100 像素</strong>)，图片设置中的 Pixels Per Unit 设置，会和该参数一起参与计算</li>
</ul>
<p>Set Native Size：恢复 Source Image 的原始尺寸，结果需要经过计算：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030641.png" alt="Pasted image 20230616165546|500"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030642.png" alt="Pasted image 20230616165421"></p>
<h5 id="Scale-With-Screen-Size-随屏幕尺寸缩放模式"><a href="#Scale-With-Screen-Size-随屏幕尺寸缩放模式" class="headerlink" title="Scale With Screen Size  随屏幕尺寸缩放模式"></a>Scale With Screen Size  随屏幕尺寸缩放模式</h5><p><strong>根据屏幕尺寸进行缩放，随着屏幕尺寸放大缩小，<mark style="background: #FF5582A6;">最常用</mark></strong></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030643.png" alt="Pasted image 20230616164147"></p>
<ul>
<li><p><strong>Reference Resolution ：参考分辨率</strong> (PC 常用 1920x1080，手机端也要适配对应分辨率，一般由美术人员决定)。缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算</p>
</li>
<li><p><strong>Screen Match Mode：屏幕匹配模式</strong>，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式。</p>
<ul>
<li>有三种模式：<strong>最常使用的是 Match Width Or Height 模式，套路如下：</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030639.png" alt="Pasted image 20230616171748"></li>
</ul>
</li>
<li><p><mark style="background: #FF5582A6;">三种模式的详细解释</mark></p>
<ol>
<li><mark style="background: #D2B3FFA6;">Expand</mark>: 水平或垂直<strong>拓展画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能有黑边： <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030645.png" alt="Pasted image 20230616171229|300"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030647.png" alt="Pasted image 20230616170712|500"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030648.png" alt="Pasted image 20230616170854|500"></li>
<li><mark style="background: #D2B3FFA6;">Shrink</mark>: 水平或垂直<strong>裁剪画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会裁剪  <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030649.png" alt="Pasted image 20230616171328|500"></li>
<li><mark style="background: #D2B3FFA6;">Match Width Or Height</mark>: <strong>以宽高或者二者的平均值</strong>作为参考来缩放画布区域（常用）<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030650.png" alt="Pasted image 20230616171520|450"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030651.png" alt="Pasted image 20230616171534|500"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030652.png" alt="Pasted image 20230616171554"></li>
</ol>
</li>
</ul>
<h5 id="Constant-Physical-Size-恒定物理模式"><a href="#Constant-Physical-Size-恒定物理模式" class="headerlink" title="Constant Physical Size 恒定物理模式"></a>Constant Physical Size 恒定物理模式</h5><p>无论屏幕大小和分辨率如何，UI 元素始终保持相同物理大小</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030653.png" alt="Pasted image 20230616164157"></p>
<p><strong>DPI: （Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数</strong><br>Physical Unit：物理单位，使用的物理单位种类<br>Falback Screen DPI：备用 DPI，当找不到设备 DPI 时，使用此值 Default Sprite DPI: 默认图片 DPI</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030654.png" alt="Pasted image 20230616172726"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030655.png" alt="Pasted image 20230616172735"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030656.png" alt="Pasted image 20230616172936"></p>
<h5 id="World-世界模式"><a href="#World-世界模式" class="headerlink" title="World 世界模式"></a>World 世界模式</h5><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030657.png" alt="Pasted image 20230616173212"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030658.png" alt="Pasted image 20230616173244"></p>
<h3 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h3><p>Graphic Raycaster 意思是图形射线投射器（不是基于碰撞器，而是基于图形）</p>
<ul>
<li><strong>用于检测 UI 输入事件</strong></li>
<li>主要负责通过射线检测玩家和 UI 元素的交互，判断是否点击到了 UI 元素</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030659.png" alt="Pasted image 20230616173440"><br><strong>lgnore Reversed Graphics</strong>: 是否忽略反转图形</p>
<ul>
<li>? 反转指的是将控件的 Rect Transfrom 中的 Rotation 属性的 x 或 y 轴旋转 180 度<br><strong>Blocking Objects</strong>: 射线被哪些类型的碰撞器阻挡 (在覆盖渲染模式 Screen Space - Overlay 下无效)<br><strong>Blocking Mask</strong>: 射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效)</li>
</ul>
<p><strong>演示：</strong><br>在一个 Button 控件前分别放一个 3D object（Cube） 和 2D object（Sprite），这两个 object 都要添加碰撞器，如下：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030660.png" alt="Pasted image 20230616175144"></p>
<ul>
<li>当 Blocking Objects 为 None 时，可以点击到 button</li>
<li>当 Blocking Objects 为 2D 时，右边点不到 button</li>
<li>当 Blocking Objects 为 3D 时，左边点不到 button</li>
<li>当 Blocking Objects 为 all 时，两边都点不到 button</li>
</ul>
<h3 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h3><p>Event System 意思是事件系统<br><strong>玩家输入事件响应系统，主要用于监听玩家操作</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030661.png" alt="Pasted image 20230616202924"></p>
<ul>
<li><strong>它是用于管理玩家的输入事件并分发给各 UI 控件</strong></li>
<li>它是事件逻辑处理模块，<strong>所有的 UI 事件都通过 EventSystem 组件中轮询检测并做相应的执行</strong></li>
<li>它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应</li>
</ul>
<p><code>First Selected</code>: 首先选择的游戏对象，可以设置游戏一开始的默认选择<br><code>Send Navigation Events</code>: 是否允许导航事件（开启后可以通过键盘控制移动&#x2F;按下&#x2F;取消，wasd 移动，空格&#x2F;回车选择)<br><code>Drag Threshold</code>: 拖拽操作的阈值（移动多少像素的距离才算开始拖拽)</p>
<h3 id="Standalone-Input-Module"><a href="#Standalone-Input-Module" class="headerlink" title="Standalone Input Module"></a>Standalone Input Module</h3><p><strong>独立输入模块组件，主要用于监听玩家操作</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030662.png" alt="Pasted image 20230616203659"></p>
<ul>
<li>它主要针对处理鼠标&#x2F;键盘&#x2F;控制器&#x2F;触屏的输入</li>
<li>输入的事件通过 Event System 进行分发</li>
<li><strong>它依赖于 Event System 组件，他们两缺一不可</strong></li>
</ul>
<p><strong>和 Input Manager 中的设置绑定，一般不会进行修改：</strong><br><code>Horizontal Axis</code>: 水平轴按钮对应的热键名 (该名字对应 Input 管理器)<br><code>Vertical Axis</code>: 垂直轴按钮对应的热键名（该名字对应 Input 管理器)<br><code>Submit Button</code>: 提交（确定)按钮对应的热建名（该名字对应 Input 管理器)<br><code>Cancel Button</code>: 取消按钮对应的热建名 (该名字对应 Input 管理器)</p>
<p><code>Input Actions Per Second</code>: 每秒允许键盘&#x2F;控制器输入的数量<br><code>Repeat Delay</code>: 每秒输入操作重复率生效前的延迟时间<br><code>ForceModule Active</code>: 是否强制模块处于激活状态</p>
<h3 id="代码获取组件属性"><a href="#代码获取组件属性" class="headerlink" title="代码获取组件属性"></a>代码获取组件属性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Transform是RectTransform父类，所以可以强转为RectTransform</span></span><br><span class="line">print(((RectTransform)<span class="keyword">this</span>.transform).sizeDelta);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">print((<span class="keyword">this</span>.transform <span class="keyword">as</span> RectTransform).sizeDelta);</span><br></pre></td></tr></table></figure>

<h2 id="2-三大基础控件"><a href="#2-三大基础控件" class="headerlink" title="2 三大基础控件"></a>2 三大基础控件</h2><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030663.png" alt="Pasted image 20230616213350"></p>
<ul>
<li><p>是 UGUI 中用于显示精灵图片（Sprite）的关键组件</p>
</li>
<li><p>除了背景图等大图用 RawImage，一般都使用 Image 来显示 UI 中的图片元素<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030664.png" alt="Pasted image 20230616213356"></p>
</li>
<li><p>@ <strong>控件显示顺序</strong>：根据在 Canvas 下的层级，越后面的优先级越高:<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030665.png" alt="Pasted image 20230616213645"></p>
</li>
<li><p>@ <strong>Raycast Taget 示例</strong>：在 Button 控件前加一个 Image 控件</p>
<ul>
<li>默认勾选，重叠部分无法点击 Button</li>
<li>取消勾选，重叠部分可以点击 Button<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030666.png" alt="Pasted image 20230616214219"></li>
</ul>
</li>
<li><p>@ <strong>ImageType 图片类型</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030667.png" alt="Pasted image 20230616215522"></p>
</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030668.png" alt="Pasted image 20230616220250"></p>
<ul>
<li>Simple：只用于固定尺寸的图片，美术出什么尺寸就用什么尺寸</li>
<li>Sliced 切片模式：拉伸常用，需要设置图片边框 border</li>
<li>Tiled-平铺模式：重复平铺中央部分，可以设置图片边框 border</li>
<li>Filled-填充模式：效果较多，可以做血条 cd 等效果</li>
</ul>
<p><strong>设置图片边框 border 的步骤：</strong></p>
<ol>
<li>找到图片，点击 SpriteEditor：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030669.png" alt="Pasted image 20230616214956|450"></li>
<li>拉动绿色线，将图片分割成九宫格区域。当拉伸图片时，横向拉伸只会拉伸竖向的中间一排，竖向拉伸只会拉伸横向的中间一排。四角不会发生拉伸<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030670.png" alt="Pasted image 20230616215136|500"></li>
</ol>
<h4 id="代码获取-Image-属性"><a href="#代码获取-Image-属性" class="headerlink" title="代码获取 Image 属性"></a>代码获取 Image 属性</h4><figure class="highlight cs"><figcaption><span>title:代码获取Image属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改当前Image控件的SourceImage</span></span><br><span class="line"><span class="comment">//图片必须放在Resources文件夹</span></span><br><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br><span class="line">img.sprite = Resources.Load&lt;Sprite&gt;( <span class="string">&quot;EmojiOne&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>有两个版本</p>
<ul>
<li>Text (TMP)，基于 TextMeshPro</li>
<li>Text (Legacy)，旧版</li>
</ul>
<h4 id="Text-TMP"><a href="#Text-TMP" class="headerlink" title="Text (TMP)"></a>Text (TMP)</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TMP_Text text;  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure>
<h4 id="Text-Legacy"><a href="#Text-Legacy" class="headerlink" title="Text (Legacy)"></a>Text (Legacy)</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030671.png" alt="Pasted image 20230616222442|450"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030672.png" alt="Pasted image 20230616222359"></p>
<h4 id="代码控制文本内容"><a href="#代码控制文本内容" class="headerlink" title="代码控制文本内容"></a>代码控制文本内容</h4><figure class="highlight cs"><figcaption><span>title:代码控制文本内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Text(TMP)</span></span><br><span class="line">TextMeshPro text = <span class="keyword">this</span>.GetComponent&lt;TextMeshPro&gt;();  </span><br><span class="line">text.text = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Text(Legacy)</span></span><br><span class="line">Text txt = <span class="keyword">this</span>.GetComponent&lt;Text&gt;();</span><br><span class="line">txt.text =<span class="string">&quot;Helloworld;</span></span><br></pre></td></tr></table></figure>

<h3 id="RawImage"><a href="#RawImage" class="headerlink" title="RawImage"></a>RawImage</h3><p>RawImage 是原始图像组件<br><strong>是 UGUI 中用于显示任何纹理图片的关键组件</strong></p>
<p><strong>和 Image 的区别：</strong></p>
<ul>
<li>一般 RawImage **用于显示大图 (背景图、不需要打入图集的图片、网络下载的图等等)**。Image 则用于显示一些小的 UI 元素。</li>
<li>RawImage 支持各种 Texture Type，Image 必须使用 Sprite</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030673.png" alt="Pasted image 20230616223059"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030674.png" alt="Pasted image 20230616223338"></p>
<h4 id="代码控制-Texture"><a href="#代码控制-Texture" class="headerlink" title="代码控制 Texture"></a>代码控制 Texture</h4><figure class="highlight cs"><figcaption><span>title:代码控制Texture</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RawImage img = <span class="keyword">this</span>.GetComponent&lt;RawImage&gt;();</span><br><span class="line">img.texture = Resources.Load&lt;Texture&gt;( <span class="string">&quot;EmojiOne&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-组合控件"><a href="#3-组合控件" class="headerlink" title="3 组合控件"></a>3 组合控件</h2><h3 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h3><p><strong>按钮组件</strong><br>是 UGUI 中用于处理玩家按钮相关交互的关键组件<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030675.png" alt="Pasted image 20230616223909|450"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030676.png" alt="Pasted image 20230616223923"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030677.png" alt="Pasted image 20230616224314"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030678.png" alt="Pasted image 20230616232905"></p>
<blockquote>
<ol>
<li>Navigation 要联动 Event System：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030679.png" alt="Pasted image 20230616232956|500"></li>
<li>Explicit 指定周边控件：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030680.png" alt="Pasted image 20230616233516|500"></li>
<li>导航连线：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030681.png" alt="Pasted image 20230616233439|350"></li>
</ol>
</blockquote>
<h4 id="代码控制-button-属性"><a href="#代码控制-button-属性" class="headerlink" title="代码控制 button 属性"></a>代码控制 button 属性</h4><figure class="highlight cs"><figcaption><span>title:代码控制button</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();  </span><br><span class="line">btn.interactable = <span class="literal">true</span>;  </span><br><span class="line">btn.transition = Selectable.Transition.ColorTint;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="监听点击事件"><a href="#监听点击事件" class="headerlink" title="监听点击事件"></a>监听点击事件</h4><p>点击事件是在按钮区域按下抬起一次就算一次点击<br>监听点击事件有两种方式：</p>
<ol>
<li><p>拖拽对象<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030682.png" alt="Pasted image 20230616234235"><br>只显示脚本上的 public 方法</p>
</li>
<li><p>代码添加</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Button button = GetComponent&lt;Button&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加监听，原理就是委托</span></span><br><span class="line">        button.onClick.AddListener(ClickButton); </span><br><span class="line">        <span class="comment">//也可以使用lambda表达式</span></span><br><span class="line">        button.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;另一种方式ClickButton&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移除监听</span></span><br><span class="line">        button.onClick.RemoveListener(ClickButton);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移除所有监听</span></span><br><span class="line">        button.onClick.RemoveAllListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClickButton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;ClickButton&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="异形按钮"><a href="#异形按钮" class="headerlink" title="异形按钮"></a>异形按钮</h3><p><strong>异形即形状不规则</strong><br>普通的 Button 是根据矩形区域来响应点击，当我们使用带有透明部分的图片时，如图，点击透明区域也会响应，我们只想要不透明部分作为 button<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030683.png" alt="Pasted image 20230618194912"></p>
<h4 id="方法一：添加子对象"><a href="#方法一：添加子对象" class="headerlink" title="方法一：添加子对象"></a>方法一：添加子对象</h4><p>按钮之所以能够响应点击，主要是根据图片矩形范围进行判断的<br>它的范围判断是<strong>自下而上</strong>的，意思是如果有子对象 Button，点击子对象 Button 的矩形范围也会让上面的 button 响应，那么我们就可运用多个透明图拼凑不规则图形作为按钮，子对象用于进行射线检测</p>
<p>如下图，先用一个 Image 作为背景图，然后修改各个 Button 按钮的矩形范围，拼出大致区域即可。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030684.png" alt="Pasted image 20230618201317"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030685.png" alt="Pasted image 20230618201241"></p>
<h4 id="方法二：通过代码改变图片的透明度响应阈值"><a href="#方法二：通过代码改变图片的透明度响应阈值" class="headerlink" title="方法二：通过代码改变图片的透明度响应阈值"></a>方法二：通过代码改变图片的透明度响应阈值</h4><ol>
<li>第一步: 修改图片参数开启 Read&#x2F; write Enabled 开关，会增大内存消耗</li>
<li>第二步: 通过代码修改图片的响应阈值</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Image image;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该参数含义: 指定一个像素必须具有的最小 alpha 值，以便能够认为射线命中了图片。</span></span><br><span class="line">    <span class="comment">//说人话: 当像素点 alpha 值小于了该值就不会被射线检测了</span></span><br><span class="line">    image.alphaHitTestMinimumThreshold = <span class="number">0.1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Toggle-开关"><a href="#Toggle-开关" class="headerlink" title="Toggle 开关"></a>Toggle 开关</h3><p><strong>开关组件</strong><br>是 UGUI 中用于处理玩家<strong>单选框多选框相关交互的关键组件</strong><br>开关组件<strong>默认是多选框</strong></p>
<blockquote>
<p>可以<strong>通过配合 ToggleGroup 组件制作为单选框</strong>（单选框就是多个框只能同时选择其中的一个）</p>
<ol>
<li>canvas 下创建一个空 object 命名为 GroupObject，添加 ToggleGroup 组件，然后将多个 Toggle 作为其子对象（Allow Switch Off 即是否允许所有选项都为关闭状态）<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030686.png" alt="Pasted image 20230617231302"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030687.png" alt="Pasted image 20230617231207"></li>
<li>每个 Toggle 的 Group 都设置为 GroupObject <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030688.png" alt="Pasted image 20230617231154"></li>
</ol>
</blockquote>
<p>默认创建的 Toggle 由 4 个对象组成</p>
<ul>
<li>父对象：Toggle 组件依附</li>
<li>子对象：背景图 (必备)、选中图 (必备)、说明文字 (可选)</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030689.png" alt="Pasted image 20230617230340|400"></p>
<p>Interactable、Transition、Navigation 设置和 Button 一致<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030690.png" alt="Pasted image 20230617230510"></p>
<h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Toggle toggle = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();  </span><br><span class="line">toggle.isOn = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">ToggleGroup toggleGroup = <span class="keyword">this</span>.GetComponent&lt;ToggleGroup&gt;();  </span><br><span class="line">toggleGroup.allowSwitchOff = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过迭代器便利的到处于选中状态的 Toggle  </span></span><br><span class="line"><span class="keyword">foreach</span> (Toggle item <span class="keyword">in</span> toggleGroup.ActiveToggles())  </span><br><span class="line">&#123;  </span><br><span class="line">print(item.name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监听点击事件-1"><a href="#监听点击事件-1" class="headerlink" title="监听点击事件"></a>监听点击事件</h4><p>点击事件是在按钮区域按下抬起一次就算一次点击<br>监听点击事件有两种方式：</p>
<ol>
<li><p>拖拽对象，注意选择的函数必须有 bool 形参，表示打开和关闭<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030691.png" alt="Pasted image 20230617232706"></p>
</li>
<li><p>代码添加</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">Toggle toggle = GetComponent&lt;Toggle&gt;();  </span><br><span class="line">tog.onValueChanged.AddListener(ChangeValue);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//必须传bool形参  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeValue</span>(<span class="params"><span class="built_in">bool</span> isOn</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">print(<span class="string">&quot;状态改变&quot;</span> + isOn);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="InputField-输入字段"><a href="#InputField-输入字段" class="headerlink" title="InputField  输入字段"></a>InputField  输入字段</h3><p><strong>输入字段组件</strong><br>是 UGUI 中用于<strong>处理玩家文本输入相关交互</strong>的关键组件</p>
<p>默认创建的 InputField 由 3 个对象组成<br>父对象：InputField 组件依附对象，以及同时在其上挂载了一个 Image 作为背景图<br>子对象：文本显示组件 (必备)、默认显示文本组件 (必备)</p>
<h4 id="InputField-TMP"><a href="#InputField-TMP" class="headerlink" title="InputField (TMP)"></a>InputField (TMP)</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TMP_InputField inputField;  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure>
<h4 id="InputField-Legacy"><a href="#InputField-Legacy" class="headerlink" title="InputField (Legacy)"></a>InputField (Legacy)</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030692.png" alt="Pasted image 20230617233548"></p>
<p><strong>Content Type：</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030693.png" alt="Pasted image 20230617233722|450"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponent&lt;InputField&gt;();print(input.text);</span><br><span class="line">input.text = <span class="string">&quot;123123123123&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Slider-滑动条"><a href="#Slider-滑动条" class="headerlink" title="Slider 滑动条"></a>Slider 滑动条</h3><p><strong>滑动条组件</strong><br>是 UGUI 中用于处理滑动条相关交互的关键组件</p>
<p>默认创建的 Slider 由 4 组对象组成<br>父对象：Slider 组件依附的对象<br>子对象：背景图、进度图、滑动块三组对象</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030694.png" alt="Pasted image 20230617234615"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030695.png" alt="Pasted image 20230617234645|450"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030697.png" alt="Pasted image 20230617234657"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slider slider = GetComponent&lt;Slider&gt;();</span><br><span class="line">slider. <span class="keyword">value</span> += <span class="number">0.01f</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Scrollbar-滚动条"><a href="#Scrollbar-滚动条" class="headerlink" title="Scrollbar 滚动条"></a>Scrollbar 滚动条</h3><p><strong>滚动条组件</strong></p>
<p>是 UGUI 中<strong>用于处理滚动条相关交互</strong>的关键组件</p>
<p>默认创建的 scrollbar 由 2 组对象组成<br>父对象：Scrollbar 组件依附的对象子对象<br>滚动块对象：<strong>一般情况下我们不会单独使用滚动条，都是配合 ScrollView 滚动视图来使用</strong></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030698.png" alt="Pasted image 20230617235146"></p>
<h3 id="ScrollView-滚动视图"><a href="#ScrollView-滚动视图" class="headerlink" title="ScrollView 滚动视图"></a>ScrollView 滚动视图</h3><p><strong>滚动视图组件</strong><br>是 UGUI 中<strong>用于处理滚动视图相关交互</strong>的关键组件</p>
<p>默认创建的 ScrollRect 由 4 组对象组成<br>父对象：ScrollRect 组件依附的对象，还有一个 Image 组件最为背景图<br>子对象：<br>Viewport 控制<strong>滚动视图可视范围</strong>和 Content <strong>控制内容范围</strong> （内部控件都放在 Content 下面 ）<br>Scrollbar Horizontal 水平滚动条<br>Scrollbar Vertical 垂直滚动条</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030699.png" alt="Pasted image 20230617235616|400"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030700.png" alt="Pasted image 20230617235604"></p>
<h3 id="DrawDown-下拉列表"><a href="#DrawDown-下拉列表" class="headerlink" title="DrawDown 下拉列表"></a>DrawDown 下拉列表</h3><p><strong>下拉列表（下拉选单)组件</strong><br>是 UGUI 中<strong>用于处理下拉列表相关交互</strong>的关键组件</p>
<p>默认创建的 DropDown 由 4 组对象组成<br>父对象：DropDown 组件依附的对象还有一个 Image 组件作为背景图<br>子对象：<br>Label 是当前选项描述<br>Arrow 右侧小箭头<br>Template 下拉列表选单</p>
<h4 id="DrawDown-TMP"><a href="#DrawDown-TMP" class="headerlink" title="DrawDown (TMP)"></a>DrawDown (TMP)</h4><h4 id="DrawDown-Legacy"><a href="#DrawDown-Legacy" class="headerlink" title="DrawDown (Legacy)"></a>DrawDown (Legacy)</h4><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030701.png" alt="Pasted image 20230618001017|350"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030702.png" alt="Pasted image 20230618000758|500"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Dropdown dropdown = GetComponent&lt;Dropdown&gt;();</span><br><span class="line">print(dropdown.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">print(dropdown.options[dropdown.<span class="keyword">value</span>].text);</span><br><span class="line">dropdown.options.Add(<span class="keyword">new</span> Dropdown.OptionData(<span class="string">&quot;新增选项&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="4-自动布局组件"><a href="#4-自动布局组件" class="headerlink" title="4 自动布局组件"></a>4 自动布局组件</h2><p>虽然 UGUI 的 RectTransform 已经非常方便的可以帮助我们快速布局，但 UGUI 中还提供了很多可以帮助我们对 UI 控件进行自动布局的组件，他们可以帮助我们<strong>自动的设置 UI 控件的位置和大小等</strong></p>
<p><strong>自动布局的工作方式</strong>：自动布局控制组件 + 布局元素 &#x3D; 自动布局 </p>
<p><strong>自动布局控制组件</strong>：unity 提供了很多用于自动布局的管理性质的组件用于布局<br><strong>布局元素</strong>： 具备布局属性的对象们，这里主要是指具备 RectTransform 的 UI 组件</p>
<blockquote>
<p>[!quote] 布局属性<br><strong>要参与自动布局的布局元素必须包含布局属性，布局属性主要有以下几条</strong><br><code>Minmum width</code>: 该布局元素应具有的最小宽度<br><code>Minmum height</code>: 该布局元素应具有的最小高度</p>
<p><code>Preferred width</code>: 在分配额外可用宽度之前，此布局元素应具有的宽度<br><code>Preferred height</code>: 在分配额外可用高度之前，此布局元素应具有的高度。</p>
<p><code>Flexible width</code>: 此布局元素应相对于其同级而填充的额外可用宽度的相对量<br><code>Flexible height</code>: 此布局元素应相对于其同级而填充的额外可用高度的相对量</p>
<p><strong>在进行自动布局时都会通过计算布局元素中的这 6 个属性得到控件的大小位置</strong></p>
<ul>
<li>! <strong>一般情况下我们不会去手动修改他们</strong>，但是如果你有这些需求，可以手动添加一个 <code>LayoutElement</code> 组件，可以修改这些布局属性。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030703.png" alt="Pasted image 20230618205443"><blockquote>
<p>控件 Insepctor 最下方可以查看布局属性</p>
</blockquote>
</li>
</ul>
<p>在布局时，<strong>布局元素大小设置的基本规则：</strong></p>
<ol>
<li>首先分配最小大小 <code>Minmum width</code> 和 <code>Minmum height</code></li>
<li>如果父类容器中有足够的可用空间，则分配 <code>Preferred width</code> 和 <code>Preferred height</code></li>
<li>如果上面两条分配完成后还有额外空间，则分配 <code>Flexible width</code> 和 <code>Flexible height</code></li>
</ol>
<p>一般情况下布局元素的这些属性都是 0，但是特定的 UI 组件依附的对象布局属性会被改变，比如 Image 和 Text</p>
</blockquote>
<h4 id="水平垂直组件"><a href="#水平垂直组件" class="headerlink" title="水平垂直组件"></a>水平垂直组件</h4><p><strong>组件名</strong>：Horizontal Layout Group 和 Vertical Layout Group<br><strong>将子对象并排或者竖直的放在一起</strong></p>
<p>通常将组件给父对象，那么子对象就会自动布局，如图，红色 Image 作为父对象，其他颜色 Image 作为子对象，父对象添加 Horizontal Layout Group 组件：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030704.png" alt="Pasted image 20230618210116"> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030705.gif" alt="6a7sd15a1da|500"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030706.png" alt="Pasted image 20230618210413"><br>参数相关:<br>Padding: 左右上下边缘偏移位置<br>Spacing: 子对象之间的间距<br>ChildAlignment: 九宫格对其方式<br>Control Child size: 是否控制子对象的宽高<br>Use child Scale: 在设置子对象大小和布局时，是否考虑子对象的缩放<br>child Force Expand: 是否强制子对象拓展以填充额外可用空间</p>
<h4 id="网格布局组件"><a href="#网格布局组件" class="headerlink" title="网格布局组件"></a>网格布局组件</h4><p><strong>组件名</strong>: Grid Layout Group<br><strong>将子对象当成一个个的格子设置他们的大小和位置</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030707.gif" alt="6a7sd15a1da 1|550"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030708.png" alt="Pasted image 20230618211335"><br>参数相关:<br>Padding: 左右上下边缘偏移位置<br>Cell size: 每个格子的大小<br>Spacing: 格子间隔<br>Start Corner: 第一个元素所在位置 (4 个角)<br>Start Axis: 沿哪个轴放置元素：Horizontal 水平放置满换行，Vertical 竖直放置满换列<br>Child Alignment: 格子对其方式（9 宫格)<br>Constraint: 行列约束<br>Flexible: 灵活模式，根据容器大小自动适应<br>Fixed column Count: 固定列数<br>Fixed Row Count: 固定行数</p>
<h4 id="内容大小适配器"><a href="#内容大小适配器" class="headerlink" title="内容大小适配器"></a>内容大小适配器</h4><p><strong>组件名</strong>: Content size Fitter<br>它可以<strong>自动的调整 RectTransform 的长宽来让组件自动设置大小</strong><br>一般在 Text 上使用或者配合其它布局组件一起使用</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030709.png" alt="Pasted image 20230618212411"><br>参数相关<br>Horizontal Fit: 如何控制宽度<br>Vertical Fit: 如何控制高度<br>Unconstrained: 不根据布局元素伸展<br>Min size: 根据布局元素的最小宽高度来伸展<br>Preferred Size: 根据布局元素的偏好宽度来伸展宽度。</p>
<p><strong>常用情景，背包动态扩容</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030710.png" alt="Pasted image 20230618211900"><br>为 Content 添加一个网格布局组件，然后不断添加 Image ，我们发现，随着 Image 数量增多，Content 的 Rect 高度并没有增加，这就导致，滚轮无法查看所有格子：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030711.gif" alt="6a7sd15a1dafasf"><br>我们只需为 Content 添加内容大小适配器，将 Verticla Fit 设置为 Preferred Size，就可以了：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030712.gif" alt="6a7sd15a1dafasf4"></p>
<h4 id="宽高比适配器"><a href="#宽高比适配器" class="headerlink" title="宽高比适配器"></a>宽高比适配器</h4><p>组件名: Aspect Ratio Fitter</p>
<p>让布局元素按照一定比例来调整自己的大小，使布局元素在父对象内部根据父对象大小进行适配<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030713.png" alt="Pasted image 20230618212719"><br>参数相关:<br>Aspect Mode: 适配模式, 如果调整矩形大小来实施宽高比<br>None: 不让矩形适应宽高比<br>width Controls Height: 根据宽度自动调整高度<br>Height Controls width: 根据高度自动调整宽度<br>Fit In Parent: 自动调整宽度、高度、位置和锚点，使矩形适应父项的矩形，同时保持宽高比，会出现黑边<br>Envelope Parent: 自动调整宽度、高度、位置和锚点，使矩形覆盖父项的整个区域，同时保持宽高比，会出现“裁剪<br>Aspect Ratio: 宽高比; 宽除以高的比值</p>
<h2 id="5-图集-需要补一下-Unity-核心"><a href="#5-图集-需要补一下-Unity-核心" class="headerlink" title="5  图集 (需要补一下 Unity 核心)"></a>5  图集 (需要补一下 Unity 核心)</h2><p>UGUI 和 NGUI 使用上最大的不同是：NGUI 使用前就要打图集，UGUI 可以再之后再打图集<br><strong>打图集的目的就是减少 Drawcall 提高性能</strong>，我们可以通过打图集，将小图合并成大图，将本应 n 次的 Drawcall 变成 1 次 Drawcall 来提高性能。</p>
<h3 id="Sprite-Packer"><a href="#Sprite-Packer" class="headerlink" title="Sprite Packer"></a>Sprite Packer</h3><p><strong>Sprite Packer (精灵包装器，可以通过 Unity 自带图集工具生成图集)</strong><br>Edit-&gt;Project Setting-&gt;Editor<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030714.png" alt="Pasted image 20230618001804"></p>
<ol>
<li><strong>Disabled</strong>: 默认设置, 不会打包图集</li>
<li><strong>Enabled For Build（常用）</strong>: Unity 仅在构建时打包图集，在编辑器模式下不会打包</li>
<li><strong>Always Enabled（常用）</strong>: Unity 在构建时打包图集，在编辑模式下运行前会打包图集</li>
</ol>
<h3 id="图集参数"><a href="#图集参数" class="headerlink" title="图集参数"></a>图集参数</h3><p>创建图集：create-&gt;2D-&gt;Sprite Atlas<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030715.png" alt="Pasted image 20230618141523|500"><br>图集打包后，不要让外部部件插入其中，这样会增加 drawcall</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载图集注意:需要引用命名空间  </span></span><br><span class="line">SpriteAtlas sa = Resources.Load&lt;SpriteAtlas&gt;( <span class="string">&quot;MyAlas&quot;</span>);  </span><br><span class="line"><span class="comment">//从图集中加载指定名字的小图  </span></span><br><span class="line">sa.GetSprite(<span class="string">&quot;bk&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-UI-事件接口"><a href="#6-UI-事件接口" class="headerlink" title="6 UI 事件接口"></a>6 UI 事件接口</h2><p>目前所有的控件都只提供了常用的事件监听列表<br><strong>如果想做一些类似长按，双击，拖拽等功能是无法制作的，或者想让 Image 和 Text, RawImage 三大基础控件能够响应玩家输入也是无法制作的</strong><br>而事件接口就是用来处理类似问题，让所有控件都能够添加更多的事件监听来处理对应的逻辑</p>
<p><strong>常用事件接口：</strong><br><code>IPointerEnterHandler</code> - <code>OnPointerEnter</code> -当指针进入对象时调用 (鼠标进入)<br><code>IPointerExitHandler</code> - <code>OnPointerExit</code> -当指针退出对象时调用 (鼠标离开)<br><code>IPointerDownHandler</code> - <code>OnPointerDown</code> -在对象上按下指针时调用  (按下)<br><code>IPointerUpHandler</code> - <code>OnPointerUp</code> -松开指针时调用（在指针正在点击的游戏对象上调用)（抬起）<br><code>IPointerClickHandler</code> - <code>OnPointerclick</code> -在同一对象上按下再松开指针时调用 (点击)</p>
<p><code>IBeginDragHandler</code> - <code>OnBeginDrag</code> -即将开始拖动时在拖动对象上调用 (开始拖拽）<br><code>IDragHandler</code> - <code>OnDrag</code> - 发生拖动时在拖动对象上调用 (拖拽中)<br><code>IEndDragHandler</code> - <code>OnEndDrag</code> -拖动完成时在拖动对象上调用 (结束拖拽)</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030716.png" alt="Pasted image 20230618142218"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>继承 MonoBehavior 的脚本继承对应的事件接口，引用命名空间 </li>
<li>实现接口中的内容</li>
<li>将该脚本挂载到想要监听自定义事件的 UI 控件上 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要什么接口就继承什么</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerClickHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现接口内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标点击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="PointerEventData"><a href="#PointerEventData" class="headerlink" title="PointerEventData"></a>PointerEventData</h3><p>上面实现的接口内容都有一个 <code>PointerEventData</code> 类型的参数<br>父类: <code>BaseEventData</code> </p>
<p><code>pointerId</code>: 鼠标左右中键点击鼠标的 ID ，通过它可以判断左中右键点击，对一个 ID 分别为-1，-2，-3<br><code>position</code>: 当前指针位置 (屏幕坐标系)<br><code>pressPosition</code>: 按下的时候指针的位置 delta: 指针移动增量<br><code>clickCount</code>: 连击次数 clickTime: 点击时间<br><code>pressEventCamera</code>: 最后一个 <code>onPointerPress</code> 按下事件关联的摄像机<br><code>enterEvetnCamera</code>: 最后一个 <code>onPointerEnter</code> 进入事件关联的摄像机</p>
<figure class="highlight cs"><figcaption><span>title:使用方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;鼠标点击&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标点击ID</span></span><br><span class="line">    print(eventData.pointerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventTrigger"><a href="#EventTrigger" class="headerlink" title="EventTrigger"></a>EventTrigger</h3><p>事件触发器是 EventTrigger 组件<br>它是一个集成了上节课中学习的所有事件接口的脚本，它可以让我们更方便的为控件添加事件监听</p>
<p>直接在 UI 控件上添加 EventTrigger 即可：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030717.png" alt="Pasted image 20230618143456"></p>
<p><strong>使用方法：</strong></p>
<ol>
<li>直接拖脚本关联，注意传入的函数参数为 BaseEventData 类型<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030718.png" alt="Pasted image 20230618143557"></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestPointerEnter</span>(<span class="params">BaseEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果想获取其他信息，就转换成PointerEventData类型</span></span><br><span class="line">        PointerEventData pointerEventData = eventData <span class="keyword">as</span> PointerEventData;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span> +  pointerEventData.position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>代码关联<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明事件</span></span><br><span class="line">EventTrigger.Entry entry = <span class="keyword">new</span> EventTrigger.Entry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事件类型</span></span><br><span class="line">entry.eventID = EventTriggerType.PointerEnter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调函数</span></span><br><span class="line">entry.callback.AddListener((data)=&gt;&#123; Debug.Log(<span class="string">&quot;鼠标进入&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">eventTrigger.triggers.Add(entry);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-屏幕坐标转-UI-坐标"><a href="#7-屏幕坐标转-UI-坐标" class="headerlink" title="7 屏幕坐标转 UI 坐标"></a>7 屏幕坐标转 UI 坐标</h2><p><code>RectTransformUtility</code> 公共类是一个 <code>RectTransform</code> 的辅助类主要用于进行一些坐标的转换等等操作，其中对于我们目前来说最重要的函数是将屏幕空间上的点，转换成 UI 本地坐标下的点</p>
<p>方法:<br><code>RectTransformUtility. ScreenPointToLocalPointInRectangle</code><br><strong>参数一</strong>：相对父对象<br><strong>参数二</strong>：屏幕点<br><strong>参数三</strong>：摄像机<br><strong>参数四</strong>：最终得到的点<br>一般配合拖拽事件使用</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030719.png" alt="Pasted image 20230618144851"><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030720.png" alt="Pasted image 20230618145514"><br>将以下脚本挂在给子对象，可以通过鼠标拖动 image 子对象相对于父对象移动</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span> , <span class="title">IDragHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">            <span class="keyword">this</span>.transform.parent <span class="keyword">as</span> RectTransfor,</span><br><span class="line">            eventData.position,</span><br><span class="line">            eventData.enterEventCamera,</span><br><span class="line">            <span class="keyword">out</span> Vector2 localPoint);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.transform.localPosition = localPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Mask-遮罩"><a href="#9-Mask-遮罩" class="headerlink" title="9 Mask 遮罩"></a>9 Mask 遮罩</h2><p>实现遮罩效果的关键组件时 Mask 组件<br>通过<strong>在父对象上添加 Mask 组件</strong>即可遮罩其子对象</p>
<p>注意:</p>
<ol>
<li>想要被遮罩的 Image 需要勾选 Maskable</li>
<li>只要父对象添加了 Mask 组件，那么所有的 UI 子对象都会被遮罩</li>
<li>遮罩父对象图片的制作，不透明的地方显示，透明的地方被遮罩</li>
</ol>
<p> 遮罩前： <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030721.png" alt="Pasted image 20230618150128"><br> 使用遮罩： <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030722.png" alt="Pasted image 20230618150119"></p>
<h2 id="10-模型和粒子显示在-UI-之前"><a href="#10-模型和粒子显示在-UI-之前" class="headerlink" title="10 模型和粒子显示在 UI 之前"></a>10 模型和粒子显示在 UI 之前</h2><h3 id="方法一：直接用摄像机渲染-3D-物体"><a href="#方法一：直接用摄像机渲染-3D-物体" class="headerlink" title="方法一：直接用摄像机渲染 3D 物体"></a>方法一：直接用摄像机渲染 3D 物体</h3><p>Canvas 的渲染模式：摄像机模式和世界 (3D)模式都可以让模型显示在 UI 之前（(Z 轴在 UI 元素之前即可)<br>注意:</p>
<ol>
<li>摄像机模式时建议用专门的摄像机渲染 UI 相关 </li>
<li>面板上的 3D 物体建议也用 UI 摄像机进行渲染</li>
</ol>
<p>![[#Screen Space - Camera]]</p>
<h3 id="方法二：渲染在-RT-上，通过-RawImage-显示"><a href="#方法二：渲染在-RT-上，通过-RawImage-显示" class="headerlink" title="方法二：渲染在 RT 上，通过 RawImage 显示"></a>方法二：渲染在 RT 上，通过 RawImage 显示</h3><p>专门使用一个摄像机渲染 3D 模型，将其渲染内容输出到 Render Texture 上，类似小地图的制作方式<br>再将渲染的图显示在 UI 上<br>该方式不管 canvas 的渲染模式是哪种都可以使用</p>
<p> <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030723.png" alt="Pasted image 20230618151231|500"></p>
<ol>
<li>创建一个专用摄像机，将想要渲染的模型单独设置一个 Layer，将摄像机的 CullingMask 设置为该 Layer，之渲染该模型</li>
<li>Create-&gt;RenderTexture，将创建的 RT 传给摄像机</li>
<li>Canvas 下创建一个 RawImage（RawImage 支持各种 Texture Type），将 RT 传过去就可以了。</li>
</ol>
<h3 id="方法三：粒子系统-Order-in-Layer"><a href="#方法三：粒子系统-Order-in-Layer" class="headerlink" title="方法三：粒子系统 Order in Layer"></a>方法三：粒子系统 Order in Layer</h3><p><strong>粒子系统也可以使用方法一和方法二，同时有一个单独的方法：</strong><br>canvas 和粒子系统都有一个层级排序选项，通过修改粒子系统的序号，让值大于 Canvas，即可实现忽略 z 轴，粒子始终显示在 UI 前<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030724.png" alt="Pasted image 20230618151821|500"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030725.png" alt="Pasted image 20230618151734|550"></p>
<h2 id="11-CanvasGroup"><a href="#11-CanvasGroup" class="headerlink" title="11 CanvasGroup"></a>11 CanvasGroup</h2><p>为面板父对象添加 CanvasGroup 组件即可同时控制一组 Canvas<br>常用于整体控制一个面板的淡入淡出或者整体禁用</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030726.png" alt="Pasted image 20230618212954"><br>参数相关:<br>Alpha: 整体透明度控制<br>Interactable: 整体启用禁用设置<br>Blocks Raycasts: 整体射线检测设置<br>Ignore Parent Groups: 是否忽略父级 CanvasGroup 的作用</p>
<h2 id="12-常用插件"><a href="#12-常用插件" class="headerlink" title="12 常用插件"></a>12 常用插件</h2><p>DoTween—缓动插件，可以制作一些缓动效果</p>
<p>TextMeshPro: 一文本网格插件，可以制作更多的特效文字</p>
<h2 id="13-实战"><a href="#13-实战" class="headerlink" title="13 实战"></a>13 实战</h2><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030727.png" alt="Pasted image 20230724215213"></p>
<h1 id="ShaderGUI"><a href="#ShaderGUI" class="headerlink" title="ShaderGUI"></a>ShaderGUI</h1><p><strong>ShaderGUI 分为两种，一种是 Drawer 一种是 GUI，当然可以把 GUI 集成后用 Drawer 的形式写。</strong><br>这里主要说的是  GUI，因为 Drawer 有很多限制，例如修改 RenderType 的时候就很麻烦。<br>回到 GUI。大部分 GUI 继承自两个类，**<code>ShaderGUI &amp; BaseShaderGUI</code>**（可以去 Unity 里翻翻，记得改成 all）。前者是自己造轮子，后者是根据前者的基础上造好了一些轮子（如果是在 Lit 基础上魔改的，用 BaseShaderGUI 方便一些）这里主要是抄作业</p>
<p>另外一点就是参考默认 lit. shader 的时候会发现<strong>CustomEditor</strong>里面是一个<strong>namespace</strong>，所以其实也可以写成<strong>CustomEditor “namespace. name”</strong>的形式</p>
<p><strong>再有一点，Drawer 和 GUI 是分开的独立的，互不影响。如果需要影响的话，有一个 base. OnGUI 可以达到 Drawer 和 GUI 混用</strong></p>
<h2 id="一、Drawer"><a href="#一、Drawer" class="headerlink" title="一、Drawer"></a>一、Drawer</h2><p>Unity 为用户提供了基础类：<code>MaterialPropertyDrawer</code>，专门<strong>用于快速实现自定义材质面板</strong>的目的。</p>
<h3 id="常用的属性特性"><a href="#常用的属性特性" class="headerlink" title="常用的属性特性"></a>常用的属性特性</h3><p><code>[Space]</code> 单行空格<br><code>[Space (5)]</code> 五行空格<br><code>[Header (name)]</code>  标题名<br><code>[HideInInSpector]</code>：在 InSpector 面板隐藏<br><code>[NoScaleOffset]</code>：隐藏纹理的 Tiling 和 Offset<br><code>[Normal]</code>：检测是否为 NormalMap<br><code>[HDR]</code>：指示纹理或颜色属性使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/Manual/HDR.html">高动态范围 (HDR)</a> 值。<br><code>[Gamma]</code>：指示浮点数或矢量属性使用 sRGB 值<br>![[1 ShaderLab#颜色空间和颜色&#x2F;矢量着色器数据]]</p>
<p><code>[MainTexture]</code> ：将纹理设置为主纹理，默认情况 Unity 会将属性名为 <code>_MainTex</code> 的纹理设置为主纹理。如果 Shader 中有多个该命令，只有第一个命令会生效 </p>
<figure class="highlight cs"><figcaption><span>title:脚本访问主纹理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Texture texture;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Material.mat = GetConponent&lt;Renderer&gt;().material;</span><br><span class="line">    mat.material = texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[MainColor]</code>：将属性设置为主颜色，默认情况 Unity 会将名为 <code>_Color</code> 的纹理设置为主纹理。如果 Shader 中有多个该命令，只有第一个命令会生效 <figure class="highlight cs"><figcaption><span>title:脚本访问主颜色</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Texture texture;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Material.mat = GetConponent&lt;Renderer&gt;().material;</span><br><span class="line">    mat.color = color.red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>[PerRendererData]</code>：指示纹理属性将来自每渲染器数据，形式为 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2022.3/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a>。材质 Inspector 会将这些属性显示为只读。</p>
<h3 id="不同类型的-DrawerClass"><a href="#不同类型的-DrawerClass" class="headerlink" title="不同类型的 DrawerClass"></a>不同类型的 DrawerClass</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030728.png" alt="Pasted image 20230615172023"><br>在编写 Shader 的时候，DrawerClass 需要写在对应属性之前的“<code>[]</code>”中，类别的后缀名称“Drawer”不需要添加，因为 Unity 在编辑的时候会自动添加。</p>
<ol start="6">
<li><p>IntRange（整数滑动条）<br><code>[IntRange]_Alpha(&quot;Alpha&quot;,Range(0,255)) = 0</code></p>
</li>
<li><p>Space（垂直间隔）<br><code>[Space]_Prop1(&quot;Prop1&quot;,Float) = 0</code><br>也可以加数字增大间隔<br><code>[Space(50)]_Prop2(&quot;Prop2&quot;,Float) = 0</code></p>
</li>
<li><p>Header（标题头）<br><code>[Header(Title)]_Title(&quot;Title&quot;,Float) = 0</code></p>
</li>
<li><p>PowerSlider（指数式的滑动条）<br><code>[PowerSlider(3.0)]_Shininess(&quot;Shininess&quot;,Range(0,1)) = 0</code></p>
</li>
<li><p>Enum（枚举）<br><code>[Enum(Zero,0,One,1,Two,2,Three,3)] _Number (&quot;Number&quot;, Float) = 0</code></p>
</li>
<li><p>KeywordEnum（枚举）<br><code>[KeywordEnum(None,Add,Multiply)]_Overlay(&quot;OverLay Mode&quot;,Float) = 0</code><br>KeywordEnum 和 Enum 使用上有些不同，区别在于 KeywordEnum 类似于 if-else，同时在 shader 代码中需要处理</p>
</li>
</ol>
<h4 id="Toggle-和-ToggleOff"><a href="#Toggle-和-ToggleOff" class="headerlink" title="Toggle 和 ToggleOff"></a>Toggle 和 ToggleOff</h4><p><strong>将 float 类型的数据以开关的形式在材质属性面板上显示，数值只能设置为 0 或 1，0 为关闭，1 为开启。</strong><br>当 Toggle 开启，Shader 关键词会被 Unity 默认设置为 <code>property name_ON</code><br>当 ToggleOff 开启，Shader 关键词会被 Unity 默认设置为 <code>property name_OFF</code></p>
<p>注意：关键词的所有字母必须大写。</p>
<figure class="highlight c"><figcaption><span>title:使用方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、声明Property，格式为：[ToggleOff] VarName(&quot;Display&quot;, Int) = 0/1</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    [Toggle] _EnableColor_Attr(<span class="string">&quot;_EnableColorAttr&quot;</span>, Int) = <span class="number">1</span></span><br><span class="line">    <span class="comment">//[ToggleOff] _EnableColor_Attr(&quot;_EnableColorAttr&quot;, Int) = 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、声明关键词ShaderFeature，格式为: #progma shader_feature VARNAME_ON/OFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature _ENABLECOLOR_ATTR_On</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _ENABLECOLOR_ATTR_OFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、使用，直接用 #if defined(VARNAME_ON/OFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_ENABLECOLOR_ATTR_ON)</span></span><br><span class="line"><span class="comment">//#if defined(_ENABLECOLOR_ATTR_OFF)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>除了使用 Unity 默认的关键词，也可以自定义一个特殊的关键词，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Toggle (ENABLE_FANCY)] _Fancy ( <span class="string">&quot;Fancy? &quot;</span> ,Float) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>括号内的名称 ENABLE_FANCY 即为自定义的 Shader 关键词。</p>
<h4 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h4><p>枚举（Enum）将 float 类型的数据以下拉列表的形式在材质属性面板上显示，Unity 为用户提供了一些内置的枚举类，例如 BlendMode、CillMode、CompareFunction，举个例子：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030729.png" alt="Pasted image 20221020200242|400"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Properties  </span><br><span class="line">&#123;  </span><br><span class="line">    ......</span><br><span class="line">    [Enum(UnityEngine.Rendering.BlendMode)]  </span><br><span class="line">    _BlendSrc(<span class="string">&quot;混合源乘子&quot;</span>,<span class="type">int</span>) = <span class="number">0</span>  </span><br><span class="line">    [Enum(UnityEngine.Rendering.BlendMode)]  </span><br><span class="line">    _BlendOst(<span class="string">&quot;混合目标乘子&quot;</span>,<span class="type">int</span>) = <span class="number">0</span>  </span><br><span class="line">    [Enum(UnityEngine.Rendering.BlendOp)]  </span><br><span class="line">    _BlendOp(<span class="string">&quot;混合算符&quot;</span>,<span class="type">int</span>) = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br><span class="line">Pass  </span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">BlendOp [_BlendOp]        <span class="comment">//可自定义混合运算符  </span></span><br><span class="line">Blend [_BlendSrc] [_BlendOst]   <span class="comment">//可自定义混合模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Unity 内置的所有混合系数的枚举类，默认值为 0 表示选择第一个混合系数，默认值为 1 表示选择第二个混合系数，<br>以此类推。最终在材质面板上的显示效果如图 11-1 所示，这些选项就是 Shader 中可以使用的所有混合系数。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030730.png" alt="Pasted image 20230615172846|450"></p>
<p>当然，用户也可以自己定义枚举的名称／数值对，但是一个枚举最多只能自定义 7 个名称／数值对。举个例子：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Enum (Off, 0，On, 1)</span>] _Zwrite ( <span class="string">&quot;ZWrite&quot;</span>, Float) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上述例子定义的枚举为“是否深度写入”，括号内为定义的名称／数值对，序号 0 对应 Off，序号 1 对应 On，中间用符号“，”间隔开。默认为序号 0，也就是 Off。</p>
<h4 id="KeywordEnum"><a href="#KeywordEnum" class="headerlink" title="KeywordEnum"></a>KeywordEnum</h4><p>关键词枚举（KeywordEnum）跟普通的枚举类似，也是将 float 类型的数据以下拉列表的形式在材质属性面板上显示，<strong>只不过关键词枚举会有与之对应的 Shader 关键词</strong>，在 Shader 中通过 <code>#pragma shader_feature</code> 或 <code>#pragma multi_compile </code> 指令可以开启或者关闭某一部分 Shader 代码。</p>
<p>Shader 关键词格式为：<code>property name_enum name</code>，属性名称+“下画线”+枚举名称，所有英文必须大写，并且最多支持 9 个关键词。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[KeywordEnum(None,Add,Multiply)] _Overlay(<span class="string">&quot;Overlay mode&quot;</span>, Float) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>括号内的 None，Add，Multiply 是定义的 3 个枚举名称，中间用逗号隔开。默认值为 0，表示默认使用 None。这三个选项所对应的 Shader 关键词分别为：<code>_OVERLAY_NONE</code>、<code>_OVERLAY_ADD</code> 和 <code>_OVERLAY_MULTIPLY</code>。</p>
<p>定义如下：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030731.png" alt="ff2ec5c9a828a57966b774f66e3c89b4_MD5"></p>
<p>使用如下：<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030732.png" alt="26594b2b6e750ca51a90aa2b193aeb79_MD5"></p>
<h4 id="在编译指令中定义关键词"><a href="#在编译指令中定义关键词" class="headerlink" title="在编译指令中定义关键词"></a>在编译指令中定义关键词</h4><p>定义了 <code>ToggleDrawer</code> 或者 <code>KeywordEnumDrawer</code> 之后，如果想要正常使用，还需要在编译指令中声明 Shader 关键词。例如，上面定义的 None、Add、Multiply 关键词枚举，在编译指令中的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature _OVERLAY_NONE _OVERLAY_ADD _OVERLAY_MULTIPLY</span></span><br></pre></td></tr></table></figure>

<p>不同关键词之间需要用空格间隔开。<br>另外，也可以使用另一种编译指令定义关键词，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile _OVERLAY_NONE _OVERLAY_ADD _OVERLAY_MULTIPLY</span></span><br></pre></td></tr></table></figure>

<p><strong>虽然表面上看似通过一个 Shader 文件实现了不同种情况，但是 Unity 会自动将不同情况编译成不同版本的 Shader 文件，这些不同版本的 Shader 文件被称为 Shader 变体（Variants），上述编译指令中包含三个 Shader 变体</strong>。</p>
<p>假设再添加一个指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> shader_feature _INVERT_ON</span></span><br></pre></td></tr></table></figure>
<p>本指令包含 Toggle 的关闭与开启两种情况，所以 Unity 最终会编译出 2×3&#x3D;6 个 Shader 变体。因此在使用大量 shader feature 或 multi compile 指令的时候，无形之中会产生大量的 Shader 变体文件。</p>
<p><strong>两种不同编译指令之间的区别如下：</strong><br>（1）shader_feature：只会为材质使用到的关键词生成变体，没有使用到的关键词不会生成变体，<strong>因此无法在运行的时候通过脚本切换效果</strong>。<br>（2）multi_compile：会为所有关键词生成变体，因此<strong>可以在运行的时候通过脚本切换效果</strong>。</p>
<p>在 Shader 文件的属性设置面板中可以查看到本 Shader 生成的变体数量，如图 11-2 所示，通过开启“Skip unused shader_features”选项可以只查看使用关键词的变体数量，也可以关闭“Skip unused shader_features”选项查看所有关键词的变体数量。如果需要确定具体的关键词是哪些，可以单击“Show”查看。<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030733.png" alt="Pasted image 20230615175748"></p>
<h3 id="内置枚举-UI-汇总"><a href="#内置枚举-UI-汇总" class="headerlink" title="内置枚举 UI 汇总"></a>内置枚举 UI 汇总</h3><p>ZWriteMode 是没有内置的，实际上也只有 on 和 off 两个状态，所以用 Toogle 其实也可以，这里是直接用 <code>[Enum(Off, 0, On, 1)]</code> 这样的写法声明了个新的自定义 Enum </p>
<p>想要知道 unity 还有哪些 shader 里可以用的 Attributes 可以看看 MaterialPropertyDrawer. cs 这个文件，或者继承 MaterialPropertyDrawer 后自己写一个。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030734.jpg" alt="Pasted image 20230622155106"></p>
<figure class="highlight cs"><figcaption><span>title:CustomEnum</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CustomEnum</span><br><span class="line">&#123;</span><br><span class="line">    Enum1 = <span class="number">0</span>,</span><br><span class="line">    Enum2 = <span class="number">1</span>,</span><br><span class="line">    Enum3 = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Mya/EnumTest&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [<span class="meta">Header(Custom)</span>]</span><br><span class="line">        [<span class="meta">Enum(CustomEnum)</span>]  _CustomEnum (<span class="string">&quot;CustomEnum&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        [<span class="meta">Header(Option)</span>]</span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.BlendOp)</span>]  _BlendOp  (<span class="string">&quot;BlendOp&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.BlendMode)</span>] _SrcBlend (<span class="string">&quot;SrcBlend&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.BlendMode)</span>] _DstBlend (<span class="string">&quot;DstBlend&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [<span class="meta">Enum(Off, 0, On, 1)</span>]_ZWriteMode (<span class="string">&quot;ZWriteMode&quot;</span>, <span class="built_in">float</span>) = <span class="number">1</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.CullMode)</span>]_CullMode (<span class="string">&quot;CullMode&quot;</span>, <span class="built_in">float</span>) = <span class="number">2</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.CompareFunction)</span>]_ZTestMode (<span class="string">&quot;ZTestMode&quot;</span>, Float) = <span class="number">4</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.ColorWriteMask)</span>]_ColorMask (<span class="string">&quot;ColorMask&quot;</span>, Float) = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">        [<span class="meta">Header(Stencil)</span>]</span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.CompareFunction)</span>]_StencilComp (<span class="string">&quot;Stencil Comparison&quot;</span>, Float) = <span class="number">8</span></span><br><span class="line">        [<span class="meta">IntRange</span>]_StencilWriteMask (<span class="string">&quot;Stencil Write Mask&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">255</span></span><br><span class="line">        [<span class="meta">IntRange</span>]_StencilReadMask (<span class="string">&quot;Stencil Read Mask&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">255</span></span><br><span class="line">        [<span class="meta">IntRange</span>]_Stencil (<span class="string">&quot;Stencil ID&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">0</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.StencilOp)</span>]_StencilPass (<span class="string">&quot;Stencil Pass&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.StencilOp)</span>]_StencilFail (<span class="string">&quot;Stencil Fail&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [<span class="meta">Enum(UnityEngine.Rendering.StencilOp)</span>]_StencilZFail (<span class="string">&quot;Stencil ZFail&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            BlendOp [_BlendOp]</span><br><span class="line">            Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">            ZWrite [_ZWriteMode]</span><br><span class="line">            ZTest [_ZTestMode]</span><br><span class="line">            Cull [_CullMode]</span><br><span class="line">            ColorMask [_ColorMask]</span><br><span class="line"></span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                Ref [_Stencil]</span><br><span class="line">                Comp [_StencilComp]</span><br><span class="line">                ReadMask [_StencilReadMask]</span><br><span class="line">                WriteMask [_StencilWriteMask]</span><br><span class="line">                Pass [_StencilPass]</span><br><span class="line">                Fail [_StencilFail]</span><br><span class="line">                ZFail [_StencilZFail]</span><br><span class="line">            &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG. cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos (v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XXX</span> : <span class="title">ShaderGUI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// OnGuI 接收的两个参数 ：</span></span><br><span class="line">    MaterialEditor materialEditor;<span class="comment">//当前材质面板</span></span><br><span class="line">    MaterialProperty[] materialProperty;<span class="comment">//当前shader的properties</span></span><br><span class="line">    Material targetMat;<span class="comment">//绘制对象材质球</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 折叠栏</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> m_GUITest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要实现逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params">MaterialEditor materialEditor, MaterialProperty[] properties</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.materialEditor = materialEditor; <span class="comment">// 当前编辑器</span></span><br><span class="line">        <span class="keyword">this</span>.materialProperty = properties;   <span class="comment">// 用到的变量</span></span><br><span class="line">        <span class="keyword">this</span>.targetMat = materialEditor.target <span class="keyword">as</span> Material; <span class="comment">// 当前材质球</span></span><br><span class="line"></span><br><span class="line">        show(); <span class="comment">// 使用下面这个 show函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Shader属性</span></span><br><span class="line">        <span class="comment">// Shader里面的属性，FindProperty 就是从shader里找这个属性</span></span><br><span class="line">        MaterialProperty _MainTex = FindProperty(<span class="string">&quot;_MainTex&quot;</span>, materialProperty);</span><br><span class="line">        MaterialProperty _MainColor = FindProperty(<span class="string">&quot;_MainColor&quot;</span>, materialProperty);</span><br><span class="line">        MaterialProperty _Range = FindProperty(<span class="string">&quot;_Range&quot;</span>, materialProperty);</span><br><span class="line">        MaterialProperty _Float = FindProperty(<span class="string">&quot;_Float&quot;</span>, materialProperty);</span><br><span class="line">        MaterialProperty _Red = FindProperty(<span class="string">&quot;_Red&quot;</span>, materialProperty);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> GUI名称</span></span><br><span class="line">        <span class="comment">// GUI名称</span></span><br><span class="line">        GUIContent mainTex = <span class="keyword">new</span> GUIContent(<span class="string">&quot;主贴图&quot;</span>);</span><br><span class="line">        GUIContent mainColor = <span class="keyword">new</span> GUIContent(<span class="string">&quot;主贴图染色&quot;</span>);</span><br><span class="line">        GUIContent range = <span class="keyword">new</span> GUIContent (<span class="string">&quot;测试用 Range&quot;</span>);</span><br><span class="line">        GUIContent float1 = <span class="keyword">new</span> GUIContent(<span class="string">&quot;测试用Float&quot;</span>);</span><br><span class="line">        GUIContent red = <span class="keyword">new</span> GUIContent(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> GUI折叠</span></span><br><span class="line">        <span class="comment">// 供折叠使用</span></span><br><span class="line">        m_GUITest = EditorGUILayout.BeginFoldoutHeaderGroup(m_GUITest, <span class="string">&quot;GUI折叠&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_GUITest)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 显示图片用</span></span><br><span class="line">            materialEditor.TexturePropertySingleLine(mainTex, _MainTex, _MainColor);</span><br><span class="line">                EditorGUI.indentLevel++;</span><br><span class="line">                materialEditor.ShaderProperty(_Range, range);</span><br><span class="line">                materialEditor.ShaderProperty(_Float, float1);</span><br><span class="line">                EditorGUI.indentLevel--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开关</span></span><br><span class="line">        EditorGUI.BeginChangeCheck ();</span><br><span class="line">        EditorGUI.showMixedValue = _Red.hasMixedValue;</span><br><span class="line">        <span class="keyword">var</span> _RED_ON = EditorGUILayout.Toggle(red, _Red.floatValue == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (EditorGUI.EndChangeCheck())</span><br><span class="line">            _Red.floatValue = _RED_ON ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        EditorGUI.showMixedValue = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 打开开关之后的效果</span></span><br><span class="line">        <span class="keyword">if</span> (_Red.floatValue == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            targetMat.EnableKeyword(<span class="string">&quot;_RED_ON&quot;</span>);</span><br><span class="line">                EditorGUI.indentLevel++;</span><br><span class="line">                GUILayout.Label(<span class="string">&quot;已启用变体 _RED_ON&quot;</span>);</span><br><span class="line">                EditorGUI.indentLevel--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            targetMat.DisableKeyword(<span class="string">&quot;_RED_ON&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        EditorGUILayout.Space(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// Render Queue</span></span><br><span class="line">        materialEditor.RenderQueueField(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、CustomEditor-GUI"><a href="#二、CustomEditor-GUI" class="headerlink" title="二、CustomEditor GUI"></a>二、CustomEditor GUI</h2><p>待补充…</p>
<p>我们使用 <code>CustomEditor</code> 来扩展材质面板，声明在 Shader 最下方。</p>
<blockquote>
<p><code>CustomEditor</code>：可为着色器定义一个 CustomEditor。如果执行了此操作，Unity 将查找具有此名称并能扩展 ShaderGUI 的类。如果找到，则使用此着色器的所有材质都将使用此 ShaderGUI</p>
</blockquote>
<p>我们要在 <code>Editor</code> 文件夹创建一个指定的 <code>CustomShaderGUI.cs</code> 脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomEditor <span class="string">&quot;CustomShaderGUI.cs&quot;</span></span><br></pre></td></tr></table></figure>

<p>该类<strong>继承 <code>ShaderGUI</code> 并重载 <code>OnGUI</code> 方法来扩展材质编辑器</strong>。</p>
<p>ShaderGUI 通过 shader 中的 CustonEditor 关联 UI 脚本，Unity 会调用 OnGUI 来绘制面板， <strong>UI 脚本必须放入 Editor 文件夹中.</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestGUI</span> : <span class="title">ShaderGUI</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//OnGUI接收两个参数：</span></span><br><span class="line">    MaterialEditor materialEditor;<span class="comment">//当前材质面板</span></span><br><span class="line">    MaterialProperty[] properties;<span class="comment">//当前shader的properties</span></span><br><span class="line"></span><br><span class="line">    Material targetMat;<span class="comment">//绘制对象材质球</span></span><br><span class="line">    <span class="built_in">string</span>[] keyWords;<span class="comment">//当前shader keywords</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Public <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params">MaterialEditor materialEditor, MaterialProperty[] properties</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.MaterialEditor = materialEditor;</span><br><span class="line">        <span class="keyword">this</span>.MaterialProperty = properties;</span><br><span class="line">        <span class="keyword">this</span>.targetMat = materialEditor.target <span class="keyword">as</span> Material;</span><br><span class="line">        <span class="keyword">this</span>.keyWords = targetMat.shaderKeywords;</span><br><span class="line">        <span class="comment">//关键字是否存在可以判断分支的开启状态</span></span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span>()</span>&#123;</span><br><span class="line">        GUILayout.Label(“Hello Word”);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030735.png" alt="7c9deaa843b7d9b2b2c3270779012a2c_MD5"></p>
<p><em>我们开启自定义 UI 显示以后，默认 UI 将会失效。</em>  </p>
<h3 id="贴图单行显示"><a href="#贴图单行显示" class="headerlink" title="贴图单行显示"></a>贴图单行显示</h3><p><code>FindProperty</code> 会根据属性名称 ID 去查找 material Properties 中包含的相应属性，Content 是一个显示 Lable, 它包含了属性名称，属性数值和属性 Tips。最后用 materialEditor 绘制单行贴图 UI</p>
<p><strong>参数一</strong>：propertyname 材质属性的名称<br><strong>参数二</strong>：properties 可用材质属性的数组<br><strong>参数三</strong>：propertylsmandatory 如果为 true，则如果没有找到 propertyName 属性，此方法将抛出异常。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示贴图</span></span><br><span class="line">MaterialProperty _CubeMap= FindProperty(“_CubeMap”, materialProperties, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">GUIContent content = <span class="keyword">new</span> GUIContent(_CubeMap.displayName, _CubeMap.textureValue, “cube Map”);<span class="comment">//tips 是说明文字，鼠标悬停属性名称时显示</span></span><br><span class="line">materialEditor.TexturePropertySingleLine(content, _CubeMap);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030736.png" alt="2936ec0ef4505833aa6d51546d970848_MD5"></p>
<p>添加调色给这张图, 在原有属性下方查找到颜色，GUI 容器还是使用 cubemap 的, 这时 color 就会出现在 cubemap 之后单行显示。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MaterialProperty tint = FindProperty (“_Color”, materialProperties, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//modification</span></span><br><span class="line">materialEditor.TexturePropertySingleLine(content, _CubeMap, tint);<span class="comment">//重载方法</span></span><br><span class="line"><span class="comment">//添加缩放偏移属性显示</span></span><br><span class="line"><span class="comment">//EditorGUI.indentLevel是将绘制的元素进行头部位置偏移</span></span><br><span class="line">EditorGUI.indentLevel++;</span><br><span class="line"><span class="comment">//添加贴图缩放</span></span><br><span class="line">materialEditor.TextureScaleOffsetProperty(_CubeMap);</span><br><span class="line">EditorGUI.indentLevel--;</span><br><span class="line"><span class="comment">//偏移后须将头部位置归位，即便在属性列表末端也需要。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030737.png" alt="38d98d0bcb87e266ed15ad6b913f20a0_MD5"></p>
<h3 id="法线单行显示，无贴图隐藏滑竿"><a href="#法线单行显示，无贴图隐藏滑竿" class="headerlink" title="法线单行显示，无贴图隐藏滑竿"></a>法线单行显示，无贴图隐藏滑竿</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MaterialProperty _Normal = FindProperty(“Normal”, materialProperties,<span class="literal">true</span>);</span><br><span class="line">MaterialProperty _NormalStrength= <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//如果有贴图让容器包括强度绘制，没贴图不绘制强度</span></span><br><span class="line">If(_Normal.textureValue != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_NormalStrength = FindProperty(“_NormalStrength”, materialproperties, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">materialEditor.TexturePropertySingleLine(MakeGUIContent(_Normal), _Normal, _NormalStrength );</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义绘制 content 方法</span></span><br><span class="line"><span class="function">GUIContent <span class="title">MakeGUICOntent</span>(<span class="params">MaterialProperty m</span>)</span>&#123;</span><br><span class="line">	GUIContent content = <span class="keyword">new</span> GUIContent(m.displayName, m.textureValue, “”);</span><br><span class="line">Return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030738.png" alt="c15abbbdf66858de8afe9ab275868012_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030739.png" alt="fa217d21b9cc784271e34dacd5b3197e_MD5"></p>
<h3 id="贴图特殊设置提示"><a href="#贴图特殊设置提示" class="headerlink" title="贴图特殊设置提示"></a>贴图特殊设置提示</h3><p>在默认 attribute 中我们使用法线贴图时会提示我们当前传入图片是否是法线，我们可以借鉴这一功能定义我们自己需要设置的内容作为提示显示出来。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MaterialProperty _Tex2 = FindProperty(<span class="string">&quot;_Tex2&quot;</span>, properties);</span><br><span class="line">materialEditor.TextureProperty(_Tex2, <span class="string">&quot;Tex 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_Tex2 != <span class="literal">null</span> &amp;&amp; _Tex2.textureValue.wrapMode != TextureWrapMode.Clamp)</span><br><span class="line">&#123;</span><br><span class="line">	setClamp = materialEditor.HelpBoxWithButton(<span class="keyword">new</span> GUIContent(<span class="string">&quot;贴图需要clamp模式&quot;</span>), <span class="keyword">new</span> GUIContent(<span class="string">&quot;设置&quot;</span>)); <span class="comment">//setClamp : bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030740.gif" alt="222151b3539e6faf843b96590fd115a5_MD5"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们修改状态以后可以对离线资源进行同步设置</span></span><br><span class="line"><span class="keyword">if</span>(setClamp)&#123;</span><br><span class="line">    setClamp = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> path = AssetDatabase.GetAssetPath(_Tex2.textureValue);</span><br><span class="line">    TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="keyword">as</span> TextureImporter;</span><br><span class="line">    textureImporter.warpMode = TexturWrapMode.Clamp;</span><br><span class="line">    textureImporter.SaveAndReimport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030741.gif" alt="4365c9eb40c7e9564164559c72ebf64b_MD5"></p>
<h3 id="UI-界面变更检查"><a href="#UI-界面变更检查" class="headerlink" title="UI 界面变更检查"></a>UI 界面变更检查</h3><p>现在是在 OnGUI 中每帧重复执行所有方法 (并不是每帧重绘制)，我们应当是 material 属性改变以后在执行内部方法赋值 shader。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetKeyWord</span>(<span class="params"><span class="built_in">string</span> keyword, <span class="built_in">bool</span> enable</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(enable)&#123;</span><br><span class="line">            targetMat.EnableKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            targetMat.DisableKeyword(keyword);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">EditorGUI.BeginChangeCheck();<span class="comment">//需要检查的位置之前放置</span></span><br><span class="line">materialEditor.TexturePropertySingleLine(MakeGUIContent(_Metallic), _Metallic, _Metal);</span><br><span class="line">If(EditorGUI.EndChangeCheck())<span class="comment">//有修改返回ture</span></span><br><span class="line">&#123;</span><br><span class="line">	SetKeyWord(_Metallic.name.ToUpper() + <span class="string">&quot;_ON&quot;</span>, _Metallic.textureValue != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030742.png" alt="2318ba91681f552da97bc6736e230faf_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030743.png" alt="8b085b56ec15cbeeea62fe93ae15f434_MD5"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以根据 debug 来查看 keyword 是否成功</span></span><br><span class="line">targetMat.IsKeywordEnabled(<span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>

<h3 id="根据条件隐藏显示所属-UI-控件"><a href="#根据条件隐藏显示所属-UI-控件" class="headerlink" title="根据条件隐藏显示所属 UI 控件"></a>根据条件隐藏显示所属 UI 控件</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置列表显示关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> LAYER_COUNT</span><br><span class="line">&#123;</span><br><span class="line">    _LAYERCOUNT_ONE, _LAYERCOUNT_TWO, _LAYERCOUNT_THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LAYER_COUNT LC;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKeyWorld</span>(<span class="params">LAYER_COUNT settings</span>)</span> &#123;</span><br><span class="line">           <span class="keyword">switch</span> (settings)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> LAYER_COUNT._LAYERCOUNT_ONE:</span><br><span class="line">                targetMat.DisableKeyword(LAYER_COUNT._LAYERCOUNT_THREE.ToString());</span><br><span class="line">                targetMat.DisableKeyword(LAYER_COUNT._LAYERCOUNT_TWO.ToString());</span><br><span class="line">                targetMat.EnableKeyword(LAYER_COUNT._LAYERCOUNT_ONE.ToString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LAYER_COUNT._LAYERCOUNT_TWO:</span><br><span class="line">                targetMat.DisableKeyword (LAYER_COUNT._LAYERCOUNT_ONE.ToString ());</span><br><span class="line">                targetMat.DisableKeyword(LAYER_COUNT._LAYERCOUNT_THREE.ToString());</span><br><span class="line">                targetMat.EnableKeyword(LAYER_COUNT._LAYERCOUNT_TWO.ToString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LAYER_COUNT._LAYERCOUNT_THREE:</span><br><span class="line">                targetMat.DisableKeyword(LAYER_COUNT._LAYERCOUNT_ONE.ToString());</span><br><span class="line">                targetMat.DisableKeyword(LAYER_COUNT._LAYERCOUNT_TWO.ToString());</span><br><span class="line">                targetMat.EnableKeyword(LAYER_COUNT._LAYERCOUNT_THREE.ToString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们将 enum 控件绘制在最顶端，根据修改去赋值 shader</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EditorGUI.BeginChangeCheck();</span><br><span class="line">LC = (LAYER_COUNT)EditorGUILayout.EnumPopup(<span class="string">&quot;LayerCount&quot;</span>, LC);</span><br><span class="line"><span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123; </span><br><span class="line">        SetKeyWorld(LC);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030744.png" alt="3173a3dd4a1e65e8ddc95c18a3952730_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030745.png" alt="36a37e9485c5e538c2970bf3d6e26e39_MD5"></p>
<p>因为我们设置了分支关键字，shader 内会根据关键字走相应流程。我们可以将不被使用的流程属性隐藏。</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030746.gif" alt="be95405ef6aeca6b9db35edddcf0c5a7_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030747.gif" alt="4a7d3a24518cf0e8840b72e5960bc410_MD5"></p>
<h3 id="折叠组"><a href="#折叠组" class="headerlink" title="折叠组"></a>折叠组</h3><p>和上一步的实现类似区别在于使用一个带有折叠判断的控件绘制, 可以使用 FoldoutHeaderGroup 或 Foldut</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isFoldut = EditorGUILayout.BeginFoldoutHeaderGroup(isFoldut, <span class="string">&quot;Group 01&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (isFoldut)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">EditorGUILayout.EndFoldoutHeaderGroup();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030748.gif" alt="7449c1a5fcb835adaf7c7845c5dfcb27_MD5"></p>
<h3 id="可调节-min-max-的滑动条"><a href="#可调节-min-max-的滑动条" class="headerlink" title="可调节 min max 的滑动条"></a>可调节 min max 的滑动条</h3><p>节省控件位置或者更直观的表达时使用，中间以 0 为例，左区间是 [minLimit, 0] 右[0, maxLimit]</p>
<p>左右区间是可以被动态修改的</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditorGUILayout.MinMaxSlider(<span class="keyword">ref</span> minVal, <span class="keyword">ref</span> maxVal, minLimit, maxLimit);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030749.gif" alt="377de902a4d3ad548a715b0159317bd0_MD5"></p>
<h3 id="控件容器-Rect"><a href="#控件容器-Rect" class="headerlink" title="控件容器 Rect"></a>控件容器 Rect</h3><p>在界面中每一个控件都可以定制长宽。x，y 0 点在左上角</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030751.png" alt="f9b6c3c6b01d719e3f4e0372c2fd727d_MD5"></p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030752.png" alt="328032c1a6abcc378000b8efa977042b_MD5"></p>
<p>如果我们手动设置 rect，那样以后排板将会很痛苦。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取上一个Rect</span></span><br><span class="line"><span class="comment">//Rect eST = GUILayoutUtility.GetLastRect();</span></span><br><span class="line">Rect e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Event. current. type == EventType. Repaint)&#123;</span><br><span class="line">    e = GUILayoutUtility.GetLastRect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断执行事件是为了避免获取失效。</p>
<p>我们用一个 silder 来控制一个 box 的长短，使其 100% 时填充满 inspector 宽。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slider =  EditorGUILayout.Slider(slider, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">GUI.backgroundColor =  Color.green;</span><br><span class="line">GUILayout.Box(<span class="keyword">new</span> GUIContent(), GUILayout.Width(slider*e.width));</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190030753.gif" alt="e8eb2a7285e194b61e01ab9116042ab4_MD5"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/64623.html">http://liuke101.github.io/post/64623.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/64863.html" title="全局光照GI"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404300005318.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全局光照GI</div></div></a></div><div class="next-post pull-right"><a href="/post/52454.html" title="Latex语法"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281221182.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Latex语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/21879.html" title="Unity Primer"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-22</div><div class="title">Unity Primer</div></div></a></div><div><a href="/post/62114.html" title="Unity数据持久化"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190020794.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Unity数据持久化</div></div></a></div><div><a href="/post/1888.html" title="Unity编辑器扩展"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">Unity编辑器扩展</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 如图片加载缓慢请使用VPN。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 3. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E5%AE%AB%E6%A0%BC-UI-%E7%90%86%E8%AE%BA"><span class="toc-text">九宫格 UI 理论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GUI"><span class="toc-text">GUI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">1 原理及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-text">2 重要参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Label-%E6%A0%87%E7%AD%BE"><span class="toc-text">3 Label 标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Button-%E6%8C%89%E9%92%AE"><span class="toc-text">4 Button 按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Toggle-%E5%BC%80%E5%85%B3"><span class="toc-text">5 Toggle 开关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1"><span class="toc-text">6 输入框和拖动条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E5%92%8C-Box-%E6%A1%86"><span class="toc-text">7 图片绘制和 Box 框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E9%80%89%E6%8B%A9%E7%BD%91%E6%A0%BC"><span class="toc-text">8 工具栏和选择网格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%92%8C%E5%88%86%E7%BB%84"><span class="toc-text">9 滚动视图和分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%AA%97%E5%8F%A3"><span class="toc-text">10 窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%A2%9C%E8%89%B2%E5%92%8C%E7%9A%AE%E8%82%A4"><span class="toc-text">11 颜色和皮肤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%B8%83%E5%B1%80-GUILayout"><span class="toc-text">12 布局 GUILayout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%87%AA%E9%80%82%E5%BA%94"><span class="toc-text">13 自适应</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UGUI"><span class="toc-text">UGUI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%AD%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">1 六大基础组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rect-Transform"><span class="toc-text">Rect Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas"><span class="toc-text">Canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RenderMode-%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F"><span class="toc-text">RenderMode 渲染模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Screen-Space-Overlay"><span class="toc-text">Screen Space - Overlay</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Screen-Space-Camera"><span class="toc-text">Screen Space - Camera</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Screen-Space-Camera-1"><span class="toc-text">Screen Space - Camera</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-Scaler"><span class="toc-text">Canvas Scaler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-text">分辨率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UI-Scale-Mode-UI-%E7%BC%A9%E6%94%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">UI Scale Mode UI 缩放模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Constant-Pixel-Size-%E6%81%92%E5%AE%9A%E5%83%8F%E7%B4%A0%E6%A8%A1%E5%BC%8F"><span class="toc-text">Constant Pixel Size 恒定像素模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Scale-With-Screen-Size-%E9%9A%8F%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E7%BC%A9%E6%94%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">Scale With Screen Size  随屏幕尺寸缩放模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Constant-Physical-Size-%E6%81%92%E5%AE%9A%E7%89%A9%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">Constant Physical Size 恒定物理模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#World-%E4%B8%96%E7%95%8C%E6%A8%A1%E5%BC%8F"><span class="toc-text">World 世界模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphic-Raycaster"><span class="toc-text">Graphic Raycaster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-System"><span class="toc-text">Event System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Standalone-Input-Module"><span class="toc-text">Standalone Input Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">代码获取组件属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6"><span class="toc-text">2 三大基础控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Image"><span class="toc-text">Image</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96-Image-%E5%B1%9E%E6%80%A7"><span class="toc-text">代码获取 Image 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text"><span class="toc-text">Text</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Text-TMP"><span class="toc-text">Text (TMP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text-Legacy"><span class="toc-text">Text (Legacy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-text">代码控制文本内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RawImage"><span class="toc-text">RawImage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-Texture"><span class="toc-text">代码控制 Texture</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E6%8E%A7%E4%BB%B6"><span class="toc-text">3 组合控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Button-%E6%8C%89%E9%92%AE"><span class="toc-text">Button 按钮</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-button-%E5%B1%9E%E6%80%A7"><span class="toc-text">代码控制 button 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-text">监听点击事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%BD%A2%E6%8C%89%E9%92%AE"><span class="toc-text">异形按钮</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">方法一：添加子对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6%E5%93%8D%E5%BA%94%E9%98%88%E5%80%BC"><span class="toc-text">方法二：通过代码改变图片的透明度响应阈值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Toggle-%E5%BC%80%E5%85%B3"><span class="toc-text">Toggle 开关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6"><span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6-1"><span class="toc-text">监听点击事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputField-%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5"><span class="toc-text">InputField  输入字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputField-TMP"><span class="toc-text">InputField (TMP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputField-Legacy"><span class="toc-text">InputField (Legacy)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Slider-%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-text">Slider 滑动条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scrollbar-%E6%BB%9A%E5%8A%A8%E6%9D%A1"><span class="toc-text">Scrollbar 滚动条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScrollView-%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE"><span class="toc-text">ScrollView 滚动视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DrawDown-%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8"><span class="toc-text">DrawDown 下拉列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DrawDown-TMP"><span class="toc-text">DrawDown (TMP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DrawDown-Legacy"><span class="toc-text">DrawDown (Legacy)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">4 自动布局组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E7%BB%84%E4%BB%B6"><span class="toc-text">水平垂直组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">网格布局组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%A4%A7%E5%B0%8F%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">内容大小适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E9%AB%98%E6%AF%94%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">宽高比适配器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9B%BE%E9%9B%86-%E9%9C%80%E8%A6%81%E8%A1%A5%E4%B8%80%E4%B8%8B-Unity-%E6%A0%B8%E5%BF%83"><span class="toc-text">5  图集 (需要补一下 Unity 核心)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sprite-Packer"><span class="toc-text">Sprite Packer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E5%8F%82%E6%95%B0"><span class="toc-text">图集参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-UI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-text">6 UI 事件接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PointerEventData"><span class="toc-text">PointerEventData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTrigger"><span class="toc-text">EventTrigger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E8%BD%AC-UI-%E5%9D%90%E6%A0%87"><span class="toc-text">7 屏幕坐标转 UI 坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Mask-%E9%81%AE%E7%BD%A9"><span class="toc-text">9 Mask 遮罩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%B2%92%E5%AD%90%E6%98%BE%E7%A4%BA%E5%9C%A8-UI-%E4%B9%8B%E5%89%8D"><span class="toc-text">10 模型和粒子显示在 UI 之前</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%94%A8%E6%91%84%E5%83%8F%E6%9C%BA%E6%B8%B2%E6%9F%93-3D-%E7%89%A9%E4%BD%93"><span class="toc-text">方法一：直接用摄像机渲染 3D 物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%B8%B2%E6%9F%93%E5%9C%A8-RT-%E4%B8%8A%EF%BC%8C%E9%80%9A%E8%BF%87-RawImage-%E6%98%BE%E7%A4%BA"><span class="toc-text">方法二：渲染在 RT 上，通过 RawImage 显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F-Order-in-Layer"><span class="toc-text">方法三：粒子系统 Order in Layer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-CanvasGroup"><span class="toc-text">11 CanvasGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-text">12 常用插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AE%9E%E6%88%98"><span class="toc-text">13 实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ShaderGUI"><span class="toc-text">ShaderGUI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Drawer"><span class="toc-text">一、Drawer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7"><span class="toc-text">常用的属性特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-DrawerClass"><span class="toc-text">不同类型的 DrawerClass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Toggle-%E5%92%8C-ToggleOff"><span class="toc-text">Toggle 和 ToggleOff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enum"><span class="toc-text">Enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeywordEnum"><span class="toc-text">KeywordEnum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-text">在编译指令中定义关键词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%9E%9A%E4%B8%BE-UI-%E6%B1%87%E6%80%BB"><span class="toc-text">内置枚举 UI 汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81CustomEditor-GUI"><span class="toc-text">二、CustomEditor GUI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B4%E5%9B%BE%E5%8D%95%E8%A1%8C%E6%98%BE%E7%A4%BA"><span class="toc-text">贴图单行显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E5%8D%95%E8%A1%8C%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%97%A0%E8%B4%B4%E5%9B%BE%E9%9A%90%E8%97%8F%E6%BB%91%E7%AB%BF"><span class="toc-text">法线单行显示，无贴图隐藏滑竿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B4%E5%9B%BE%E7%89%B9%E6%AE%8A%E8%AE%BE%E7%BD%AE%E6%8F%90%E7%A4%BA"><span class="toc-text">贴图特殊设置提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-%E7%95%8C%E9%9D%A2%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5"><span class="toc-text">UI 界面变更检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E6%89%80%E5%B1%9E-UI-%E6%8E%A7%E4%BB%B6"><span class="toc-text">根据条件隐藏显示所属 UI 控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E7%BB%84"><span class="toc-text">折叠组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E8%8A%82-min-max-%E7%9A%84%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-text">可调节 min max 的滑动条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E5%AE%B9%E5%99%A8-Rect"><span class="toc-text">控件容器 Rect</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46645.html" title="GAS精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250017189.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAS精粹"/></a><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/24808.html" title="蓝图精粹"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408070002240.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝图精粹"/></a><div class="content"><a class="title" href="/post/24808.html" title="蓝图精粹">蓝图精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202405190021833.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>