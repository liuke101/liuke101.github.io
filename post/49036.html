<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LeetCode笔记 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、数组01 二分查找 (折半查找)性能优异，仅适用于有序的顺序表 二分查找：每次将中间位置的数与 key 比较，若相等则查找成功，不等则选择前半部分或后半部分继续查找。由于顺序表是有序的，所以中间位置与前面和后面元素的关系也是确定（例如，在升序表中，前面元素&lt;中间位置&lt;后面元素。若给定值 key 大于中间元素，则查找的元素只能在后半部分） 时间复杂度：$O (log_n)$ 二分查找">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode笔记">
<meta property="og:url" content="http://liuke101.github.io/post/49036.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="一、数组01 二分查找 (折半查找)性能优异，仅适用于有序的顺序表 二分查找：每次将中间位置的数与 key 比较，若相等则查找成功，不等则选择前半部分或后半部分继续查找。由于顺序表是有序的，所以中间位置与前面和后面元素的关系也是确定（例如，在升序表中，前面元素&lt;中间位置&lt;后面元素。若给定值 key 大于中间元素，则查找的元素只能在后半部分） 时间复杂度：$O (log_n)$ 二分查找">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-08-24T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-06T15:44:36.055Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/49036.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 23:44:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-24T16:00:00.000Z" title="发表于 2023-08-25 00:00:00">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T15:44:36.055Z" title="更新于 2024-08-06 23:44:36">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">94.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>382分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/49036.html#post-comment"><span class="waline-comment-count" data-path="/post/49036.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="01-二分查找-折半查找"><a href="#01-二分查找-折半查找" class="headerlink" title="01 二分查找 (折半查找)"></a>01 二分查找 (折半查找)</h2><p>性能优异，<strong>仅适用于有序的顺序表</strong></p>
<p><strong>二分查找</strong>：每次将中间位置的数与 key 比较，若相等则查找成功，不等则选择前半部分或后半部分继续查找。由于顺序表是有序的，所以中间位置与前面和后面元素的关系也是确定（例如，在升序表中，前面元素&lt;中间位置&lt;后面元素。若给定值 key 大于中间元素，则查找的元素只能在后半部分）</p>
<p>时间复杂度：$O (log_n)$</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（LeetCode）</a></p>
<p>给定一个 $n$ 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 $target$，如果目标值存在返回下标，否则返回 $-1$。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>你可以假设 nums 中的所有元素是不重复的。</li>
<li>n 将在 [1, 10000]之间。</li>
<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>二分法使用条件：</strong></p>
<ul>
<li><strong>有序数组</strong></li>
<li><strong>数组中无重复元素</strong>。因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的</li>
</ul>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即$[left, right]$，或者左闭右开即$[left, right)$。</p>
<p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p>
<h4 id="左闭右闭写法（用这种）"><a href="#左闭右闭写法（用这种）" class="headerlink" title="左闭右闭写法（用这种）"></a>左闭右闭写法（用这种）</h4><p>第一种写法，我们定义 <code>target</code> 是在一个在左闭右闭的区间里，<strong>也就是<code>[left, right] </code>（这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在<code>[left, right]</code>区间，所以有如下两点：</strong></p>
<ul>
<li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为<code>left == right</code>是有意义的，所以使用 <code>&lt;=</code></li>
<li><code>if (nums[middle] &gt; target) &#123;right = middle - 1&#125;</code>，因为当前这个 <code>nums[middle]</code> 一定不是 <code>target</code>，那么接下来要查找的左区间结束下标位置就是 <code>middle - 1</code></li>
</ul>
<p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200203.png" alt="54650641ee166bcbaff901651e3ef7ba_MD5"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//记录范围左边界</span></span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//记录范围右边界</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) </span><br><span class="line">        &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//计算 mid 时需要防止溢出，和(left + right)/2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, mid - 1]</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) </span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[mid + 1, right]</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; <span class="comment">// nums[mid] == target</span></span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：$O(log n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<p><strong>时间复杂度分析：</strong><br>对于 n 个元素，二分查找每次排除掉一半的值</p>
<ul>
<li>一次二分剩下 $n&#x2F;2$</li>
<li>二次二分剩下 $n&#x2F;2^2$</li>
<li>m 次二分剩下 $n&#x2F;2^m$</li>
<li>在最坏的情况下排除到只剩下最后一个值在之后得到结果，即 $n&#x2F;2^{m}&#x3D;1$<br>得 $m &#x3D; log_2(n)$</li>
</ul>
<h3 id="值存在返回位置，不存在返回-1"><a href="#值存在返回位置，不存在返回-1" class="headerlink" title="值存在返回位置，不存在返回-1"></a>值存在返回位置，不存在返回-1</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值存在返回位置，不存在返回插入位置"><a href="#值存在返回位置，不存在返回插入位置" class="headerlink" title="值存在返回位置，不存在返回插入位置"></a>值存在返回位置，不存在返回插入位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/description/">35. 搜索插入位置 - 力扣（LeetCode）</a></p>
<p>如果目标数组中没有要查的 target，那么二分到最后 left 位置一定在 right 右边，即 <code>left = right+1</code>。<br><strong>此时 <code>right&lt;target, left&gt;target</code></strong><br><strong>如果值不存在将会插入 left 位置，并将原来的元素后移。</strong></p>
<p>![[assets&#x2F;Diagram 1.svg]]</p>
<ol>
<li>找到 target，返回 mid</li>
<li>没有 target，返回 left（二分到最后 left 位置一定在 right 右边，即 <code>left = right+1</code> ）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] = target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查左右边界"><a href="#查左右边界" class="headerlink" title="查左右边界"></a>查左右边界</h3><h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p>
<p>方法一：找到目标后再继续往左往右二分，看是否有左右边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两次二分查找，分开查找第一个和最后一个</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(log n), 空间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心思路是：找到目标后再继续往左往右二分，看是否有左右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找第一个等于Target的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//重点，找到后继续在左边二分，如果有目标值就更新first，直到找到最左边的（第一个等于）Target位置。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个等于target的位置 </span></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                last  = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//重点，找到后继续往右边二分，如果有目标值就更新last ，直到找到最右边的（最后一个等于）Target位置。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;first, last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：查找<code>target+0.5</code> 和 <code>target-0.5</code><br>使用二分查找，找到 <code>target+0.5</code> 和 <code>target-0.5</code> 应该出现的位置，取左left 右right 即可得到元素的第一个和最后一个位置。</p>
<p>查找元素 2：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200204.png" alt="Pasted image 20240219161135"></p>
<blockquote>
<p>注意二分如果没有找到 target，最后 right 在 left 左边。我们求得区间是查找 1.5 的 left 和查找 2.5 的 right。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//实现二分算法，这里我们只返回left。如果求right只需要left+1</span></span><br><span class="line">    <span class="comment">//注意，target参数类型为float</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">float</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left =mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="built_in">search</span>(nums, target<span class="number">-0.5</span>); <span class="comment">//求target-0.5对应的left</span></span><br><span class="line">        <span class="type">int</span> high = <span class="built_in">search</span>(nums, target+<span class="number">0.5</span>)<span class="number">-1</span>; <span class="comment">//求target+0.5对应的right</span></span><br><span class="line">        <span class="keyword">return</span> &#123;low, high&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法三：STL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stl解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lower = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target); <span class="comment">//第一个小于等于</span></span><br><span class="line">        <span class="keyword">auto</span> upper = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target); <span class="comment">//第一个大于</span></span><br><span class="line">        <span class="comment">//如果lower指向的等于target</span></span><br><span class="line">        <span class="keyword">if</span>(lower!=nums.<span class="built_in">end</span>() &amp;&amp; *lower == target) <span class="comment">//是否存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = lower -nums.<span class="built_in">begin</span>();   </span><br><span class="line">            <span class="type">int</span> right = upper - nums.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">return</span> &#123;left, right<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="【剑】数字在升序数组中出现的次数"><a href="#【剑】数字在升序数组中出现的次数" class="headerlink" title="【剑】数字在升序数组中出现的次数"></a>【剑】数字在升序数组中出现的次数</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=23274&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数字在升序数组中出现的次数_牛客题霸_牛客网 (nowcoder.com)</a>：本题数组存在重复数字，我们只需要求得重复数字的左右边界，就可以算出出现次数。另外要求时间复杂度 $O(logn)$, 因此使用二分</p>
<p>查找到左边界 <code>left</code> 和右边界 <code>right</code>，返回 <code>right-left+1</code> 即数字的出现次数。 </p>
<h3 id="查平方数"><a href="#查平方数" class="headerlink" title="查平方数"></a>查平方数</h3><h4 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/description/">367. 有效的完全平方数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找符合 k*k = num 的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;num)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/description/">69. x 的平方根 - 力扣（LeetCode）</a></p>
<p>给定一个非负整数，求它的开方，向下取整。8 的开方结果是 2.82842…，向下取整即是 2。</p>
<p>思路一：平方根的整数部分 ans 是满足 <code>k*k&lt;=x</code> 的最大 k 值，因此可以对 k 进行二分查找得到答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = x, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid &lt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = mid; <span class="comment">//第一次找到符合条件的mid，就记录下来</span></span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//继续往右边找，找到最右边的（最大的）符合条件的mid，更新ans</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>思路二：<br>二分到最后 left 位置一定在 right 右边，即 <code>left = right+1</code>。<br>此时 <code>right&lt;target, left&gt;target</code></p>
<p>![[assets&#x2F;Diagram 1.svg]]</p>
<p><strong>本题如果没有找到复合 <code>mid*mid=x</code> 得整数，说明 x 得算数平方根是小数。有题目可知小数部分被舍去，即向下取整。所以 mid 取 right 位置。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>定理一：只有在顺序区间内才可以通过区间两端的数值判断 target 是否在其中。<br>定理二：判断顺序区间还是乱序区间，只需要对比 left 和 right 是否是顺序对即可，<code>left &lt;= right</code> 则为顺序区间，否则乱序区间。<br>定理三：每次二分都会至少存在一个顺序区间。</p>
<h4 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h4><p><strong>通过不断的用 Mid 二分，根据定理二，将整个数组划分成顺序区间和乱序区间，然后利用定理一判断 target 是否在顺序区间，如果在顺序区间，下次循环就直接取顺序区间，如果不在，那么下次循环就取乱序区间。</strong></p>
<p>对于有重复元素的数组，处理方式见代码。</p>
<h5 id="无重复元素"><a href="#无重复元素" class="headerlink" title="无重复元素"></a>无重复元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组 - 力扣（LeetCode）</a>etcode.cn&#x2F;problems&#x2F;search-in-rotated-sorted-array&#x2F;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= nums[mid]) <span class="comment">//left-mid是顺序区间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//target是否在left-mid区间</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[right] &gt;= nums[mid]) <span class="comment">//mid-right是顺序区间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//target是否在mid-right区间</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有重复元素"><a href="#有重复元素" class="headerlink" title="有重复元素"></a>有重复元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">81. 搜索旋转排序数组 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= nums[mid]) <span class="comment">//left-mid是顺序区间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//类似 10111 这种用例，此种情况下 nums[left] == nums[mid]，分不清到底是前面有序还是后面有序，此时 ++left 即可。相当于去掉一个重复的干扰项。</span></span><br><span class="line">                <span class="comment">//其他处理方法和没有重复元素的旋转数组一致</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left] == nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//target是否在left-mid区间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[right] &gt;= nums[mid]) <span class="comment">//mid-right是顺序区间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right] == nums[mid]) </span><br><span class="line">                &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//target是否在mid-right区间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[right] &gt;= target) </span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h4><h5 id="无重复元素-1"><a href="#无重复元素-1" class="headerlink" title="无重复元素"></a>无重复元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p>
<p>题目要求个时间复杂度为 <code>O(log n)</code>，需要使用二分查找</p>
<p>一个不包含重复元素的<strong>升序数组</strong>在经过旋转之后，可以得到下面可视化的折线图：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200205.png" alt="Pasted image 20240219221332"><br>我们考虑数组中的<strong>最后一个元素 x</strong>：</p>
<ul>
<li>在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；</li>
<li>而在最小值左侧的元素，它们的值一定都严格大于 x。<br>因此，我们可以<strong>根据这一条性质，通过二分查找的方法找出最小值。</strong></li>
</ul>
<p>在二分查找的每一步中，左边界为 left，右边界为 right，区间的中点为 mid，最小值就在该区间内。我们将中轴元素 <code>nums[mid]</code> 与右边界元素 <code>nums[right]</code> 进行比较，可能会有以下的三种情况：</p>
<p><strong>第一种情况</strong>是 <code>nums[mid]&lt;nums[right]</code>。如下图所示，这说明 <code>nums[mid]</code> 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分，令<code>right=mid</code>。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200208.png" alt="Pasted image 20240219221558"><br><strong>第二种情况</strong>是 <code>nums[mid]&gt;nums[right]</code>。如下图所示，这说明 <code>nums[mid]</code> 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。令<code>low=mid+1</code><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200209.png" alt="Pasted image 20240219221637"></p>
<p>由于数组不包含重复元素，且<strong>遍历条件为 <code>left==right</code> 时循环结束</strong>，mid 就不会与 right 重合；所以<strong>不会存在 <code>nums[mid]==nums[right]</code> 的情况。</strong></p>
<p>当二分查找结束时，我们就得到了最小值所在的位置 <code>nums[left]</code>。</p>
<p><strong>数组无重复元素：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当left==right时循环结束</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid; <span class="comment">//nums[mid]也可能是极小值，所以不能令right = mid -1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="【剑】有重复元素"><a href="#【剑】有重复元素" class="headerlink" title="【剑】有重复元素"></a>【剑】有重复元素</h5><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=23269&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">旋转数组的最小数字_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/">154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode）</a></p>
<p>与 [[#无重复元素]] 相比多了第三种情况：<br><strong>第三种情况</strong>是 <code>nums[mid]==nums[right]</code>。如下图所示，由于重复元素的存在，我们并不能确定 <code>nums[mid]</code> 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 <code>nums[right]</code> 是不是最小值，都有一个它的「替代品」 <code>nums[mid]</code>，因此我们可以忽略二分查找区间的右端点，令 right 左移。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200210.png" alt="Pasted image 20240219223700"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当left==right时循环结束</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid; <span class="comment">//nums[mid]也可能是极小值，所以不能令right = mid -1</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相等时说明重复，right左移去重</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="02-双指针法"><a href="#02-双指针法" class="headerlink" title="02 双指针法"></a>02 双指针法</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p>
<p>若<strong>两个指针指向同一数组</strong>，<strong>遍历方向相同且不会相交</strong>，则也称为<strong>滑动窗口</strong>（两个指针包围的区域即为当前的窗口），经常<strong>用于区间搜索</strong>。</p>
<p>若<strong>两个指针指向同一数组</strong>，但是<strong>遍历方向相反</strong>，则可以用来进行搜索，待搜索的数组往往是<strong>排好序</strong>的。</p>
<h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><p>相向，指针运动方向相反（正对着运动）</p>
<h4 id="两数之和-II"><a href="#两数之和-II" class="headerlink" title="两数之和 II"></a>两数之和 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></p>
<p>因为<strong>数组已经排好序</strong>，我们可以<strong>采用方向相反的双指针</strong>来寻找这两个数字，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。</p>
<ul>
<li>如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。</li>
<li>如果两个指针指向元素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。</li>
<li>如果两个指针指向元素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。</li>
</ul>
<p><strong>可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解</strong>。证明方法如下：假设最优解的两个数的位置分别是 l 和 r。我们假设在左指针在 l 左边的时候，右指针已经移动到了 r；此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达 l。同理，如果我们假设在右指针在 r 右边的时候，左指针已经移动到了 l；此时两个指针指向值的和大于给定值，因此右指针会一直左移直到到达 r。所以双指针在任何时候都不可能处于 (l,r) 之间，又因为不满足条件时指针必须移动一个，所以最终一定会收敛在 l 和 r。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;; <span class="comment">//注意题目要求下标从1开始</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sum过大, right右移，使得sum减小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sum过小, left左移，使得sum增大</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200211.png" alt="15.三数之和"><br>拿这个 nums 数组来举例，首先将数组排序，然后有一层 for 循环，i 从下标0的地方开始，同时定一个下标 left 定义在 i+1的位置上，定义下标 right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得 a + b +c &#x3D;0，我们这里相当于 <code>a = nums[i]，b = nums[left]，c = nums[right]</code>。</p>
<p>接下来如何移动left 和right呢， 如果<code>nums[i] + nums[left] + nums[right] &gt; 0</code> 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 <code>nums[i] + nums[left] + nums[right] &lt; 0</code> 说明此时三数之和小了，left 就向右移动，才能让三数之和大一些，直到 left 与 right 相遇为止。<br><strong>难点在于去重的时机：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//去重a</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right) <span class="comment">//注意left不能等于right</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right <span class="number">-1</span>]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="a-的去重"><a href="#a-的去重" class="headerlink" title="a 的去重"></a>a 的去重</h5><p>说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p>
<p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p>
<p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p>
<p>有同学可能想，这不都一样吗。</p>
<p>其实不一样！</p>
<p>都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。</p>
<p>如果我们的写法是 这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; <span class="comment">// 去重操作</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p>
<p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p>
<p>所以这里是有两个重复的维度。</p>
<p>那么应该这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p>
<p>这是一个非常细节的思考过程。</p>
<h5 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="b与c的去重"></a>b与c的去重</h5><p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &gt; left) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 去重 right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">// 去重 left</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p>
<p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p>
<p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p>
<p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p>
<p>所以这种去重是可以不加的。仅仅是把去重的逻辑提前了而已。</p>
<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a><br>在三数之和的基础上再加一层 for</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || n &lt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三数之和基础上再套一层for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//剪枝处理</span></span><br><span class="line">            <span class="comment">//如果nums[k]已经大于target，而且是整数，说明后面的数也都是整数。怎么加结果都大于target，所以直接返回。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; target &amp;&amp; nums[k]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理，同理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">long</span> sum = (<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right]; <span class="comment">//转换成long，案例有些数字过大</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target) </span><br><span class="line">                    &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum == target)</span><br><span class="line">                    &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[k],nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) </span><br><span class="line">                        &#123;</span><br><span class="line">                            ++left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right <span class="number">-1</span>]) </span><br><span class="line">                        &#123;</span><br><span class="line">                            --right;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a>平方数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-square-numbers/solutions/747079/ping-fang-shu-zhi-he-by-leetcode-solutio-8ydl/">633. 平方数之和 - 力扣（LeetCode）</a></p>
<p><code>sqrt</code> 开根号，返回double 类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设 a≤b。初始时 a=0, b=sqrt(c) </span></span><br><span class="line">        <span class="comment">//下面left相当于a，right相当于b，作为相向双指针</span></span><br><span class="line">        <span class="type">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> right = <span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> sum = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span>(sum == c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种解法：在枚举 a 的同时，使用 sqrt 函数找出 b</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在枚举 a 的同时，使用 sqrt 函数找出 b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> a = <span class="number">0</span>; a*a &lt;= c; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> b = <span class="built_in">sqrt</span>(c - a*a);</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="built_in">int</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>有序数组的平方，存在负数时，两头大中间小<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绝对值两头大中间小，所以从两头往中间遍历，每次对比两边绝对值大小，挑出大的放result数组(从右往左)；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">//开一个数组存结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; <span class="comment">//原数组双指针</span></span><br><span class="line">        <span class="type">int</span> res_right = n - <span class="number">1</span>;  <span class="comment">//新数组末尾指针</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left_pow = <span class="built_in">pow</span>(nums[left],<span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right_pow = <span class="built_in">pow</span>(nums[right],<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//比较绝对值</span></span><br><span class="line">            <span class="keyword">if</span>(left_pow &gt; right_pow)</span><br><span class="line">            &#123;</span><br><span class="line">                res[res_right] = left_pow;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[res_right] = right_pow;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            --res_right; <span class="comment">//每次赋值后末尾指针前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome-ii/description/">680. 验证回文串 II - 力扣（LeetCode）</a></p>
<p><strong>回文字符串：正读和反读都一样的字符串。</strong></p>
<ul>
<li>使用双指针，left 从前往后遍历，right 从后往前遍历。</li>
<li>同时检测首尾元素，如果不相等说明不符合回文串的对称性。</li>
</ul>
<p><strong>当首尾元素不相等时：</strong></p>
<ol>
<li>题目要求最多删除一个字符，也就是说不相等的首尾元素只能删除其一，那么第一次不相等时我们就不返回 false 而是删除其中之一再次检查剩余子串。<ul>
<li>如果删除首元素, 剩余子串范围为 <code>(left+1, right)</code></li>
<li>如果删除尾元素，剩余子串范围为 <code>(left, right-1)</code></li>
</ul>
</li>
<li>分别对两种情况的剩余子串检查是否是回文子串</li>
<li>只要有一个是，就返回 true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//检测子串</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">IsValid</span>(s, left+<span class="number">1</span>, right) || <span class="built_in">IsValid</span>(s, left, right<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="【剑】构建乘积数组"><a href="#【剑】构建乘积数组" class="headerlink" title="【剑】构建乘积数组"></a>【剑】构建乘积数组</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=23445&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">构建乘积数组_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mul = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//计算left到i-1的累乘</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= i<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mul *= A[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算i+1到right的累乘</span></span><br><span class="line">            <span class="keyword">while</span>(right &gt;= i+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mul *= A[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            B.<span class="built_in">push_back</span>(mul);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a>同向双指针</h3><h4 id="匹配子串（双数组双指针）"><a href="#匹配子串（双数组双指针）" class="headerlink" title="匹配子串（双数组双指针）"></a>匹配子串（双数组双指针）</h4><p><strong>按条件找子串</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/">524. 通过删除字母匹配到字典里最长单词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//按长度从大到小排列, 相等的按字母序从小到大排列</span></span><br><span class="line">        <span class="built_in">sort</span>(dictionary.<span class="built_in">begin</span>(),dictionary.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> string&amp; str1, <span class="type">const</span> string&amp; str2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.<span class="built_in">size</span>() == str2.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> str1 &lt; str2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> str1.<span class="built_in">size</span>() &gt; str2.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到符合第一个条件的字符串</span></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(dictionary.<span class="built_in">begin</span>(), dictionary.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;s](<span class="type">const</span> string&amp; str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//双数组双指针判断s是否包含str子串</span></span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; str.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == str[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果s遍历完了，但str还没遍历完，说明没有子串，返回false</span></span><br><span class="line">            <span class="comment">//如果成功遍历完str，说明有子串，返回true</span></span><br><span class="line">            <span class="keyword">return</span> j == str.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果答案不存在，则返回空字符串。</span></span><br><span class="line">        <span class="keyword">if</span>(it == dictionary.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="倒序三指针"><a href="#倒序三指针" class="headerlink" title="倒序三指针"></a>倒序三指针</h3><h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/description/">88. 合并两个有序数组 - 力扣（LeetCode）</a></p>
<p>题解： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/solutions/2385610/dao-xu-shuang-zhi-zhen-wei-shi-yao-dao-x-xxkp/">https://leetcode.cn/problems/merge-sorted-array/solutions/2385610/dao-xu-shuang-zhi-zhen-wei-shi-yao-dao-x-xxkp/</a></p>
<p><strong>三指针，倒序合并避免覆盖</strong><br>pivot 指针最多移动 m+n 次，时间复杂度 $O(m+n)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = m + n - <span class="number">1</span>; <span class="comment">//指向合并数组末尾，每次将比较的最大值放入后pivot前移</span></span><br><span class="line">        <span class="type">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>) <span class="comment">//nums2还有要合并的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//p1指向的值大</span></span><br><span class="line">            <span class="keyword">if</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; nums1[p1] &gt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">              nums1[pivot--] = nums1[p1--]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p2指向的值大</span></span><br><span class="line">            <span class="comment">//当nums1遍历完，此时不需要比较，将剩余的nums按顺序存入数组即可</span></span><br><span class="line">            <span class="comment">//当nums1[p1] = nums2[p2]时,放入谁都可以，这里规定放入nums2[p2]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//if(p1 &lt; 0 || nums1[p1] &lt;= nums2[p2])</span></span><br><span class="line">            &#123;</span><br><span class="line">              nums1[pivot--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该题的另一简单思路，将 nums2 放到 nums1 末尾，然后直接排序。<br>时间复杂度 $O((m+n)log (m+n)))$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="删除元素-原地删除"><a href="#删除元素-原地删除" class="headerlink" title="删除元素 (原地删除)"></a>删除元素 (原地删除)</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a><br>删除元素（单数组快慢指针）</p>
<p>双指针法（快慢指针法）： 通过一个快指针和慢指针<strong>在一个 for 循环下完成两个 for 循环的工作。</strong></p>
<ul>
<li>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<p>删除过程如下：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200212.png" alt="27.移除元素-双指针法"><br>fast 不断后移，知道遇到不等于 val 的，就更新slow</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//可以将该算法提炼出来，用于删除任意值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">//返回剩余数组长度，此时slow正好指向末尾元素的下一位置</span></span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找左边等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; nums[left] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边不等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; nums[right] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//right遍历结束后指向最后一个不等于val的元素，left最终为right+1,即最终数组末尾的下一个元素。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解，两层for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; size - <span class="number">1</span>; ++j) <span class="comment">//如果j=size-1,此时nums[j+1]相当于nums[size]）,超过了数组上限会报错</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                --i; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                --size; <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="删除-0（原地删除）"><a href="#删除-0（原地删除）" class="headerlink" title="删除 0（原地删除）"></a>删除 0（原地删除）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除所有值为0的元素（算法和上一节删除元素相同）</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow; <span class="comment">//slow最后指向非0末尾元素的下一位置</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//之后的元素全部赋值0</span></span><br><span class="line">        <span class="keyword">for</span>(;slow &lt; nums.<span class="built_in">size</span>();++slow)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[slow] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="删除有序数组重复项"><a href="#删除有序数组重复项" class="headerlink" title="删除有序数组重复项"></a>删除有序数组重复项</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26. 删除有序数组中的重复项 - 力扣（LeetCode</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200213.png" alt="1"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快指针fast进行数组遍历，慢指针slow指向有效数组的最后一个位置。</span></span><br><span class="line"><span class="comment">//只有当 fast 所指向的值和 slow 不一致（不重复），才将 fast 的值添加到 slow 的下一位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow]!=nums[fast])</span><br><span class="line">            &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/description/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">BackString</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; str.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[fast] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str[slow] = str[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[fast] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; slow &gt; <span class="number">0</span>) <span class="comment">//第一个为#则回退，否则会访问越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                --slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">substr</span>(<span class="number">0</span>, slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BackString</span>(s) == <span class="built_in">BackString</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题目没有要求原地，所以可以创建新数组来解题。<br>以下是使用栈的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用栈处理遍历过程，每次我们遍历到一个字符：(stl容器提供了push_back，pop_back，本身就可以当做栈来使用)</span></span><br><span class="line"><span class="comment">//1. 如果它是退格符，那么我们将栈顶弹出；</span></span><br><span class="line"><span class="comment">//2.如果它是普通字符，那么我们将其压入栈中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">BackString</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string stack_str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack_str.<span class="built_in">push_back</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(!stack_str.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    stack_str.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack_str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BackString</span>(s) == <span class="built_in">BackString</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="03-滑动窗口"><a href="#03-滑动窗口" class="headerlink" title="03 滑动窗口"></a>03 滑动窗口</h2><p>遇见<strong>子串</strong>问题，<strong>子数组</strong>问题，优先去想滑动窗口；滑动窗口本质还是双指针</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。用一个 for 循环完成区间的搜索<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200214.png" alt="209.长度最小的子数组"></p>
<p>**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O (n^2)暴力解法降为 O (n)。</p>
<h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> MinLength = INT_MAX; <span class="comment">//记录最小长度</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;  <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">//滑动窗口终止位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意这里使用while，每次更新 left（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">            <span class="comment">// 当sum&gt;=target时，就更新最小长度,并前移left</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> subLength = right-left+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(subLength &lt; MinLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    MinLength = subLength;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更left（子序列的起始位置）</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果result没有被赋值过的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> MinLength == INT_MAX ? <span class="number">0</span> : MinLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小覆盖子串（hard不会）"><a href="#最小覆盖子串（hard不会）" class="headerlink" title="最小覆盖子串（hard不会）"></a>最小覆盖子串（hard不会）</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a><br>本问题要求我们返回字符串 <code>s</code> 中包含字符串 <code>t</code> 的全部字符的最小窗口。我们称包含 <code>t</code> 的全部字母的窗口为「可行」窗口。</p>
<p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有<strong>两个指针，一个用于「延伸」现有窗口的 <code>r</code> 指针，和一个用于「收缩」窗口的 <code>l</code> 指针</strong>。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 <code>s</code> 上滑动窗口，通过移动 <code>r</code> 指针不断扩张窗口。当窗口包含 <code>t</code> 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200215.png" alt="76_fig1"><br>如何判断当前的窗口包含所有 <code>t</code> 所需的字符呢？</p>
<ul>
<li><strong>用一个哈希表表示 <code>t</code> 中所有的字符以及它们的个数</strong>，</li>
<li><strong>用一个哈希表动态维护 <code>窗口</code> 中所有的字符以及它们的个数</strong>，如果这个动态表中包含 <code>t</code> 的哈希表中的所有字符，并且对应的个数都不小于 <code>t</code> 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</li>
</ul>
<p>注意：这里 <code>t</code> 中可能出现重复的字符，所以我们要记录字符的个数。</p>
<h3 id="【剑】无重复字符的最长子串"><a href="#【剑】无重复字符的最长子串" class="headerlink" title="【剑】无重复字符的最长子串"></a>【剑】无重复字符的最长子串</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&tqId=2276769&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">最长不含重复字符的子字符串_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<p>滑动窗口+哈希</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表记录窗口字符出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[s[right]]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重复，则窗口左移，同时移出的字符要在mp中减少次数</span></span><br><span class="line">            <span class="keyword">while</span>(mp[s[right]] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                mp[s[left]]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="04-中心扩散法"><a href="#04-中心扩散法" class="headerlink" title="04 中心扩散法"></a>04 中心扩散法</h2><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<p>中心扩散法怎么去找回文串？<br>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束，即<strong>左和右不相等</strong>时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从中心向两端扩散的双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。</span></span><br><span class="line">    <span class="comment">//以下函数可以在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">    <span class="comment">//如果输入相同的 l 和 r，就相当于寻找长度为奇数的回文串，如果输入相邻的 l 和 r，则相当于寻找长度为偶数的回文串。</span></span><br><span class="line">    <span class="function">string <span class="title">GetPalindromeSubstr</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 防止索引越界</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 双指针，向两边展开</span></span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环最后一步执行后，会不满足条件跳出循环，我们需要把 l,r 还原到上一步即(l+1,r-1)才是符合要求的字符串范围</span></span><br><span class="line">        <span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(l + <span class="number">1</span>, (r<span class="number">-1</span>)-(l+<span class="number">1</span>)+<span class="number">1</span>);  <span class="comment">//右边范围计算公式（left-right+1）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//缓存</span></span><br><span class="line">        string MaxStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 偶数，以 s[i] 为中心的最长回文子串</span></span><br><span class="line">            string s1 = <span class="built_in">GetPalindromeSubstr</span>(s, i, i);</span><br><span class="line">            <span class="comment">// 奇数，以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">            string s2 = <span class="built_in">GetPalindromeSubstr</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取最大</span></span><br><span class="line">            string maxstr = s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(maxstr.<span class="built_in">size</span>() &gt; MaxLength)</span><br><span class="line">            &#123;</span><br><span class="line">                MaxLength = maxstr.<span class="built_in">size</span>();</span><br><span class="line">                MaxStr = maxstr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="05-【剑】螺旋矩阵（顺时针打印矩阵）"><a href="#05-【剑】螺旋矩阵（顺时针打印矩阵）" class="headerlink" title="05 【剑】螺旋矩阵（顺时针打印矩阵）"></a>05 【剑】螺旋矩阵（顺时针打印矩阵）</h2><p>相同题：<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/solutions/2362055/54-luo-xuan-ju-zhen-mo-ni-qing-xi-tu-jie-juvi/">54. 螺旋矩阵 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/">LCR 146. 螺旋遍历二维数组 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=23279&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">顺时针打印矩阵_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>变体：和上述题目方法一致<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>根据题目示例 <code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code> 的对应输出 <code>[1,2,3,6,9,8,7,4,5]</code> 可以发现，顺时针打印矩阵的顺序是 <strong>“从左向右、从上向下、从右向左、从下向上”</strong> 循环。</p>
<p>因此，考虑设定矩阵的 “左、上、右、下” 四个边界，模拟以上矩阵遍历顺序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200217.gif" alt="ad2a6434019af70ddab6311e9f631192_MD5"></p>
<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><strong>空值处理：</strong> 当 <code>matrix</code> 为空时，直接返回空列表 <code>[]</code> 即可。</li>
<li><strong>初始化：</strong> 矩阵左、右、上、下四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> ，用于打印的结果列表 <code>res</code> 。</li>
<li><strong>循环打印：</strong> “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。<ol>
<li>根据边界打印，即将元素按顺序添加至列表 <code>res</code> 尾部。</li>
<li>边界向内收缩 1 （代表已被打印）。</li>
<li>判断边界是否相遇（是否打印完毕），若打印完毕则跳出。</li>
</ol>
</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ol>
<table><thead><tr><th>打印方向</th><th>1. 根据边界打印</th><th>2. 边界向内收缩</th><th>3. 是否打印完毕</th></tr></thead><tbody><tr><td>从左向右</td><td>左边界<code>l</code> ，右边界 <code>r</code></td><td>上边界 <code>t</code> 加 <span><span><span></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span></span></td><td>是否 <code>t &gt; b</code></td></tr><tr><td>从上向下</td><td>上边界 <code>t</code> ，下边界<code>b</code></td><td>右边界 <code>r</code> 减 <span><span><span></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span></span></td><td>是否 <code>l &gt; r</code></td></tr><tr><td>从右向左</td><td>右边界 <code>r</code> ，左边界<code>l</code></td><td>下边界 <code>b</code> 减 <span><span><span></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span></span></td><td>是否 <code>t &gt; b</code></td></tr><tr><td>从下向上</td><td>下边界 <code>b</code> ，上边界<code>t</code></td><td>左边界 <code>l</code> 加 <span><span><span></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span></span></td><td>是否 <code>l &gt; r</code></td></tr></tbody></table>

<p><strong>顺序：123，69，87，4，5</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200218.gif" alt="202308012045"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空值处理</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化矩阵上下左右四个边界</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//列数</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = matrix.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//注意：matrix.size()返回的是m*n矩阵的m值，即行数。不是m*n所有元素的数量</span></span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从左向右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) <span class="comment">//注意是小于等于</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[t][i]); </span><br><span class="line">            &#125;</span><br><span class="line">            ++t; <span class="comment">//++t,代表当前行打印完毕，后续不再处理这一行</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; b) <span class="keyword">break</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从上向下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= b; i++)  </span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            --r; <span class="comment">//--r当前列处理完毕，后续不在处理这一列。</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右向左</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; i--) <span class="comment">//注意判断条件方向变化</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[b][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            --b; <span class="comment">//--b,代表当前行打印完毕，后续不再处理这一行</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; b) <span class="keyword">break</span>; </span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 从下向上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= t; i--) </span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][l]);  </span><br><span class="line">            &#125;</span><br><span class="line">            ++l; <span class="comment">//++l当前列处理完毕，后续不在处理这一列。</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O (MN) ：</strong> M,  N 分别为矩阵行数和列数。</li>
<li><strong>空间复杂度 O (1) ：</strong> 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> 使用常数大小的额外空间。</li>
</ul>
<h2 id="06-排序"><a href="#06-排序" class="headerlink" title="06 排序"></a>06 排序</h2><h3 id="【剑】数组中的逆序对"><a href="#【剑】数组中的逆序对" class="headerlink" title="【剑】数组中的逆序对"></a>【剑】数组中的逆序对</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=23260&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数组中的逆序对_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>题目规定时间复杂度 $O(nlogn)$，所以不能用暴力方法。<br><strong>使用归并排序</strong></p>
<p>原题目翻译成人话就是：给定一个数组 nums，数组元素各不相同，求 <code>nums[i] &gt; nums[j] 且 i &lt; j</code> 的个数。</p>
<p>需要对归并排序处理的地方仅仅是⭐部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个数组arr， 数组元素各不相同，求nums[i] &gt; nums[j] 且 i &lt; j的个数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>, count); <span class="comment">//count传引用</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">MergeSort</span>(nums, left, mid ,count);</span><br><span class="line">            <span class="built_in">MergeSort</span>(nums, mid+<span class="number">1</span>, right ,count);</span><br><span class="line">            <span class="built_in">Merge</span>(nums, left, mid, right ,count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right-left+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = left, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//⭐符合nums[i] &gt; nums[j] 且 i &lt; j</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">                count += (mid-i+<span class="number">1</span>); <span class="comment">//左区间也是升序，说明左区间后面的数都可以和右区间这个数组成逆序对</span></span><br><span class="line">                count %= <span class="number">1000000007</span>; <span class="comment">//防止溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> inx = <span class="number">0</span>;inx&lt;temp.<span class="built_in">size</span>();inx++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[left+inx] = temp[inx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="【剑】二维数组查找"><a href="#【剑】二维数组查找" class="headerlink" title="【剑】二维数组查找"></a>【剑】二维数组查找</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=23256&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二维数组中的查找_牛客题霸_牛客网 (nowcoder.com)</a><br>题目中的二维数组<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong></p>
<p>简单思路：暴力遍历时间复杂度 $O(m<em>n)$，或者对每行进行二分时间复杂度 $O(m</em>logn)$</p>
<p>进阶思路：时间复杂度 $O(m+n)$, 空间复杂度 $O(1)$</p>
<p><strong>利用二维数组行列递增特性</strong>  </p>
<ol>
<li>由于行列递增，可以得出：<br> a.在一列中的某个数字，其上的数字都比它小<br> b.在一行中的某个数字，其右的数字都比它大</li>
<li>搜索流程：<br> a.首先从数组左下角搜索.<br> b.如果当前数字大于target,那么查找往上移一位,如果当前数字小于target,那么查找往右移一位。<br> c.查找到target,返回true; 如果越界，返回false;<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200219.png" alt="Pasted image 20240219163842"></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左下角坐标（i,j)</span></span><br><span class="line">        <span class="type">int</span> i = array.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;array[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target) j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="01-链表定义"><a href="#01-链表定义" class="headerlink" title="01  链表定义"></a>01  链表定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以不手动定义构造函数，C++默认生成一个无参构造函数。<ul>
<li>使用默认构造函数初始化节点：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动定义构造函数初始化节点 (更方便一些)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200220.png" alt="Pasted image 20231211144504"></p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200221.gif" alt="Pasted image 20231211144414"></p>
<p>注意删除节点操作根据有无头结点，操作不同：</p>
<p>这里以链表 1 4 2 4 来举例，移除元素4。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200222.png" alt="Pasted image 20231211145545"></p>
<p>移除操作，就是让节点 next 指针直接指向<strong>下下个节点</strong>就可以了，</p>
<p><strong>那么如果删除的是头结点又该怎么办呢？这里就涉及如下链表操作的两种方式：</strong></p>
<h5 id="直接使用原来的链表来进行删除操作"><a href="#直接使用原来的链表来进行删除操作" class="headerlink" title="直接使用原来的链表来进行删除操作"></a>直接使用原来的链表来进行删除操作</h5><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200223.png" alt="Pasted image 20231211145724"><br>移除头结点和移除其他节点的操作是不一样的，<strong>因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</strong></p>
<p>所以头结点如何移除呢，其实<strong>只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200224.png" alt="Pasted image 20231211150205"><br>依然别忘将原头结点从内存中删掉。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200225.png" alt="Pasted image 20231211150209"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = p-&gt;next; <span class="comment">//指向非头节点</span></span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样移除了一个头结点，是不是发现，在单链表中移除头结点和移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p>
<p><strong>那么可不可以以一种统一的逻辑来移除链表的节点呢？</strong></p>
<h5 id="设置一个虚拟头结点在进行删除操作"><a href="#设置一个虚拟头结点在进行删除操作" class="headerlink" title="设置一个虚拟头结点在进行删除操作"></a>设置一个虚拟头结点在进行删除操作</h5><p><strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200226.png" alt="Pasted image 20231211150250"><br>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p>
<p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p>
<p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p>
<p><strong>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* virtualNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head); <span class="comment">//虚拟头结点指向head</span></span><br><span class="line"></span><br><span class="line">        ListNode* p = virtualNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* temp = p-&gt;next; </span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; </span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复原头结点并删除虚拟头结点</span></span><br><span class="line">        head = virtualNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> virtualNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="用-O-1-的时间复杂度删除链表节点"><a href="#用-O-1-的时间复杂度删除链表节点" class="headerlink" title="用 O(1)的时间复杂度删除链表节点"></a>用 O(1)的时间复杂度删除链表节点</h5><p>已知单向链表，给定了头指针和一个节点指针，如何在 O(1)的时间内删除该节点？</p>
<p>如前文，通过找到前一个节点来删除，时间复杂度是 O(n)。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200227.png" alt="Pasted image 20240220113911"></p>
<p>接下来，我们换一种思路，既然最耗时的地方是遍历寻找节点，那么我们就不遍历了，充分利用题目所给条件来进一步思考。</p>
<p><strong>解题思路：</strong></p>
<ul>
<li>如果该节点不是尾节点，那么可以直接将下一个节点的值赋值给该节点，然后令该节点指向下下个节点即可，再删除下个节点，时间复杂度为 $O(1)$ <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200228.png" alt="Pasted image 20240220113935"></li>
<li>当删除的列表中只有一个节点的情况下，即链表只有头节点一个节点。直接将 head &#x3D; nullptr 即可</li>
<li>当删除的节点为尾节点，因为没有下一个节点所以<strong>只能从头遍历链表，找到节点的前一个节点</strong>，然后让前一个节点指向 nullptr ，时间复杂度为 O（N）<br>总的时间复杂度为 $(N -1 + N ) &#x2F; N$  即为 $O(1)$</li>
</ul>
<h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><figcaption><span>title:链表操作（有头结点）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> Inval) : <span class="built_in">val</span>(Inval),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> Inval, LinkedNode* Innext) : <span class="built_in">val</span>(Inval),<span class="built_in">next</span>(Innext) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() </span><br><span class="line">    : m_virtualNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>)</span><br><span class="line">    , m_size = <span class="number">0</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">get</span>(<span class="type">int</span> index) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; (m_size - <span class="number">1</span>)) &#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line">        LinkedNode* p = m_virtualNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) </span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedNode* NewNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val, m_virtualNode-&gt;next);</span><br><span class="line">        m_virtualNode-&gt;next = NewNode;</span><br><span class="line">        ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将一个值为 val 的节点追加到链表中作为链表的最后一个元素。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedNode* NewNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line"></span><br><span class="line">        LinkedNode* p = m_virtualNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = NewNode;</span><br><span class="line">        ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将一个值为 val 的节点插入到链表中下标为 index 的节点之前</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。</span></span><br><span class="line">        <span class="keyword">if</span>(index == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">addAtTail</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果 index 比长度更大，该节点将 不会插入 到链表中。</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; m_size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        LinkedNode* NewNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里和get函数中的指向不同：</span></span><br><span class="line">        <span class="comment">//1.如果p = m_virtualNode-&gt;next,则遍历后p指向下表为index的节点</span></span><br><span class="line">        <span class="comment">//2.如果p = m_virtualNode,则遍历后p指向下表为index的节点的前一个节点</span></span><br><span class="line">        LinkedNode* p = m_virtualNode; </span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NewNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">        ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; (m_size - <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//因为要删除节点，所以要找到下标位index节点的前一个节点</span></span><br><span class="line">        LinkedNode* p = m_virtualNode; </span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedNode* temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="comment">//delete命令指示释放了tmp指针原本所指的那部分内存，</span></span><br><span class="line">        <span class="comment">//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span></span><br><span class="line">        <span class="comment">//如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span></span><br><span class="line">        <span class="comment">//如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span></span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        --m_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">    LinkedNode* m_virtualNode; <span class="comment">//虚拟头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="【剑】从尾到头访问链表"><a href="#【剑】从尾到头访问链表" class="headerlink" title="【剑】从尾到头访问链表"></a>【剑】从尾到头访问链表</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=23278&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">从尾到头打印链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>方法一：正序输入 vector，然后翻转vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：insert 插入到 vector 头部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法三：使用栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(stack.<span class="built_in">top</span>());</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">下一份</span><br></pre></td></tr></table></figure>

<h2 id="【剑】合并两个有序链表"><a href="#【剑】合并两个有序链表" class="headerlink" title="【剑】合并两个有序链表"></a>【剑】合并两个有序链表</h2><p>剑指offer<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/submissions/">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创捷一个带头结点的新链表</span></span><br><span class="line">        ListNode* virtualhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* cur = virtualhead;</span><br><span class="line"></span><br><span class="line">        ListNode* p1 = list1;</span><br><span class="line">        ListNode* p2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比链表节点，小的接入cur-&gt;next;</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">nullptr</span> &amp;&amp; p2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩下的全部接入</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virtualhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h2><h4 id="【剑】反转链表"><a href="#【剑】反转链表" class="headerlink" title="【剑】反转链表"></a>【剑】反转链表</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a><br>可以借助栈或者额外的一个链表，遍历节点存入，然后重新连接成倒序。</p>
<p><strong>但题目要求：时间复杂度 $O(n)$，空间复杂度 $O(1)$ 。所以就不能借助额外的内存空间：考虑快慢指针</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200229.png" alt="Pasted image 20240318092722"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200230.png" alt="Pasted image 20240318092806"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200231.png" alt="Pasted image 20240318092823"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = cur-&gt;next; <span class="comment">//保存cur的下一位置，最后将cur移过来</span></span><br><span class="line">            </span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || !head-&gt;next==<span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="【剑】链表中倒数第-k-个结点"><a href="#【剑】链表中倒数第-k-个结点" class="headerlink" title="【剑】链表中倒数第 k 个结点"></a>【剑】链表中倒数第 k 个结点</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tqId=1377477&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">链表中倒数最后k个结点_牛客题霸_牛客网 (nowcoder.com)</a>：找到倒数第 k 个节点</p>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第 k 个节点。<br>如果该链表长度小于 k，请返回一个长度为 0 的链表。</p>
<p><strong>使用 slow 和 fast 双指针，让 fast 先走 k 步，然后同时后移，直到 fast 指向 nullptr，此时 slow 真好指向倒数第 k 个元素。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     </span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fast后移k次</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果fast==nullptr了，而k仍大于0，说明k&gt;链表长度，返回空链表</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者直接多写一个循环计算链表长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = pHead;</span><br><span class="line">        <span class="comment">//计算长度并比较</span></span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;k) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a>：类似 [[#【剑】链表中倒数最后 k 个结点]] 找到后还要删除，所以要将 slow 指针移动到待删除节点前一个位置。<strong>所以这里要先将fast 移动n+1 步，最后slow 的位置才能使倒数第n 个节点的前一个位置（链表倒数第n+1 个节点）。</strong></p>
<p><strong>涉及删除操作的时候建议使用虚拟头结点</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200232.png" alt="cc43daa8cbb755373ce4c5cd10c44066dc770a34a6d2913a52f8047cbf5e6e56-file_1559548337458"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* virtualHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = virtualHead;</span><br><span class="line">        ListNode* fast = virtualHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// q 移动 n+1 步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//slow和fast同时走，直到fast指向末尾元素的下一个位置（nullptr）</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除slow和fast中间的元素（即导数第n个节点）</span></span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> virtualHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="【剑】-删除排序链表中的重复元素"><a href="#【剑】-删除排序链表中的重复元素" class="headerlink" title="【剑】 删除排序链表中的重复元素"></a>【剑】 删除排序链表中的重复元素</h4><h5 id="重复节点不保留"><a href="#重复节点不保留" class="headerlink" title="重复节点不保留"></a>重复节点不保留</h5><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=23450&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">删除链表中重复的结点_牛客题霸_牛客网 (nowcoder.com)</a>：删除该链表中重复的结点，<strong>重复的结点不保留</strong>，返回链表头指针</p>
<p>法一：用一个 hash 记录出现次数，然后借助虚拟头结点删除出现次数&gt;1 的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[p-&gt;val]++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* virtualHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualHead-&gt;next = pHead;</span><br><span class="line">        ListNode* v = virtualHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(v != <span class="literal">nullptr</span> &amp;&amp; v-&gt;next !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[v-&gt;next-&gt;val]&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* temp = v-&gt;next;</span><br><span class="line">                v-&gt;next = v-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v = v-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pHead = virtualHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> virtualHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二：有序数组有序，所以重复的元素一定相邻，这样可以在一次遍历中完成元素的删除。借助快慢指针：</p>
<ol>
<li>定义两个指针（slow、fast），以及虚拟结点，初始化三者指针，slow 和 fast 相邻；</li>
<li>当遇到重复时，「只有fast指针」向前移动，此时slow和fast不相邻；</li>
<li>若没有重复，则slow指针和fast指针都向前移动一步；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        ListNode* virtualHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualHead-&gt;next = pHead;</span><br><span class="line">        ListNode* slow = virtualHead;</span><br><span class="line">        ListNode* fast = virtualHead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遇到重复fast就后移到最后一个重复元素位置</span></span><br><span class="line">            <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;val == fast-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果重复那么fast就会移动, 我们将slow移动到fast的下一位置，即最后一个重复元素的下一位置</span></span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next != fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next = fast-&gt;next;</span><br><span class="line">                fast = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有重复就同时后移</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virtualHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="重复节点只保留一个"><a href="#重复节点只保留一个" class="headerlink" title="重复节点只保留一个"></a>重复节点只保留一个</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素 - 力扣（LeetCode）</a>： 删除所有重复的元素，<strong>使每个元素只出现一次</strong></p>
<p>思路一：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200233.gif" alt="2"><br>fast 找到与 slow 不同的值，就将 slow 的 next 指针指向 fast。然后移动 slow 到 fast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next= fast;</span><br><span class="line">                slow = fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>思路二：<br>fast 指针只要找到和 slow 指针值不同的元素，就让 slow 右移，并将 fast 值赋给 slow 值。slow 始终指向已排序链表的尾部，最后让 slow 指向 nullptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;val != slow-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                slow-&gt;val = fast-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="【剑】链表中环的入口结点（链表找环路）"><a href="#【剑】链表中环的入口结点（链表找环路）" class="headerlink" title="【剑】链表中环的入口结点（链表找环路）"></a>【剑】链表中环的入口结点（链表找环路）</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=23449&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">链表中环的入口结点_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a><br>对于链表找环路的问题，有一个<strong>通用的解法——快慢指针（Floyd 判圈法）</strong>：给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。<strong>每次 fast 前进两步，slow 前进一步。</strong></p>
<ul>
<li>如果 fast 可以走到尽头（指向nullptr），那么说明没有环路；否则 fast 可以无限走下去，说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。</li>
<li>当 slow 和 fast <strong>第一次相遇</strong>时，我们将 fast 重新移动到链表头结点，并让 slow 和 fast 每次都前进一步。</li>
<li>当 slow 和 fast <strong>第二次相遇</strong>时，相遇的节点即为环路的开始点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否存在环路</span></span><br><span class="line">        <span class="comment">//每次fast前进两步，slow前进一步，如果fast可以一直走下去（即fast-&gt;next一直不为空）则说明一定有环路，否则返回nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有环路，则一定在某个时刻slow和fast相遇，此时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//slow和fast第一次相遇时，fast重置到head,让slow和fast每次都只走一步</span></span><br><span class="line">        <span class="comment">//直到第二次相遇，相遇的节点即为环路的开始节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200234.gif" alt="Pasted image 20231212100801"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* virtualhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* cur = virtualHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp1 = cur-&gt;next; <span class="comment">//记录第一个节点</span></span><br><span class="line">            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//记录第三个节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//虚拟头结点指向第二个</span></span><br><span class="line">            cur-&gt;next-&gt;next = temp1; <span class="comment">//第二个指向第一个</span></span><br><span class="line">            temp1-&gt;next = temp2; <span class="comment">//第一个指向第三个</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">//cur移动两位,准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virtualHead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】两个链表的第一个公共结点（链表相交）"><a href="#【剑】两个链表的第一个公共结点（链表相交）" class="headerlink" title="【剑】两个链表的第一个公共结点（链表相交）"></a>【剑】两个链表的第一个公共结点（链表相交）</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=23257&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">两个链表的第一个公共结点_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p>
<p>简单来说，就是求两个链表交点节点的<strong>指针</strong>相等。这里同学们要注意，<strong>交点不是数值相等，而是指针相等。</strong></p>
<ul>
<li>计算链表长度差值为n</li>
<li>让长的先走n 步</li>
<li>然后长短一起走，直到指针相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求链表长度</span></span><br><span class="line">        <span class="type">int</span> LengthA = <span class="number">0</span>,LengthB = <span class="number">0</span>;</span><br><span class="line">        ListNode* TempA = headA;</span><br><span class="line">        ListNode* TempB = headB;</span><br><span class="line">        <span class="keyword">while</span>(TempA != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TempA = TempA-&gt;next;</span><br><span class="line">            ++LengthA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(TempB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TempB = TempB-&gt;next;</span><br><span class="line">            ++LengthB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求链表长度差值，将长的头结点向后移动，保持两表长度相同</span></span><br><span class="line">        <span class="type">int</span> substract = LengthA - LengthB;</span><br><span class="line">        <span class="keyword">if</span>(substract&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(substract--)</span><br><span class="line">            &#123;</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            substract = -substract;</span><br><span class="line">            <span class="keyword">while</span>(substract--)</span><br><span class="line">            &#123;</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找相交节点</span></span><br><span class="line">        <span class="keyword">while</span>(headA!=<span class="literal">nullptr</span> &amp;&amp; headB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(headA == headB) <span class="comment">//注意判断交点是指针相等，而不是指针指向的值相等。（不要写成headA-&gt;val == headB-&gt;val）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】复杂链表的复制"><a href="#【剑】复杂链表的复制" class="headerlink" title="【剑】复杂链表的复制"></a>【剑】复杂链表的复制</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=23254&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">复杂链表的复制_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>注意审题：我们需要对链表进行深拷贝</strong></p>
<p>假如链表没有随机指针, 我们的拷贝方式很简单, 只要先创建一个虚拟头结点, 然后遍历一下给定链表, 创建新节点, 并不断和上个节点连接<br>本题的难点就在于每个节点还有一个指向空或其它节点的指针, 一种比较直观的想法就是先把整条链表连起来, 然后再挨着改变指针, 因此我们可以用哈希表来存放指针的映射关系, 然后根据将随机指针指向原链表随机指针映射在新链表的位置<br>算法实现：首先创建一个虚拟头结点节点, 遍历一次原链表, 先将除随机指针外的部分创建并连接, 同时用哈希表记录指针之间的映射, 最后遍历一次哈希表, 将随机指针指向对应的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原链表节点和拷贝节点的映射</span></span><br><span class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; origin_to_copy;</span><br><span class="line"></span><br><span class="line">        RandomListNode* virtualNode = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(<span class="number">0</span>);</span><br><span class="line">        RandomListNode* pre = virtualNode;</span><br><span class="line"></span><br><span class="line">        RandomListNode* cur = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝原链表节点，并保存映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* CopyNode = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(cur-&gt;label);</span><br><span class="line">            pre-&gt;next = CopyNode; <span class="comment">//与上个节点连接</span></span><br><span class="line">            origin_to_copy[cur] = CopyNode; <span class="comment">//记录映射关系</span></span><br><span class="line">            pre = pre-&gt;next; <span class="comment">//指针移动</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = origin_to_copy.<span class="built_in">begin</span>();it!=origin_to_copy.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* originNode = it-&gt;first;</span><br><span class="line">            RandomListNode* copyNode = it-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取原节点random指针对应的的新位置</span></span><br><span class="line">            <span class="keyword">if</span>(originNode-&gt;random == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                copyNode-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copyNode-&gt;random = origin_to_copy[originNode-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> virtualNode; <span class="comment">//释放虚拟头结点空间</span></span><br><span class="line">        <span class="keyword">return</span> origin_to_copy[pHead];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n)$, 遍历一次链表和哈希表的时间<br>空间复杂度：$O(n)$, 哈希表使用的空间</p>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。<br>如果在做面试题目的时候遇到<strong>需要判断一个元素是否出现过的场景</strong>也应该第一时间想到哈希法（unordered_set）！</p>
<p><code>std::unordered_set</code> 底层实现为哈希表，<code>std::set</code> 和 <code>std::multiset</code> 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以 key 值是有序的，但 <strong>key 不可以修改</strong>，改动 key 值会导致<br>虽然 <code>std:: set</code>、<code>std:: multiset</code> 的底层实现是红黑树，不是哈希表，<code>std:: set</code>、<code>std:: multiset</code> 使用红黑树来索引和存储，<strong>不过给我们的使用方式，还是哈希法的使用方式，即 key 和 value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。</strong><br>map也是一样的道理。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>利用数组也可以实现哈希，且性能更好。但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong><br>如果这道题目没有限制数值的大小，就无法使用数组来做哈希表了。<strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p>
<h2 id="【剑】第一个只出现一次的字符"><a href="#【剑】第一个只出现一次的字符" class="headerlink" title="【剑】第一个只出现一次的字符"></a>【剑】第一个只出现一次的字符</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=23258&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">第一个只出现一次的字符_牛客题霸_牛客网 (nowcoder.com)</a><br>遍历两次，第一次用 map 记录出现次数，第二次返回下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s1 : str)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[s1]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p>
<p>字母异位词：若两字母的<strong>每个字符出现的次数都相同</strong>，则他们互为字母异位词。<strong>注意，字母异位词长度一定相等。</strong><br>判断方法：</p>
<ol>
<li>排序后相等（注意，如果长度不同必不是字母异位词）</li>
<li>使用哈希表记录字母出现次数</li>
</ol>
<figure class="highlight c++"><figcaption><span>title:排序后相等</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s == t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:哈希表记录字母出现次数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存储字母及其出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; Alpha_To_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历s,记录所有字母次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++Alpha_To_count[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历t, 减少所有字母对应的次数，如果最后有的字母次数不为0，说明多了或少了，即s，t不是字母异位词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            --Alpha_To_count[t[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = Alpha_To_count.<span class="built_in">begin</span>();it!=Alpha_To_count.<span class="built_in">end</span>();++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><figcaption><span>title:数组哈希</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(std::string s, std::string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录字符串出现的次数</span></span><br><span class="line">    <span class="comment">//把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历s,记录所有字母次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</span></span><br><span class="line">        ++record[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历t, 减少所有字母对应的次数，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        --record[t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后有的字母次数不为0，说明多了或少了，即s，t不是字母异位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或这样写</span></span><br><span class="line">    <span class="comment">//for(auto i : record)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    if(i!=0)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        return false;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/description/">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<p>主要技巧：利用排序统一异位词 key 值来进行分组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span> || strs.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> vector&lt;vector&lt;string&gt;&gt;&#123;strs&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key:标识字母异位词，value:保存字母异位词</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="comment">//排序后统一字母异位词key值</span></span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(),key.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将str插入value（由于统一了key值，所以这里可以保证字母异位词插入到同一key值对应的value）</span></span><br><span class="line">            mp[key].<span class="built_in">push_back</span>(str); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> t_size = t.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_size != t_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++record[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t_size;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            --record[t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//提前存起来，提升性能，否则该题会超时</span></span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> p_size = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s_size &lt; p_size) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//固定滑动窗口长度为p.size()</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>;left &lt; s_size-p_size+<span class="number">1</span>; ++left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isAnagram</span>(s.<span class="built_in">substr</span>(left,p_size),p))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p>
<p>因为元素有重复 key 值，所以可以选择 set 排除重复值</p>
<figure class="highlight c++"><figcaption><span>title:unordered_set哈希</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">    </span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过,则插入结果数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res_set.<span class="built_in">begin</span>(),res_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>title:数组哈希</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">record</span><span class="params">(<span class="number">1000</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            record[num] = <span class="literal">true</span>;  <span class="comment">//nums1出现过的字母在record中标识为true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遇到标识过的就添加到结果数组，并将标识改为false，防止重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(record[num]==<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(num);</span><br><span class="line">                record[num] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>判断一个元素是否出现过的场景</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a><br><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数平方之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无限循环：求和的过程中，sum会重复出现</span></span><br><span class="line">    <span class="comment">//使用哈希法判断sum是否重复出现：</span></span><br><span class="line">    <span class="comment">//- 如果重复出现就return false;</span></span><br><span class="line">    <span class="comment">//- 否则一直找到sum为1为止</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【H1】无序数组的两数之和"><a href="#【H1】无序数组的两数之和" class="headerlink" title="【H1】无序数组的两数之和"></a>【H1】无序数组的两数之和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p>
<p>可能会想到先对 nums 数组排序再用双指针求和，但是排序会破坏数组下标。所以不适合。如果要求返回的是数值的话，就可以使用双指针法了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map中的存储结构为 &#123;key：数据元素，value：数组元素对应的下标&#125;。</span></span><br><span class="line"><span class="comment">//在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Num_To_Index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> FindNum = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(Num_To_Index.<span class="built_in">find</span>(FindNum) != Num_To_Index.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;i, Num_To_Index[FindNum]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">            Num_To_Index.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: $O(n)$</li>
<li>空间复杂度: $O(n)$</li>
</ul>
<h2 id="四数相加-II"><a href="#四数相加-II" class="headerlink" title="四数相加 II"></a>四数相加 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p>
<p><strong>本题是使用哈希法的经典题目，而 <a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">0015.三数之和 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">0018.四数之和 (opens new window)</a> 并不合适使用哈希法</strong>，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p>
<p><strong>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] &#x3D; 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p>
<p>本题解题步骤：</p>
<ol>
<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这道题目是四个独立的数组，和之前使用双指针处理的四数相加是不同的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;  AB_Value_To_Count; <span class="comment">//key:a+b的数值，value:a+b数值出现的次数</span></span><br><span class="line">        <span class="comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : A)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : B)</span><br><span class="line">            &#123;</span><br><span class="line">                AB_Value_To_Count[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//a+b+c+d = 0 出现的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c : C)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d : D)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(AB_Value_To_Count.<span class="built_in">find</span>(<span class="number">0</span>-(c+d)) != AB_Value_To_Count.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    count += AB_Value_To_Count[<span class="number">0</span>-(c+d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n^2)$<br>空间复杂度 $O(n^2)$</p>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<p>当需要固定规律一段一段去处理字符串的时候，要想想在在 for 循环的表达式上做做文章。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们直接按题意进行模拟：反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=(<span class="number">2</span>*k))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> remain = s.<span class="built_in">size</span>() - (i+<span class="number">1</span>); <span class="comment">//剩余字符</span></span><br><span class="line">           <span class="comment">//如果剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">           <span class="keyword">if</span>(remain &lt; k)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*remain &lt; 2*k &amp;&amp;*/</span> remain &gt;= k)  <span class="comment">//加上小于2k的判断条件就过不了，为什么？</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】翻转单词序列"><a href="#【剑】翻转单词序列" class="headerlink" title="【剑】翻转单词序列"></a>【剑】翻转单词序列</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=23287&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">翻转单词序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>方法一：两次反转（推荐使用）</strong><br>我们需要的是将单词位置反转，也即是单词内部不变，属于字符串部分反转问题。如果将整个字符串反转，单词位置倒是反转了，但是内部次序也改变了，此时就需要将内部再反转回去，因此两次反转可以解决。</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：将字符串整体反转。</li>
<li>step 2：遍历反转后的字符串，以空格为界限找到一个单词。</li>
<li>step 3：将每个单词部分反转。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200235.png" alt="Pasted image 20240222151046"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n= str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//第一次整体翻转</span></span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="comment">//从位置j开始找到第一个空格</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时str[j]是一个空格,[i, j-1]是一个单词，将这个单词反转</span></span><br><span class="line">            <span class="comment">//注意第二个参数是end迭代器，所以指向单词最后一个字母的下一个位置，即空格的位置。</span></span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + i, str.<span class="built_in">begin</span>() + j); </span><br><span class="line">            </span><br><span class="line">            i = j + <span class="number">1</span>; <span class="comment">//将i重置到空格后的下一个单词首字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>方法二：栈</p>
<ul>
<li>step 1：遍历字符串，将整个字符串按照空格分割然后入栈。</li>
<li>step 2：遍历栈，将栈中内容弹出拼接成字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;string&gt; ST;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从位置j开始找到第一个空格</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时str[j]是一个空格,[i, j-1]是一个单词，将这个单词入栈</span></span><br><span class="line">            ST.<span class="built_in">push</span>(str.<span class="built_in">substr</span>(i, j<span class="number">-1</span>-i+<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            i = j+<span class="number">1</span>; <span class="comment">//将i重置到空格后的下一个单词首字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res += ST.<span class="built_in">top</span>();</span><br><span class="line">            ST.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最后一次出栈不需要加空格</span></span><br><span class="line">            <span class="keyword">if</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p>
<p>与 [[#【剑】翻转单词序列]] 不同的地方在于，输入字符串 <code>s</code> 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>我们使用栈的方法，只需要对多余的空格进行处理，其他逻辑大体相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找到从currentIndex开始的下一个字母</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindNextWord</span><span class="params">(string str, <span class="type">int</span> currentIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(currentIndex&lt;str.<span class="built_in">size</span>() &amp;&amp; str[currentIndex] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到从currentIndex开始的下一个空格</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindNextSpace</span><span class="params">(string str, <span class="type">int</span> currentIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(currentIndex&lt;str.<span class="built_in">size</span>() &amp;&amp; str[currentIndex] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n= str.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;string&gt; ST;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">FindNextWord</span>(str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从位置i开始找到第一个空格</span></span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">FindNextSpace</span>(str, i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时str[j]是一个空格,[i, j-1]是一个单词，将这个单词入栈</span></span><br><span class="line">            ST.<span class="built_in">push</span>(str.<span class="built_in">substr</span>(i, j<span class="number">-1</span>-i+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            i = <span class="built_in">FindNextWord</span>(str, j); <span class="comment">//将i重置到空格后的下一个单词首字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res += ST.<span class="built_in">top</span>();</span><br><span class="line">            ST.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最后一次出栈不需要加空格</span></span><br><span class="line">            <span class="keyword">if</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一个思路：双指针，不太容易想到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针从后往前走</span></span><br><span class="line">        <span class="type">int</span> left = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//除去尾部空格</span></span><br><span class="line">        <span class="keyword">while</span>(s[left] == <span class="string">&#x27; &#x27;</span> &amp;&amp; left&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> right = left;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从后往前找空格</span></span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; s[left]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += s.<span class="built_in">substr</span>(left + <span class="number">1</span>,right-(left+<span class="number">1</span>)+<span class="number">1</span>) + <span class="string">&quot; &quot;</span>;  <span class="comment">//空格后面的一个单词加入ans,并添加空格</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//忽略空格，前移right位置</span></span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 忽略最后一位的空格</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a>找出字符串中第一个匹配项的下标</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<p>需要补 KMP 。记忆性，等最后再学</p>
<p>STL 快速解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = haystack.<span class="built_in">find</span>(needle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pos;  <span class="comment">//find方法查找失败会返回std::string::npos,值为-1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进阶：KMP</p>
<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<p>s+s从下标为1处搜索，包含一个s子串，如果s 不是由重复子串构成，find 找到s 的位置一定是 s.size ()。如果提前找到，就说明由重复子串构成。</p>
<p>例如：s &#x3D; “abab” 则s+s &#x3D; “abababab”, 从下标 1 开始搜索是否包含s，若s 可由子串构成，那么s+s 一定能提前找到s。本例子在下标 2 （符合2!&#x3D;4）处既可找到s，说明s 可以由子串构成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s+s).<span class="built_in">find</span>(s, <span class="number">1</span>) &lt; s.<span class="built_in">size</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="五、栈与队列"><a href="#五、栈与队列" class="headerlink" title="五、栈与队列"></a>五、栈与队列</h1><h2 id="【剑】用栈实现队列"><a href="#【剑】用栈实现队列" class="headerlink" title="【剑】用栈实现队列"></a>【剑】用栈实现队列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=23281&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">用两个栈实现队列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>思路：使用两个栈来模拟一个队列</strong></p>
<ul>
<li><strong>进（push）</strong> 的时候入栈 In </li>
<li><strong>出（pop）</strong> 的时候要先判断栈Out 是否为空：<ul>
<li>若为空，先将栈 In 的数据全部入栈 Out，再从 Out 出</li>
<li>若不为空，直接从Out 出</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200236.png" alt="232.用栈实现队列版本2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将元素 x 推到队列的末尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        In.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从队列的开头移除并返回元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//⭐只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span>(Out.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从In导入数据直到In为空</span></span><br><span class="line">            <span class="keyword">while</span>(!In.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                Out.<span class="built_in">push</span>(In.<span class="built_in">top</span>()); <span class="comment">//将In栈顶元素push到Out</span></span><br><span class="line">                In.<span class="built_in">pop</span>(); <span class="comment">//删除In栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> TopVar = Out.<span class="built_in">top</span>();</span><br><span class="line">        Out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> TopVar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回队列开头的元素（和pop的区别在于不移除元素）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> TopVar = <span class="built_in">pop</span>(); <span class="comment">//复用pop函数</span></span><br><span class="line">        Out.<span class="built_in">push</span>(TopVar); <span class="comment">// 因为pop函数弹出了元素，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> TopVar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果队列为空，返回 true; 否则，返回 false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> In.<span class="built_in">empty</span>() &amp;&amp; Out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; In;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; Out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></p>
<h3 id="单队列实现"><a href="#单队列实现" class="headerlink" title="单队列实现"></a>单队列实现</h3><p>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//size-1是为了保留最后一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="双队列实现"><a href="#双队列实现" class="headerlink" title="双队列实现"></a>双队列实现</h3><p>用两个队列 que1 和 que2 实现队列的功能，<br>que2 其实完全就是一个备份的作用，把 que1 最后面的元素以外的元素都备份到 que2，然后弹出最后面的元素，再把其他元素从 que2 导回 que1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素 x 压入栈顶。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除并返回栈顶元素。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 留下的最后一个元素就是要返回的值,实现后入先出</span></span><br><span class="line">        <span class="type">int</span> res = que1.<span class="built_in">front</span>(); </span><br><span class="line">        que1.<span class="built_in">pop</span>(); <span class="comment">//将留下的元素弹出</span></span><br><span class="line">        que1 = que2; <span class="comment">//再将que2赋值给que1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空que2</span></span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果栈是空的，返回 true ；否则，返回 false 。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="【剑】包含-min-函数的栈（最小栈）"><a href="#【剑】包含-min-函数的栈（最小栈）" class="headerlink" title="【剑】包含 min 函数的栈（最小栈）"></a>【剑】包含 min 函数的栈（最小栈）</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=23268&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">包含min函数的栈_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈 - 力扣（LeetCode）</a></p>
<p><strong>思路一 ：辅助栈（时间复杂度 $O(1)$, 推荐这种方法）</strong></p>
<ol>
<li>使用栈 ST 记录进入栈的元素，正常进行 push、pop、top 操作。</li>
<li>使用另一个栈 （ ST_Min）记录每次 push 进入时 ST 中的最小值。</li>
<li>每次 ST push 元素的时候与 ST_Min 的栈顶元素比较，<ul>
<li>若是较小，则进入 ST_Min 栈</li>
<li>若是较大，则 ST_Min 的栈顶元素再次入栈（因为即便加了一个元素，它依然是最小值）</li>
</ul>
</li>
<li>每次访问最小值即访问 ST_Min 的栈顶。</li>
</ol>
<p><strong>注意，在辅助栈中，存放着每一位主栈元素对应的最小值。所以push 的时候else 要重复加入栈顶，pop 的时候两个栈都要pop</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//用于栈的push 与 pop</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; ST; </span><br><span class="line">    <span class="comment">//用于存储最小min</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; ST_Min;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        ST.<span class="built_in">push</span>(value); </span><br><span class="line">        <span class="comment">//空或者新元素较小，则入栈</span></span><br><span class="line">        <span class="keyword">if</span>(ST_Min.<span class="built_in">empty</span>() ||  value &lt; ST_Min.<span class="built_in">top</span>()) </span><br><span class="line">            ST_Min.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">//重复加入栈顶</span></span><br><span class="line">            ST_Min.<span class="built_in">push</span>(ST_Min.<span class="built_in">top</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ST.<span class="built_in">pop</span>();</span><br><span class="line">        ST_Min.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ST.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ST_Min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路二：用 vector 模拟栈，通过 std:: min_element 获取最小值（时间复杂度较高，不推荐）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vec.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vec.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vec.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vec.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *std::<span class="built_in">min_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】栈的压入、弹出序列"><a href="#【剑】栈的压入、弹出序列" class="headerlink" title="【剑】栈的压入、弹出序列"></a>【剑】栈的压入、弹出序列</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=23290&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>解题思路：辅助栈</p>
<p>首先我们创建一个辅助栈 stack，并初始化。然后遍历 pushV，依次把元素压入该辅助栈中：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200237.png" alt="Pasted image 20240222144208"><br>压入每个元素的同时<strong>比较辅助栈的栈顶元素与 popV 的初始元素，当发现两元素相等的时候就弹出该栈顶元素，同时j++</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200238.png" alt="Pasted image 20240222144217|350"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200239.gif" alt="Pasted image 20240222144230|349"><br>此时辅助栈中就只有三个元素，因为 pushV 还有元素，所以接着添加到辅助栈中，再同 popV 的下一个元素比较：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200240.jpg" alt="Pasted image 20240222144242"><br>发现又是相等的两元素，所以继续弹出 stack 中的栈顶元素；后面就一直重复这个过程。<strong>直到最后辅助栈清空！而 popV 的 j 值刚好等于 popV 的长度</strong>，此时这个 popV 的顺序就是压入栈的弹出顺序！！！<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200241.png" alt="Pasted image 20240222144249"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushV, vector&lt;<span class="type">int</span>&gt;&amp; popV)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; ST;  <span class="comment">//辅助栈</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//遍历popV的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把pushV中的元素依次添加到辅助栈ST中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> var : pushV)</span><br><span class="line">        &#123;</span><br><span class="line">            ST.<span class="built_in">push</span>(var);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!ST.<span class="built_in">empty</span>() &amp;&amp; ST.<span class="built_in">top</span>()==popV[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ST.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j==popV.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)(因为辅助栈的最差就是遍历整个压入栈长度，花费时间是n；同理空间复杂度也是n）</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>掌握上述方法即可。</p>
<p>拓展：<br>其实我们还<strong>可以不用辅助栈，直接在pushV数组上进行操作</strong>（仔细看上面的分析就可以知道辅助栈跟 pushV是一样的），这样可以把空间复杂度**优化为只需要O(1)**。</p>
<ul>
<li>当<code>pushV[i] != popV[0]</code>元素，表示还没匹配到待弹出元素；继续<code>i = i + 1</code>压入元素；</li>
<li>当 <code>push[i] == popV[0]</code> 时，即匹配上弹出元素，并 <code>i = i - 1</code> 让它始终指向 pushV 的顶部元素；同时 popV 也要更新到下一个元素 <code>j = j + 1</code>，使其成为新的 <code>popV[0]</code>。最后直到 pushV 和 popV 都为空即匹配结束。</li>
</ul>
<p>python 代码供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsPopOrder</span>(<span class="params">self, pushV, popV</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#不用辅助栈，直接把pushV当作stack来处理</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> pushV:</span><br><span class="line">            pushV[i] = x                                     <span class="comment">#直接把pushV当作压入栈</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> pushV[i] == popV[j]:            <span class="comment">#当pushV的当前元素等于popV弹出列的顶部元素</span></span><br><span class="line">                i, j = i - <span class="number">1</span>, j + <span class="number">1</span>                          <span class="comment">#分别更新栈顶元素</span></span><br><span class="line">            i += <span class="number">1</span>                                           <span class="comment">#否则继续往pushV压入栈中添加元素</span></span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>                                         <span class="comment">#直到pushV的索引减小为0</span></span><br></pre></td></tr></table></figure>
<h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p>
<p><strong>栈的经典应用：括号匹配</strong></p>
<ul>
<li><p><code> ([()])</code> 最后出现的左括号最先被匹配 (栈的特性—先进后出);</p>
</li>
<li><p>遇到左括号就入栈;</p>
</li>
<li><p>遇到右括号，就 “消耗” 一个左括号 (出栈); </p>
</li>
<li><p>匹配失败情况：</p>
<ul>
<li>扫描到右括号且栈空，说明栈中没有与该右括号匹配的的左括号。</li>
<li>扫描完所有括号后，栈非空，说明栈中的左括号没有与之匹配的右括号。</li>
<li>左右括号不匹配;</li>
</ul>
</li>
</ul>
<ul>
<li>成功的情况：遍历完字符串，栈是空的，就说明全都匹配了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; ST;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遇到左括号就入栈;</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ST.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//扫描到右括号且栈空，说明栈中没有与该右括号匹配的的左括号。</span></span><br><span class="line">                <span class="keyword">if</span>(ST.empty()) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左右括号不匹配</span></span><br><span class="line">                <span class="type">char</span> TopElem = ST.top();</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; TopElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; TopElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; TopElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//遇到右括号，匹配成功，就 “消耗” 一个左括号 (出栈); </span></span><br><span class="line">                ST.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描完字符串</span></span><br><span class="line">        <span class="comment">//栈空，则匹配成功</span></span><br><span class="line">        <span class="comment">//栈非空，说明栈中的左括号没有与之匹配的右括号,则匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> ST.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p>
<p>string 当作栈使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> str : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//string最后一个元素当作栈顶元素</span></span><br><span class="line">            <span class="comment">//如果相等，就让栈顶出栈</span></span><br><span class="line">            <span class="comment">//注意：应先判断栈是否为空，再调用back()函数。因为当栈为空时，调用back()函数会导致未定义行为。</span></span><br><span class="line">            <span class="keyword">if</span>(!ans.<span class="built_in">empty</span>() &amp;&amp; str == ans.<span class="built_in">back</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//不相等就入栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p>
<p>逆波兰表达式即<strong>后缀表达式</strong>（将运算符写在操作数之后）。</p>
<p>中缀表达式不仅依赖运算符的优先级，而且还要处理括号。<br>后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。<br>中缀表达式 <code>A+B*(C-D)-E/F</code> 所对应的后缀表达式为 <code>ABCD-*+EF/-</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200244.png" alt="Pasted image 20231219092013"><br><strong>后缀表示计算表达式值的过程</strong>:<br>顺序扫描表达式的每一项，然后根据它的类型做如下相应操作: </p>
<ul>
<li>若该项是操作数，则将其压入栈中; </li>
<li>若该项是操作符 <code>&lt;op&gt;</code>，则连续从栈中退出两个操作数 <code>Y</code> 和 <code>X</code>，形成运算指令 <code>X&lt;op&gt;Y</code>，并将计算结果重新压入栈中。</li>
<li>当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若该项是操作符 &lt;op&gt;，则连续从栈中退出两个操作数 Y 和 X，形成运算指令 X&lt;op&gt;Y，并将计算结果重新压入栈中。</span></span><br><span class="line">            <span class="keyword">if</span>(token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意顺序，先弹出的是Y</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> Y = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> X = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(token == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(X + Y);</span><br><span class="line">                <span class="keyword">if</span>(token == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(X - Y);</span><br><span class="line">                <span class="keyword">if</span>(token == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(X * Y);</span><br><span class="line">                <span class="keyword">if</span>(token == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(X / Y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若该项是操作数，则将其压入栈中; </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(token)); <span class="comment">//注意将string转换为longlong</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】最小的-K-个数"><a href="#【剑】最小的-K-个数" class="headerlink" title="【剑】最小的 K 个数"></a>【剑】最小的 K 个数</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=23263&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">最小的K个数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>法一：<code>priority_queue</code> 小根堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.<span class="built_in">size</span>() || k==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : input)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二：直接 sort 快排</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.<span class="built_in">size</span>() || k==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            res.<span class="built_in">push_back</span>(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p>
<p>法一：**<code>priority_queue</code> 小根堆**，根据频率排序，所以要自定义排序规则</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的就是前k个最大元素。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数对象，自定义排序规则</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">comp</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//map统计出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Num_To_Count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++Num_To_Count[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, comp&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = Num_To_Count.<span class="built_in">begin</span>();it!=Num_To_Count.<span class="built_in">end</span>();++it)</span><br><span class="line">        &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>()&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出堆中的元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二：直接 sort 快排</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//map统计出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Num_To_Count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++Num_To_Count[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无法直接对map排序，所以将map值复制到vector中进行排序</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(Num_To_Count.<span class="built_in">begin</span>(),Num_To_Count.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据出现次数降序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">        [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; A,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; B)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.second &gt; B.second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出前k个元素</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;++i)</span><br><span class="line">         &#123;</span><br><span class="line">             res.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】滑动窗口最大值（单调队列）（未掌握）"><a href="#【剑】滑动窗口最大值（单调队列）（未掌握）" class="headerlink" title="【剑】滑动窗口最大值（单调队列）（未掌握）"></a>【剑】滑动窗口最大值（单调队列）（未掌握）</h2><p>单调队列 </p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=23458&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">滑动窗口的最大值_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<p>设窗口区间为 $[i, j]$ ，最大值为 $x_j$​ 。当窗口向前移动一格，则区间变为 $[i+1, j+1]$ ，即添加了 $nums[j+1]$，删除了 $nums[i]$。</p>
<p>若只向窗口 $[i, j]$ 右边添加数字 $nums[j+1]$ ，则新窗口最大值可以 <strong>通过一次对比</strong> 使用  $O(1)$ 时间得到，即：<br>$$x_{j+1} &#x3D; \max (x_{j}, nums[j + 1])$$</p>
<p>而由于删除的 $nums[i]$ 可能恰好是窗口内唯一的最大值 $x_j$  ，因此不能通过以上方法计算 $x_{j+1}​$ ，而必须使用 $O (j−i)$ 时间， <strong>遍历整个窗口区间</strong> 获取最大值，即：<br>$$x_{j+1} &#x3D; \max (nums (i+1), \cdots , num (j+1))$$</p>
<p>根据以上分析，可得 <strong>暴力法</strong> 的时间复杂度为 $O ((n-k+1) k) \approx O (nk)$</p>
<hr>
<ul>
<li>设数组 <code>nums</code> 的长度为 $n$ ，则共有 $(n−k+1)$个窗口；<ul>
<li>窗口数量 &#x3D; 数组末尾元素下标 - 第一个滑动窗口最后元素的下标 + 1 &#x3D; (n-1) - (k-1) + 1&#x3D; n-k+1</li>
</ul>
</li>
<li>获取每个窗口最大值需线性遍历，时间复杂度为 $O (k)$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200246.png" alt="6496d5305b9def3fa2a5f7eb99b32920_MD5"></p>
<blockquote>
<p><strong>本题难点：</strong> 如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 $O(k)$ 降低至 $O(1)$ 。</p>
</blockquote>
<p>[[#【剑】包含 min 函数的栈（最小栈）]]使用 <strong>单调栈</strong> 实现了随意入栈、出栈情况下的 $O (1)$ 时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，<strong>而 “窗口滑动” 删除的是 “列表首部元素”</strong> 。<br>![[Pasted image 20230825103846.jpg]]<br>⭐窗口对应的数据结构为 <strong>双端队列 deque</strong> ，将其实现为<strong>单调队列</strong>。遍历数组时，每轮保证单调队列 ：</p>
<ol>
<li>deque 内 <strong>仅包含窗口内的元素</strong> ⇒ 每轮窗口滑动移除了元素 $nums[i−1]$ ，需将 deque 内的对应元素一起删除。</li>
<li>deque 内的元素 **非严格递减 ⇒ 每轮窗口滑动添加了元素 $nums[j+1]$ ，需将 deque 内所有 $&lt;nums[j+1]$ 的元素删除。</li>
</ol>
<p><strong>算法流程：</strong></p>
<ol>
<li><strong>初始化：</strong> 双端队列 deque ，结果列表 res ，数组长度 n ；</li>
<li><strong>滑动窗口：</strong> 左边界范围 $i∈[1−k, n−k]$ ，右边界范围 $j∈[0, n−1]$<ol>
<li>若 $i&gt;0$ 且队首元素等于被删除元素 <code>deque.front() == nums[i - 1]</code>，则队首元素出队；</li>
<li>删除 deque 内所有 $&lt;nums[j]$的元素，以保持deque 递减；</li>
<li>将 $nums[j]$ 添加至 deque 尾部；</li>
<li>若已形成窗口（即 $i≥0$ ）：将窗口最大值（即队首元素）添加至列表 res ；</li>
</ol>
</li>
<li><strong>返回值：</strong> 返回结果列表 res；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200247.png" alt="Pasted image 20240222202745"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200250.png" alt="Pasted image 20240222202855"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200255.png" alt="Pasted image 20240222202819"><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200256.png" alt="Pasted image 20240222203843"><br>依次移动窗口直到 j 指向 deque 末尾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n - k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>-k, j = <span class="number">0</span>; j &lt; n; i++, j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若 i&gt;0 且队首元素等于被删除元素，则队首元素出队</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.<span class="built_in">front</span>() == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                deque.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除 deque 内所有 &lt;nums[j]的元素，以保持deque递减；</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.<span class="built_in">empty</span>() &amp;&amp; deque.<span class="built_in">back</span>() &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                deque.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 nums[j] 添加至 deque 尾部</span></span><br><span class="line">            deque.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若已形成窗口（即i≥0）：将窗口最大值（即队首元素）添加至 res </span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = deque.<span class="built_in">front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O (n) ：</strong> 其中 n 为数组 nums 长度；线性遍历 nums占用 O (n)  ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O (2n) </li>
<li><strong>空间复杂度 O (k)：</strong> 双端队列 deque 中最多同时存储 k 个元素（即窗口大小）。</li>
</ul>
<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><p>链式存储的二叉树节点的定义方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>树的深度优先遍历：</p>
<ul>
<li>前序</li>
<li>中序</li>
<li>后序</li>
</ul>
<p>树的广度优先遍历：</p>
<ul>
<li>层序遍历</li>
</ul>
<p>遍历方法有递归法和迭代法（非递归法）</p>
<h2 id="1-递归遍历"><a href="#1-递归遍历" class="headerlink" title="1 递归遍历"></a>1 递归遍历</h2><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><p>递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>好了，我们确认了递归的三要素，接下来就来练练手：</p>
<p><strong>以下以前序遍历为例：</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入 vector 来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是 void，代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接 return，代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>确定单层递归的逻辑</strong>：前序遍历是根左右的循序，所以在单层递归的逻辑，是要先取根节点的数值，代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 访问根节点</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure>

<p>单层递归的逻辑就是按照根左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p>
<h3 id="前序遍历（根左右）"><a href="#前序遍历（根左右）" class="headerlink" title="前序遍历（根左右）"></a>前序遍历（根左右）</h3><p>若二叉树为空，不用操作<br>若二叉树非空：</p>
<ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>N 叉树前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(Node* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> child : cur-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(child,vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历（左根右）"><a href="#中序遍历（左根右）" class="headerlink" title="中序遍历（左根右）"></a>中序遍历（左根右）</h3><p>若二叉树为空，不用操作</p>
<p>若二叉树非空：</p>
<ul>
<li>先序遍历左子树</li>
<li>访问根节点</li>
<li>先序遍历右子树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);  <span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);   <span class="comment">//访问根节点 </span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历（左右根）"><a href="#后序遍历（左右根）" class="headerlink" title="后序遍历（左右根）"></a>后序遍历（左右根）</h3><p>若二叉树为空，不用操作<br>若二叉树非空：  </p>
<ul>
<li>先序遍历左子树  </li>
<li>先序遍历右子树  </li>
<li>访问根节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);  <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec); <span class="comment">//右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);   <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归二叉树的返回值"><a href="#递归二叉树的返回值" class="headerlink" title="递归二叉树的返回值"></a>递归二叉树的返回值</h3><p><strong>递归函数究竟什么时候需要返回值，什么时候不要返回值？</strong></p>
<ul>
<li>需要搜索整颗二叉树，递归函数就不要返回值</li>
<li>要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</li>
</ul>
<p><strong>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</strong><br>搜索一条边的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);  <span class="comment">// 左</span></span><br><span class="line">right = 递归函数(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">left与right的逻辑处理;         <span class="comment">// 中 </span></span><br></pre></td></tr></table></figure>


<p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量 left、right 接住返回值，这个 left、right 后续还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p>
<h2 id="2-迭代遍历"><a href="#2-迭代遍历" class="headerlink" title="2 迭代遍历"></a>2 迭代遍历</h2><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>所以<strong>用栈也可以实现二叉树的前后中序遍历</strong>。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>我们使用栈来进行迭代，过程如下：</p>
<ol>
<li>初始化栈，并将根节点入栈；</li>
<li>当栈不为空时：<ul>
<li>弹出栈顶元素 node，并将值添加到结果中；</li>
<li>如果 node 的右子树非空，将右子树入栈；</li>
<li>如果 node 的左子树非空，将左子树入栈；</li>
</ul>
</li>
</ol>
<p><strong>为什么要先右子树入栈，再左子树入栈？ 因为这样出栈的时候才是中左右的顺序。</strong>**<br>**<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200260.png" alt="二叉树前序遍历（迭代法）"></p>
<p><strong>注意代码中空节点不入栈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; ST;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入栈</span></span><br><span class="line">        ST.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = ST.<span class="built_in">top</span>(); <span class="comment">//根（出栈）</span></span><br><span class="line">            ST.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//访问根节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) ST.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) ST.<span class="built_in">push</span>(node-&gt;left);   <span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>注意，前序迭代遍历的逻辑无法直接应用到中序遍历上。</p>
<p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p>
<p>动画如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200263.png" alt="二叉树中序遍历（迭代法）"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; ST;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span> || !ST.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从根节点一路沿着左边访问到叶子节点，沿途节点全部入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ST.<span class="built_in">push</span>(cur);    <span class="comment">//入栈</span></span><br><span class="line">                cur = cur-&gt;left; <span class="comment">//左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//访问到叶子节点的左节点，cur==NULL</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = ST.<span class="built_in">top</span>();  <span class="comment">// 弹出叶子节点，叶子节点作为中</span></span><br><span class="line">                ST.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//访问根节点</span></span><br><span class="line">                cur = cur-&gt;right; <span class="comment">//右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>思路和先序类似，我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转 result 数组，输出的结果顺序就是左右中了，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200265.png" alt="bd15c643bfe8a0575eb8d7ee809f1092_MD5"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; ST;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入栈</span></span><br><span class="line">        ST.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!ST.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = ST.<span class="built_in">top</span>(); <span class="comment">//根（出栈）</span></span><br><span class="line">            ST.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//访问根节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//相对于前序遍历，这更改一下入栈顺序</span></span><br><span class="line">            <span class="comment">//出栈顺序为中右左</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) ST.<span class="built_in">push</span>(node-&gt;left); <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) ST.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转，中右左-&gt;左右中</span></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="01-标记法统一模板-推荐"><a href="#01-标记法统一模板-推荐" class="headerlink" title="01 标记法统一模板 (推荐)"></a>01 标记法统一模板 (推荐)</h3><p>上述三种迭代遍历，无法统一模板，不方便记忆。01 标记法可以将这三种迭代遍历统一起来。<br><strong>这种方法的本质</strong>是二叉树的遍历时，每个节点都要入栈两次后才能访问其元素值，第一次入栈是不能访问其值的，因为第一次入栈是第一次访问该节点，需要先访问该节点的左子树，这时会把该结点和左子树都入栈，所以第二次出栈就可以访问该结点的值。</p>
<p><strong>使用 01 标记节点，新节点为 0，已访问的节点为 1。以前序遍历为例：</strong></p>
<ol>
<li>首先根节点入栈，标记为 0</li>
<li>然后访问栈顶，并出栈。将其右子节点（标记 0）、左子节点（标记 0）、自身（标记1）依次入栈。</li>
<li>如果遇到的节点为 1，则将节点的值输出。</li>
</ol>
<p><strong>为什么要先右子节点入栈，再左子节点入栈？ 因为这样出栈的时候才是中左右的顺序。</strong></p>
<p><strong>前序和后序同理，只需要更改入栈顺序，注意入栈顺序和出栈顺序是相反的。我们需要的是正确的出栈顺序</strong></p>
<p>前序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt; &gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = st.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">auto</span> tag = st.<span class="built_in">top</span>().second;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果为0，入栈</span></span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="number">0</span>&#125;); <span class="comment">//右</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="number">0</span>&#125;);  <span class="comment">//左</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node, <span class="number">1</span>&#125;);        <span class="comment">//根，标记为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果为1，输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tag == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//访问根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tag == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="number">0</span>&#125;); <span class="comment">//右</span></span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node, <span class="number">1</span>&#125;);        <span class="comment">//根，标记为1</span></span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="number">0</span>&#125;);  <span class="comment">//左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tag == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node, <span class="number">1</span>&#125;);        <span class="comment">//根，标记为1</span></span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="number">0</span>&#125;); <span class="comment">//右</span></span><br><span class="line">    st.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="number">0</span>&#125;);  <span class="comment">//左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】由遍历序列构造二叉树"><a href="#【剑】由遍历序列构造二叉树" class="headerlink" title="【剑】由遍历序列构造二叉树"></a>【剑】由遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=23282&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">重建二叉树_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<p>![[1 数据结构#由遍历序列构造二叉树]]</p>
<h4 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<p><strong>关键点：前序遍历首元素是二叉树的根节点</strong><br>递归边界：如果 <code>postorder</code> 的长度是 0（此时 <code>inorder</code> 的长度也是 0），对应着空节点，返回 nullptr 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200266.png" alt="Pasted image 20240223150407"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> root_val = preorder[<span class="number">0</span>]; <span class="comment">//前序首一个元素是根节点</span></span><br><span class="line">        <span class="keyword">auto</span> root_it = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), root_val); <span class="comment">//在中序中找到root的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中序root左边是左子树，右边是右子树（注意end迭代器指向数组末尾元素的下一个位置）</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L_inorder</span><span class="params">(inorder.begin(), root_it)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R_inorder</span><span class="params">(root_it + <span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据左右子树的大小获取前序中左右子树的数组范围</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L_preorder</span><span class="params">(preorder.begin() + <span class="number">1</span>, preorder.begin() + <span class="number">1</span> + L_inorder.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R_preorder</span><span class="params">(preorder.begin() + <span class="number">1</span> + L_inorder.size(), preorder.end())</span></span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归左右子树(注意参数顺序别填反了)</span></span><br><span class="line">        TreeNode *left = <span class="built_in">buildTree</span>(L_preorder, L_inorder);</span><br><span class="line">        TreeNode *right = <span class="built_in">buildTree</span>(R_preorder, R_inorder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建二叉树</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val, left, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<p><strong>关键点：后序遍历末尾元素是二叉树的根节点</strong></p>
<p>递归边界：如果 <code>preorder</code> 的长度是 0（此时 <code>inorder</code> 的长度也是 0），对应着空节点，返回 nullptr 。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200267.png" alt="Pasted image 20240223145940"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> root_val = postorder.<span class="built_in">back</span>(); <span class="comment">//后序最后一个元素是根节点</span></span><br><span class="line">        <span class="keyword">auto</span> root_it = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), root_val); <span class="comment">//在中序中找到root的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中序root左边是左子树，右边是右子树（注意end迭代器指向数组末尾元素的下一个位置）</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L_inorder</span><span class="params">(inorder.begin(), root_it)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R_inorder</span><span class="params">(root_it + <span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据左右子树的大小获取后序中左右子树的数组范围</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L_postorder</span><span class="params">(postorder.begin(), postorder.begin() + L_inorder.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R_postorder</span><span class="params">(postorder.begin() + L_inorder.size(), postorder.end() - <span class="number">1</span>)</span></span>; <span class="comment">//-1是因为末尾是root</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归左右子树</span></span><br><span class="line">        TreeNode *left = <span class="built_in">buildTree</span>(L_inorder, L_postorder);</span><br><span class="line">        TreeNode *right = <span class="built_in">buildTree</span>(R_inorder, R_postorder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建二叉树</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val, left, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="3-层序遍历"><a href="#3-层序遍历" class="headerlink" title="3 层序遍历"></a>3 层序遍历</h2><h3 id="【剑】二叉树的层序遍历"><a href="#【剑】二叉树的层序遍历" class="headerlink" title="【剑】二叉树的层序遍历"></a>【剑】二叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=23280&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">从上往下打印二叉树_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=23453&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把二叉树打印成多行_牛客题霸_牛客网 (nowcoder.com)</a><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200269.png" alt="Pasted image 20230905105548"></p>
<p>要进行层次遍历，需要借助一个<strong>队列<code>queue</code><strong>。（</strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。）</strong><br><strong>这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p>
<ul>
<li>先将二叉树根结点入队</li>
<li>然后队头节点出队，访问出队结点，<ul>
<li>若它有左子树，则将左子树根结点入队; </li>
<li>若它有右子树，则将右子树根结点入队。</li>
</ul>
</li>
<li>如此反复，直至队列为空。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200270.png" alt="102二叉树的层序遍历"><br>迭代遍历（推荐）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que; <span class="comment">//使用队列实现层序遍历</span></span><br><span class="line"></span><br><span class="line">        que.<span class="built_in">push</span>(root); <span class="comment">//根结点入队</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每一层</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>(); <span class="comment">//保存que初始size</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 逐个处理本层中的节点</span></span><br><span class="line">            <span class="comment">// 这里一定要使用que初始size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队头节点出队，访问队头节点</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若它有左子树，则将左子树根结点入队;</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="comment">//若它有右子树，则将右子树根结点入队; </span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归前序遍历实现层序遍历</span></span><br><span class="line">    <span class="comment">//利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果depth &gt;= vector.size()说明这一层还没来过，这是第一次来，所以得扩容</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= result.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容后将根节点添加到结果数组</span></span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//访问根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth+<span class="number">1</span>); <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth+<span class="number">1</span>);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">order</span>(root,result,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下题目都是用层序遍历，套用迭代遍历模板即可。</p>
<h3 id="二叉树的层序遍历-II"><a href="#二叉树的层序遍历-II" class="headerlink" title="二叉树的层序遍历 II"></a>二叉树的层序遍历 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/discussion/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a><br>题目要求倒序输出层序遍历的结果，只需要把正序层序遍历的 result 数组反转一下就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里反转一下数组即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】从上往下打印二叉树"><a href="#【剑】从上往下打印二叉树" class="headerlink" title="【剑】从上往下打印二叉树"></a>【剑】从上往下打印二叉树</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=23280&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">从上往下打印二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>套用层序遍历模板即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; res; <span class="comment">//存储节点值</span></span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line"></span><br><span class="line">		que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">				que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(node != <span class="literal">nullptr</span>) <span class="comment">//题目要求空节点不打印</span></span><br><span class="line">				&#123;</span><br><span class="line">					res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200271.png" alt="Pasted image 20231221105121"><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//该数组记录每一层的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//或者不使用vec数组，在这里判断当前索引是否是最后一个元素，如果是，直接放入结果数组</span></span><br><span class="line">                <span class="comment">//if(i == (size-1)) result.push_back(node-&gt;val;)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>()); <span class="comment">//将每一层的最后一个元素存入结果数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//层序遍历的时候把一层求个总和在取一个均值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>; <span class="comment">//统计每一层的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val; <span class="comment">//求和</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="built_in">push_back</span>(sum/size); <span class="comment">//求平均</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="N-叉树的层序遍历"><a href="#N-叉树的层序遍历" class="headerlink" title="N 叉树的层序遍历"></a>N 叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/">429. N 叉树的层序遍历 - 力扣（LeetCode）</a></p>
<p>区别在于将 N 叉树有多个孩子节点（二叉树只有 left 和right），遍历 push 进队列即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> child : node-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(child) que.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h3><p>层序遍历，取每一层的最大值<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">515. 在每个树行中找最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> MaxValue = INT_MIN; <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//更新最大值</span></span><br><span class="line">                MaxValue = <span class="built_in">max</span>(node-&gt;val, MaxValue);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="built_in">push_back</span>(MaxValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a><br>两题解法一致<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200272.jpg" alt="Pasted image 20231221153052"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//除了每行最后一个元素，所有元素都将next指向右边的节点</span></span><br><span class="line">                <span class="comment">//因为node为当前根节点，pop之后que.front()即为node的下一个节点</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;size<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】二叉树的深度"><a href="#【剑】二叉树的深度" class="headerlink" title="【剑】二叉树的深度"></a>【剑】二叉树的深度</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=23294&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的深度_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>递归写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">TreeDepth</span>(pRoot-&gt;left),<span class="built_in">TreeDepth</span>(pRoot-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法，使用层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">//记录深度</span></span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line"></span><br><span class="line">		que.<span class="built_in">push</span>(pRoot);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//扫描每一层</span></span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">			depth++; <span class="comment">//每一层+1</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">				que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最大-最小深度"><a href="#二叉树的最大-最小深度" class="headerlink" title="二叉树的最大&#x2F;最小深度"></a>二叉树的最大&#x2F;最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a><br>本题定义：二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">//记录最大深度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> CurrentDepth = <span class="number">0</span>;   <span class="comment">//记录当前深度</span></span><br><span class="line">        <span class="type">int</span> MinDepth = INT_MAX; <span class="comment">//记录最小深度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            CurrentDepth++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当遍历到叶子节点时，更新最小深度</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    MinDepth = CurrentDepth &lt; MinDepth ? CurrentDepth : MinDepth;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MinDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录第一个元素值</span></span><br><span class="line">                <span class="comment">// 直到que.empty()结束循环，记录的正是最后一行的第一个元素值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) result = node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-综合"><a href="#4-综合" class="headerlink" title="4 综合"></a>4 综合</h2><h3 id="【剑】二叉树的下一个结点"><a href="#【剑】二叉树的下一个结点" class="headerlink" title="【剑】二叉树的下一个结点"></a>【剑】二叉树的下一个结点</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的下一个结点_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>next 指针指向父节点，向上遍历找到根节点，然后中序遍历获得递增数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeLinkNode*&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeLinkNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//向上遍历直到找到根节点（根节点的next==nullptr)</span></span><br><span class="line">        TreeLinkNode* root = pNode;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;next!=<span class="literal">nullptr</span>) root = root-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从中序遍历数组中找到pNode，然后返回下一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; vec.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; vec[i] == pNode) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> vec[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】翻转二叉树（镜像）"><a href="#【剑】翻转二叉树（镜像）" class="headerlink" title="【剑】翻转二叉树（镜像）"></a>【剑】翻转二叉树（镜像）</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/discussion/">226. 翻转二叉树 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tqId=1374963&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的镜像_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>思路：把每一个节点的左右孩子交换一下</p>
<p>可以使用前序遍历、后序遍历、层序遍历，中序不太方便（中序会将某些节点反转两次）</p>
<p>层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//反转左右子树</span></span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left,node-&gt;right);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前序递归遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right); <span class="comment">//根</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);      <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);     <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前序迭代遍历（01 标记）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt; &gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = st.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">auto</span> tag = st.<span class="built_in">top</span>().second;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果为0，入栈</span></span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="number">0</span>&#125;); <span class="comment">//右</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="number">0</span>&#125;);  <span class="comment">//左</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node, <span class="number">1</span>&#125;);        <span class="comment">//根，标记为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果为1，输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tag == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left,node-&gt;right); <span class="comment">//根</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/discussion/">101. 对称二叉树 - 力扣（LeetCode）</a><br>递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span> &amp;&amp; right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right !=<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span> &amp;&amp; (left-&gt;val != right-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="comment">// 左子树（左右中），右子树（右左中）</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left,right-&gt;right); </span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//有两种情况节点left和节点right对称</span></span><br><span class="line">        <span class="comment">//1. left和right为空</span></span><br><span class="line">        <span class="comment">//2. left和right节点不为空，且值相等</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right &amp;&amp; left-&gt;val == right-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归判断节点left和right的下一层</span></span><br><span class="line">            <span class="comment">// 比较节点left和right的内侧和外侧是否对称</span></span><br><span class="line">            <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">            <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200273.png" alt="101.对称二叉树"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把左右两个子树要比较的元素顺序放进队列，然后成对成对的取出来进行比较（用栈也可以）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);  <span class="comment">//左子树头结点入队</span></span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right); <span class="comment">//右子树头结点入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* leftNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">nullptr</span> &amp;&amp; rightNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right !=<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span> &amp;&amp; (left-&gt;val != right-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//外侧</span></span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//内测</span></span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/discussion/">100. 相同的树 - 力扣（LeetCode）</a></p>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//有两种情况节点A和节点B对称</span></span><br><span class="line">        <span class="comment">//1. A和B都为空</span></span><br><span class="line">        <span class="comment">//2. A和B节点不为空，且值相等</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> &amp;&amp; B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A &amp;&amp; B &amp;&amp; A-&gt;val == B-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归判断节点A和B的下一层</span></span><br><span class="line">            <span class="type">bool</span> leftside = <span class="built_in">isSame</span>(A-&gt;left,B-&gt;left);</span><br><span class="line">            <span class="type">bool</span> rightside = <span class="built_in">isSame</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> leftside &amp;&amp; rightside;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/description/">572. 另一棵树的子树 - 力扣（LeetCode）</a></p>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//有两种情况节点A和节点B对称</span></span><br><span class="line">        <span class="comment">//1. A和B都为空</span></span><br><span class="line">        <span class="comment">//2. A和B节点不为空，且值相等</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> &amp;&amp; B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A &amp;&amp; B &amp;&amp; A-&gt;val == B-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归判断节点A和B的下一层</span></span><br><span class="line">            <span class="type">bool</span> leftside = <span class="built_in">isSameTree</span>(A-&gt;left,B-&gt;left);</span><br><span class="line">            <span class="type">bool</span> rightside = <span class="built_in">isSameTree</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> leftside &amp;&amp; rightside;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSameTree</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//根</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right,subRoot); <span class="comment">//左右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】树的子结构"><a href="#【剑】树的子结构" class="headerlink" title="【剑】树的子结构"></a>【剑】树的子结构</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=23293&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">树的子结构_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/">LCR 143. 子结构判断 - 力扣（LeetCode）</a></p>
<p>和 [[#另一棵树的子树]] 不同，该题判断的是子结构！子树是判断是否相等，子结构是判断是否包含。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200274.png" alt="Pasted image 20240225110655"></p>
<blockquote>
<p>如图，SubRoot 是 root 的子结构，但不是 root 的子树</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200276.png" alt="Pasted image 20240225111720"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="comment">//B为空，说明 B 已匹配完成（越过叶子节点）</span></span><br><span class="line">		<span class="keyword">if</span>(B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//A为空，说明已经越过树 A 的叶节点，说明匹配失败</span></span><br><span class="line">		<span class="comment">//值不相等，说明匹配失败</span></span><br><span class="line">		<span class="keyword">if</span>(A == <span class="literal">nullptr</span> || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="built_in">recur</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断B是否为A的子结构</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">recur</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不是，则递归A的左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a><br>可以直接使用常规二叉树的层序、递归、迭代遍历<br>或者利用完全二叉树的性质解题，时间复杂度更低。</p>
<p><strong>根据完全二叉树的性质简化遍历次数</strong></p>
<ul>
<li>这是一棵完全二叉树：除最后一层外，其余层全部铺满；且最后一层向左停靠</li>
<li><strong>如果根节点的左子树深度大于右子树深度，则说明右子树为满二叉树</strong> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200280.png" alt="cc56172b22a7e774c67d548a63d05546_MD5"></li>
<li><strong>如果根节点的左子树深度等于右子树深度，则说明左子树为满二叉树</strong> <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200281.png" alt="Pasted image 20231225103456"></li>
</ul>
<p>如果知道子树是满二叉树，那么就可以轻松得到该子树的节点数目：$2^{depth}-1$ 。其中 <code>depth</code> 为子树的深度；为了加快幂的运算速度，可以使用移位操作符 <code>(1&lt;&lt;depth) - 1</code><br>接着我们只需要接着对另一子树递归即可<br>时间复杂度为 <code>O (logn∗logn) </code>，空间复杂度为<code> O (1)</code>【不考虑递归调用栈】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据完全二叉树的性质简化遍历次数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//计算深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> Depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            ++Depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//求左右子树深度</span></span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">countDepth</span>(root-&gt;left); <span class="comment">//实际上左子树深度每次递归都减1，没必要每次都重新计算，这里可以优化。</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">countDepth</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点的左子树深度等于右子树深度，则说明左子树为满二叉树 </span></span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,leftDepth) - <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>; <span class="comment">//别忘了+1,将root节点算进去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果根节点的左子树深度大于右子树深度，则说明右子树为满二叉树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,rightDepth) - <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="【剑】二叉树中和为某一值的路径"><a href="#【剑】二叉树中和为某一值的路径" class="headerlink" title="【剑】二叉树中和为某一值的路径"></a>【剑】二叉树中和为某一值的路径</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/965fef32cae14a17a8e86c76ffe3131f?tpId=13&tqId=2277604&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树中和为某一值的路径(三)_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询路径数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> sum, <span class="type">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        curSum += node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (curSum == sum)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;left, sum, curSum);</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;right, sum, curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">traversal</span>(root, sum, <span class="number">0</span>);    <span class="comment">//根</span></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, sum);  <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, sum); <span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404. 左叶子之和 - 力扣（LeetCode）</a></p>
<p>左叶子的明确定义：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200283.png" alt="Pasted image 20240112064613"></p>
<p>⭐<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong><br>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归（中序）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left); <span class="comment">//左</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) <span class="comment">//中，判断左子树是左叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right); <span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代（01 标记法）前中后都可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt; &gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点入栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = st.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">auto</span> tag = st.<span class="built_in">top</span>().second;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果为0，入栈</span></span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="number">0</span>&#125;); <span class="comment">//右</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="number">0</span>&#125;);  <span class="comment">//左</span></span><br><span class="line">                st.<span class="built_in">push</span>(&#123;node, <span class="number">1</span>&#125;);        <span class="comment">//根，标记为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果为1，输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tag == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//访问根节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    result += node-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>层序遍历也可以，略</p>
<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></p>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxValue)</span><br><span class="line">            &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大值所在的下标左区间 构造左子树</span></span><br><span class="line">        <span class="keyword">if</span>(maxValueIndex &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最大值所在的下标右区间 构造右子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200284.png" alt="Pasted image 20240112093444"></p>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不为 null 的节点将直接作为新二叉树的节点</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2; </span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        <span class="comment">//前序遍历（中序、后序皆可）</span></span><br><span class="line">        node-&gt;val = root1-&gt;val + root2-&gt;val; </span><br><span class="line">        node-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left); </span><br><span class="line">        node-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p>贪心</p>
<p>摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。<br><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p>
<p><strong>确定遍历顺序</strong>：从下往上推导，后序遍历（左右根）</p>
<p>每个节点可能有如下三种状态，我们分别有三个数字来表示：</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<p><strong>空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong><br>回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。<br>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。<br><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p>
<p>递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空节点，该节点有覆盖</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>主要有如下四类情况：</p>
<ul>
<li><p>情况1：左右节点都有覆盖，那么此时中间节点应该就是无覆盖的状态了。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200287.png" alt="Pasted image 20240224101230|600"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右节点都有覆盖</span></span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况2：左右节点至少有一个无覆盖，则中间节点（父节点）应该放摄像头：</p>
</li>
</ul>
<p>这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。</p>
<p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况3：左右节点至少有一个有摄像头<br>如果是以下情况，其实就是左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如果 left &#x3D;&#x3D; 1, right &#x3D;&#x3D; 0 怎么办？其实这种条件在情况2中已经判断过了</strong>，如图<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200288.png" alt="Pasted image 20240224101550|500"></p>
<ul>
<li>情况4：头结点没有覆盖</li>
</ul>
<p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200289.png" alt="Pasted image 20240224101614"><br>所以递归结束之后，还要判断根节点，如果没有覆盖，根节点也要放一个摄像头，result++，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(root) == <span class="number">0</span>) &#123; <span class="comment">// root 无覆盖</span></span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  每个节点可能有如下三种状态，我们分别有三个数字来表示：</span></span><br><span class="line"><span class="comment">// - 0：该节点无覆盖</span></span><br><span class="line"><span class="comment">// - 1：本节点有摄像头</span></span><br><span class="line"><span class="comment">// - 2：本节点有覆盖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">traversal</span>(cur-&gt;left);   </span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况1：左右节点都有覆盖，那么此时中间节点应该就是无覆盖的状态了。</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况2：左右节点至少有一个无覆盖，则中间节点（父节点）应该放摄像头</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况3：左右节点至少有一个有摄像头</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span> || right == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//情况4：根结点没有覆盖，在根节点放一个摄像头</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traversal</span>(root) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】二叉树的最近公共祖先"><a href="#【剑】二叉树的最近公共祖先" class="headerlink" title="【剑】二叉树的最近公共祖先"></a>【剑】二叉树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=13&tqId=1024325&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">在二叉树中找到两个节点的最近公共祖先_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
<p>自底向上查找公共祖先<br>后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p>
<p>接下来就看如何判断一个节点是节点 q 和节点 p 的公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点 p，右子树出现节点 q，或者左子树出现结点 q，右子树出现节点 p，那么该节点就是节点 p 和 q 的最近公共祖先。</strong> 即情况一：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200290.png" alt="Pasted image 20240304100119"></p>
<p>判断逻辑是如果递归遍历遇到 q，就将 q 返回，遇到 p 就将 p 返回，那么如果左右子树的返回值都不为空，说明此时的中节点，一定是 q 和 p 的最近祖先。</p>
<p>情况二：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200291.png" alt="Pasted image 20240304100201"><br>其实情况一和情况二代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。</p>
<p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是公共祖先的情况。</p>
<p>如 [[#递归二叉树的返回值]] 所述，该题我们需要利用 left 和 right 进行逻辑判断，所以需要遍历整棵树（有返回值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果 left 和 right 都不为空，说明此时 root 就是最近公共节点。这个比较好理解</strong></li>
<li><strong>如果 left 为空，right 不为空，就返回 right，说明目标节点是通过 right 返回的，反之依然</strong>。</li>
<li>如果 left 和 right 都为空，则返回 left 或者 right 都是可以的，也就是返回空。</li>
</ul>
<p>这里有的同学就理解不了了，为什么 left 为空，right 不为空，目标节点通过 right 返回呢？</p>
<p>如图：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200292.png" alt="Pasted image 20240304101902"></p>
<p>图中节点 10 的左子树返回 null，右子树返回目标值 7，那么此时节点 10 的处理逻辑就是把右子树的返回值（最近公共祖先 7）返回上去！</p>
<p>这里也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p>
<p>寻找最小公共祖先，完整流程图如下：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200293.png" alt="Pasted image 20240304102000"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归函数有返回值，遍历整棵树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == q || root == p ) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>剑指 offer 版本，给的是节点值 o1, o2，改写一下即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span> || cur-&gt;val == o1 || cur-&gt;val == o2  ) <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, o1, o2);</span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, o1, o2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, o1, o2)-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】二叉搜索树的最近公共祖先-鸽"><a href="#【剑】二叉搜索树的最近公共祖先-鸽" class="headerlink" title="【剑】二叉搜索树的最近公共祖先 (鸽)"></a>【剑】二叉搜索树的最近公共祖先 (鸽)</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=13&tqId=2290592&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树的最近公共祖先_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p>
<p>在有序树里，如果判断一个节点的左子树里有 p，右子树里有 q 呢？</p>
<p>因为是有序树，所有如果中间节点是 q 和 p 的公共祖先，那么中节点的数组一定是在 $[p, q]$ 区间的。即 <code>中节点 &gt; p &amp;&amp; 中节点 &lt; q</code> 或者 <code>中节点 &gt; q &amp;&amp; 中节点 &lt; p</code>。</p>
<p>那么只要从上到下去遍历，遇到 cur 节点是数值在[p, q]区间中则一定可以说明该节点 cur 就是 p 和 q 的公共祖先。那问题来了，<strong>一定是最近公共祖先吗</strong>？</p>
<p>如图，我们从根节点搜索，第一次遇到 cur 节点是数值在[q, p]区间中，即节点 5，此时可以说明 q 和 p 一定分别存在于节点 5 的左子树，和右子树中。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200294.png" alt="Pasted image 20240304111937"><br>此时节点 5 是不是最近公共祖先？ 如果从节点 5 继续向左遍历，那么将错过成为 p 的祖先，如果从节点 5 继续向右遍历则错过成为 q 的祖先。</p>
<p><strong>所以当我们从上向下去递归遍历，第一次遇到 cur 节点是数值在[q, p]区间中，那么 cur 就是 q 和 p 的最近公共祖先。</strong></p>
<p>理解这一点，本题就很好解了。</p>
<p><strong>而递归遍历顺序，本题就不涉及到前中后序了（这里没有中节点的处理逻辑，遍历顺序无所谓了）。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。</span></span><br><span class="line">    <span class="comment">//递归函数有返回值，遍历一条边</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在遍历二叉搜索树的时候就是寻找区间[p-&gt;val, q-&gt;val]</span></span><br><span class="line">        <span class="comment">//向左遍历（大于pq, 说明目标区间在左子树上）</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p ,q);</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右遍历（小于pq, 说明目标区间在右子树上）</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p ,q);</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cur在区间，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>剑指 offer 版本，给的是节点值 p, q，改写一下即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p &amp;&amp; cur-&gt;val &gt; q) &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p &amp;&amp; cur-&gt;val &lt; q) &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q)-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】序列化二叉树（不会）"><a href="#【剑】序列化二叉树（不会）" class="headerlink" title="【剑】序列化二叉树（不会）"></a>【剑】序列化二叉树（不会）</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=23455&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">序列化二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>题目给的初始化规则很奇怪</p>
<h3 id="二叉树回溯"><a href="#二叉树回溯" class="headerlink" title="二叉树回溯"></a>二叉树回溯</h3><h4 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h4><p>前序遍历+回溯<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200295.png" alt="Pasted image 20240303093214|500"></p>
<p><strong>什么时候算是找到了叶子节点？</strong> 是当 cur 不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p><strong>为什么使用了 vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用 vector 方便来做回溯。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中，中为什么写在这里，因为最后叶子节点也要加入到path中 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历到叶子节点，递归中止</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string sPath;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//叶子节点前的路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//还要加上叶子节点，叶子节点后面不再需要添加&#x27;-&gt;&#x27;</span></span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">push_back</span>(sPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();  <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200296.jpg" alt="Pasted image 20240304093424|450"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根</span></span><br><span class="line">        sum += cur-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到叶子结点，则判断是否满足返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> LeftSum = <span class="built_in">traversal</span>(cur-&gt;left, targetSum);</span><br><span class="line">            <span class="keyword">if</span>(LeftSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum -= cur-&gt;left-&gt;val; <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> RightSum = <span class="built_in">traversal</span>(cur-&gt;right, targetSum);</span><br><span class="line">            <span class="keyword">if</span>(RightSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum -= cur-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="5-平衡二叉树"><a href="#5-平衡二叉树" class="headerlink" title="5 平衡二叉树"></a>5 平衡二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a><br>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li>
</ul>
<p><strong>但 leetcode 中强调的深度和高度很明显是按照节点来计算的</strong>，如图：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200297.png" alt="Pasted image 20240112050800"></p>
<p>关于根节点的深度究竟是 1 还是 0，不同的地方有不一样的标准，<strong>leetcode 的题目中都是以节点为一度，即根节点深度是 1</strong>。但维基百科上定义用边为一度，即根节点的深度是 0，我们暂时以 leetcode 为准（毕竟要在这上面刷题）。</p>
<p><strong>重点思路：</strong></p>
<ul>
<li><strong>求深度可以从上到下去查所以需要前序遍历（中左右）</strong></li>
<li>**求高度只能从下到上去查，所以只能后序遍历（左右中）</li>
</ul>
<p>递归法（后序遍历，自下到上）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果存在一棵子树不平衡，则整个二叉树一定不平衡。</span></span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="comment">//分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度</span></span><br><span class="line">        <span class="comment">//否则返回-1，表示已经不是二叉平衡树了。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>)  <span class="comment">//中</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight); <span class="comment">// 以当前节点为根节点的树的最大高度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="6-二叉排序树-二叉查找树、二叉搜索树"><a href="#6-二叉排序树-二叉查找树、二叉搜索树" class="headerlink" title="6 二叉排序树 (二叉查找树、二叉搜索树)"></a>6 二叉排序树 (二叉查找树、二叉搜索树)</h2><p>[[1 数据结构#5.5.1 二叉排序树（BST）]]</p>
<p>二叉搜索树重要特性：</p>
<ol>
<li>左子树结点值&lt;根结点值&lt;右子树结点值</li>
<li>对二叉排序树进行 <code>中序遍历</code>，可以得到一个递增的有序序列</li>
</ol>
<h3 id="查找（搜索）"><a href="#查找（搜索）" class="headerlink" title="查找（搜索）"></a>查找（搜索）</h3><p>迭代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span> &amp;&amp; val != root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>根据二叉排序树的定义，<strong>左子树结点值&lt;根结点值&lt;右子树结点值</strong>，所以<strong>对二叉排序树进行<code>中序遍历</code>，可以得到一个递增的有序序列</strong>。</p>
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<p>递归中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序遍历，节点值加入vec数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否为递增数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span>(vec[i] &lt;= vec[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法同理</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val == root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不进行操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1. 被删除结点是叶子节点，直接删除，返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 节点只有左子树，删除后用左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 节点只有右子树，删除后用右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 左右子树都不为空，则将删除节点的左子树放到删除节点的右子树的最左边节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到删除节点的右子树最左面的节点</span></span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">                cur-&gt;left = root-&gt;left;</span><br><span class="line"></span><br><span class="line">                TreeNode* temp = root;</span><br><span class="line">                root = root-&gt;right; <span class="comment">//返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key &lt; root-&gt;val) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root-&gt;val) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】二叉搜索树的第-k-个节点"><a href="#【剑】二叉搜索树的第-k-个节点" class="headerlink" title="【剑】二叉搜索树的第 k 个节点"></a>【剑】二叉搜索树的第 k 个节点</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&tqId=2305268&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树的第k个节点_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>请找出二叉搜索树中第<strong>第 k 小</strong>的 TreeNode 结点值。</p>
<p>二叉搜索树中序遍历是递增序列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* proot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(proot-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(proot-&gt;val); <span class="comment">//也可以不使用辅助数组，直接在这记录第k个数返回</span></span><br><span class="line">        <span class="built_in">traversal</span>(proot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(proot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &gt; vec.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vec[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a><br>把二叉搜索树通过中序遍历转换成有序数组，然后遍历一遍数组，就统计出来最小差值了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历，节点值加入vec数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">traversal</span>(root, vec);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码是把二叉搜索树转化为有序数组了，<strong>其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</strong></p>
<p>需要<strong>用一个 pre 节点记录一下 cur 节点的前一个节点。</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200301.png" alt="Pasted image 20240113090329"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">//记录前一个节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历，遍历的节点是有序的，在遍历过程中计算最小插值。和单独创建一个有序数组进行计算是一样的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);  <span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span>)     <span class="comment">//中</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p>
<p>如果该题是求普通二叉树的众数，只需要遍历并用 map 记录频率<br>该题为二叉搜索树，可以利用二叉搜索树的性质</p>
<p>普通二叉树解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        map[cur-&gt;val]++;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,map);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val_to_count;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计出现次数</span></span><br><span class="line">        <span class="built_in">traversal</span>(root, val_to_count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 map 复制到 vector</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(val_to_count.<span class="built_in">begin</span>(),val_to_count.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按出现次数从大到小排序</span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个值肯定为众数</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面和第一个值出现次数相同的数也为众数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i].second == vec[<span class="number">0</span>].second)</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用二叉搜索树的性质，使用上一节介绍过的 pre 节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">//记录中序遍历的前一个节点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left); <span class="comment">//左</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">nullptr</span>) <span class="comment">// 第一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre-&gt;val == cur-&gt;val) <span class="comment">//数值相同，次数+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//数值不同，重新计算</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于被修剪的是二叉搜索树，因此修剪过程必然能够顺利进行。</span></span><br><span class="line"><span class="comment">//容易想到使用原函数作为递归函数：</span></span><br><span class="line"><span class="comment">//若 root.val 小于边界值 low，则 root 的左子树必然均小于边界值，我们递归处理 root.right 即可；</span></span><br><span class="line"><span class="comment">//若 root.val 大于边界值 high，则 root 的右子树必然均大于边界值，我们递归处理 root.left 即可；</span></span><br><span class="line"><span class="comment">//若 root.val 符合要求，则 root 可被保留，递归处理其左右节点并重新赋值即可。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>注意题目要求是<strong>高度平衡</strong>的二叉搜索树<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。</span></span><br><span class="line"><span class="comment">//有序数组构造二叉搜索树，寻找分割点就比较容易，分割点就是数组中间的节点，如果数组长度为偶数，两个中间点任取其中一个即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid  = left + (right-left)/<span class="number">2</span>; <span class="comment">//防止越界</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]); <span class="comment">//切割点作为根节点</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="built_in">traversal</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>); </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a><br>可以遍历存储到 vec 数组，也可以使用 pre 节点，节省空间开销。</p>
<p>注意该题使用了<strong>反中序遍历（右根左），遍历结果是一个递减数组。</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200302.png" alt="Pasted image 20240113105414|500"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质是一个有序数组，求从后到前的累加数组，</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">//记录前一个节点的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右中左遍历(反中序)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】验证二叉搜索树的后序遍历序列"><a href="#【剑】验证二叉搜索树的后序遍历序列" class="headerlink" title="【剑】验证二叉搜索树的后序遍历序列"></a>【剑】验证二叉搜索树的后序遍历序列</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=23289&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树的后序遍历序列_牛客题霸_牛客网 (nowcoder.com)</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">LCR 152. 验证二叉搜索树的后序遍历序列 - 力扣（LeetCode）</a></p>
<ul>
<li>后序遍历的最后一个节点是二叉搜索树根节点</li>
<li>后序遍历序列中第一个大于根节点值的一定是右子树的第一个节点，以此我们就可以将后序遍历序列分出根和左右区间范围。</li>
<li>对左右区间递归遍历，满足左区间全部小于根，右区间全部大于根，则为 true</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sequence, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归的结束条件：如果这棵树只剩下一个节点，就返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找第一个大于根节点 的节点</span></span><br><span class="line">        <span class="comment">//确定左子树区间[left, index-1], 右子树区间[index, right - 1]</span></span><br><span class="line">        <span class="type">int</span> index = left; </span><br><span class="line">        <span class="keyword">while</span>(sequence[index] &lt; sequence[right])</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上一步可以确定左子树区间都死小于根节点sequence[right]的</span></span><br><span class="line">        <span class="comment">//若要满足二叉搜索树，还需确定右子树区间都大于根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index;i&lt;=right<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &lt; sequence[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果都大于，那么对左右子树区间递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsBST</span>(sequence, left, index<span class="number">-1</span>) &amp;&amp; <span class="built_in">IsBST</span>(sequence, index, right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsBST</span>(sequence, <span class="number">0</span>, sequence.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】二叉搜索树与双向链表"><a href="#【剑】二叉搜索树与双向链表" class="headerlink" title="【剑】二叉搜索树与双向链表"></a>【剑】二叉搜索树与双向链表</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=23253&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树与双向链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个<strong>排序</strong>的双向链表</p>
<p>将该二叉搜索树转换成一个排序的双向链表，初看题目可能会被误导创建 list 容器。题目意思其实是利用节点的 left 和 right 指针模拟双向链表，而不是创建一个 list 容器直接存节点。</p>
<ul>
<li>另外要求是排序的，自然想到二叉搜索树的中序遍历。</li>
<li>利用 pre 节点记录上一个遍历的节点，来指定 left 和 right 指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;TreeNode*&gt; vec;  <span class="comment">//题目意思其实是利用节点的left和right指针模拟双向链表，而不是创建一个list容器直接存节点</span></span><br><span class="line">	TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">		vec.<span class="built_in">push_back</span>(cur);</span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;left = pre;</span><br><span class="line">			pre-&gt;right = cur;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = cur;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="built_in">traversal</span>(pRootOfTree);</span><br><span class="line">		<span class="keyword">return</span> vec.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="七、回溯法"><a href="#七、回溯法" class="headerlink" title="七、回溯法"></a>七、回溯法</h1><p><strong>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。<br>既然回溯法并不高效为什么还要用它呢？因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p><strong>回溯法解决的问题：</strong></p>
<ul>
<li><strong>组合</strong>问题：N个数里面按一定规则找出k个数的集合</li>
<li><strong>切割</strong>问题：一个字符串按一定规则有几种切割方式</li>
<li><strong>子集</strong>问题：一个N个数的集合里有多少符合条件的子集</li>
<li><strong>排列</strong>问题：N个数按一定规则全排列，有几种排列方式</li>
<li><strong>棋盘</strong>问题：N皇后，解数独等等</li>
</ul>
<p><strong>什么是组合，什么是排列？</strong></p>
<ul>
<li><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。（组合无序，排列有序）</li>
<li>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</li>
</ul>
<p><strong>如何理解回溯法？</strong></p>
<ul>
<li><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</li>
<li>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小构成了树的宽度，递归的深度构成的树的深度。</strong></li>
<li>递归就要有终止条件，所以必然是一棵<strong>高度有限的树（N 叉树）</strong>。</li>
</ul>
<h2 id="1-回溯三部曲"><a href="#1-回溯三部曲" class="headerlink" title="1 回溯三部曲"></a>1 回溯三部曲</h2><ol>
<li><strong>回溯函数返回值以及参数</strong><br>在回溯算法中，我的习惯是函数起名字为<code>backtracking</code>，这个起名大家随意。</li>
</ol>
<ul>
<li>回溯算法中函数返回值一般为 void。</li>
<li>再来看一下参数，因为<strong>回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</strong><br>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。<br>回溯函数伪代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>回溯函数终止条件</strong></li>
</ol>
<p>遍历树形结构一定要有终止条件，所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，<strong>一般来说搜到叶子节点了，也就找到了满足条件的一条答案</strong>，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>回溯搜索的遍历过程</strong><br>回溯法一般是在集合中递归搜索，<strong>集合的大小构成了树的宽度，递归的深度构成的树的深度。</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200304.png" alt="d6a307889e6aa2557443f07534c60a0f_MD5"></p>
<p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li><strong>for 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 for 循环就执行多少次。</strong></li>
<li><strong>backtracking 这里自己调用自己，实现递归。</strong></li>
</ul>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2 组合问题"></a>2 组合问题</h2><p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input disabled="" type="checkbox"> path 元素数量</li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能 </li>
<li><input disabled="" type="checkbox"> 不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>对于组合问题，什么时候需要 startIndex 呢？</strong></p>
<ul>
<li>如果是一个集合来求组合的话，就需要 startIndex，例如：<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>。</li>
<li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：<a target="_blank" rel="noopener" href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></p>
<p>题目条件</p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：只要 <code>path.size() == k</code> 就return</strong></li>
<li><input disabled="" type="checkbox"> path 元素总和：</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能：</li>
<li><input checked="" disabled="" type="checkbox"> <strong>不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 <code>i+1</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>很容易想到用 k 层 for 循环暴力解，但是 k 如果很大就需要很多层。<strong>回溯法可以用递归来解决嵌套层数的问题</strong>。<br>递归来做层叠嵌套（可以理解是开 k 层 for 循环），<strong>每一次的递归中嵌套一个 for 循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p>
<p><strong>回溯法解决的问题都可以抽象为树形结构（N 叉树），用树形结构来理解回溯就容易多了</strong>。<br>把组合问题抽象为如下树形结构：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200305.png" alt="Pasted image 20240114093601"></p>
<p>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。第一次取1，集合变为2，3，4 ，因为 k 为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合 $[1,2] [1,3] [1,4]$，以此类推。<br><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p>
<p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p>
<p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？<br><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。相当于只需要把达到叶子节点的结果收集起来，就可以求得 n 个数中 k 个数的组合集合。</p>
<p><strong>对于组合问题，什么时候需要 startIndex 呢？</strong></p>
<ul>
<li>如果是一个集合来求组合的话，就需要 startIndex，例如：<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>。</li>
<li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：<a target="_blank" rel="noopener" href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">//path集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">//存放符合条件的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//startIndex来记录下一层递归，搜索的起始位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//path保存到叶子节点递归终止</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//横向遍历</span></span><br><span class="line">        <span class="comment">//每次从startIndex开始遍历，然后用path保存取到的节点i。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);  <span class="comment">//处理节点 [1]</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i+<span class="number">1</span>);<span class="comment">//递归：控制输的纵向遍历，注意下一层搜索从i+1开始, 直到递归中止, 然后进行下一行代码 [1,2]</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//回溯, [1,2]-&gt;[1],这样才能保证下次得到[1,3]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意这里，startIndex本题传入1，因为本题没有给数组，算法中我们之直接将startIndex作为数值，这样遍历的时候时从1开始依次加入path</span></span><br><span class="line">        <span class="comment">//后面很多题都是有数组的，所以传入0，从nums[0]开始遍历</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="关于-path-元素数量的剪枝优化"><a href="#关于-path-元素数量的剪枝优化" class="headerlink" title="关于 path 元素数量的剪枝优化"></a>关于 path 元素数量的剪枝优化</h4><p><strong>递归结束条件如果需要判断 path 元素数量就可以使用这种剪枝</strong></p>
<p>思路：已知题目要求 path 长度必须为 k。在 for 循环中，循环条件为 i&lt;&#x3D;n，遍历过程中剩余的元素数量不足以令 path 长度达到要求时，就没必要遍历了。所以我们可以收缩遍历的范围 <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200306.png" alt="Pasted image 20240117141513"></p>
<ul>
<li>path 已经拥有的元素数量：<code>path.size()</code></li>
<li>path 达到要求仍需要的元素数量：<code>k - path.size()</code></li>
<li>当前下标：<code>i</code></li>
<li>最后下标：<code>n</code></li>
<li>遍历到最后还可以插入到 path 中的元素数量 (遍历过程中剩余的元素数量)：<code>n-i+1</code></li>
<li>所以判断条件可以改为：<code>n-i+1 &gt;= k-path. size()</code></li>
</ul>
<p>只需要修改源代码的遍历条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剪枝：遍历过程中剩余的元素数量不足以令 path 长度达到要求时，就没必要遍历了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex; n-i+<span class="number">1</span> &gt;= k-path. <span class="built_in">size</span>(); i++)  </span><br><span class="line">&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);  </span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i+<span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200307.png" alt="Pasted image 20240114105622"></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input disabled="" type="checkbox"> path 元素数量</li>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素总和：本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过 target，就返回。</strong></li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：</li>
<li><input disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input checked="" disabled="" type="checkbox"> 能：**不需要去重，<code>backtracking</code> 传入 &#96;i</li>
<li><input disabled="" type="checkbox"> 不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归累加sum</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意这里不用i+1了，题目规定 candidates 中的 同一个 数字可以 无限制重复被选取 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i, sum); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意回溯要处理sum</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="关于-path-元素总和的剪枝优化"><a href="#关于-path-元素总和的剪枝优化" class="headerlink" title="关于 path 元素总和的剪枝优化"></a>关于 path 元素总和的剪枝优化</h4><p><strong>递归结束条件如果需要判断 path 元素总和就可以使用这种剪枝</strong></p>
<p>思路：原来的代码对于 sum 已经大于 target 的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断 sum &gt; target 的话就返回。<br>其实如果已经知道下一层的 sum 会大于 target，就没有必要进入下一层递归了。那么可以在 for 循环的搜索范围上做做文章了。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200308.png" alt="Pasted image 20240117144815"><br><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。<br>注意：要对集合排序，这样时从小到大取数组元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if(sum &gt; target) return; //这里不需要判断了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剪枝优化: 如果sum + candidates[i] &gt; target就没必要进入下一层递归了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归累加sum</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意这里不用i+1了，题目规定 candidates 中的 同一个 数字可以 无限制重复被选取 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i, sum); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意回溯要处理sum</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//剪枝优化的判断条件前提是数组升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input disabled="" type="checkbox"> path 元素数量</li>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素总和：本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过 target，就返回。</strong></li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> <strong>否：考虑去重</strong><ul>
<li>给定数组是否有重复元素？<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>有 &#x3D;&gt; 同一层之间去重，记得必须先对原数组排序</strong></li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 <code>i+1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200309.png" alt="Pasted image 20240116093357"></p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200310.png" alt="Pasted image 20240116090916"></p>
<h4 id="使用-startIndex-同层去重"><a href="#使用-startIndex-同层去重" class="headerlink" title="使用 startIndex 同层去重"></a>使用 <code>startIndex</code> 同层去重</h4><p>使用 <code>startIndex</code> 进行同层之间去重：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同层之间去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtracing</span>(candidates, target, i+<span class="number">1</span>, sum); <span class="comment">// 不同层之间去重</span></span><br><span class="line"></span><br><span class="line">            sum -= candidates[i]; </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 同层之间去重 和 剪枝优化 都需要对原数组排序！</span></span><br><span class="line">        std::<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracing</span>(candidates, target, <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用-unordererd-set-同层去重"><a href="#使用-unordererd-set-同层去重" class="headerlink" title="使用 unordererd_set 同层去重"></a>使用 <code>unordererd_set</code> 同层去重</h4><p>使用 <code>unordererd_set</code> 进行同层之间去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同层之间去重: 标记已使用过的数字</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; UsedNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i&lt;candidates.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同层之间去重</span></span><br><span class="line">            <span class="keyword">if</span>(UsedNum.<span class="built_in">find</span>(candidates[i])!=UsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsedNum.<span class="built_in">insert</span>(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtracing</span>(candidates, target, i+<span class="number">1</span>, sum); <span class="comment">// 不同层之间去重</span></span><br><span class="line"></span><br><span class="line">            sum -= candidates[i]; </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 同层之间去重 和 剪枝优化 都需要对原数组排序！</span></span><br><span class="line">        std::<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracing</span>(candidates, target, <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>剪枝：[[#关于 path 元素总和的剪枝优化]]</p>
<h3 id="组合总和-III"><a href="#组合总和-III" class="headerlink" title="组合总和 III"></a>组合总和 III</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：k 个数</strong></li>
<li><input checked="" disabled="" type="checkbox"> **path 元素总和：相加之和为 n</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> <strong>否：考虑去重</strong><ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同一层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 <code>i+1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200311.png" alt="Pasted image 20240114094752"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//只有path中元素总和为n时，才保存到结果数组</span></span><br><span class="line">            <span class="keyword">if</span>(num == n)</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意集合的大小是 9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num += i;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, i+<span class="number">1</span>, num); <span class="comment">//不同层之间去重</span></span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            num -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该题两个递归结束条件都可以进行剪枝优化：<br>[[#关于 path 元素数量的剪枝优化]]<br>[[#关于 path 元素总和的剪枝优化]]</p>
<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><blockquote>
<p>[!warning] 与前面题目的不同<br>本题是从多个集合取组合，各个集合之间相互不影响，所以不用 <code>startIndex</code>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p>
<p>题目条件：</p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：<code>digits.size()</code></strong></li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> <strong>否：考虑去重</strong><ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同一层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 &#96;i+1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200312.png" alt="Pasted image 20240114103911"><br>例如：输入：”23”，抽象为树形结构，如图所示：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200313.png" alt="Pasted image 20240114100906"><br><strong>本题是从多个集合取组合，各个集合之间相互不影响，所以不用 startIndex。</strong><br>这个 <code>index</code> 是记录遍历第几个数字了，就是用来遍历 <code>digits</code> 数组的，同时 <code>index</code> 也表示树的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//按键数字到字符串的映射</span></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; number_to_string</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//index用来记录遍历digits到第几个数字，从0开始计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果index已经遍历完digits，则return</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; digits.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//char转换为int(char对应的ASCII值-&#x27;0&#x27;)</span></span><br><span class="line">        <span class="type">int</span> number = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//根据数字获取对应的字符串</span></span><br><span class="line">        string str = number_to_string[number];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-分割问题"><a href="#3-分割问题" class="headerlink" title="3 分割问题"></a>3 分割问题</h2><p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input disabled="" type="checkbox"> 切割位置</li>
</ul>
</li>
<li>切割条件</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input disabled="" type="checkbox"> 不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>切割线（切割位置）：在处理组合&#x2F;切割问题的时候，递归参数需要传入 <code>startIndex</code>，表示下一轮递归遍历的起始位置，这个 startIndex 就是切割线。</strong></p>
<p>在 <code>for (int i = startIndex; i &lt; s.size(); i++)</code> 循环中，我们定义了起始位置 startIndex，那么 <code>[startIndex, i] </code> 就是要截取的子串。</p>
<p><strong>切割问题类似组合问题，也可以抽象为一棵树形结构。</strong><br>例如对于字符串 abcdef：</p>
<ul>
<li>组合问题：选取一个 a 之后，在 bcdef 中再去选取第二个，选取 b 之后在 cdef 中再选取第三个…..。</li>
<li>切割问题：切割一个 a 之后，在 bcdef 中再去切割第二段，切割 b 之后在 cdef 中再切割第三段…..。</li>
</ul>
<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><strong>切割位置：<code>startIndex &gt; s.size() - 1</code> 说明切完了</strong></li>
</ul>
</li>
<li><strong>切割条件：子串<code>[startIndex, i]</code>是回文串</strong></li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input checked="" disabled="" type="checkbox"> <strong>不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 <code>i+1</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200314.png" alt="Pasted image 20240115090445"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断s的子串[left,right]是否为回文串</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// startIndex已经遍历完s,说明切割完了</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt; s.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//切割条件：判断回文子串[startIndex, i]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsPalindrome</span>(s, startIndex, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获取截取的子串</span></span><br><span class="line">                string str = s.<span class="built_in">substr</span>(startIndex,i-startIndex+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i+<span class="number">1</span>); <span class="comment">//不同层之间去重</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><strong>切割位置：逗点数量为 3 时，分隔结束</strong></li>
</ul>
</li>
<li><strong>切割条件：子串 <code>[startIndex, i]</code> 是否合法</strong></li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 有 </li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 &#96;i+1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200317.png" alt="Pasted image 20240117164221"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前导0不合法(例如01，012)</span></span><br><span class="line">        <span class="keyword">if</span>(s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i&lt;=end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//非数字字符不合法</span></span><br><span class="line">            <span class="keyword">if</span>(!std::<span class="built_in">isdigit</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个整数位于 0 到 255 </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> number = std::<span class="built_in">stoll</span>(s.<span class="built_in">substr</span>(start, end-start+<span class="number">1</span>)); <span class="comment">//这里整数使用long long防止越界，stoi仅支持长度为10的string</span></span><br><span class="line">        <span class="keyword">if</span>(number &lt; <span class="number">0</span> || number &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">int</span> pointCount = <span class="number">0</span>; <span class="comment">//记录点数量，最多3个</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">        <span class="keyword">if</span>(pointCount == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断第四段子字符串是否合法，如果合法就将s放进result中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>()<span class="number">-1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s, startIndex, i))</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>()+i+<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">//在i后面插入&#x27;.&#x27;</span></span><br><span class="line">                ++pointCount;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">backtracking</span>(s,i+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                --pointCount;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i+<span class="number">1</span>); <span class="comment">//回溯，删掉&#x27;.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//只要有一个子串不合法，后面就不用判断了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-子集问题"><a href="#4-子集问题" class="headerlink" title="4 子集问题"></a>4 子集问题</h2><blockquote>
<p>[!NOTE] 和组合问题的区别<br>将 <code>result.push_back (path);</code> 放在终止条件判断语句前面，这样可以收集全部子集（和组合问题不同，组合问题只在递归终止时才将 path 添加进 result）</p>
</blockquote>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input disabled="" type="checkbox"> path 元素数量</li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input disabled="" type="checkbox"> 不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，<strong>而子集问题是找树的所有节点！所以子集问题不要进行剪枝！</strong></p>
<p>其实<strong>子集也是一种组合问题 （可以抽象成一棵树，遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合）</strong>，因为它的集合是无序的，子集{1,2} 和子集{2,1}是一样的。<strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for 就要从 startIndex 开始，而不是从 0 开始！</strong></p>
<p><strong>有同学问了，什么时候 for 可以从 0 开始呢？</strong><br>求<strong>排列问题</strong>的时候，就要从 0 开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p>
<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：<code>startIndex &gt; nums.size() - 1</code> 时，说明这条 path 遍历完了。</strong></li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input checked="" disabled="" type="checkbox"> <strong>不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 <code>i+1</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200319.png" alt="Pasted image 20240115105348"></p>
<p>因为我们要记录所有的节点，所以要<strong>将 <code>result.push_back (path);</code> 放在终止条件判断语句前面。（和组合问题不同，组合问题只在递归终止时才将 path 添加进result）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将所有path都添加进result, 注意要放在终止条件前执行，否则会漏掉最后一个集合(包含nums全部的元素)</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt; nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i+<span class="number">1</span>); <span class="comment">//不同层之间去重</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a>子集 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：<code>startIndex &gt; nums.size() - 1</code> 时，说明这条 path 遍历完了。</strong></li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>有 &#x3D;&gt; 同层之间去重，记得必须先对原数组排序</strong></li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 &#96;i+1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200320.png" alt="Pasted image 20240116095529"></p>
<h4 id="使用-startIndex-同层去重-1"><a href="#使用-startIndex-同层去重-1" class="headerlink" title="使用 startIndex 同层去重"></a>使用 <code>startIndex</code> 同层去重</h4><p>使用 <code>startIndex</code> 进行同层之间去重：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将不重复的path放进result</span></span><br><span class="line">        <span class="comment">//注意要放在终止条件前执行，否则会漏掉最后一个集合(包含nums全部的元素)</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt; nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同一层之间去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>); <span class="comment">//不同层之间去重</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同一层之间去重需要排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-unordered-set-同层去重"><a href="#使用-unordered-set-同层去重" class="headerlink" title="使用 unordered_set 同层去重"></a>使用 <code>unordered_set</code> 同层去重</h4><p>使用 <code>unordered_set</code> 进行同层之间去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意要放在终止条件前执行，否则会漏掉最后一个集合(包含nums全部的元素)</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt; nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同层之间去重: 标记已使用过的数字</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; UsedNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同层之间去重</span></span><br><span class="line">            <span class="keyword">if</span>(UsedNum.<span class="built_in">find</span>(nums[i]) != UsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsedNum.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>); <span class="comment">//不同层之间去重</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同一层之间去重需要排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列 - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>path 元素数量：<code>startIndex &gt; nums.size() - 1</code> 时，说明这条 path 遍历完了。</strong></li>
<li><input disabled="" type="checkbox"> path 元素总和</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>有 &#x3D;&gt; 同层之间去重，不能对原数组排序!</strong></li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重，<code>backtracking</code> 传入 &#96;i+1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200322.png" alt="Pasted image 20240118095037"></p>
<ul>
<li>! <strong>本题不能对原数组排序</strong>，所以不能只使用 startIndex 进行同层之间的去重。该题使用 <code>unordered_set</code> 标记使用过的元素，对本层元素去重。</li>
</ul>
<p><strong>为什么不能排序：</strong></p>
<ul>
<li>本题要求找出并返回所有该数组中不同的递增子序列，例如：</li>
<li><strong>输入：</strong> <code>nums = [4,4,3,2,1]</code></li>
<li><strong>输出：</strong> <code>[[4,4]]</code></li>
<li>如果对 nums 排序，则 <code>nums = [1,2,3,4,4]</code>。输出就会不止 <code>[4,4]</code> 一个了。所以不能对原数组排序。</li>
</ul>
<p><strong>没有排序的集合使用 <code>unordered_set</code> 进行本层去重会出现重复子集：以集合 <code>&#123;2,1,2,2&#125;</code> 为例：</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200323.png" alt="Pasted image 20240118102055"><br>可以看到得到的子集是会重复的，但是本题 for 循环里我们进行了剪枝：如果元素小于 path 最后一个元素也会被剪掉，所以最后只会保留了非递减序列 <code>&#123;1,2&#125;</code>。<br><strong>而对于[[#组合总和 II]] 和[[#子集 II]] 使用 <code>unordered_set</code> 对本层去重时，没有上述剪枝条件。所以要求必须先对给定数组排序，这样就不会出现子集重复。</strong></p>
<h4 id="使用-unordered-set-同层去重-1"><a href="#使用-unordered-set-同层去重-1" class="headerlink" title="使用 unordered_set 同层去重"></a>使用 <code>unordered_set</code> 同层去重</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//非递减子序列 至少有两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用set标记使用过的元素，对本层元素去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; UsedNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果元素小于path最后一个元素，或者已经使用过该元素，则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(startIndex &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>() || UsedNum.<span class="built_in">find</span>(nums[i]) != UsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsedNum.<span class="built_in">insert</span>(nums[i]); <span class="comment">//标记</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-排列问题"><a href="#5-排列问题" class="headerlink" title="5 排列问题"></a>5 排列问题</h2><blockquote>
<p>[!NOTE] 和组合问题的区别</p>
<ul>
<li>for 循环 <code>i</code> 就要从 0 开始，<strong>因为排列集合是有序的，<code>&#123;1, 2&#125;</code> 和 <code>&#123;2, 1&#125;</code> 是两个集合。</strong></li>
<li>不能使用 <code>startIndex</code>，所以不同层之间去重只能借助 Used 数组或 set</li>
</ul>
</blockquote>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li>全排列需要遍历所有节点，对于单条 path，肯定要遍历到最后： <code>path.size() == nums.size()</code> 说明该 path 遍历完了</li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input disabled="" type="checkbox"> 不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="全排列（不含重复元素）"><a href="#全排列（不含重复元素）" class="headerlink" title="全排列（不含重复元素）"></a>全排列（不含重复元素）</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><strong>全排列需要遍历所有节点，对于单条 path，肯定要遍历到最后： <code>path.size() == nums.size()</code> 说明该 path 遍历完了</strong></li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input disabled="" type="checkbox"> 有 &#x3D;&gt; 同层之间去重</li>
<li><input checked="" disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input checked="" disabled="" type="checkbox"> <strong>不能 &#x3D;&gt; 不同层之间去重</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200325.png" alt="Pasted image 20240117104114"></p>
<p><strong>不同层之间去重思路：</strong><br>之前的问题再不同层之间去重时，使用的是 <code>backtracking</code> 传入 <code>i+1</code> 作为下次 for 循环的 <code>startIndex</code> 值。<br>但是排列问题不能使用 <code>startIndex</code>，我们可以利用 <code>vector</code> 数组或 <code>unordered_set</code> 进行不同层之间的去重。<br>注意：之前的问题或 <code>unordered_set</code> 主要用于<strong>同层之间去重</strong>，所以 <code>backtracking</code> 中声明。而如果要在<strong>不同层之间去重</strong>，则需要在 <code>backtracking</code> 函数外声明。</p>
<h4 id="使用-unordered-set-不同层去重"><a href="#使用-unordered-set-不同层去重" class="headerlink" title="使用 unordered_set 不同层去重"></a>使用 <code>unordered_set</code> 不同层去重</h4><p><strong>使用 <code>unordered_set&lt;int&gt;</code> 再不同层之间去重，如果 path 允许包含重复数字则不能使用该方法。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,unordered_set&lt;<span class="type">int</span>&gt;&amp; UsedNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每层都是从0开始搜索而不是startIndex</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(UsedNum.<span class="built_in">find</span>(nums[i]) != UsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsedNum.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,UsedNum);</span><br><span class="line">            </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            UsedNum.<span class="built_in">erase</span>(nums[i]); <span class="comment">//记得回溯UsedNum,前面几个问题使用在同层之间去重，则不需要回溯。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//使用set标记使用过的元素，对不同层的元素去重</span></span><br><span class="line">        <span class="comment">//本体给定的数组不含重复数字，所以不需要对本层进行去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; UsedNum;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, UsedNum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-vector-不同层去重（推荐）"><a href="#使用-vector-不同层去重（推荐）" class="headerlink" title="使用 vector 不同层去重（推荐）"></a>使用 <code>vector</code> 不同层去重（推荐）</h4><p>**同理，不用 <code>unordered_set&lt;int&gt;</code> 用一个 <code>vector&lt;bool&gt;</code> 也是可以的。</p>
<p>⭐<strong>使用 <code>vector&lt;bool&gt;</code> 支持包含重复数字的 path，更通用！</strong> 比如下一题就不能使用 unordered_set。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt;&amp; UsedNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每层都是从0开始搜索而不是startIndex</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(UsedNum[i] == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsedNum[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,UsedNum);</span><br><span class="line">            </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            UsedNum[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">UsedNum</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">//注意要先初始化</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, UsedNum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两种写法的性能分析"><a href="#两种写法的性能分析" class="headerlink" title="两种写法的性能分析"></a>两种写法的性能分析</h4><p><strong>使用 <code>vector</code> 去重比使用 <code>set</code> 去重更高效</strong>，主要是因为程序运行的时候对 unordered_set 频繁的 insert，unordered_set 需要做哈希映射（也就是把 key 通过 hash function 映射为唯一的哈希值）相对费时间，而且 insert 的时候其底层的符号表也要做相应的扩充，也是费时的。</p>
<p><strong>而使用 vector 数组在时间复杂度上几乎没有额外负担！</strong></p>
<p><strong>使用 set 去重，不仅时间复杂度高了，空间复杂度也高了</strong>，组合，子集，排列问题的空间复杂度都是 O(n)，但如果使用 set 去重，空间复杂度就变成了 O(n^2)，因为每一层递归都有一个 set 集合，系统栈空间是 n，每一个空间都有 set 集合。</p>
<p>那有同学可能疑惑 用used数组也是占用O(n)的空间啊？<br>used数组可是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是O(n + n)，最终空间复杂度还是O(n)。</p>
<h3 id="【剑】全排列-（含重复元素）"><a href="#【剑】全排列-（含重复元素）" class="headerlink" title="【剑】全排列 （含重复元素）"></a>【剑】全排列 （含重复元素）</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=23291&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">字符串的排列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>题目条件</strong></p>
<ol>
<li>递归结束条件<ul>
<li><strong>全排列需要遍历所有节点，对于单条 path，肯定要遍历到最后： <code>path.size() == nums.size()</code> 说明该 path 遍历完了</strong></li>
</ul>
</li>
<li>result 是否允许包含重复 path<ul>
<li><input disabled="" type="checkbox"> 是：不需要去重</li>
<li><input checked="" disabled="" type="checkbox"> 否：考虑去重<ul>
<li>给定数组是否有重复元素？<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>有 &#x3D;&gt; 同层之间去重</strong></li>
<li><input disabled="" type="checkbox"> 没有</li>
</ul>
</li>
<li>给定数组中的元素能否重复使用？<ul>
<li><input disabled="" type="checkbox"> 能</li>
<li><input checked="" disabled="" type="checkbox"> **不能 &#x3D;&gt; 不同层之间去重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200326.png" alt="Pasted image 20240117112147"></p>
<p><strong>本题和上一题不同的地方在于：需要对本层去重，本层去重可以直接使用 <code>unordered_set</code></strong></p>
<ul>
<li><strong>不同层之间去重</strong>：由于本题 path 包含可重复数字，所以不能使用 <code>unordered_set</code> 了，我们使用 <code>vector&lt;bool&gt;</code> 来标记已经使用过的数字。</li>
<li><strong>本层之间去重</strong>：使用 <code>unordered_set</code></li>
</ul>
<h4 id="使用-unordered-set-同层去重-2"><a href="#使用-unordered-set-同层去重-2" class="headerlink" title="使用 unordered_set 同层去重"></a>使用 <code>unordered_set</code> 同层去重</h4><p>使用 <code>unordered_set</code> 对同层之间去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt; DifferentLayersUsedNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本层之间去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; CurrentLayerUsedNum;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每层都是从0开始搜索而不是startIndex</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(DifferentLayersUsedNum[i] == <span class="literal">true</span> ||  CurrentLayerUsedNum.<span class="built_in">find</span>(nums[i]) != CurrentLayerUsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CurrentLayerUsedNum.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            DifferentLayersUsedNum[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">backtracking</span>(nums, DifferentLayersUsedNum); </span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            DifferentLayersUsedNum[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//标记使用过的数字，用于不同层之间去重</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">DifferentLayersUsedNum</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(nums,DifferentLayersUsedNum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-棋盘问题"><a href="#7-棋盘问题" class="headerlink" title="7 棋盘问题"></a>7 棋盘问题</h2><h3 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/description/">51. N 皇后 - 力扣（LeetCode）</a></p>
<p>在 nxn 的棋盘上摆放 n 个皇后，使任意两个皇后都不能处于同一行，同一列或同一斜线上。</p>
<p><strong>给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。</strong></p>
<p>每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 <code>Q</code> 和 <code>.</code> 分别代表了皇后和空位。</p>
<p>示例 1：<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200170.png" alt="img"></p>
<ul>
<li>输入：n &#x3D; 4</li>
<li>输出：<code>[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</code></li>
<li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先来看一下<strong>皇后们的约束条件：</strong></p>
<ol>
<li><strong>不能同行</strong></li>
<li><strong>不能同列</strong></li>
<li><strong>不能同斜线</strong></li>
</ol>
<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以<strong>抽象为一棵树</strong>。</p>
<p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200171.jpg" alt="51.N皇后"></p>
<p>从图中，可以看出，二维矩阵中<strong>矩阵的行数&#x3D;树的高度</strong>，<strong>矩阵的列数&#x3D;树的宽度</strong>。</p>
<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p>
<h4 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h4><p>按照我总结的如下回溯模板，我们来依次分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><mark style="background: #FF5582A6;">递归函数参数</mark><br><strong>定义全局变量二维数组 result 来记录最终结果</strong>。<br><strong>参数 n 是棋盘的大小</strong>，然后用 <strong>row 来记录当前遍历到棋盘的第几层了</strong>。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong>tips：对 <code>vector&lt;vector&lt;string&gt;&gt;</code> 遍历的方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = result.<span class="built_in">begin</span>(); it != result.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = (*it).<span class="built_in">begin</span>(); iter != (*it).<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><mark style="background: #FF5582A6;">递归终止条件</mark><br>在如下树形结构中： <img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200171.jpg" alt="51.N皇后"></li>
</ul>
<p>可以看出，<strong>当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><mark style="background: #FF5582A6;">单层搜索的逻辑</mark><br>递归深度就是<strong>row 控制棋盘的行，每一层里 for 循环的 col 控制棋盘的列，一行一列，确定了放置皇后的位置。</strong><br>每次都是要从新的一行的起始位置开始搜，所以都是从 0 开始。</li>
</ul>
<p><strong>棋盘的宽度就是 for 循环的长度，递归的深度就是棋盘的高度</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) &#123; <span class="comment">// 验证合法就可以放</span></span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 放置皇后</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 回溯，撤销皇后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><mark style="background: #FF5582A6;">验证棋盘是否合法</mark><br>按照如下标准去重：</li>
</ul>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线 （左上角到右下角，右上角到左下角两条斜线）</li>
</ol>
<p><strong>这里我们不需要检查整个棋盘，只需要根据当前位置，检查已经遍历过的位置。即：</strong></p>
<ol>
<li><p>不需要检查行，因为 backtracking 中每层递归只会在放置一个皇后，保证同一行只有一个皇后</p>
</li>
<li><p>上面</p>
</li>
<li><p>左上角斜线</p>
</li>
<li><p>右上角斜线</p>
<p>如图，遍历到第三行，第四行因为还没遍历，不可能存在皇后，所以就不要考虑了。</p>
</li>
</ol>
<p>![[assets&#x2F;Diagram.svg]]</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">//不需要检查行，因为backtracking中每层递归只会在放置一个皇后，保证同一行只有一个皇后</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 检查上面</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 检查左上角斜线</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 检查右上角斜线</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n：棋盘大小</span></span><br><span class="line">    <span class="comment">//row: 记录当前遍历到棋盘第几行</span></span><br><span class="line">    <span class="comment">//chessboard: 棋盘</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="comment">//当递归超过棋盘范围，就可以收集结果并返回了。</span></span><br><span class="line">        <span class="keyword">if</span>(row &gt; n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右,从上到下遍历棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) <span class="comment">//从左往右，每次都是从本层第一个数开始，所以 col = 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果合法就放置皇后</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(n, row, col, chessboard))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;  <span class="comment">//放置皇后</span></span><br><span class="line">                <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard); <span class="comment">//row+1 进入下一层</span></span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;   <span class="comment">//回溯，撤销放置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不需要检查行，因为backtracking中每层递归只会在放置一个皇后，保证同一行只有一个皇后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查上面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上角斜线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上角斜线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>; <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p>
<p>首先注意题目条件，题目数据 <strong>保证</strong> 输入数独仅有一个解且棋盘长宽为 9。</p>
<p>N皇后问题因为每一行每一列只放一个皇后，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p>
<p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字（而 N 皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比 N 皇后更宽更深</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200327.png" alt="Pasted image 20240118163924"></p>
<h4 id="回溯三部曲-1"><a href="#回溯三部曲-1" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h4><ul>
<li><mark style="background: #FF5582A6;">递归函数以及参数</mark><br><strong>递归函数的返回值需要是bool类型，为什么呢？</strong><br>因为<strong>解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。</strong></li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark style="background: #FF5582A6;">递归终止条件</mark><br>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</li>
</ul>
<p><strong>不用终止条件会不会死循环？</strong><br>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p>
<p><strong>那么有没有永远填不满的情况呢？</strong><br>这个问题我在递归单层搜索逻辑里再来讲！</p>
<ul>
<li><mark style="background: #FF5582A6;">递归单层搜索逻辑</mark></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200328.gif" alt="d96de07a12c77f36233e46684d21e2e6_MD5"></p>
<p>在树形图中可以看出我们需要的是一个二维的递归（也就是两个for循环嵌套着递归）<br><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">// 遍历列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) </span><br><span class="line">            &#123;     </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board))  <span class="comment">// (i, j) 位置放k是否合适</span></span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = k;     <span class="comment">// 放置k</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;.&#x27;</span>;   <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里 return false 的地方，这里放 return false 是有讲究的。</strong><br>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！<br>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p>
<h4 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h4><p>相关题： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-sudoku/description/">36. 有效的数独 - 力扣（LeetCode）</a></p>
<p>判断棋盘是否合法有如下三个维度：</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> val, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == val) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (board[j][col] == val) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查方格</span></span><br><span class="line">    <span class="type">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>; <span class="comment">//获取所属宫的第一个元素所在行</span></span><br><span class="line">    <span class="type">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>; <span class="comment">//获取所属宫的第一个元素所在列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == val ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) </span><br><span class="line">                &#123;     </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board))  <span class="comment">// (i, j) 位置放k是否合适</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = k;     <span class="comment">// 放置k</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回</span></span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;   <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查填写的值是否符合规则</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> val, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//检查行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == val) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (board[j][col] == val) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查方格</span></span><br><span class="line">        <span class="type">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>; <span class="comment">//获取所属宫的第一个元素所在行</span></span><br><span class="line">        <span class="type">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>; <span class="comment">//获取所属宫的第一个元素所在列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val ) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="八、动态规划"><a href="#八、动态规划" class="headerlink" title="八、动态规划"></a>八、动态规划</h1><p>Dynamic Programming，简称 DP，<strong>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</strong></p>
<p><strong>动态规划和贪心的区别：</strong></p>
<ul>
<li>所以动态规划中每一个状态一定是由上一个状态推导出来的</li>
<li>贪心没有状态推导，而是从局部直接选最优的</li>
</ul>
<p>例如：有 <code>N</code> 件物品和一个最多能背重量为 <code>W</code> 的背包。第 <code>i</code>件物品的重量是 <code>weight[i]</code>，得到的价值是 <code>value[i]</code> 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。<br>动态规划中<code>dp[j]</code>是由<code>dp[j-weight[i]]</code>推导出来的，然后取<code>max(dp[j], dp[j - weight[i]] + value[i])</code>。<br>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。<br>所以贪心解决不了动态规划的问题。</p>
<h2 id="动态规划五部曲"><a href="#动态规划五部曲" class="headerlink" title="动态规划五部曲"></a>动态规划五部曲</h2><ol>
<li><h2 id="确定-dp-数组（dp-table）以及下标的含义"><a href="#确定-dp-数组（dp-table）以及下标的含义" class="headerlink" title="确定 dp 数组（dp table）以及下标的含义"></a>确定 dp 数组（dp table）以及下标的含义</h2></li>
<li><h2 id="确定递推公式（状态转移公式）"><a href="#确定递推公式（状态转移公式）" class="headerlink" title="确定递推公式（状态转移公式）"></a>确定<strong>递推公式（状态转移公式）</strong></h2></li>
<li><h2 id="dp-数组如何初始化"><a href="#dp-数组如何初始化" class="headerlink" title="dp 数组如何初始化"></a>dp 数组如何初始化</h2></li>
<li><h2 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h2></li>
<li><h2 id="举例推导-dp-数组"><a href="#举例推导-dp-数组" class="headerlink" title="举例推导 dp 数组"></a>举例推导 dp 数组</h2></li>
</ol>
<p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p>
<p>为什么要先确定递推公式，然后在考虑初始化呢？<br><strong>因为一些情况是递推公式决定了 dp 数组要如何初始化！</strong></p>
<p>如何 Debug?<br><strong>最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的</strong></p>
<h2 id="【剑】斐波那契数列"><a href="#【剑】斐波那契数列" class="headerlink" title="【剑】斐波那契数列"></a>【剑】斐波那契数列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=23255&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">斐波那契数列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>动规五部曲：</strong><br>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol>
<li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>的定义为：第i个数的斐波那契数值是<code>dp[i]</code></p>
</li>
<li><p>确定递推公式<br>这是一道非常简单的入门题目呢，<strong>题目已经把递推公式直接给我们了：状态转移方程 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>;</strong></p>
</li>
<li><p>dp数组如何初始化<br><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>确定遍历顺序<br>从递归公式<code>dp[i] = dp[i - 1] + dp[i - 2]</code>;中可以看出，<code>dp[i]</code>是依赖 <code>dp[i - 1]</code>和 <code>dp[i - 2]</code>，那么遍历的顺序一定是<strong>从前到后</strong>遍历的</p>
</li>
<li><p>举例推导dp数组<br>按照这个递推公式<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：<br><code>0 1 1 2 3 5 8 13 21 34 55</code><br>如果代码写出来，发现结果不对，就把 dp 数组打印出来看看和我们推导的数列是不是一致的。</p>
</li>
</ol>
<p>动态规划解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. dp[i]的含义：第i个数的斐波那契数值是dp[i]</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>; <span class="comment">//从dp[0]开始，而我们要求dp[n], n+1个元素最后一个元素下标为n。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 初始化dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 遍历顺序从前往后，因为dp[i]依赖于dp[i-1]和dp[i-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2. 递推公式</span></span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>(); <span class="comment">//即dp[n]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归解法（比动态规划慢很多）</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】爬楼梯（跳台阶）"><a href="#【剑】爬楼梯（跳台阶）" class="headerlink" title="【剑】爬楼梯（跳台阶）"></a>【剑】爬楼梯（跳台阶）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=23261&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">跳台阶_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>![[assets&#x2F;Diagram 4.svg]]</p>
<ul>
<li>爬到1楼有1种方法  </li>
<li>爬到2喽有2种方法</li>
<li>爬到3喽有3种方法</li>
<li>爬到4楼有5种方法</li>
</ul>
<p>规律如下：<br>爬到第 <code>i</code> 楼的方法为爬到第 <code>i-1</code> 和 <code>i-2</code> 楼方法的总和。<br>即 <code>dp[i] = dp[i-1] + dp[i-2]</code>，和费纳波契数列一样。</p>
<p>对于 4 楼，如果从 3 楼爬到四楼，只有 1 种方法。从 2 楼爬到 4楼，有两种方法，但是如果是一次 1个台阶，那么这种方法已经包含在爬到 3 喽的方法中。我们只看一次 2 个台阶的方法。<br>所以爬到 4 楼比爬到 3 楼多了两种方法，这就找到了规律。</p>
<p><strong>动规五部曲：</strong></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义<ul>
<li><code>dp[i]</code>表示爬到第 i 层楼梯，有 <code>dp[i]</code>种方法</li>
</ul>
</li>
<li>确定<strong>递推公式（状态转移公式）</strong><ul>
<li><code>dp[i] = dp[i-1] + dp[i-2]</code></li>
</ul>
</li>
<li>dp 数组如何初始化</li>
</ol>
<ul>
<li><code>dp[0] = 0 dp[1] = 1 dp[2] = 2</code></li>
</ul>
<ol start="4">
<li>确定遍历顺序：从递归公式 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>; 中可以看出，<code>dp[i]</code> 是依赖 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>，那么遍历的顺序一定是<strong>从前到后</strong>遍历的</li>
<li>举例推导 dp 数组：同斐波那契数列</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n; </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>; <span class="comment">//dp[0]占位，这样才能让i和层数对应起来</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>(); <span class="comment">//即dp[n]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】跳台阶扩展"><a href="#【剑】跳台阶扩展" class="headerlink" title="【剑】跳台阶扩展"></a>【剑】跳台阶扩展</h3><p>和上一题区别在于，上一题限制一次只能跳 1 或 2 级台阶，符合斐波那契数列规律。<br>本题一次可以跳 1~n 级，对于最后一级台阶，我们可以由倒数第二级台阶跳1 级，也可以由倒数第三级台阶跳两级，也可以由倒数第四级台阶跳三级。</p>
<p>规律是 $dp[n] &#x3D; 2*dp[n-1]$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//初始化前面两个</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//依次乘2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">            dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n为台阶数，一次遍历</li>
<li>空间复杂度：O(n)，辅助数组dp的长度为n</li>
</ul>
<p>直接使用数学计算，时间复杂度：O(n)，空间复杂度 O（1）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, number - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义<ul>
<li><code>dp[i]</code>表示爬到第 <code>i</code> 层台阶的最低花费</li>
</ul>
</li>
<li>确定<strong>递推公式（状态转移公式）</strong><ul>
<li>**可以有两个途径得到 <code>dp[i]</code>，一个是 <code>dp[i-1]</code> 一个是 <code>dp[i-2]</code>**。<ul>
<li><code>dp[i - 1]</code> 跳到 <code>dp[i]</code> 需要花费 <code>dp[i - 1] + cost[i - 1]</code>。</li>
<li><code>dp[i - 2]</code> 跳到 <code>dp[i]</code> 需要花费 <code>dp[i - 2] + cost[i - 2]</code>。</li>
</ul>
</li>
<li>从 dp <code>[i-1]</code> 跳还是从 <code>dp[i-2]</code> 跳？一定是选择最少花费的，所以 <code>dp[i]=min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li>
</ul>
</li>
<li>dp 数组如何初始化<ul>
<li>由题意知可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯，那么说明在这两个楼梯上的花费都是 0，即 <code> dp[0] = 0</code> <code>dp[1] = 0 </code></li>
</ul>
</li>
<li>确定遍历顺序<ul>
<li>从左向右遍历</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由题意可知这两个楼梯上的花费都是 0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两种途径选花费最小的</span></span><br><span class="line">            dp[i] = std::<span class="built_in">min</span>(dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】矩形覆盖"><a href="#【剑】矩形覆盖" class="headerlink" title="【剑】矩形覆盖"></a>【剑】矩形覆盖</h2><p>n&#x3D;1, 1 种<br>n&#x3D;2，2 种<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200329.png" alt="Pasted image 20240312070223"><br>n&#x3D;3, 3 种<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200332.gif" alt="Pasted image 20240312070228"><br>n&#x3D;4，5 种<img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200333.jpg" alt="Pasted image 20240312070232"></p>
<p>对 <code>1，2，3，5</code> 这个排列要敏感，是费纳波契数列！<br>$f(n)&#x3D;f(n−1)+f(n−2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">2</span>) <span class="keyword">return</span> number;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(number+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i&lt;number+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//约定 n == 0 时，输出 0, 1时也只有一种</span></span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="comment">//f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rectCover</span>(number - <span class="number">1</span>) + <span class="built_in">rectCover</span>(number - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p>
<p>![[assets&#x2F;Diagram 5.svg]]<br>想要计算到达右下角 <code>[m, n]</code> 的不同路径，只需要计算到达上面和左边两个位置的不同路径。因为这两个位置到终点只有一条路径。这样就拆分成了两个更小的网格。<br><img src="/undefined" alt="Pasted image 20240119171336"></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义<ul>
<li><code>dp[i][j] </code>：表示从 <code>(0,0)</code> 出发，到<code>(i,j)</code> 有 <code>dp[i][j]</code>条不同的路径。</li>
</ul>
</li>
<li>确定<strong>递推公式（状态转移公式）</strong><ul>
<li><code>dp[i, j] = dp[i-1, j] + dp[i, j-1]</code></li>
</ul>
</li>
<li>dp 数组如何初始化<ul>
<li><code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。</li>
</ul>
</li>
<li>确定遍历顺序<ul>
<li><code>dp[i][j]</code> 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导 <code>dp[i][j]</code> 的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 一定是有数值的。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] ：表示从 (0,0) 出发，到(i,j) 有 dp[i][j]条不同的路径。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意起始下标为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p>
<p>上一题已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的 dp 数组保持初始值(0)就可以了。<br><img src="/undefined" alt="Pasted image 20240120132205|300"><img src="/undefined" alt="Pasted image 20240120132158|378"></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义<ul>
<li><code>dp[i][j] </code>：表示从 <code>(0,0)</code> 出发，到 <code>(i,j)</code> 有 <code>dp[i][j]</code> 条不同的路径。</li>
</ul>
</li>
<li>确定<strong>递推公式（状态转移公式）</strong><ul>
<li><code>dp[i, j] = dp[i-1, j] + dp[i, j-1]</code>，注意这里，<strong>如果有障碍就标记对应的 dp 数组保持初始值 0 就可以了。</strong></li>
</ul>
</li>
<li>dp 数组如何初始化<ul>
<li><code>dp[i][0]</code> 一定都是 1，因为从 (0, 0)的位置到 (i, 0)的路径只有一条，那么 <code>dp[0][j]</code> 也同理。<strong>如果（i，0）这条边有了障碍，那么障碍之后（包括障碍）都是走不到的位置了</strong>，这些 dp 数组都是初始值 0。（0，j）同理 <img src="/undefined" alt="Pasted image 20240120132110"></li>
</ul>
</li>
<li>确定遍历顺序<ul>
<li><code>dp[i][j]</code> 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导 <code>dp[i][j]</code> 的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 一定是有数值的。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果在起点或终点出现了障碍物</span></span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dp数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有障碍物的位置及其后面的位置保持初始值0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//有障碍物的位置保持初始值0，不参与计算</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="【剑】礼物的最大价值"><a href="#【剑】礼物的最大价值" class="headerlink" title="【剑】礼物的最大价值"></a>【剑】礼物的最大价值</h2><p>[[#不同路径]] 的变式，思想基本一致</p>
<p><code>dp[i][j]</code> 表示走到 <code>grid[i][j]</code> 能拿到多少价值的礼物，等于上一个格子的价值+当前格子的价值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一列</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="【剑】整数拆分（剪绳子）"><a href="#【剑】整数拆分（剪绳子）" class="headerlink" title="【剑】整数拆分（剪绳子）"></a>【剑】整数拆分（剪绳子）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&tqId=587690&ru=/practice/1a834e5e3e1a4b7ba251417554e07c00&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">剪绳子_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>贪心：数学解法：每次拆成 n 个3，如果剩下是4，则保留4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> product = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当n&gt;4时，拆分越多的3，乘积结果越大</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            product *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product *= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划解法：</p>
<ol>
<li><strong>确定dp数组以及下标的含义</strong></li>
</ol>
<p><code>dp[i]</code>：分拆数字<code>i</code>，可以得到的最大乘积为<code>dp[i]</code>。</p>
<ol start="2">
<li><strong>确定递推公式</strong></li>
</ol>
<p>同样递推！如果我有一个长度为 n 的绳子，我们要怎么确定其分出最大的乘积，我们可以尝试其中一段不可分的为 j，那么如果另一段 n−j 最大乘积已知，我们可以遍历所有 j 找到这个最大乘积。因此用 <code>dp[i]</code> 表示长度为 i 的绳子可以被剪出来的最大乘积，那么后续遍历每个 j 的时候，我们取最大 <code>dp[i]=max(dp[i], j∗dp[i−j])</code>就好了。&#96;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以被分成两份</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">    <span class="comment">//取最大值</span></span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i], j * dp[i - j]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dp的初始化<br>dp[0]和 dp[1]没有意义，不用初始化。</li>
</ol>
<p>dp[2]~dp[4] 直接初始化</p>
<ol start="4">
<li><strong>确定遍历顺序</strong></li>
</ol>
<p><code>dp[i]</code> 是依靠 <code>dp[i - j]</code>的状态，所以遍历<code>i</code>一定是<strong>从前向后</strong>遍历，先有<code>dp[i - j]</code>再有<code>dp[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">5</span>; i&lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], j * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="剪绳子（进阶版）"><a href="#剪绳子（进阶版）" class="headerlink" title="剪绳子（进阶版）"></a>剪绳子（进阶版）</h3><p>【困难】<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/106f666170554379ab1974e5a601e741?tpId=13&tqId=2254224&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">剪绳子（进阶版）_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>该题和上一题唯一的区别就是数据范围巨大，由于答案过大，题目要求对 998244353 取模。<br>用老方法法线内存占用爆炸</p>
<p>需要使用[[#快速幂 + 快速乘法（难）]]</p>
<p>答案可见官方题解<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/106f666170554379ab1974e5a601e741?tpId=13&tqId=2254224&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">剪绳子（进阶版）_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h2 id="【剑】把数字翻译成字符串-规律不好找"><a href="#【剑】把数字翻译成字符串-规律不好找" class="headerlink" title="【剑】把数字翻译成字符串 (规律不好找)"></a>【剑】把数字翻译成字符串 (规律不好找)</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&tqId=1024831&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把数字翻译成字符串_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>设置 $dp[i]$ 为数字串从左到右第 i 个数字结尾的当前数字串所拥有的翻译方法数，往前一步，如果拼接成的数在 <code>[11,19]</code> 或者 <code>[21,26]</code> 的范围内，那么 $dp[i] &#x3D; dp[i-1] + dp[i-2]$；否则 $dp[i] &#x3D; dp[i-1]$；<br>特别的当拼接的数为 10 或者 20 时，由于不存在数字0的译码，往前一步不会增加译码数，只有10或者20各自对应的译码，因此 $dp[i]&#x3D;dp[i-2]$ 最终的译码方法数为 $dp[len-1]$，其中 $len$ 表示数字串的长度。将上述分析可归纳为最终的转移方程,如下： </p>
<ul>
<li>如果 $i&#x3D;0$, $dp[i]&#x3D;1$</li>
<li>否则如下:  <ul>
<li>如果 $nums[i]&#x3D;0$,如果10或者20出现在开头，则 $dp[1]&#x3D;1$;否则$dp[i]&#x3D;dp[i-2]$  </li>
<li>否则如果拼接的数在规定的范围内，$dp[i]&#x3D;dp[i-1]+dp[i-2]$  </li>
<li>以上情况均不符合 $dp[i]&#x3D;dp[i-1]$</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span> || nums[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)<span class="comment">//排除掉空数字串以及以0开始的数字串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len,<span class="number">0</span>)</span></span>;<span class="comment">//dp[i]用于存储到第i位数字的译码方案数，其中i=0,1,2...len-1</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//i=0,第一位数结尾的译码方法数必为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>] ==<span class="string">&#x27;1&#x27;</span>||nums[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span>) dp[i] = <span class="number">1</span>;<span class="comment">//数字串以10或者20开头的情况</span></span><br><span class="line">                    <span class="keyword">else</span> dp[i] = dp[i<span class="number">-2</span>];<span class="comment">//数字串中存在10或者20的情况下，当前译码数等于后退两步的译码数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || (nums[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums[i] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums[i] &lt;= <span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>) dp[i] = <span class="number">2</span>;<span class="comment">//数字串开始不是10或者20的情况，dp[1]=2</span></span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="不同的二叉搜索树-规律不好找"><a href="#不同的二叉搜索树-规律不好找" class="headerlink" title="不同的二叉搜索树 (规律不好找)"></a>不同的二叉搜索树 (规律不好找)</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a> </p>
<p>本题不需要实际操作树，先找规律：</p>
<p><img src="/undefined" alt="Pasted image 20240120144648|500"> <img src="/undefined" alt="Pasted image 20240120144713"></p>
<ul>
<li><p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，和 n 为2的时候两棵树的布局是一样的。</p>
</li>
<li><p>当 2 为头结点的时候，其左右子树都只有一个节点，布局和 n 为 1 的时候只有一棵树的布局也是一样的。</p>
</li>
<li><p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，和 n 为 2 的时候两棵树的布局是一样的。</p>
</li>
<li><p>发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过 <code>dp[1]</code> 和 <code>dp[2]</code> 来推导出来 <code>dp[3]</code> 的某种方式。</p>
</li>
</ul>
<p>思考到这里，这道题目就有眉目了：</p>
<ul>
<li><code>dp[3]</code>，就是元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</li>
<li>元素1为头结点搜索树的数量 &#x3D; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</li>
<li>元素2为头结点搜索树的数量 &#x3D; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</li>
<li>元素3为头结点搜索树的数量 &#x3D; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</li>
</ul>
<p>有2个元素的搜索树数量就是<code>dp[2]</code>。<br>有1个元素的搜索树数量就是<code>dp[1]</code>。<br>有0个元素的搜索树数量就是<code>dp[0]</code>。<br>所以 <code>dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</code><br><img src="/undefined" alt="Pasted image 20240120150228"></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义</li>
</ol>
<p>**<code>dp[i]</code> ： 1到 <code>i</code> 为节点值组成的二叉搜索树的个数为 <code>dp[i]</code>**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在上面的分析中，其实已经看出其递推关系， <code>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code> （注意是<code>+=</code>）<br><code>j</code> 相当于是头结点的元素，从1遍历到 <code>i</code> 为止。</p>
<p>所以递推公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code> ，<code>j-1</code> 为<code>j</code>为头结点左子树节点数量，<code>i-j</code> 为以<code>j</code>为头结点右子树节点数量</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>初始化，只需要初始化 <code>dp[0]</code>就可以了，推导的基础，都是 <code>dp[0]</code>。<br>那么<code>dp[0]</code>应该是多少呢？<br>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p>
<p>从递归公式上来讲，<code>dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code> 中以j为头结点左子树节点数量为0，也需要<code>dp[以j为头结点左子树节点数量] = 1</code>， 否则乘法的结果就都变成0了。</p>
<p>所以初始化 <code>dp[0] = 1</code></p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>首先一定是遍历节点数，从递归公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>可以看出，节点数为<code>i</code>的状态是依靠 <code>i</code>之前节点数的状态。<br>那么遍历 <code>i</code> 里面每一个数作为头结点的状态，用 <code>j</code> 来遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coded-ream/p/7208019.html">背包问题（背包九讲） - Code-dream - 博客园 (cnblogs.com)</a></p>
<p>背包问题有很多，主要掌握01背包和完全背包，多重背包作为补充。</p>
<p>完全背包是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。<strong>所以背包问题的理论基础重中之重是01背包</strong></p>
<p><strong>一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong><br><img src="/undefined" alt="Pasted image 20240120154753"></p>
<h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>有 <code>n</code> 件物品和一个最多能背重量为 <code>w</code> 的背包。第 i 件物品的重量是 <code>weight[i]</code>，得到的价值是 <code>value[i]</code> 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200177.jpg" alt="动态规划-背包问题|500"></p>
<p>接下来还是用如下这个例子来进行讲解</p>
<ul>
<li>背包最大重量为 4。</li>
<li>物品为：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h4 id="二维-dp-数组-01-背包"><a href="#二维-dp-数组-01-背包" class="headerlink" title="二维 dp 数组 01 背包"></a>二维 dp 数组 01 背包</h4><ol>
<li>确定 dp 数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，<strong>即<code>dp[i][j] </code>表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少。</strong></p>
<p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：<br><img src="/undefined" alt="Pasted image 20240120161202"></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>两个方向推出来 <code>dp[i][j]</code>：</p>
<ul>
<li>**不放物品<code>i</code>**：由<code>dp[i - 1][j]</code>推出，即背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品<code>i</code>的重量大于背包<code>j</code>的重量时，物品<code>i</code>无法放进背包中，所以背包内的价值依然和前面相同。)</li>
<li>**放物品 <code>i</code>**：由 <code>dp[i - 1][j - weight[i]]</code> 推出，<code>dp[i - 1][j - weight[i]] </code> 为背包容量为 <code>j - weight[i]</code> 的时候不放物品 i 的最大价值，那么 <code>dp[i - 1][j - weight[i]] + value[i]</code> （物品 i 的价值），就是背包放物品 <code>i</code> 得到的最大价值</li>
</ul>
<p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;</p>
<ol start="3">
<li>dp 数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>首先从 <code>dp[i][j]</code> 的定义出发，如果背包容量 <code>j</code> 为 0 的话，即 <code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。<br><img src="/undefined" alt="Pasted image 20240129140654"><br>在看其他情况。</p>
<p>状态转移方程 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> 可以看出 <code>i</code> 是由 <code>i-1</code> 推导出来，那么 i 为0的时候就一定要初始化。 </p>
<p><code>dp[0][j]</code>，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<ul>
<li>当 <code>j &lt; weight[0]</code> 的时候，<code>dp[0][j]</code> 应该是 <code>0</code>，因为背包容量比编号0的物品重量还小。</li>
<li>当 <code>j &gt;= weight[0]</code> 时，<code>dp[0][j]</code> 应该是 <code>value[0]</code>，因为背包容量放足够放编号0物品。</li>
</ul>
<p>代码初始化如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////如果把dp数组预先初始化为0了，这一步就可以省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) </span><br><span class="line">&#123;  </span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 dp 数组初始化情况如图所示：<br><img src="/undefined" alt="Pasted image 20240129140707"><br><code>dp[0][j]</code> 和 <code>dp[i][0]</code>都已经初始化了，那么其他下标应该初始化多少呢？</p>
<p>其实从递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;可以看出<code>dp[i][j]</code> 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>
<p><strong>初始-1，初始-2，初始100，都可以！</strong></p>
<p>但只不过一开始就统一把 dp 数组统一初始为0，更方便一些。如图：<br><img src="/undefined" alt="Pasted image 20240129140750"><br>最后初始化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) </span><br><span class="line">&#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量<br><img src="/undefined" alt="Pasted image 20240127101107"></p>
<p>那么问题来了，<strong>先遍历物品还是先遍历背包重量呢？</strong></p>
<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>
<p>那么我先给出先遍历物品，然后遍历背包重量的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) </span><br><span class="line">    &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/undefined" alt="Pasted image 20240127101203"><br><strong>虽然两个 for 循环遍历的次序不同，但是 <code>dp[i][j]</code>所需要的数据就是左上角，根本不影响 <code>dp[i][j]</code>公式的推导！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维dp数组实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, bagweight;<span class="comment">// bagweight代表行李箱空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 存储每件物品所占空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 存储每件物品价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; value[j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化, 因为需要用到dp[i - 1]的值</span></span><br><span class="line">    <span class="comment">// j &lt; weight[0]已在上方被初始化为0</span></span><br><span class="line">    <span class="comment">// j &gt;= weight[0]的值就初始化为value[0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历行李箱容量</span></span><br><span class="line">            <span class="comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span></span><br><span class="line">            <span class="comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="一维-dp-数组（滚动数组）"><a href="#一维-dp-数组（滚动数组）" class="headerlink" title="一维 dp 数组（滚动数组）"></a>一维 dp 数组（滚动数组）</h4><blockquote>
<p>[!NOTE]<br>做这类题目，需要确定三个点：背包容量，物品重量、物品价值</p>
</blockquote>
<p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max (dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<p><strong>其实可以发现如果把 <code> dp[i - 1]</code> 那一层拷贝到 <code>dp[i]</code> 上，表达式完全可以是，即利用上一层的 <code>dp[i]</code>计算当前层：<code>dp[i][j] = max (dp[i][j], dp[i][j - weight[i]] + value[i])</code></strong></p>
<p><strong>与其把 <code>dp[i - 1]</code>这一层拷贝到 <code>dp[i]</code>上，不如只用一个一维数组了</strong>，只用 <code>dp[j]</code>（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<p>一定要时刻记住这里 i 和 j 的含义，要不然很容易看懵了。<br><code>i</code>: 物品下标<br><code>j</code>: 背包容量</p>
<hr>
<p><strong>动规五部曲分析如下：</strong></p>
<ol>
<li>确定 dp 数组的定义</li>
</ol>
<p>在一维 dp 数组中，**<code>dp[j]</code>表示：容量为 <code>j</code> 的背包，所背的物品价值可以最大为 <code>dp[j]</code>。**</p>
<ol>
<li>一维 dp 数组的递推公式</li>
</ol>
<p><strong><code>dp[j]</code>可以通过 <code>dp[ j - weight[i] ]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为 <code>j - weight[i]</code>的背包所背的最大价值。</strong></p>
<p><strong><code>dp[j - weight[i]] + value[i]</code> 表示容量为 <code>j - 物品 i 重量</code>的背包加上物品 <code>i</code> 的价值。（也就是容量为 <code>j</code> 的背包，放入物品 <code>i</code>了之后的价值即：<code>dp[j]</code>）</strong></p>
<p>此时 <code>dp[j]</code> 有两个选择，一个是取自己 <code>dp[j]</code> 相当于二维 dp 数组中的 <code>dp[i-1][j]</code>，即不放物品 <code>i</code> ，已经放不下了。一个是取 <code>dp[ j - weight[i] ] + value[i]</code>，即放物品 <code>i</code>，指定是取最大的，毕竟是求最大价值。</p>
<p>所以递归公式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>

<ol>
<li>一维 dp 数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和 dp 数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p><code>dp[j]</code> 表示：容量为 <code>j</code> 的背包，所背的物品价值可以最大为 <code>dp[j]</code>，那么 <code>dp[0]</code> 就应该是 0，因为背包容量为 0 所背的物品的最大价值就是 0。</p>
<p>那么 dp 数组除了下标 0 的位置，初始为 0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：<code>dp[j] = max (dp[j], dp[j - weight[i]] + value[i])</code></p>
<ul>
<li>**如果题目给的价值都是正整数那么非 0 下标都初始化为 0 就可以了，</li>
<li><strong>如果题目给的价值有负数，那么非 0 下标就要初始化为负无穷。</strong></li>
</ul>
<p>这样才能让 dp 数组在递推的过程中取得最大的价值，而不是被初始值覆盖了</p>
<p>那么我假设物品价值都是大于 0 的，所以 dp 数组初始化的时候，都初始为 0 就可以了。</p>
<ol>
<li>一维 dp 数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) </span><br><span class="line">    &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一维 dp 遍历的时候，背包是从大到小。为什么呢？</strong></p>
<p><strong>倒序遍历是为了保证物品 i 只被放入一次！</strong>。但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！</p>
<p>举一个例子：物品 0 的重量 weight[0] &#x3D; 1，价值 value[0] &#x3D; 15<br>如果正序遍历</p>
<ul>
<li>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</li>
<li>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30<br>此时 dp[2]就已经是 30 了，意味着物品 0，被放入了两次，所以不能正序遍历。</li>
</ul>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算 dp[2]</p>
<ul>
<li>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp 数组已经都初始化为 0）</li>
<li>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15<br>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</li>
</ul>
<p><strong>两个嵌套 for 循环的顺序是先遍历物品嵌套遍历背包容量</strong>，<mark style="background: #FFB8EBA6;">不可以</mark>先遍历背包容量嵌套遍历物品。</p>
<ol>
<li>举例推导 dp 数组</li>
</ol>
<p>一维 dp，分别用物品 0，物品 1，物品 2 来遍历背包，最终得到结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292200178.jpg" alt="动态规划-背包问题9"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) </span><br><span class="line">        &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_1_wei_bag_problem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，一维 dp 的 01 背包，要比二维简洁的多！ 初始化和遍历顺序相对简单了。</p>
<p><strong>所以我倾向于使用一维 dp 数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p>
<p><strong>在后面背包问题的讲解中，我都直接使用一维 dp 数组来进行推导</strong>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有 <code>n</code> 件物品和一个容量为 <code>w</code> 的背包。第 i 件物品的重量是 <code>weight[i]</code>，价值是 <code>value[i]</code> 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>01 背包每件物品只能用一次！</strong></p>
<p>以一维 dp 数组为例：</p>
<ol>
<li>ij 含义： <code>i</code>: 物品下标  <code>j</code>: 背包容量</li>
<li>dp 数组的定义：**<code>dp[j]</code> 表示：容量为 <code>j</code> 的背包，所背的物品价值可以最大为 <code>dp[j]</code>。**</li>
<li>dp 数组的递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></li>
<li>初始化：<ul>
<li>dp[0] &#x3D; 0</li>
<li>物品价值都是正整数，非 0 下标都初始化为 0</li>
<li>物品价值有负数，非 0 下标都初始化为负无穷</li>
</ul>
</li>
<li>先<strong>正序</strong>遍历物品，再<strong>倒序</strong>遍历背包容量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,w; <span class="comment">//n件物品和容量为w的背包</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化每件物品的重量和价值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;weight[i]&gt;&gt;value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(w + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[j] 表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]。        </span></span><br><span class="line">        <span class="comment">// i: 物品下标  j: 背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【正序遍历】物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 【倒序遍历】背包容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = w; j &gt;= weight[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-weight[i]]+value[i]); <span class="comment">//递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;dp[w]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集 - 力扣（LeetCode）</a></p>
<p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<strong>那么只要找到集合里能够出现 sum &#x2F; 2 的子集总和，就算是可以分割成两个相同元素和子集了。</strong></p>
<p><strong>本题的元素我们只能用一次，所以本题使用的是 01 背包</strong></p>
<ul>
<li>背包的<strong>容量</strong>为 sum &#x2F; 2</li>
<li><strong>物品重量</strong>为元素的数值，<strong>物品价值</strong>也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<ol>
<li>确定 dp 数组以及下标的含义</li>
</ol>
<p>01背包中，<code>dp[j]</code> 表示： 容量为j的背包，所背的物品价值最大可以为<code>dp[j]</code>。</p>
<p><strong>注意，本题中每一个元素的数值既是重量，也是价值。</strong></p>
<p>那么如果背包容量为 target，<code>dp[target]</code> 就是装满背包之后的重量，所以当 <code>dp[target] == target</code> 的时候，背包就装满了。</p>
<p>有录友可能想，那还有装不满的时候？<br>拿输入数组 [1, 5, 11, 5]，举例， dp[7] 只能等于 6，因为 只能放进 1 和 5。而dp[6] 就可以等于6了，放进1 和 5，那么dp[6] &#x3D;&#x3D; 6，说明背包装满了。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>01背包的递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></p>
<p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p>
<p>所以递推公式：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])</code>;</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从dp[j]的定义来看，首先dp[0]一定是0。</p>
<p>本题题目中只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>如果使用一维 dp 数组，物品遍历的 for 循环放在外层，遍历背包的 for 循环放在内层，且内层 for 循环倒序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//数组和不能整除2, 说明不能分割</span></span><br><span class="line">        <span class="type">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target; j&gt;=nums[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了</span></span><br><span class="line">        <span class="comment">//集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span>(dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a><br>本题其实就是<strong>尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小</strong>，<strong>这样就化解成01背包问题了</strong>。</p>
<p>本题物品重量为 <code>stones[i]</code>，物品价值也为 <code>stones[i]</code>。（对应01背包里的 <code>weight[i]</code>和 <code>value[i]</code>）</p>
<p><strong>动规五部曲：</strong></p>
<ol>
<li>确定 dp 数组以及下标的含义</li>
</ol>
<p><code>dp[j]</code> 表示容量为 j 的背包，最多可以装的价值为 <code>dp[j]</code>。</p>
<ol start="2">
<li><p>确定递推公式<br><code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code></p>
</li>
<li><p>dp数组如何初始化</p>
</li>
</ol>
<p>既然 <code>dp[j]</code>中的<code>j</code>表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。<br><strong>而我们要求的 target 其实只是最大重量的一半，所以 dp 数组开到15000大小就可以了。</strong> 当然也可以把石头遍历一遍，计算出石头总重量然后除2，得到 dp 数组的大小。<strong>我这里就直接用15000了。</strong></p>
<p>如何初始化 <code>dp[j]</code>呢，因为重量都不会是负数，所以 <code>dp[j]</code>都初始化为0就可以了，</p>
<ol start="4">
<li><p>确定遍历顺序<br>使用一维 dp 数组，物品遍历的 for 循环放在外层，遍历背包的 for 循环放在内层，且内层 for 循环倒序遍历</p>
</li>
<li><p>举例推导 dp 数组</p>
</li>
</ol>
<p>举例，输入：[2,4,1,1]，此时 target &#x3D; (2 + 4 + 1 + 1)&#x2F;2 &#x3D; 4 ，dp 数组状态图如下<br><img src="/undefined" alt="Pasted image 20240129153940"><br>最后 <code>dp[target]</code>里是容量为 target 的背包所能背的最大重量。</p>
<p>那么分成两堆石头，一堆石头的总重量是<code>dp[target]</code>，另一堆就是sum - <code>dp[target]</code>。</p>
<p><strong>在计算 <code>target</code> 的时候，<code>target = sum / 2</code> 因为是向下取整，所以 <code>sum - dp[target]</code> 一定是大于等于 <code>dp[target]</code>的</strong>。 </p>
<p>那么相撞之后剩下的最小石头重量就是 <code>(sum - dp[target]) - dp[target]</code>。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(),stones.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;stones.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历背包重量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target;j&gt;=stones[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum - dp[target]) - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和 - 力扣（LeetCode）</a></p>
<p>如何转化为01背包问题呢。</p>
<p>我们将给定数组元素的总和记为 <code>sum</code> ，假设其中加法的总和为 <code>x</code>，那么减法对应的总和就是 <code>sum - x</code>。所以我们要求的是 <code>x - (sum - x) = target</code></p>
<p>故 <code>x = (target + sum) / 2</code></p>
<p><strong>此时问题就转化为，装满容量为<code>x</code>的背包，有几种方法</strong>。这里的 <code>x</code>，就是 <code>bagSize</code>，也就是我们后面要求的<strong>背包容量</strong>。 </p>
<p>如果 (target + sum) &#x2F; 2 结果不为整数，或者 target 的绝对值已经大于 sum，是没有可行方案的。</p>
<p>再回归到01背包问题，为什么是01背包呢？<br>因为每个物品（题目中的1）只用一次！<br><strong>这次和之前遇到的背包问题不一样了，之前都是求容量为 j 的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个组合问题了。</strong></p>
<ol>
<li>确定 dp 数组以及下标的含义</li>
</ol>
<p><code>dp[j]</code> 表示：填满<code>j</code>（包括j）这么大容积的包，有<code>dp[j]</code>种方法</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>有哪些来源可以推出<code>dp[j]</code>呢？<br>只要搞到 <code>nums[i]</code>，凑成 <code>dp[j]</code>就有 <code>dp[j - nums[i]]</code> 种方法。</p>
<p>例如：<code>dp[j]</code>，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]种方法凑成容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]种方法凑成容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]种方法凑成容量为5的背包</li>
</ul>
<p><strong>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</strong></p>
<p>所以求组合类问题的公式，都是类似这种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>

<p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p>
<ol start="3">
<li>dp 数组如何初始化</li>
</ol>
<p>从递推公式可以看出，在初始化的时候<code>dp[0]</code> 一定要初始化为1，因为<code>dp[0]</code>是在公式中一切递推结果的起源，如果<code>dp[0]</code>是0的话，递推结果将都是0。</p>
<p>如果数组[0] ，target &#x3D; 0，那么 bagSize &#x3D; (target + sum) &#x2F; 2 &#x3D; 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p>
<p>所以本题我们应该初始化 dp[0] 为 1。</p>
<p>可能有同学想了，那 如果是 数组[0,0,0,0,0] target &#x3D; 0 呢。</p>
<p>其实 此时最终的dp[0] &#x3D; 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] &#x3D; 1 累加起来的。</p>
<p>dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由 dp[j - nums[i]]推导出来。</p>
<ol start="4">
<li>确定遍历顺序<br>使用一维 dp 数组，nums 放在外循环，target 在内循环，且内循环倒序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面两种情况没有方案</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((target + sum) % <span class="number">2</span> != <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bagSize = (target + sum)/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = bagSize;j&gt;=nums[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/">474. 一和零 - 力扣（LeetCode）</a></p>
<p>本题其实是01背包问题！</p>
<p>只不过这个背包有两个维度，一个是 <code>m</code> 一个是 <code>n</code>，而不同长度的字符串就是不同大小的待装物品。 </p>
<p>开始动规五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**<code>dp[i][j]</code>：最多有i个0和j个1的strs的最大子集的大小为<code>dp[i][j]</code>**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p>
<p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum] + 1</code></p>
<p>然后我们在遍历的过程中，取dp[i][j]的最大值。</p>
<p>所以递推公式：<code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code></p>
<p>此时大家可以回想一下01背包的递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>对比一下就会发现，<strong>字符串的zeroNum和oneNum相当于物品的重量（<code>weight[i]</code>），字符串本身的个数相当于物品的价值（<code>value[i]</code>）。</strong></p>
<p><strong>这就是一个典型的01背包！</strong> 只不过物品的重量有了两个维度而已。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>物品价值不会是负数，dp数组初始化为0</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>外层 for 循环遍历物品，内层 for 循环遍历背包容量且从后向前遍历！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 默认初始化0</span></span><br><span class="line">        <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历背包容量且从后向前遍历！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有<code>N</code>件物品和一个最多能背重量为<code>W</code>的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>我依然举这个例子：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p><strong>01背包和完全背包唯一不同就是体现在遍历顺序上</strong>，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！</p>
<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而<strong>完全背包的物品是可以添加多次的，所以要从小到大去遍历</strong>，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) </span><br><span class="line">    &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先遍历物品，或者先遍历背包都是可以的。</p>
<h4 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></p>
<p>题目中假设每一种面额的硬币有无限个，所以说这是一个完全背包问题。<br>但本题和纯完全背包不一样，<strong>纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！</strong><br>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？<br>例如示例 1：<br>5 &#x3D; 2 + 2 + 1<br>5 &#x3D; 2 + 1 + 2<br>这是<strong>一种组合</strong>，都是 2 2 1。<br>如果问的是排列数，那么上面就是<strong>两种排列</strong>了。<br><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。</p>
<p>动规五部曲：</p>
<ol>
<li><p>确定 dp 数组（dp table）以及下标的含义<code> </code>dp[j]<code>：凑成总金额</code>j<code>的货币组合数为dp</code>[j]&#96;</p>
</li>
<li><p>确定递推公式<br><strong>求装满背包有几种方法，公式都是：<code>dp[j] += dp[j - nums[i]]</code>;</strong>&#96;</p>
</li>
<li><p>dp 数组如何初始化</p>
</li>
</ol>
<p>因为递推公式 <code>dp[i] += dp[i - nums[j]]</code> 的缘故，<code>dp[0]</code> 要初始化为 1，这样递归其他 <code>dp[i]</code> 的时候才会有数值基础。</p>
<p>至于非 0 下标的 <code>dp[i]</code> 应该初始化为 0，这样才不会影响 <code>dp[i]</code> 累加所有的 <code>dp[i - nums[j]]</code>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>本题中我们是外层 for 循环遍历物品（钱币），内层 for 遍历背包（金钱总额），还是外层 for 遍历背包（金钱总额），内层 for 循环遍历物品（钱币）呢？</p>
<p>纯完全背包的两个 for 循环的先后顺序都是可以的。<strong>但本题就不行了！</strong></p>
<p>因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！</p>
<p><strong>而本题要求凑成总和的组合数，元素之间明确要求没有顺序。</strong></p>
<p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p>
<p>本题是求凑出来的方案个数，且每个方案个数是为组合数。</p>
<p>那么本题，两个for循环的先后顺序可就有说法了。</p>
<p><strong>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) </span><br><span class="line">    &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。<br>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。<br><strong>所以这种遍历顺序中 dp[j]里计算的是组合数！</strong></p>
<p>如果把两个 for 交换顺序，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) </span><br><span class="line">&#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coins.<span class="built_in">size</span>(); j++) </span><br><span class="line">    &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span>) dp[i] += dp[i - coins[j]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<br><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p>综上：在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。</p>
<ul>
<li><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</li>
<li><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = coins[i]; j&lt;=amount; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和-Ⅵ"><a href="#组合总和-Ⅵ" class="headerlink" title="组合总和 Ⅵ"></a>组合总和 Ⅵ</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p>
<p>本题题目让求总和，但是示例中的注意事项提示顺序不同的序列被视作不同的组合。<strong>此题实际上是求序列！</strong></p>
<ol>
<li>确定 dp 数组以及下标的含义</li>
</ol>
<p><strong><code>dp[i]</code>: 凑成总和为 <code>i</code> 的排列个数为 <code>dp[i]</code></strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>求装满背包有几种方法，递推公式一般都是<code>dp[i] += dp[i - nums[j]]</code></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>因为递推公式<code>dp[i] += dp[i - nums[j]]</code>的缘故，<code>dp[0]</code>要初始化为1，这样递归其他<code>dp[i]</code>的时候才会有数值基础。</p>
<p>至于非0下标的<code>dp[i]</code>应该初始化为0，这样才不会影响<code>dp[i]</code>累加所有的<code>dp[i - nums[j]]</code>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>个数可以不限使用，说明这是一个完全背包。</p>
<p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。内循环从前到后遍历。</p>
<p>注意，此题 C++测试用例有两个数相加超过 int 的数据，所以需要在 if 里加上 <code>dp[i] &lt; INT_MAX - dp[i - nums[j]]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;=target; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//再遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意题目数据保证答案符合 32 位整数范围。</span></span><br><span class="line">                <span class="keyword">if</span>(i-nums[j]&gt;=<span class="number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p>
<p>题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。</p>
<p>动规五部曲：</p>
<ol>
<li><p>确定 dp 数组（dp table）以及下标的含义 <code>**dp[j]：凑足总额为</code>j<code> 所需的最少硬币个数为 dp[j]**</code></p>
</li>
<li><p>确定递推公式<br>凑足总额为<code> j - coins[i]</code>的最少个数为 <code>dp[j - coins[i]]</code>，那么只需要加上一个钱币 <code>coins[i]</code>即 <code>dp[j - coins[i]] + 1</code>就是 <code>dp[j]</code>（考虑 <code>coins[i]</code>）<br>所以<code>dp[j]</code> 要取所有 <code>dp[j - coins[i]] + 1</code> 中最小的。<br>递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code></p>
</li>
<li><p>dp 数组如何初始化</p>
</li>
</ol>
<p>首先凑足总金额为0所需钱币的个数一定是0，那么 <code>dp[0] = 0</code>;</p>
<p>其他下标对应的数值呢？<br>考虑到递推公式的特性，<code>dp[j]</code>必须初始化为一个最大的数，否则就会在<code>min(dp[j - coins[i]] + 1, dp[j])</code>比较的过程中被初始值覆盖。<br>所以下标非0的元素都是应该是最大值。</p>
<ol start="4">
<li>确定遍历顺序<br>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。<br>所以本题并不强调集合是组合还是排列。<br>我们选择外层遍历物品，内层遍历背包，由于是完全背包，内层循环从前向后。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = coins[i]; j&lt;= amount; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果dp[j-coins[i]]是初始值则跳过</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j-coins[i]] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j-coins[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><p>动规五部曲：</p>
<ol>
<li><p>确定 dp 数组（dp table）以及下标的含义 <code>**dp[j]：和为</code>j<code> 所需的最少完全平方数个数为 dp[j]**</code></p>
</li>
<li><p>确定递推公式<br><code>dp[j]</code> 可以由<code>dp[j - i * i]</code>推出， <code>dp[j - i * i] + 1</code> 便可以凑成<code>dp[j]</code>。<code> 取最小的，所以递推公式为：</code>dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j])&#96;</p>
</li>
<li><p>dp 数组如何初始化<br>dp[0]表示 和为0的完全平方数的最小数量，那么<code>dp[0]</code>一定是0。&#96;</p>
</li>
</ol>
<p>其他下标对应的数值呢？<br>考虑到递推公式的特性，<code>dp[j]</code> 必须初始化为一个最大的数，否则就会在 <code>min(dp[j - 1] + 1, dp[j])</code> 比较的过程中被初始值覆盖。<br>所以下标非0的元素都是应该是最大值。</p>
<ol start="4">
<li>确定遍历顺序<br>所以本题并不强调集合是组合还是排列, 那么有顺序和没有顺序都可以。<br>我们选择外层遍历物品，内层遍历背包，由于是完全背包，内层循环从前向后。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历物品</span></span><br><span class="line">        <span class="comment">//n从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i*i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i*i; j&lt;=n; j++)</span><br><span class="line">            &#123;   </span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j- i*i]+<span class="number">1</span>, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="单词拆分（不懂）"><a href="#单词拆分（不懂）" class="headerlink" title="单词拆分（不懂）"></a>单词拆分（不懂）</h4><p>单词就是物品，字符串 s 就是背包，单词能否组成字符串 s，就是问物品能不能把背包装满。</p>
<p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong><code>dp[i]</code> : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果确定<code>dp[j]</code> 是true，且 <code>[j, i]</code> 这个区间的子串出现在字典里，那么<code>dp[i]</code>一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 <code>if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true)</code> 那么 <code>dp[i] = true</code>。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式中可以看出，<code>dp[i]</code> 的状态依靠 <code>dp[j]</code>是否为true，那么<code>dp[0]</code>就是递推的根基，<code>dp[0]</code>一定要为true，否则递推下去后面都都是false了。</p>
<p>那么<code>dp[0]</code>有没有意义呢？</p>
<p><code>dp[0]</code>表示如果字符串为空的话，说明出现在字典里。</p>
<p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么<code>dp[0]</code>初始为true完全就是为了推导公式。</p>
<p>下标非0的<code>dp[i]</code>初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>还要讨论两层for循环的前后顺序。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>我在这里做一个总结：</p>
<p>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II (opens new window)</a><br>求排列数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)</a><br>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></p>
<p>而<strong>本题其实我们求的是排列数</strong>，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p>
<p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p>
<p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是强调物品之间顺序。</p>
<p><strong>所以说，本题一定是 先遍历 背包，再遍历物品。</strong><br>5. 举例推导 dp[i]</p>
<p>以输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]为例，dp状态如图：</p>
<p><img src="/undefined" alt="Pasted image 20240201153714"></p>
<p><code>dp[s.size()]</code> 就是最终结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="多重背包（略）"><a href="#多重背包（略）" class="headerlink" title="多重背包（略）"></a>多重背包（略）</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">代码随想录 (programmercarl.com)</a></p>
<h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a><br>首先通过本题大家要明确什么是子序列，“子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序”。</p>
<p>子序列问题是动态规划解决的经典问题，当前下标 <code>i</code> 的递增子序列长度，其实和 <code>i</code> 之前的下标 <code>j</code> 的子序列长度有关系，那又是什么样的关系呢。</p>
<p>接下来，我们依然用动规五部曲来详细分析一波：</p>
<ol>
<li>dp[i]的定义</li>
</ol>
<p><strong><code>dp[i]</code>表示<code>i</code>之前包括<code>i</code>的以<code>nums[i]</code>结尾的最长递增子序列的长度</strong></p>
<p>为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p>
<ol start="2">
<li>状态转移方程</li>
</ol>
<p>位置<code>i</code>的最长升序子序列等于<code>j</code>从<code>0</code>到<code>i-1</code>各个位置的最长升序子序列 + 1 的最大值。</p>
<p>所以：<code>if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</code></p>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
<ol start="3">
<li>dp[i]的初始化</li>
</ol>
<p>每一个i，对应的dp[i]（即最长递增子序列）起始大小<strong>至少都是1.</strong></p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p><code>dp[i]</code> 是有0到i-1各个位置的最长递增子序列 推导而来，那么<strong>遍历<code>i</code>一定是从前向后遍历。</strong></p>
<p><code>j</code>其实就是遍历0到<code>i-1</code></p>
<p>遍历i的循环在外层，遍历j则在内层，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// 取长的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[i]表示 i 之前(包括 i) 的以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>; <span class="comment">//dp[i]初始化为1</span></span><br><span class="line">        <span class="type">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                MaxLength = <span class="built_in">max</span>(dp[i], MaxLength); <span class="comment">//取最长的子序列长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回溯法：超时了<br>思路类似 [[#非递减子序列]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断数组是否递增</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsIncrease</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backingtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsIncrease</span>(path))</span><br><span class="line">        &#123;</span><br><span class="line">            MaxLength = std::<span class="built_in">max</span>(MaxLength, (<span class="type">int</span>)path.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用set标记使用过的元素，对本层元素去重</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; UsedNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果元素小于等于path最后一个元素，或者已经使用过该元素，则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(startIndex &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= path.<span class="built_in">back</span>() || UsedNum.<span class="built_in">find</span>(nums[i]) != UsedNum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            UsedNum.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backingtracking</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backingtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">674. 最长连续递增序列 - 力扣（LeetCode）</a></p>
<p>动态规划：<br><code>dp[i]</code>：以下标i为结尾的连续递增的子序列长度&#96;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> MaxLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MaxLength = <span class="built_in">max</span>(MaxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滑动窗口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//right不断增加直到不再递增</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[right] &gt; nums[right<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录之前的递增数组长度</span></span><br><span class="line">            MaxLength = <span class="built_in">max</span>(MaxLength, (right<span class="number">-1</span>)-left+<span class="number">1</span>);</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组 - 力扣（LeetCode）</a></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><code>dp[i][j] </code>：以 <code>A[i-1]</code> 为结尾的A，和以<code>B[j-1]</code> 为结尾的B，最长重复子数组长度为 <code>dp[i][j]</code>。</p>
<p><code>dp[i][j]</code>的定义也就决定着，我们在遍历dp[i][j]的时候i 和 j都要从1开始。</p>
<p>那有同学问了，我就定义dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？</p>
<p>行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分，在本题解下面的拓展内容里，我给出了 第二种 dp数组的定义方式所对应的代码和讲解，大家比较一下就了解了。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</p>
<p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p>
<p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！</p>
<p>但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p>
<p>所以dp[i][0] 和dp[0][j]初始化为0。</p>
<p>举个例子A[0]如果和B[0]相同的话，dp[1][1] &#x3D; dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>外层for循环遍历A，内层for循环遍历B。</p>
<p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p>
<p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p>
<p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来。</p>
<h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p>
<ul>
<li>指定每次拿最大的，最终结果就是拿走最大数额的钱。</li>
<li>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</li>
</ul>
<p>再举一个例子如果是有一堆盒子，你有一个背包体积为 n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>贪心算法没有模板！</p>
<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干 - 力扣（LeetCode）</a></p>
<p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p>
<p>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.<span class="built_in">size</span>() &amp;&amp; j&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反过来也是可以的，大的饼干优先给最大饥饿度的孩子。</p>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列 - 力扣（LeetCode）</a></p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>题目让我们想办法得到一个最长的摆动序列。</p>
<p>在一个局部范围内，我们要保留尽可能多的峰值，实现局部最优。这样在整体的范围内，我们能获得最多的峰值，也就得到了最长的摆动序列，即实现全局最优。</p>
<p>这个序列画一个图，其实题目就是让我们找到这个序列到底转折了多少次，即总共有多少个峰值。先下后上也叫峰值 先上后下也叫峰值。</p>
<p>如图，我们只需要找到所有的局部峰值。题目让我们从原始序列中删除一些元素，来得到一个最长的摆动序列。为这个序列画一个图，其实题目就是让我们找到这个序列到底转折了多少次，如图，我们只需要找到所有的局部峰值。<br><img src="/undefined" alt="Pasted image 20240119104256"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">0</span>] == nums[<span class="number">1</span>]) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从开头找到第一个转折点</span></span><br><span class="line">        <span class="comment">//up记录上一次趋势是往上还是往下，true向上，false向下</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">bool</span> up = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                up = nums[i] &gt; nums[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果最后遍历到最后仍没有转折点，则说明元素值都相同</span></span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里我们已经找到了第一个转折点, 至少已经知道了有两个不同的值</span></span><br><span class="line">        <span class="type">int</span> MaxLength = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//=0 不是转折点，我们不做任何处理</span></span><br><span class="line">            <span class="comment">//&gt;0 说明转折点是上坡</span></span><br><span class="line">            <span class="comment">//&lt;0 说明转折点是下坡</span></span><br><span class="line">            <span class="type">int</span> diff = nums[j] - nums[j<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当前转折点是上坡，上一个转折点是下坡</span></span><br><span class="line">            <span class="comment">//或</span></span><br><span class="line">            <span class="comment">//当前转折点是下坡，上一个转折点是上坡</span></span><br><span class="line">            <span class="keyword">if</span>(diff &gt; <span class="number">0</span> &amp;&amp; !up || diff&lt;<span class="number">0</span> &amp;&amp; up)</span><br><span class="line">            &#123;</span><br><span class="line">                ++MaxLength;</span><br><span class="line">                up = !up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>设当前在第 <code>i</code> 位置，如果想要能追加到前面的摆动序列的结尾，那么我们需要知道一个事情，之前的这摆动序列的结尾是升序还是降序的<br>这样的情况下，我们建立了 2 维 dp 数组</p>
<ul>
<li><code>dp[i][0]</code> 表示，到当前位置，以降序结尾的摆动数组的最长子序列的长度</li>
<li><code>dp[i][1]</code> 表示，到当前位置，以升序结尾的摆动数组的最长子序列的长度</li>
</ul>
<p>所以如果当前是升序的话，则当前位置的升序结尾的最长子序列的长度可以由之前的降序最长子序列的长度加 1，此时的降序继续继承前一个状态的长度。若当前是降序同理<br>最终以为我们统计的实际是能追加的个数，需要在结果上再加 1 表示加上一开始初始的节点个数（我的解法进行了优化，初始长度为 1 而不是 0，哲远最后就不需要加 1 了）<br><img src="/undefined" alt="Pasted image 20240203133121"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][0] 表示，到当前位置，以降序结尾的摆动数组的最长子序列的长度</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示，到当前位置，以升序结尾的摆动数组的最长子序列的长度</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始长度为1</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//相等</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后两个值取最大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>局部：当前面的连续子数组的和小于 0时，立刻放弃，从下个元素重新计算连续和。<br>全局：局部最优的情况下，记录最大的连续和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果和大于记录结果，则更新结果</span></span><br><span class="line">           <span class="keyword">if</span>(sum &gt; result)</span><br><span class="line">           &#123;</span><br><span class="line">               result = sum;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果和小于0，那么和下一个数组元素相加肯定小于下一个数组元素值。所以清零sum，下次循环重新计算总和</span></span><br><span class="line">           <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               sum = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**<code>dp[i]</code>：下标 0~i 的最大连续子序列和为 <code>dp[i]</code>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><code>dp[i]</code>只有两个方向可以推出来：</p>
<ul>
<li><code>dp[i - 1] + nums[i]</code>，即：<code>nums[i]</code>加入当前连续子序列和</li>
<li><code>nums[i]</code>，即：从头开始计算当前连续子序列和</li>
</ul>
<p>一定是取最大的，所以<code>dp[i] = max(dp[i - 1] + nums[i], nums[i])</code></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>根据dp[i]的定义，很明显<code>dp[0] = nums[0]</code>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>递推公式中 <code>dp[i]</code> 依赖于 <code>dp[i - 1]</code> 的状态，需要从前向后遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = dp[<span class="number">0</span>];  <span class="comment">//记录最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意最后的结果可不是 <code>dp[nums.size() - 1]</code> ，result 对应的下标应是出现最大和时对应的 <code>dp[i]</code> 中的 <code>i</code>。结果直接返回 result 即可。</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="【剑】连续子数组的最大和-二"><a href="#【剑】连续子数组的最大和-二" class="headerlink" title="【剑】连续子数组的最大和 (二)"></a>【剑】连续子数组的最大和 (二)</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/11662ff51a714bbd8de809a89c481e21?tpId=13&tqId=2282583&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">连续子数组的最大和(二)_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>和上题区别是返回值要求返回子数组，思路大体相同</p>
<h3 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> CurSum = <span class="number">0</span>; <span class="comment">//当前和</span></span><br><span class="line">        <span class="type">int</span> MaxSum = INT_MIN; <span class="comment">//最大和</span></span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;   <span class="comment">//记录当前连续子数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : array)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            CurSum += i;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(CurSum &gt; MaxSum || (CurSum == MaxSum &amp;&amp; temp.<span class="built_in">size</span>() &gt; result.<span class="built_in">size</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                MaxSum = CurSum;</span><br><span class="line">                result = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果和小于0，那么和下一个数组元素相加肯定小于下一个数组元素值。所以清零，下次循环重新计算总和</span></span><br><span class="line">            <span class="keyword">if</span>(CurSum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CurSum = <span class="number">0</span>;</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (n)</li>
<li>空间复杂度：O (n)</li>
</ul>
<p>优化空间复杂度为 O（1）的思路：用下标（滑动窗口）代替数组，最后结果根据下标取 array 中的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> MaxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录最大子区间的索引下标</span></span><br><span class="line">        <span class="type">int</span> resLeft, resRight = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; array.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum += array[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新索引下标</span></span><br><span class="line">            <span class="keyword">if</span>(curSum &gt; MaxSum || (curSum == MaxSum &amp;&amp; right - left &gt; resRight - resLeft))</span><br><span class="line">            &#123;</span><br><span class="line">                MaxSum = curSum;</span><br><span class="line">                resLeft = left;</span><br><span class="line">                resRight = right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果和小于0，那么和下一个数组元素相加肯定小于下一个数组元素值。所以清零，下次循环重新计算总和</span></span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据索引下标将数组元素拷贝到res</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = resLeft; i &lt;= resRight;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>注意股票只能买卖一次</p>
<h3 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h3><p>思路：因为股票就买卖一次，那么贪心的想法很自然就是<strong>取最左最小值，取最右最大值</strong>，那么得到的差值就是最大利润。<br>取最小值右边的最大值需要两层遍历，会超时，我们就直接在一层中完成利润的计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反过来先取右边最大数，也可以</p>
<h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<ul>
<li><code>dp[i][0]</code> 表示第 <code>i</code> 天持有股票所得最多现金 <ul>
<li><strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong> 其实一开始现金是0，那么加入第 i 天买入股票现金就是 <code>-prices[i]</code>，这是一个负数。</li>
<li><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></li>
</ul>
</li>
<li><code>dp[i][1]</code> 表示第 <code>i</code> 天不持有股票所得最多现金</li>
</ul>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><strong>如果第<code>i</code>天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</strong></p>
<ul>
<li>第<code>i-1</code>天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></li>
<li>第<code>i</code>天买入股票，所得现金就是买入今天的股票后所得现金即：<code>-prices[i]</code><br>那么<code>dp[i][0]</code>应该选所得现金最大的，所以<code>dp[i][0] = max(dp[i - 1][0], -prices[i])</code></li>
</ul>
<p><strong>如果第 <code>i</code> 天不持有股票即 <code>dp[i][1]</code>， 也可以由两个状态推出来</strong></p>
<ul>
<li>第<code>i-1</code>天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li>
<li>第<code>i</code>天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></li>
</ul>
<p>同样<code>dp[i][1]</code>取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code></p>
<p>这样递推公式我们就分析完了</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>由递推公式可以看出</p>
<p>其基础都是要从<code>dp[0][0]</code>和<code>dp[0][1]</code>推导出来。</p>
<p>那么 <code>dp[0][0]</code> 表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以 <code>dp[0][0] = -prices[0]</code>;</p>
<p><code>dp[0][1]</code>表示第0天不持有股票，不持有股票那么现金就是<code>0</code>，所以<code>dp[0][1] = 0</code>;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式可以看出 <code>dp[i]</code> 都是由 <code>dp[i - 1]</code> 推导出来的，那么一定是从前向后遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回不持有股票状态对应的现金</span></span><br><span class="line">        <span class="comment">//因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p>
<ul>
<li>只有持有一只股票！</li>
<li>可以多次买卖</li>
<li>想获得利润至少要两天为一个交易单元。<br><img src="/undefined" alt="Pasted image 20240203150938"><br>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。<br>第一天没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</li>
</ul>
<p>那么只收集正利润就是贪心所贪的地方！<br><strong>局部最优：收集每天的正利润</strong><br><strong>全局最优：求得最大利润</strong></p>
<h3 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;prices.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> profit  = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(profit &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result += profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>注意这里和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 (opens new window)</a> 唯一不同的地方，就是推导 <code>dp[i][0]</code>的时候，第 <code>i</code> 天买入股票的情况</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 (opens new window)</a>中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即<code>dp[i][0]</code>一定就是 <code>-prices[i]</code>。</p>
<p><strong>而本题，因为一只股票可以买卖多次，所以当第<code>i</code>天买入股票的时候，所持有的现金可能有之前买卖过的利润。</strong></p>
<p>那么第<code>i</code>天持有股票即<code>dp[i][0]</code>，如果是第<code>i</code>天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code>。</p>
<p>再来看看如果第<code>i</code>天不持有股票即<code>dp[i][1]</code>的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第<code>i-1</code>天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li>
<li>第 <code>i</code> 天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>dp[i - 1][0] + prices[i]</code></li>
</ul>
<p><strong>注意这里和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 (opens new window)</a> 就是一样的逻辑，卖出股票收获利润（可能是负值）</strong></p>
<p>代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回不持有股票状态对应的现金</span></span><br><span class="line">        <span class="comment">//因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏 - 力扣（LeetCode）</a></p>
<h3 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果一个位置能够到达，那么这个位置左侧所有位置都能到达</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxReach = <span class="number">0</span>; <span class="comment">//可以到达的最远位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//maxReach记录了从上一个位置可以走到的最远位置</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxReach) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            maxReach = <span class="built_in">max</span>(maxReach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[i]表示前i个节点的能跳跃到的最大距离;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>] &lt; i) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 无法到达当前位置</span></span><br><span class="line"></span><br><span class="line">            dp[i] = std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>], i+nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//可以到达最后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/">45. 跳跃游戏 II - 力扣（LeetCode）</a></p>
<p>贪心：每次在可跳范围内选择可以使得跳的更远的位置。</p>
<p>如下图，开始的位置是 2，可跳的范围是橙色的。然后<strong>因为 3 可以跳的更远，所以跳到 3 的位置。</strong><br><img src="/undefined" alt="Pasted image 20240314085553"><br>如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。<br><img src="/undefined" alt="Pasted image 20240314085602"><br>写代码的话，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，<strong>遍历数组的时候，到了边界，我们就重新更新新的边界。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//跳跃次数</span></span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxPos = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次跳跃到最大距离</span></span><br><span class="line">        <span class="comment">//注意遍历条件i&lt;nums.size()-1，到达末尾位置[nums.size()-1]后不需要再次跳跃。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxPos = std::<span class="built_in">max</span>(i + nums[i], maxPos);</span><br><span class="line">            <span class="keyword">if</span>(i == end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尽量将负数转换为正数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换完所有负数，k仍大于0</span></span><br><span class="line">        <span class="comment">//若k&gt;0, 对数组中的最小正值进行单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> minVar = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            result -= minVar;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果k为偶数，那么只需要对任意一个正值反复取反</span></span><br><span class="line">                <span class="comment">//最后仍是正值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果k为奇数，只需要对最小正值反复取反，结果为最小负数</span></span><br><span class="line">                minVar = (-minVar);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result += minVar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/">134. 加油站 - 力扣（LeetCode）</a></p>
<p>在计算每个加油站的净油量后，先判断总净油量是否小于 0。如果是，则无法绕环一周，直接返回-1。否则，它使用一个循环遍历加油站，并通过累加的方式计算当前的净油量。如果净油量变为负数，说明无法到达下一个加油站，此时将 k 设置为当前索引加 1，并重置净油量为 0。</p>
<p><strong>那么局部最优：当前累加 <code>rest[i]</code> 的和 <code>curSum</code> 一旦小于0，起始位置至少要是 i+1，因为从 i 之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<p>即考虑两种情况：<br>情况一：如果总的油量剩余小于 0，则从哪个加油站出发都不能走完一圈<br>情况二：从加油站 n 到加油站 m 之间的油量剩余之和不能小于 0，否则不能走完一圈，局部最优推到全局最优</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//净油量 rest[i] = gas[i] - cost[i]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;   <span class="comment">//当前净油量</span></span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>; <span class="comment">//总净油量</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;gas.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(totalSum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//总净油量&lt;0 肯定无法绕一周</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>运用贪心策略，我们只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；</p>
<ol>
<li>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；</li>
<li>再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。</li>
</ol>
<p>通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//糖果数初始化为1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="comment">//如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                num[i] = num[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右往左</span></span><br><span class="line">        <span class="comment">//如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &lt; ratings[i - <span class="number">1</span>] &amp;&amp; num[i<span class="number">-1</span>] &lt;= num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num[i - <span class="number">1</span>] = num[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/">860. 柠檬水找零 - 力扣（LeetCode）</a></p>
<ul>
<li>情况一：账单是5，直接收下。</li>
<li>情况二：账单是10，消耗一个5，增加一个10</li>
<li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li>
</ul>
<p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<br><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p>
<p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num_5 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num_10 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;bills.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num_5++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num_5 &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    num_5--;</span><br><span class="line">                    num_10++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//优先换10</span></span><br><span class="line">                <span class="keyword">if</span>(num_10 &gt;= <span class="number">1</span> &amp;&amp; num_5 &gt;= <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    num_10--;</span><br><span class="line">                    num_5--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num_5 &gt;= <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    num_5 -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="x-y-区间相关问题"><a href="#x-y-区间相关问题" class="headerlink" title="[x, y]区间相关问题"></a>[x, y]区间相关问题</h2><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p>
<p>题目描述：整数对 <code>(h, k)</code> 表示，其中 <code>h</code> 是这个人的身高，<code>k</code> 是排在这个人前面且身高大于或等于 <code>h</code> 的人数。</p>
<p><strong>一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</strong></p>
<p>在本题目中，我首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p>
<p><strong>局部最优：优先按身高高的 people 的 k 来插入。插入操作过后的 people 满足队列属性</strong><br><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong><br><img src="/undefined" alt="Pasted image 20240207144616"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序完的 people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</span><br><span class="line"></span><br><span class="line">插入的过程：</span><br><span class="line">插入[7,0]：[[7,0]]</span><br><span class="line">插入[7,1]：[[7,0],[7,1]]</span><br><span class="line">插入[6,1]：[[7,0],[6,1],[7,1]]</span><br><span class="line">插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</span><br><span class="line">插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</span><br><span class="line">插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">//按k从高到低排列，同k按h从小到大排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), </span><br><span class="line">        [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + position, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p>
<p>用最少的箭引爆气球，每个气球都有一个引爆范围。那毋庸置疑，我们一定要让尽可能多的公共引爆范围重叠在一起。所以我们需要对引爆范围进行一个排序，我们以引爆范围起始值 start 作为 key 排序，然后我们比较当前引爆范围的结束值 right 和下一个引爆范围的起始值比较：如果当前的结束值小于下一个的起始值，说明一定不能同时射爆，如下:<br><img src="/undefined" alt="Pasted image 20240207160556"><br>此时我们需要更新 right 为当前的引爆范围的结束值，即 right &#x3D; 4. 同时箭+1<br>如果当前的结束值大于下一个的起始值，说明它们重叠，此时也更新 right 为两个引爆的范围的结束值的最小值.<br>为什么要更新最小的呢，看下面这种情况：<br><img src="/undefined" alt="Pasted image 20240207160605"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按Xstart从小到大排列</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">//points不为空至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> LastMinXend = points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">//记录上一个最小右边界,初始化为第一个元素的Xend</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;points.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前气球的Xstart大于上一个气球的Xend,说明气球没有挨着</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; LastMinXend) </span><br><span class="line">            &#123;</span><br><span class="line">                result++; <span class="comment">//没有挨着就射上一个范围内的气球</span></span><br><span class="line">                LastMinXend = points[i][<span class="number">1</span>]; <span class="comment">//将右边界重新定位为当前元素的Xend</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//气球挨着</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LastMinXend = <span class="built_in">min</span>(LastMinXend, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//统计元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//前区间升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), </span><br><span class="line">        [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;intervals.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对前区间排序过的数组,用intervals[i]的后区间和intervals[i+1]的前区间比较,只要出现前者比后者大,那么必定需要移除一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt; intervals[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只保留后区间较小的数组元素(可以当做是移除后区间较大的元素操作)</span></span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt;= intervals[i+<span class="number">1</span>][<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    intervals[i+<span class="number">1</span>] = intervals[i];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p>这道题感觉不像贪心，学习下思路把。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间 - 力扣（LeetCode）</a><br>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p>
<p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p>
<p>可以分为如下两步：</p>
<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br><img src="/undefined" alt="Pasted image 20240211102059"></li>
</ul>
<p>进一步解析：<br>想切割，要有首尾两个指针，确定了结尾指针，就能确定下一个切割的开始指针。<br>遍历字符串，如果已扫描部分的所有字符，都只出现在已扫描的范围内，即可做切割。<br>下图已扫描的绿色字符，对应的最远位置，都不超过 8，在 8 这切一刀，<code>[0:8]</code>的字符都不会出现在别处。<br><img src="/undefined" alt="Pasted image 20240211104208"><br>记录「已扫描的字符能去到的最远位置」，扫到这个位置就切割，切出的字符不会在之后出现。<br>更新开始指针，准备下一次切割。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FinalLocation</span><span class="params">(<span class="number">27</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计每一个字符最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            FinalLocation[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result; </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 待切割的起始位置</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">// 已扫描的字符中最远的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到当前扫描的字符的最远位置</span></span><br><span class="line">            right = <span class="built_in">max</span>(right, FinalLocation[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扫描到 「已扫描的字符的最远位置」，到达切割点</span></span><br><span class="line">            <span class="keyword">if</span>(i == right)</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i+<span class="number">1</span>; <span class="comment">//更新，下一个待切割的字符串的起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">. - 力扣（LeetCode）</a><br>本题是判断区间重叠后要进行区间合并。</p>
<p>所以一样的套路，先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。</p>
<p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code> 即 <code>intervals[i]的左边界 &lt;= intervals[i - 1]的右边界</code>，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;&#x3D;）。</p>
<p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）<br><img src="/undefined" alt="Pasted image 20240211105601"><br>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p>
<p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到 <code>result</code> 数组里就可以了。如果没有合并就把原区间加入到 result 数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">//按左区间升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), </span><br><span class="line">        [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//如果重叠</span></span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//合并区间，只更新右边界即可, result.back()的左边界一定是最小值，因为我们按照左边界排序的</span></span><br><span class="line">                result.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(result.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不重叠</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(intervals[i]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字 - 力扣（LeetCode）</a><br>题目要求小于等于 N 的最大单调递增的整数，那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现 <code>strNum[i - 1] &gt; strNum[i]</code> 的情况（非单调递增），首先想让 <code>strNum[i - 1]--</code>，然后 <code>strNum[i]</code> 变为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？<br>从前向后遍历的话，遇到 <code>strNum[i - 1] &gt; strNum[i]</code>的情况，让 <code>strNum[i - 1]</code>减一，但此时如果 <code>strNum[i - 1]</code>减一了，可能又小于 <code>strNum[i - 2]</code>。</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p><strong>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转换为string进行处理</span></span><br><span class="line">        string strNum = std::<span class="built_in">to_string</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记9从哪开始,从index开始都是9</span></span><br><span class="line">        <span class="type">int</span> index = strNum.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= strNum.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strNum[i<span class="number">-1</span>] &gt; strNum[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index = i; <span class="comment">//更新index</span></span><br><span class="line">                strNum[i<span class="number">-1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index;i&lt;strNum.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            strNum[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么要记录 index，再遍历一次将之后的都改为 9。而不是直接将 <code>strNum[i]</code> 改为 9 呢？如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= strNum.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strNum[i<span class="number">-1</span>] &gt; strNum[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//index = i; //更新index</span></span><br><span class="line">                strNum[i] = <span class="number">9</span>;</span><br><span class="line">                strNum[i<span class="number">-1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>假设 n&#x3D;100, 经过这种方法输出结果为 90, 正确答案应该是 99</p>
<h1 id="十、单调栈"><a href="#十、单调栈" class="headerlink" title="十、单调栈"></a>十、单调栈</h1><p>什么时候用单调栈？<br><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为 O (n)。</p>
<p>单调栈的原理？为什么时间复杂度是 O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？</p>
<p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p>
<p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p>
<hr>
<p><strong>在使用单调栈的时候首先要明确如下几点：</strong></p>
<ol>
<li><p>单调栈里存放的元素是什么？<br><strong>单调栈里只需要存放元素的下标<code>i</code>就可以了</strong>，如果需要使用对应的元素，直接<code>T[i]</code>就可以获取。</p>
</li>
<li><p>单调栈里元素是递增呢？ 还是递减呢？<br><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong></p>
</li>
</ol>
<ul>
<li>如果求一个元素右边第一个更大元素，单调栈就是<strong>递增</strong>的，</li>
<li>如果求一个元素右边第一个更小元素，单调栈就是<strong>递减</strong>的。<br>注意，这里所说的递增&#x2F;递减是针对下标对应的元素值大小，而不是针对下标值。</li>
</ul>
<ol start="3">
<li><strong>使用单调栈主要有三个判断条件。</strong></li>
</ol>
<ul>
<li>当前遍历的元素<code>T[i]</code>小于栈顶元素<code>T[st.top()]</code>的情况</li>
<li>当前遍历的元素<code>T[i]</code>等于栈顶元素<code>T[st.top()]</code>的情况</li>
<li>当前遍历的元素 <code>T[i]</code> 大于栈顶元素 <code>T[st.top()]</code> 的情况，</li>
</ul>
<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
<p>思路一：两层 for 循环遍历，复杂度 $O(n^2)$<br>思路二：单调栈，复杂度 $O(n)$</p>
<p>本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。</p>
<p>求一个元素右边第一个更大元素我们要使用<strong>递增单调栈（从栈头到栈底）</strong>，因为只有递增的时候，栈里要加入一个元素 i 的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是 i。</p>
<p>图例：<a target="_blank" rel="noopener" href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单调递增栈，存储元素的数组下标</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//result[i]表示对于第 i 天，下一个更高温度出现在几天后</span></span><br><span class="line">        <span class="comment">//result[i] = j表示temperatures[i]右边第一个比它大的元素出现在j天后</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先先将第一个遍历元素下标加入单调栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从下个位置开始遍历给定数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;temperatures.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前遍历的元素小于栈顶元素：当前元素下标加入单调栈</span></span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &lt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前遍历的元素等于栈顶元素：当前元素下标加入单调栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temperatures[i] == temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前遍历的元素大于栈顶元素，直接入栈会破坏单调递增顺序，需要处理</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将所有小于当前遍历的栈顶元素弹出，并计算距离</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()]) </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">//计算距离存入结果数组</span></span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    <span class="comment">//弹出栈顶元素下标</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前元素加入单调栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到三个 st. push 可以合并起来，代码简化如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;temperatures.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//单调递增栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="comment">//注意题目说如果不存在下一个更大元素，那么本次查询的答案是-1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储nums1中元素键值对映射（给定数组无重复元素）</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; value_to_index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            value_to_index[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums2.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[i] &lt; nums2[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums2[i] == nums2[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">if</span>(value_to_index.<span class="built_in">find</span>(nums2[st.<span class="built_in">top</span>()]) != value_to_index.<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//找出满足 nums1[i] == nums2[j] 的下标 j</span></span><br><span class="line">                        <span class="type">int</span> index = value_to_index[nums2[st.<span class="built_in">top</span>()]];</span><br><span class="line">                        <span class="comment">//确定 nums2[j] 的 下一个更大元素</span></span><br><span class="line">                        result[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
<p>本题涉及循环数组，STL本身没有提供专门的循环数组容器，但可以使用<code>vector</code>结合取余运算来模拟一个循环数组的行为。<br><code>int currentIndex = i % n;</code></p>
<p>注意遍历条件 <code> i&lt;2*n</code>，这样才能保证能转回原点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">//单调递增栈</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">//如果不存在，则输出-1</span></span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//i：循环数组起始索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;<span class="number">2</span>*n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历条件为i &lt; 2*n, 模拟循环遍历两遍nums，使用i%n作为下标</span></span><br><span class="line">            <span class="type">int</span> currentIndex = i % n;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[currentIndex] &lt; nums[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(currentIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[currentIndex] == nums[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(currentIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums[currentIndex]&gt;nums[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[currentIndex];</span><br><span class="line">                    st.<span class="built_in">pop</span>(); </span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(currentIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a><br>接雨水这道题目，我们需要寻找每个柱子<strong>左右两边第一个大于该柱子高度的柱子</strong>，来计算雨水面积。</p>
<ol>
<li>首先单调栈是<strong>按照行方向来计算</strong>雨水，如图：<br><img src="/undefined" alt="Pasted image 20240202154438"></li>
<li>使用单调栈内元素的顺序</li>
</ol>
<p>使用<strong>递增单调栈</strong></p>
<p>从栈头到栈底的顺序应该是从小到大的顺序。</p>
<p>因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。<br><img src="/undefined" alt="Pasted image 20240202154610|400"><br>3. 遇到相同高度的柱子怎么办。</p>
<p><strong>遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。</strong></p>
<p>例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。</p>
<p><strong>因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度</strong>。<br><img src="/undefined" alt="Pasted image 20240202154714|500"></p>
<ol start="4">
<li>栈里要保存什么数值</li>
</ol>
<p>使用单调栈，也是通过 <strong>长 * 宽</strong> 来计算雨水面积的。</p>
<p><strong>长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，</strong></p>
<p><strong>栈里就存放下标</strong>，想要知道对应的高度，通过height[stack.top()] 就知道弹出的下标对应的高度了。</p>
<p>所以栈的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 存着下标，计算的时候用下标对应的柱子高度</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>单调栈处理逻辑</li>
</ol>
<p>以下操作过程其实和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度 (opens new window)</a>也是一样的</p>
<p>先将下标 0 的柱子加入到栈中</p>
<p>以下逻辑主要就是三种情况</p>
<ul>
<li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 <code>height[i] &lt; height[st.top()]</code>，就将当前元素下标入栈</li>
<li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 <code>height[i] == height[st.top()]</code>，我们只需要使用最右边的柱子计算高度，所以弹出栈顶元素，将当前元素下标入栈</li>
<li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 <code>height[i] &gt; height[st.top()]</code>，此时出现凹槽，需要计算结果。<br><img src="/undefined" alt="Pasted image 20240202155454|450"><br>取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为 <code>mid</code>，对应的高度为 <code>height[mid]</code>（就是图中的高度1）。</li>
</ul>
<p>此时的栈顶元素 <code>st.top()</code>，就是凹槽的左边位置，下标为 <code>st.top()</code>，对应的高度为 <code>height[st.top()]</code>（就是图中的高度2）。</p>
<p>当前遍历的元素 <code>i</code>，就是凹槽右边的位置，下标为<code>i</code>，对应的高度为 <code>height[i]</code>（就是图中的高度3）。</p>
<p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p>
<p>那么雨水高度是 <code>min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度</code>，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p>
<p>雨水的宽度是 <code>凹槽右边的下标 - 凹槽左边的下标 - 1</code>（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p>
<p>当前凹槽雨水的体积就是：<code>h * w</code>。</p>
<p>求当前凹槽雨水的体积代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[mid];</span><br><span class="line">        <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>; <span class="comment">// 注意减一，只求中间宽度</span></span><br><span class="line">        sum += h * w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">//递增单调栈，存储下标</span></span><br><span class="line">        </span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只需要使用最右边的柱子计算高度，所以弹出栈顶元素，将当前元素下标入栈</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前遍历的元素（柱子）高度大于栈顶元素的高度，出现凹槽</span></span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//凹槽中间高度</span></span><br><span class="line">                    <span class="type">int</span> mid_height = height[st.<span class="built_in">top</span>()];</span><br><span class="line">                    <span class="comment">//弹出栈顶，只剩凹槽左边柱子</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//左右凹槽高度</span></span><br><span class="line">                        <span class="type">int</span> leftHeight = height[st.<span class="built_in">top</span>()];</span><br><span class="line">                        <span class="type">int</span> rightHeight = height[i];</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//雨水高度</span></span><br><span class="line">                        <span class="type">int</span> h = <span class="built_in">min</span>(leftHeight, rightHeight) - midHeight;</span><br><span class="line">                        <span class="comment">//雨水宽度</span></span><br><span class="line">                        <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>; <span class="comment">// 注意减一，只求中间宽度</span></span><br><span class="line">                        <span class="comment">//总体积</span></span><br><span class="line">                        sum += h*w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
<p>[[#接雨水]] 是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是<strong>找每个柱子左右两边第一个小于该柱子的柱子</strong>。</p>
<p>所以使用<strong>递减单调栈</strong>（从栈头到栈底的顺序应该是从大到小）<br>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。<br><img src="/undefined" alt="Pasted image 20240202161247"></p>
<p><strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度。</strong></p>
<p><strong>第 <code>i</code> 位置最大面积是什么？（公式）</strong><br>是以 i 为中心，向左找第一个小于 <code>heights[i]</code> 的位置 <code>left_i</code>；向右找第一个小于于 <code>heights[i]</code> 的位置 <code>right_i</code>，即最大面积为 <code>heights[i] * (right_i - left_i -1)</code>，如下图所示：<br><img src="/undefined" alt="Pasted image 20240202164436"></p>
<p><strong>对于每个柱子我们都如上计算一遍以当前柱子作为高的矩形面积，最终比较出最大的矩形面积即可。</strong><br>例如对于图中第三个柱子 <code>heights[2]</code>：高为 5，左边第一个高度小于该柱子的是 heights[1], 右边第一个高度小于该柱子的是 heights[4], 宽度为 4-1-1 &#x3D; 2。面积为 5 x 2 &#x3D; 10;<br>对于图中第四个柱子 <code>heights[3]</code>：高为 6，左边第一个高度小于该柱子的是 heights[2], 右边第一个高度小于该柱子的是 heights[4], 宽度为 4-2-1 &#x3D; 1。面积为 6 x 1 &#x3D; 6;</p>
<p><strong>疑问：为什么要在 height 末端插入0;要在 height 头部插入0？</strong><br>此题解法有待商榷.。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哨兵</span></span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;heights.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i] &gt; heights[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heights[i] == heights[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//中间高度</span></span><br><span class="line">                    <span class="type">int</span> mid_height = heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//弹出栈顶，新栈顶为左边柱子</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right = i;</span><br><span class="line">                        <span class="type">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">                        result = <span class="built_in">max</span>(result, w * mid_height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>在 height 数组前后都加了一个元素0，为什么这么做呢？</strong></p>
<ul>
<li><p>末尾为什么要加元素0？<br>如果数组本身就是升序的，例如[2,4,6,8]，那么入栈之后都是单调递减，一直都没有走情况三计算结果的哪一步，所以最后输出的就是0了。 那么结尾加一个0，就会让栈里的所有元素，走到情况三的逻辑。</p>
</li>
<li><p>开头为什么要加元素0？<br>如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），rigt（6），但是得不到 left。<br>（mid、left，right 都是对应版本一里的逻辑）</p>
</li>
</ul>
<p>因为 将 8 弹出之后，栈里没有元素了，那么为了避免空栈取值，直接跳过了计算结果的逻辑。</p>
<p>之后又将6 加入栈（此时8已经弹出了），然后就是 4 与栈口元素 8 进行比较，周而复始，那么计算的最后结果 resutl 就是0。所以我们需要在 height 数组前后各加一个元素0。<br>如图所示：<br><img src="/undefined" alt="Pasted image 20240202163114"></p>
<h1 id="十一、图"><a href="#十一、图" class="headerlink" title="十一、图"></a>十一、图</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>DFS 沿着树的深度遍历树&#x2F;图的节点，选一条路一直走到底，回溯，遍历所有的子节点，进而达到全局搜索的目的。</p>
<h3 id="dfs-搜索过程"><a href="#dfs-搜索过程" class="headerlink" title="dfs 搜索过程"></a>dfs 搜索过程</h3><p><img src="/undefined" alt="Pasted image 20240212170910"></p>
<p>以图 6.11 的无向图为例，dfs遍历结果为 abdehcfg。</p>
<p>关键就两点：</p>
<ul>
<li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li>
<li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程</li>
</ul>
<hr>
<p>正是因为 dfs 搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。<br>有递归的地方就有回溯，那么回溯在哪里呢？</p>
<p>就地递归函数的下面，例如如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    处理节点</span><br><span class="line">    <span class="built_in">dfs</span>(图，选择的节点) <span class="comment">//递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讲解<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">二叉树章节 (opens new window)</a> 的时候，二叉树的递归法其实就是 dfs，而二叉树的迭代法，就是 bfs（广度优先搜索）<br>所以<strong>dfs，bfs 其实是基础搜索算法，也广泛应用与其他数据结构与算法中</strong>。</p>
<p>我们在回顾一下回溯法的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法，其实就是 dfs 的过程，这里给出 dfs 的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) </span><br><span class="line">    &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 dfs 的代码框架和回溯算法的代码框架是差不多的。</p>
<p>深搜三部曲如下：</p>
<ol>
<li>确认递归函数，参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure>

<p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。</p>
<p>一般情况，深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 保存符合条件的所有路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 起点到终点的路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(图，目前搜索的节点)</span>  </span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>确认终止条件</li>
</ol>
<p>终止条件很重要，很多同学写 dfs 的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理目前搜索节点出发的路径</li>
</ol>
<p>一般这里就是一个 for 循环的操作，去遍历目前搜索节点所能到的所有节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径 - 力扣（LeetCode）</a></p>
<p>深搜三部曲来分析题目：</p>
<ol>
<li>确认递归函数，参数</li>
</ol>
<p>首先我们dfs函数一定要存一个图，用来遍历的，还要存一个目前我们遍历的节点，定义为x</p>
<p>至于单一路径，和路径集合可以放在全局变量，那么代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 0节点到终点的路径</span></span><br><span class="line"><span class="comment">// x：目前遍历的节点</span></span><br><span class="line"><span class="comment">// graph：存当前的图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x)</span> </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确认终止条件</li>
</ol>
<p><strong>什么时候我们就找到一条路径了？当目前遍历的节点 为 最后一个节点的时候，就找到了一条，从 出发点到终止点的路径。</strong></p>
<p>当前遍历的节点，我们定义为x，最后一点节点，就是 graph.size() - 1（因为题目描述是找出所有从节点 0 到节点 n-1 的路径并输出）。</p>
<p>所以但 x 等于 graph.size() - 1 的时候就找到一条有效路径。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span></span><br><span class="line"><span class="keyword">if</span> (x == graph.<span class="built_in">size</span>() - <span class="number">1</span>)  <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path); <span class="comment">// 收集有效路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理目前搜索节点出发的路径</li>
</ol>
<p>接下来是走 当前遍历节点x的下一个节点。</p>
<p>首先是要找到 x节点链接了哪些节点呢？ 遍历方式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[x].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历节点n链接的所有节点</span></span><br></pre></td></tr></table></figure>
<p>接下来就是将选中的 x 所连接的节点，加入到单一路径来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="built_in">push_back</span>(graph[x][i]); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br></pre></td></tr></table></figure>

<p>进入下一层递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(graph, graph[x][i]); <span class="comment">// 进入下一层递归</span></span><br></pre></td></tr></table></figure>

<p>最后就是回溯的过程，撤销本次添加节点的操作。该过程整体代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历节点n链接的所有节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[x].<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; </span><br><span class="line">    path.<span class="built_in">push_back</span>(graph[x][i]); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, graph[x][i]); <span class="comment">// 进入下一层递归</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 0节点到终点的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x：目前遍历的节点</span></span><br><span class="line">    <span class="comment">// graph：存当前的图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span></span><br><span class="line">        <span class="keyword">if</span> (x == graph.<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">        &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[x].<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123; </span><br><span class="line">            path.<span class="built_in">push_back</span>(graph[x][i]); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, graph[x][i]); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) </span><br><span class="line">    &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, <span class="number">0</span>); <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>BFS 类似于树的层次遍历过程, 从树&#x2F;图的根节点开始，遍历所有子节点。如果所有节点均被访问，则算法中止。</p>
<p><strong>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</strong></p>
<p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>
<p>当然，也有一些问题是广搜和深搜都可以解决的，例如岛屿问题，<strong>这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行</strong>。 （我们会在具体题目讲解中详细来说）</p>
<p>具体是怎么一圈一圈来搜呢。</p>
<p>我们用一个方格地图，假如每次搜索的方向为上下左右（不包含斜上方），那么给出一个 start 起始位置，那么 BFS 就是从四个方向走出第一步。<br><img src="/undefined" alt="Pasted image 20240229100648"><br>如果加上一个 end 终止位置，那么使用 BFS 的搜索过程如图所示：<br><img src="/undefined" alt="Pasted image 20240229100702"><br>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p>
<p><strong>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</strong></p>
<p>而且地图还可以有障碍，如图所示：<br><img src="/undefined" alt="Pasted image 20240229100733"></p>
<blockquote>
<p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注关键地方染色的逻辑就可以。</p>
</blockquote>
<p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p>
<p><strong>只要 BFS 只要搜到终点一定是一条最短路径</strong></p>
<p>我们需要一个容器，能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p>
<ul>
<li><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</li>
<li><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。因为栈是先进后出，加入元素和弹出元素的顺序改变了。</li>
</ul>
<p>那么<strong>广搜需要注意转圈搜索的顺序吗？ 不需要</strong> 所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p>
<p>下面给出广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,  </span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, </span><br><span class="line">                 &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;; </span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 从队列取元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始想当前节点的四个方向去遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt; grid.<span class="built_in">size</span>() - <span class="number">1</span> || nexty &lt; <span class="number">0</span> || nexty &gt; grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">continue</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) </span><br><span class="line">            &#123; </span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集常用来解决<strong>连通性问题</strong>。当我们需要<strong>判断两个元素是否在同一个集合里</strong>的时候，我们就要想到用并查集。</p>
<p><strong>并查集主要有两个功能：</strong></p>
<ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<p>空间复杂度： O(n) ，申请一个father数组。<br>时间复杂度：路径压缩后在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。<br>在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数和 isSame函数里涉及的查询操作也是一样的过程。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，<mark style="background: #FF5582A6;">如何连通呢？</mark>只需要用一个一维数组来表示，即：father[A] &#x3D; B，father[B] &#x3D; C 这样就表述 A 与 B 与 C连通了（有向连通图）。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u; <span class="comment">//连通v u, uv顺序可以改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">那怎么知道 B 连通 A呢？</mark>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。<br>这里要讲到<strong>寻根思路，只要 A ，B，C 在同一个根下就是同一个集合</strong>。给出A元素，就可以通过 father[A] &#x3D; B，father[B] &#x3D; C，找到根为 C。给出B元素，就可以通过 father[B] &#x3D; C，找到根也为为 C，说明 A 和 B 是在同一个集合里。<br>大家会想第一段代码里find函数是如何实现的呢？其实就是<strong>通过数组下标找到数组元素，一层一层寻根过程</strong>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">如何表示 C 也在同一个元素里呢？</mark> 我们需要 father[C] &#x3D; C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。所以<strong>father数组初始化的时候要 father[i] &#x3D; i，默认自己指向自己。</strong> 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">最后我们如何判断两个元素是否在同一个集合里？</mark>如果通过 find函数找到两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。搜索过程像是一个多叉树中从叶子到根节点的过程，如图：<br><img src="/undefined" alt="Pasted image 20240323083551|500"><br>如果这棵多叉树高度很深的话，每次find函数 去寻找跟的过程就要递归很多次。我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：<br><img src="/undefined" alt="Pasted image 20240323083604"><br><strong>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</strong> 如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。那么在代码层面如何实现呢？</p>
<p><strong>我们只需要在递归的过程中，让 father[u] 接住递归函数 find(father[u]) 的返回结果。</strong> 因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数返回的根节点，这样就让节点 u 的父节点变成根节点。</p>
<p>代码如下，注意看注释，路径压缩就一行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集（注意，我们连的是uv的根节点！）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u; <span class="comment">//father[u] = v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过模板，我们可以知道，并查集主要有三个功能。</p>
<ol>
<li><code>find(int u)</code> 寻找根节点：也就是判断这个节点的祖先节点是哪个</li>
<li><code>join(int u, int v)</code> 将两个节点接入到同一个集合：将两个节点连在同一个根节点上</li>
<li><code>isSame(int u, int v)</code> 判断两个节点是否在同一个集合：就是判断两个节点是不是同一个根节点</li>
</ol>
<h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p><img src="/undefined" alt="Pasted image 20240323084750"></p>
<h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/">547. 省份数量 - 力扣（LeetCode）</a><br>求连通分量数：深搜、广搜、并查集</p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="type">bool</span>&gt;&amp; Visited, <span class="type">int</span> n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; Visited[j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Visited[j] == <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, Visited, n, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>(); <span class="comment">//城市数量</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果该节点没访问过</span></span><br><span class="line">            <span class="keyword">if</span>(Visited[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++; <span class="comment">//数量+1</span></span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, Visited, n, i); <span class="comment">//遍历与其链接的节点，都标上true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="type">bool</span>&gt;&amp; Visited, <span class="type">int</span> n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;     </span><br><span class="line">                <span class="keyword">if</span>(isConnected[j][k] == <span class="number">1</span> &amp;&amp; !Visited[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(k);</span><br><span class="line">                    Visited[k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>(); <span class="comment">//城市数量</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果该节点没访问过</span></span><br><span class="line">            <span class="keyword">if</span>(Visited[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++; <span class="comment">//数量+1</span></span><br><span class="line">                <span class="built_in">bfs</span>(isConnected, Visited, n, i); <span class="comment">//遍历与其链接的节点，都标上true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">205</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">return</span> u==v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span>;</span><br><span class="line">        father[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = isConnected.<span class="built_in">size</span>(); <span class="comment">//默认视为每个城市都是单独的</span></span><br><span class="line">         </span><br><span class="line">        <span class="built_in">init</span>(); <span class="comment">//初始化并查集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;isConnected.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;isConnected[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j &amp;&amp; isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果根不同，就连接i,j</span></span><br><span class="line">                    <span class="comment">//只要发生了连接，count就-1</span></span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">isSame</span>(i, j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">join</span>(i, j);</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量 - 力扣（LeetCode）</a></p>
<p>注意题目中每座岛屿只能由<strong>水平方向和&#x2F;或竖直方向上</strong>相邻的陆地连接形成。</p>
<p>也就是说斜角度链接是不算了，例如示例二，是三个岛屿，如图：<br><img src="/undefined" alt="Pasted image 20240229102729"><br>这道题题目是 DFS，BFS，并查集，基础题目。</p>
<p><strong>本题思路</strong>，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。</p>
<p>在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p>
<p>那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS 或者并查集。</p>
<p><strong>⭐注意记录岛屿数量（<code>result++</code>）的位置</strong></p>
<h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[x][y] || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>; <span class="comment">// 终止条件：访问过的节点 或者 遇到海水</span></span><br><span class="line">        visited[x][y] = <span class="literal">true</span>; <span class="comment">// 标记访问过</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt; grid.<span class="built_in">size</span>()<span class="number">-1</span> || nexty &lt; <span class="number">0</span> || nexty &gt; grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录格子是否遍历过</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">//记录岛屿数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个格子，遇到没访问过的就记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    result++; <span class="comment">// 遇到没访问过的陆地，+1</span></span><br><span class="line">    </span><br><span class="line">                    <span class="built_in">dfs</span>(grid, visited, i, j); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><p>这里有一个广搜中很重要的细节：<br><strong>只要加入队列就代表走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>; <span class="comment">//只要加入队列，立刻标记</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curx = cur.first;</span><br><span class="line">            <span class="type">int</span> cury = cur.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nextx&gt;grid.<span class="built_in">size</span>()<span class="number">-1</span> || nexty&lt;<span class="number">0</span> || nexty&gt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(visited[nextx][nexty] == <span class="literal">false</span> &amp;&amp; grid[nextx][nexty] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;); </span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result++; <span class="comment">// 遇到没访问过的陆地，+1</span></span><br><span class="line">                    <span class="built_in">bfs</span>(grid, visited, i, j); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/description/">695. 岛屿的最大面积 - 力扣（LeetCode）</a> </p>
<p>本题核心是求<strong>单个岛屿面积</strong>，求面积即求岛屿中标记为 1 的单元格！<br>⭐注意记录面积（<code>size++</code>）的位置</p>
<h4 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxsize = INT_MIN;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> hasIsland = <span class="literal">false</span>; <span class="comment">//是否有岛屿</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>&amp; size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span> || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        size++; <span class="comment">//记录本岛屿的单元格数量</span></span><br><span class="line">        hasIsland = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextx = x+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y+dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nextx&gt;grid.<span class="built_in">size</span>()<span class="number">-1</span> || nexty &lt;<span class="number">0</span> || nexty&gt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(grid, Visited, nextx, nexty, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span>(Visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!hasIsland) hasIsland = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> size = <span class="number">0</span>; <span class="comment">//记录本岛屿的单元格数量</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, Visited, i ,j, size);</span><br><span class="line">                    maxsize = <span class="built_in">max</span>(maxsize, size);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasIsland) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxsize = INT_MIN;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> hasIsland = <span class="literal">false</span>; <span class="comment">//是否有岛屿</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>&amp; size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curx = que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> cury = que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            size++; <span class="comment">//记录本岛屿的单元格数量</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nextx = curx+dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nexty = cury+dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nextx&gt;grid.<span class="built_in">size</span>()<span class="number">-1</span> || nexty &lt;<span class="number">0</span> || nexty&gt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(Visited[nextx][nexty] == <span class="literal">false</span> &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">                    Visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                    hasIsland = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span>(Visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!hasIsland) hasIsland = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> size = <span class="number">0</span>;  <span class="comment">//记录本岛屿的单元格数量</span></span><br><span class="line">                    <span class="built_in">bfs</span>(grid, Visited, i ,j, size);</span><br><span class="line">                    maxsize = <span class="built_in">max</span>(maxsize, size);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasIsland) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="飞地的数量"><a href="#飞地的数量" class="headerlink" title="飞地的数量"></a>飞地的数量</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-enclaves/description/">1020. 飞地的数量 - 力扣（LeetCode）</a></p>
<p>本题考察的还是面积的计算</p>
<h3 id="DFS-3"><a href="#DFS-3" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>&amp; count,<span class="type">bool</span>&amp; flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span> || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        count++;<span class="comment">//本岛屿中的单元格数量+1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextX = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextY = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//越界</span></span><br><span class="line">            <span class="keyword">if</span>(nextX&lt;<span class="number">0</span> || nextX &gt; grid.<span class="built_in">size</span>()<span class="number">-1</span> || nextY&lt;<span class="number">0</span> || nextY&gt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//标记可离开</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(grid, Visited, nextX, nextY, count, flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标记移动是否可以离开边界</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, Visited, i, j ,count, flag);</span><br><span class="line">                    <span class="keyword">if</span>(!flag) res += count; <span class="comment">//如果本岛屿无法离开，那么就将陆地单元格数量添加进结果</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-3"><a href="#BFS-3" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标记移动是否可以离开边界</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//本岛屿中的单元格数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curX = que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> curY = que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            count++; <span class="comment">//本岛屿中的单元格数量</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nextX = curX+dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nextY = curY+dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//越界</span></span><br><span class="line">                <span class="keyword">if</span>(nextX&lt;<span class="number">0</span> || nextX &gt; grid.<span class="built_in">size</span>()<span class="number">-1</span> || nextY&lt;<span class="number">0</span> || nextY&gt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>; <span class="comment">//标记可离开</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(Visited[nextX][nextY] == <span class="literal">false</span> &amp;&amp; grid[nextX][nextY] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(&#123;nextX, nextY&#125;);</span><br><span class="line">                    Visited[nextX][nextY] = <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) res += count; <span class="comment">//如果本岛屿无法离开，那么就将陆地单元格数量添加进结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, Visited, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/description/">130. 被围绕的区域 - 力扣（LeetCode）</a><br>常规思路：DFS 或 BFS 记录有效路径，如果该路径有边界，那么就不对board 进行修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,  vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; path, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span>&amp; hasEdge)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span> || board[x][y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(&#123;x,y&#125;); <span class="comment">//记录有效路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextX = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextY = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一旦遇到边界，说明该路径不符合，记录下来</span></span><br><span class="line">            <span class="keyword">if</span>(nextX&lt;<span class="number">0</span> || nextX&gt;board.<span class="built_in">size</span>()<span class="number">-1</span> || nextY&lt;<span class="number">0</span> || nextY&gt;board[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hasEdge = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(board, Visited, path, nextX, nextY, hasEdge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">//标记已访问</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Visited[i][j] == <span class="literal">false</span> &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path;</span><br><span class="line">                    <span class="type">bool</span> hasEdge = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(board, Visited, path, i, j, hasEdge);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(!hasEdge &amp;&amp; !path.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> pair : path)</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[pair.first][pair.second] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化思路：</p>
<ol>
<li>DFS 或BFS 从边界的 <code>&#39;O&#39;</code> 格子开始搜，路径中的 <code>&#39;O&#39;</code> 格子全部改为 <code>&#39;A&#39;</code>，代表着这些格子是和边界格子相连的。</li>
<li>将没被修改的 <code>&#39;O&#39;</code> 格子填充为 <code>X</code>, 这些格子都是符合要求的被围绕区域。</li>
<li>被标记的 <code>&#39;A&#39;</code> 的格子恢复为 <code>&#39;O&#39;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,  vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span> || board[x][y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//标记为A</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextX = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextY = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nextX&lt;<span class="number">0</span> || nextX&gt;board.<span class="built_in">size</span>()<span class="number">-1</span> || nextY&lt;<span class="number">0</span> || nextY&gt;board[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(board, Visited, nextX, nextY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">//标记已访问</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dfs 从边界格子开始搜，路径中的格子全部标记为&#x27;A&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Visited[i][<span class="number">0</span>] == <span class="literal">false</span> &amp;&amp; board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, Visited, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Visited[i][n<span class="number">-1</span>] == <span class="literal">false</span> &amp;&amp; board[i][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, Visited, i, n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Visited[<span class="number">0</span>][i] == <span class="literal">false</span> &amp;&amp; board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, Visited, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Visited[m<span class="number">-1</span>][i] == <span class="literal">false</span> &amp;&amp; board[m<span class="number">-1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, Visited, m<span class="number">-1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="大西洋水流问题"><a href="#大西洋水流问题" class="headerlink" title="大西洋水流问题"></a>大西洋水流问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/">417. 太平洋大西洋水流问题 - 力扣（LeetCode）</a><br>思路类似[[#被围绕的区域]]，我们的策略是从边界【逆向流动】，下一个格子的高度必须大于等于当前格子，雨水才能从下一个格子流入当前格子。如果小于，则不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextX = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextY = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//我们的策略是从边界【逆向流动】</span></span><br><span class="line">            <span class="comment">//下一个格子的高度必须大于等于当前格子，雨水才能从下一个格子流入当前格子。如果小于，则不行</span></span><br><span class="line">            <span class="keyword">if</span>(nextX&lt;<span class="number">0</span> || nextX&gt;heights.<span class="built_in">size</span>()<span class="number">-1</span> || nextY&lt;<span class="number">0</span> || nextY&gt;heights[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span> || heights[nextX][nextY] &lt; heights[x][y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(heights, Visited, nextX, nextY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分别从两个边界开始dfs，逆向流动</span></span><br><span class="line">        <span class="comment">//Pacific Ocean</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">PacificVisited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">//标记已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(PacificVisited[i][<span class="number">0</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(heights, PacificVisited, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(PacificVisited[<span class="number">0</span>][i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(heights, PacificVisited, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Altlantic ocean</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">AltlanticVisited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">//标记已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AltlanticVisited[i][n<span class="number">-1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(heights, AltlanticVisited, i, n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AltlanticVisited[m<span class="number">-1</span>][i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(heights, AltlanticVisited, m<span class="number">-1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------------------------------</span></span><br><span class="line">        <span class="comment">//如果格子的PacificVisited和AltlanticVisited都标记为true，说明既可流向太平洋也可流向大西洋</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(PacificVisited[i][j] == <span class="literal">true</span> &amp;&amp; AltlanticVisited[i][j] == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长 - 力扣（LeetCode）</a><br><img src="/undefined" alt="Pasted image 20240324120235"><br>直接DFS：上下左右越界或有水，周长就+1</p>
<p>其实本题用dfs 反而复杂了，直接两层for 遍历判断即可。代码就不写了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//记录周长</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[x][y] || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; </span><br><span class="line">        visited[x][y] = <span class="literal">true</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上下左右越界或有水，周长就+1</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt; grid.<span class="built_in">size</span>()<span class="number">-1</span> || nexty &lt; <span class="number">0</span> || nexty &gt; grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span> || grid[nextx][nexty] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i][j] == <span class="literal">false</span> &amp;&amp; grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, visited, i, j); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="钥匙和房间"><a href="#钥匙和房间" class="headerlink" title="钥匙和房间"></a>钥匙和房间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/keys-and-rooms/description/">841. 钥匙和房间 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms, vector&lt;<span class="type">bool</span>&gt;&amp; Visited, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[i] == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;rooms[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(rooms, Visited, rooms[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Visited</span><span class="params">(rooms.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从0号开始dfs</span></span><br><span class="line">        <span class="built_in">dfs</span>(rooms, Visited, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还有没访问过的则返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;rooms.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Visited[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="【剑】矩阵中的路径"><a href="#【剑】矩阵中的路径" class="headerlink" title="【剑】矩阵中的路径"></a>【剑】矩阵中的路径</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/2a49359695a544b8939c77358d29b7e6?tpId=13&tqId=1517966&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">矩阵中的路径_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><img src="/undefined" alt="6D7F11F6465F19627B99E8097812E8ED"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//index为当前word的索引</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; matrix, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> x, <span class="type">int</span> y, string word, <span class="type">int</span> index,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//下标越界、字符不匹配、已经遍历过不能重复</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || matrix[x][y] != word[index] || Visited[x][y] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//word中字符访问完毕</span></span><br><span class="line">        <span class="keyword">if</span>(index == word.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>; <span class="comment">//标记为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, n, m, nextx, nexty, word, index + <span class="number">1</span>, Visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Visited[x][y] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; matrix, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Visited记录是否走过</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从0，0开始dfs</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, n, m, i, j, word, <span class="number">0</span>, Visited))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】-机器人的运动范围"><a href="#【剑】-机器人的运动范围" class="headerlink" title="【剑】 机器人的运动范围"></a>【剑】 机器人的运动范围</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=23460&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">机器人的运动范围_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>取数值各个位上的单数之和的算法</strong>需要记住：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        sum += n % <span class="number">10</span>; <span class="comment">// 取模操作得到最后一位数字</span></span><br><span class="line">        n /= <span class="number">10</span>; <span class="comment">// 整除操作去掉最后一位数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：dfs,搜索四个方向，并记录该方格是否被搜索过，</span></span><br><span class="line"><span class="comment">// 预判方格是否合法，合法就从该方格接着搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += n % <span class="number">10</span>; <span class="comment">// 取模操作得到最后一位数字</span></span><br><span class="line">            n /= <span class="number">10</span>; <span class="comment">// 整除操作去掉最后一位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; Visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[x][y] == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否合法，不合法就跳过，合法就接着深搜</span></span><br><span class="line">            <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nextx&gt;=rows || nexty&lt;<span class="number">0</span> || nexty&gt;=cols || <span class="built_in">getSum</span>(nextx) + <span class="built_in">getSum</span>(nexty) &gt; threshold) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">dfs</span>(threshold, rows, cols, nextx, nexty, Visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//格子是否已经被记录到总数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Visited</span>(rows,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从(0,0)开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, Visited);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="寻找图中是否存在路径"><a href="#寻找图中是否存在路径" class="headerlink" title="寻找图中是否存在路径"></a>寻找图中是否存在路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">1971. 寻找图中是否存在路径 - 力扣（LeetCode）</a></p>
<p>题目中各个点是双向图链接，那么<strong>判断一个顶点到另一个顶点有没有有效路径其实就是看这两个顶点是否在同一个集合里。</strong></p>
<p>如何算是同一个集合呢，有边连在一起，就算是一个集合。此时我们就可以直接套用并查集模板。使用join(int u, int v)将每条边加入到并查集。最后 isSame(int u, int v) 判断是否是同一个根 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">200005</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">return</span> u==v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span>;</span><br><span class="line">        father[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPath</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(); <span class="comment">//注意先初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;edges.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(source, destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/description/">684. 冗余连接 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection-ii/">685. 冗余连接 II - 力扣（LeetCode）</a> (困难题，暂时鸽)</p>
<p><strong>从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。<br>节点 A 和节点 B 不在同一个集合，那么就可以将两个节点连在一起。</strong><br>（如果题目中说：如果有多个答案，则返回二维数组中最前出现的边。那我们就要从后向前遍历每一条边了）<br><img src="/undefined" alt="Pasted image 20240323092806|500"></p>
<p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。<br>已经判断节点 A 和节点 B 在在同一个集合（同一个根），如果将节点 A 和节点 B 连在一起就一定会出现环。<br><img src="/undefined" alt="Pasted image 20240323092836|500"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1005</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">return</span> v==u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        father[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;edges.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSame</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) <span class="keyword">return</span> edges[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="几个困难题（略）"><a href="#几个困难题（略）" class="headerlink" title="几个困难题（略）"></a>几个困难题（略）</h2><p>DFS&#x2F;BFS:<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332. 重新安排行程 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/description/">127. 单词接龙 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/making-a-large-island/description/">827. 最大人工岛 - 力扣（LeetCode）</a></p>
<p>并查集：<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection-ii/description/">685. 冗余连接 II - 力扣（LeetCode）</a></p>
<p>思路可参考：<a target="_blank" rel="noopener" href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<h1 id="十二、数学"><a href="#十二、数学" class="headerlink" title="十二、数学"></a>十二、数学</h1><h2 id="【剑】数字序列中某一位的数字"><a href="#【剑】数字序列中某一位的数字" class="headerlink" title="【剑】数字序列中某一位的数字"></a>【剑】数字序列中某一位的数字</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/29311ff7404d44e0b07077f4201418f5?tpId=13&tqId=2285751&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数字序列中某一位的数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>思路：</strong></p>
<p>我们尝试来找一下规律：</p>
<ul>
<li>小于10的数字一位数，1～9，共9个数字，9位；</li>
<li>小于100的数字两位数，10～99，共90个数字，180位；</li>
<li>小于1000的数字三位数，100～999，共900个数字，2700位；</li>
<li>……</li>
</ul>
<p>我们可以用这样的方式，不断减去前面位数较少的数字的那些位，锁定第n位所在的区间，即第n位是几位数。<strong>这个区间的起点值加上剩余部分除以这个区间的位数就可以定位n在哪个数字上，再通过n对位数取模可以定位是哪一位。（下标从0开始，需要对n减1）</strong></p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：通过对每个区间起点数字的计算，按照上述规律求得该区间的位数，n不断减去它前面区间的位数，定位到属于它的区间。</li>
<li>step 2：通过除以位数定位n在哪个数字上，用字符串形式表示。</li>
<li>step 3：通过在字符串上位置对几位数取模定位目标数字。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> digit = <span class="number">1</span>; <span class="comment">//记录n是几位数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> start = <span class="number">1</span>; <span class="comment">//记录当前位数区间的起始数字：1,10,100...</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">9</span>; <span class="comment">//记录当前区间之前总共有多少位数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将n定位在某个位数的区间中</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            n -= sum;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit++;</span><br><span class="line">            <span class="comment">//该区间的总共位数</span></span><br><span class="line">            sum = <span class="number">9</span> * start * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">//定位n在哪个数字上</span></span><br><span class="line">        <span class="type">int</span> index = (n - <span class="number">1</span>) % digit;  <span class="comment">//定位n在数字的哪一位上</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(num)[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】数据流中的中位数"><a href="#【剑】数据流中的中位数" class="headerlink" title="【剑】数据流中的中位数"></a>【剑】数据流中的中位数</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=23457&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数据流中的中位数_牛客题霸_牛客网 (nowcoder.com)</a><br>快排</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(num);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> median;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            median = (<span class="type">double</span>)(vec[n/<span class="number">2</span>] + vec[n/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            median = (<span class="type">double</span>)vec[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="【剑】位运算"><a href="#【剑】位运算" class="headerlink" title="【剑】位运算"></a>【剑】位运算</h2><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><p>按位操作是对数据的二进制位进行操作的一种操作。在C++中，常见的按位操作符包括：</p>
<ol>
<li><code>&amp;</code>：按位与运算符，对两个操作数的每一位进行<strong>与</strong>操作。（两数都为 1，结果为 1）</li>
<li><code>|</code>：按位或运算符，对两个操作数的每一位进行<strong>或</strong>操作。</li>
<li><code>^</code>：按位异或运算符，对两个操作数的每一位进行<strong>异或</strong>操作。（相同位0，不同为 1）</li>
<li><code>~</code>：按位取反运算符，对操作数的每一位进行<strong>取反</strong>操作。</li>
</ol>
<p>在 C++中，<code>^</code> 运算符表示<strong>按位异或操作（XOR）</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;   <span class="comment">// 二进制表示为 0011</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result_and = a &amp; b;   <span class="comment">// 结果为 1，二进制表示为 0001</span></span><br><span class="line"><span class="type">int</span> result_or = a | b;    <span class="comment">// 结果为 7，二进制表示为 0111</span></span><br><span class="line"><span class="type">int</span> result_xor = a ^ b;   <span class="comment">// 结果为 6，二进制表示为 0110</span></span><br><span class="line"><span class="type">int</span> result_not_a = ~a;    <span class="comment">// 结果为 -6（在二进制中表示为补码形式）</span></span><br></pre></td></tr></table></figure>

<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符包括左移位运算符 <code>&lt;&lt;</code> 和右移位运算符 <code>&gt;&gt;</code>。</p>
<ol>
<li>左移位运算符 <code>&lt;&lt;</code>：将一个数的二进制表示向左移动指定的位数。左移位操作相当于将数<strong>乘以 2 的指定次幂</strong>。</li>
<li>右移位运算符 <code>&gt;&gt;</code>：将一个数的二进制表示向右移动指定的位数。右移位操作相当于将数<strong>除以 2 的指定次幂，舍弃小数部分。</strong></li>
</ol>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 二进制表示为 0000 1010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftShiftResult = x &lt;&lt; <span class="number">2</span>;  <span class="comment">// 左移两位，相当于乘以2的2次幂，结果为 40，二进制表示为 0010 1000</span></span><br><span class="line"><span class="type">int</span> rightShiftResult = x &gt;&gt; <span class="number">1</span>; <span class="comment">// 右移一位，相当于除以2的1次幂，结果为 5，二进制表示为 0000 0101</span></span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>常用的处理大型数据</p>
<p>计算幂运算，我们还可以使用快速幂快速计算。如果我们要计算 $5^{10}$，常规的算法是 5∗5&#x3D;25，然后再 25∗5&#x3D;125，如此往下，一共是 9 次运算，即 n−1 次。<br>但是我们可以考虑这样：5∗5&#x3D;25 (二次）、25∗25&#x3D;625（四次）、625∗625&#x3D;…（八次），这是一个二分的思维，运算次数缩减到 $log_2​n$ 次，公式如下：<br><img src="/undefined" alt="Pasted image 20240307104929"></p>
<p>使用快速幂计算次方：将已乘出来的部分求次方，可以每次缩小一半要求的次方数。<br><img src="/undefined" alt="D1BBAD5FEB77FAB86A8895C28455AE59"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Pow</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//循环遍历指数 exponent 的每一位，直到 exponent 变为 0。</span></span><br><span class="line">    <span class="keyword">while</span>(exponent != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最低位如果是 1，就将基数 base 乘以 res。</span></span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环的过程中，让base做乘方运算</span></span><br><span class="line">        base *= base;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移</span></span><br><span class="line">        exponent = exponent &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (log2​n)，其中 n 为所求的次方数，快速幂相当于对求幂使用二分法</li>
<li>空间复杂度：O (1)，常数级变量，无额外辅助空间</li>
</ul>
<h3 id="快速幂-快速乘法（难）"><a href="#快速幂-快速乘法（难）" class="headerlink" title="快速幂 + 快速乘法（难）"></a>快速幂 + 快速乘法（难）</h3><p>例题： [[#剪绳子（进阶版）]]<br>适用范围：快速计算 a * b % mod 的结果（主要目的是换乘法为加法，防止超出 long long 的表示范围），或者快速计算 a^b % mod 的结果，时间复杂度大大降低。</p>
<p>我们可以考虑用加法来代替乘法，并在这其中取模。就比如 $a∗b&#x3D;a∗(b_1​+b_2​+b3_​+…)$，其中 $b_i​$ 是数字 $b$ 的二进制各位，假设 $a&#x3D;5，b&#x3D;110101$，我们有 $$a∗b&#x3D;a∗(100000∗1+10000∗1+1000∗0+100∗1+10∗0+1∗1)$$<br>那么设立一个 ans&#x3D;0用于保存答案，每一位让 a*&#x3D;2，在根据 b 的对应为1看是不是加上此时的 a，即可完成快速运算。比如刚才的例子让 a&#x3D;5，运转流程如下。<br><img src="/undefined" alt="Pasted image 20240312064818"><br>即可计算出$5*53&#x3D;265$。</p>
<p>对于快速幂其实是一样的道理，只不过每一位 a 更新的时候不是 $<em>2$，而是 $a&#x3D;a</em>a$，$ans+$ 变成 $ans*$。</p>
<p>例如3^9的流程如下：$3^5&#x3D;3^{1001} （二进制）&#x3D; 3^{1000<em>1+100</em>0+10<em>0+1</em>1}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速乘</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">q_mul</span><span class="params">( <span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> mod )</span> <span class="comment">//快速计算 (a*b) % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">while</span>(b)				<span class="comment">//根据b的每一位看加不加当前a</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)			<span class="comment">//如果当前位为1</span></span><br><span class="line">		&#123;</span><br><span class="line">			b--;</span><br><span class="line">			ans =(ans+ a)%mod;   <span class="comment">//ans+=a</span></span><br><span class="line">		&#125;</span><br><span class="line">		b /= <span class="number">2</span>;							<span class="comment">//b向前移位</span></span><br><span class="line">		a = (a + a) % mod;			<span class="comment">//更新a</span></span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">q_pow</span><span class="params">( <span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> mod )</span> <span class="comment">//快速计算 (a^b) % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">while</span>(b)<span class="comment">//根据b的每一位看乘不乘当前a</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)	<span class="comment">//如果当前位为1</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans = <span class="built_in">q_mul</span>( ans, a, mod ); <span class="comment">//ans*=a</span></span><br><span class="line">		&#125;</span><br><span class="line">		b /= <span class="number">2</span>;										<span class="comment">//b向前移位</span></span><br><span class="line">		a = <span class="built_in">q_mul</span>( a, a, mod );			<span class="comment">//更新a</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> a, b, n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b &gt;&gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a*b%n = &quot;</span> &lt;&lt; <span class="built_in">q_mul</span>( a, b, n ) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a^b%n = &quot;</span> &lt;&lt; <span class="built_in">q_pow</span>( a, b, n ) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【剑】不用加减乘除做加法"><a href="#【剑】不用加减乘除做加法" class="headerlink" title="【剑】不用加减乘除做加法"></a>【剑】不用加减乘除做加法</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=23249&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">不用加减乘除做加法_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+、-、*、/</code>四则运算符号。</p>
<p><strong>方法一：自增自减运算符</strong><br>主体思路：循环其中一个值，每次自减1，让另外一个值自增<br>复杂度分析：<br>时间复杂度:$O(n)$,循环了n次；<br>空间复杂度:$O(1)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果num1&gt;0,就自减，都加到num2上</span></span><br><span class="line">        <span class="keyword">if</span>(num1&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(num1!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num1--;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果num1&lt;0,就自增，num2减少</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(num1!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num1++;</span><br><span class="line">                num2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：位运算</p>
<table>
<thead>
<tr>
<th>A(i)</th>
<th>B(i)</th>
<th>求和</th>
<th>进位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>如上图所示，  </p>
<ol>
<li><strong>当前位的和值等于 <code>A(i)^B(i)</code></strong>  </li>
<li><strong>进位等于 <code>A(i)&amp;B(i)</code>,进位需要加在计算位的前一位，所以左移1位，即 <code>A(i)&amp;B(i)&lt;&lt;1</code></strong><br>所以找出规律 <code>A+B=A^B + (A&amp;B)&lt;&lt;1</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//相加各位 + 计算进位</span></span><br><span class="line">        <span class="comment">//十进制思想</span></span><br><span class="line">        <span class="comment">//5+7 各位相加：2 进位：10</span></span><br><span class="line">        <span class="comment">//2+10 12 0</span></span><br><span class="line">        <span class="comment">//12+0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//二进制计算过程</span></span><br><span class="line">        <span class="comment">//5+7 各位相加：101^111=010 进位：101&amp;111=101 (&lt;&lt;1=1010)</span></span><br><span class="line">        <span class="comment">//2+10 各位相加：010^1010=1000 进位：010&amp;1010=010 (&lt;&lt;1=0100)</span></span><br><span class="line">        <span class="comment">//8+4 1000^0100=1100 1000&amp;0100=0</span></span><br><span class="line">        <span class="comment">//12+0</span></span><br><span class="line">        <span class="keyword">if</span> (num2 == <span class="number">0</span>) <span class="keyword">return</span> num1;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Add</span>(num1^num2, (num1&amp;num2)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归写法：<br>每次将 <code>num1^num2</code> 赋给num1，将 <code>(num1&amp;num2)&lt;&lt;1</code> 赋给nums2，直到nums2&#x3D;0，返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//num2可以表示为进位，</span></span><br><span class="line">        <span class="comment">//循环的意义：循环将进位加到num1值上；</span></span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="type">int</span> temp = (num1&amp;num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】二进制中-1-的个数"><a href="#【剑】二进制中-1-的个数" class="headerlink" title="【剑】二进制中 1 的个数"></a>【剑】二进制中 1 的个数</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=23273&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二进制中1的个数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>方法：循环按位比较法</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：遍历 1 的二进制的32位，通过移位0-31次实现。</li>
<li>step 2：将移位后的1与数字进行按位与运算，记录结果</li>
</ul>
<p>设 n 的二进制为：<br>0000 1010 0000 1111 0001 0001 0001 0011<br>分别与移位后的 1 的二进制进行按位与运算：<br>0000 0000 0000 0000 0000 0000 0000 0001<br>0000 0000 0000 0000 0000 0000 0000 0010<br>…<br>1000 0000 0000 0000 0000 0000 0000 0000</p>
<p>可以发现，<strong>当 n 与移位后的 1 进行【按位与<code>&amp;</code>】运算时，如果结果仍是移位后的 1，说明 n 的二进制对应位置也是 1.</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历1的二进制的32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//按位比较</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; (<span class="number">1</span>&lt;&lt;i)) == (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】数值的整数次方"><a href="#【剑】数值的整数次方" class="headerlink" title="【剑】数值的整数次方"></a>【剑】数值的整数次方</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=23277&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数值的整数次方_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><strong>方法一：累乘</strong><br>既然是求次方，那我们做不断累乘就可以了，重点是处理负的次方数，因为 $x^{-n}&#x3D;(\frac1x)^{n}$，因此我们将底数转换为相应分数，就可以将次方数变回正数。</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：先处理次方数为负数的情况，将底数化为分数解决。</li>
<li>step 2：遍历次方数的次数，不断累乘底数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理负数次方</span></span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累乘exponent次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;exponent; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，其中n为所求的次方数，一共需要乘n次</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<p><strong>方法二：快速幂</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//快速幂</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Pow</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//循环遍历指数 exponent 的每一位，直到 exponent 变为 0。</span></span><br><span class="line">        <span class="keyword">while</span>(exponent != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//最低位如果是 1，就将基数 base 乘以 res。</span></span><br><span class="line">            <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res *= base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环的过程中，让base做乘方运算</span></span><br><span class="line">            base *= base;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右移</span></span><br><span class="line">            exponent = exponent &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Pow</span>(base, exponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log2​n)，其中n为所求的次方数，快速幂相当于对求幂使用二分法</li>
<li>空间复杂度：O(1)，常数级变量，无额外辅助空间</li>
</ul>
<h3 id="【剑】数组中只出现一次的两个数字"><a href="#【剑】数组中只出现一次的两个数字" class="headerlink" title="【剑】数组中只出现一次的两个数字"></a>【剑】数组中只出现一次的两个数字</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&tqId=1375231&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数组中只出现一次的两个数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>要求：空间复杂度 $O(1)$，时间复杂度 $O(n)$</p>
<p>使用哈希表简单，但空间复杂度为 O(n)。既满足时间复杂度又满足空间复杂度，就要提到<strong>位运算中的异或运算 XOR</strong>，主要因为异或运算有以下几个特点：</p>
<ul>
<li>一个数和 0 做 XOR 运算等于本身：<code>a⊕0 = a</code></li>
<li>一个数和其本身做 XOR 运算等于 0：<code>a⊕a = 0</code></li>
<li>XOR 运算满**交换律和结合律：<code>a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</code><br>  故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</li>
</ul>
<p><strong>例</strong>:将数组[4, 1, 2, 1, 2]的第一项与之后的元素进行位运算<br><code>4^1^2^1^2 = 100 -&gt; 101 -&gt; 111 -&gt; 110 -&gt; 100 = 4</code></p>
<p>化简后可得</p>
<p><code>4^(1^1)^(2^2) = 100 = 4</code></p>
<p>实现中出现过的问题：</p>
<p>1.<code>&amp;</code>位与的优先级比 <code>==</code> 等号的优先级低，没加括号。<br>2.左移操作没重新赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>, mask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先遍历整个数组，对数组中所有数字进行异或操作。由于相同数字异或结果为0，因此最终的结果会是两个只出现一次的数字的异或结果。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            tmp ^= num;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出异或结果中为1的某一位，用这一位来区分两个只出现一次的数字。这里使用了一个mask变量，初始值为1，通过左移来找到异或结果中为1的位。</span></span><br><span class="line">        <span class="comment">//注：tmp是两个数字的异或结果，所以为1的位是两个数字对应位不相等的位置（即一个该位为0，一个该位为1）</span></span><br><span class="line">        <span class="keyword">while</span>((tmp&amp;mask) == <span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再次遍历数组，根据这一位是否为1来将数组中的数字分成两组，一组该位为1，一组该位为0。因为除了两个只出现一次的数字外，其他数字都是成对出现的，因此这样分组保证了两个只出现一次的数字被分到不同的组中。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>] ^= num; <span class="comment">//该位为0的所有数字进行异或，结果为只出现一次的数字</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">1</span>] ^= num; <span class="comment">//该位为1的所有数字进行异或，结果为只出现一次的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序，题目要求非递减</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【剑】求-1-2-3-…-n"><a href="#【剑】求-1-2-3-…-n" class="headerlink" title="【剑】求 1+2+3+…+n"></a>【剑】求 1+2+3+…+n</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=23248&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">求1+2+3+…+n_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<p>正常递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码出现了 if 判断语句，我们可以采用<strong>逻辑与运算符 <code>&amp;&amp;</code></strong> 的短路特性代替这一语句，具体修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过与运算判断n是否为正数，以结束递归</span></span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，一共递归n次</li>
<li>空间复杂度：O(n)，递归栈深度为n</li>
</ul>
<h1 id="十三、模拟"><a href="#十三、模拟" class="headerlink" title="十三、模拟"></a>十三、模拟</h1><h2 id="【剑】扑克牌顺子"><a href="#【剑】扑克牌顺子" class="headerlink" title="【剑】扑克牌顺子"></a>【剑】扑克牌顺子</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=23252&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">扑克牌顺子_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//计算所缺的最少牌数量，如果0的数量可以抵消，则返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsContinuous</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> zeroNum = <span class="number">0</span>; <span class="comment">//0的数量</span></span><br><span class="line">        <span class="type">int</span> index= <span class="number">0</span>; <span class="comment">//记录非0最小值下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//若非0牌含有重复元素，返回false</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; numbers[i] == numbers[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> midNum = n - <span class="number">1</span> - index - <span class="number">1</span>;  <span class="comment">//最小值与最大值之间的元素数量</span></span><br><span class="line">        <span class="type">int</span> diff = numbers[n<span class="number">-1</span>] - numbers[index] - <span class="number">1</span> - midNum;  <span class="comment">//若要补齐还需要的元素数量</span></span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= zeroNum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/49036.html">http://liuke101.github.io/post/49036.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/21879.html" title="Unity Primer"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190029709.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity Primer</div></div></a></div><div class="next-post pull-right"><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">模板与泛型编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/1106.html" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-29</div><div class="title">数据结构</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">一、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-text">01 二分查找 (折半查找)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD%E5%86%99%E6%B3%95%EF%BC%88%E7%94%A8%E8%BF%99%E7%A7%8D%EF%BC%89"><span class="toc-text">左闭右闭写法（用这种）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1"><span class="toc-text">值存在返回位置，不存在返回-1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-text">值存在返回位置，不存在返回插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E5%B7%A6%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="toc-text">查左右边界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">【剑】数字在升序数组中出现的次数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">查平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">有效的完全平方数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-text">x 的平方根</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">旋转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">无重复元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">有重复元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">寻找旋转排序数组中的最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-1"><span class="toc-text">无重复元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">【剑】有重复元素</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">02 双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">相向双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II"><span class="toc-text">两数之和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-text">a 的去重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E4%B8%8Ec%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-text">b与c的去重</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">平方数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">回文字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text">【剑】构建乘积数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">同向双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2%EF%BC%88%E5%8F%8C%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">匹配子串（双数组双指针）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E5%BA%8F%E4%B8%89%E6%8C%87%E9%92%88"><span class="toc-text">倒序三指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="toc-text">合并数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-text">快慢指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8E%9F%E5%9C%B0%E5%88%A0%E9%99%A4"><span class="toc-text">删除元素 (原地删除)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-0%EF%BC%88%E5%8E%9F%E5%9C%B0%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-text">删除 0（原地删除）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">删除有序数组重复项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">比较含退格的字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">03 滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">长度最小的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88hard%E4%B8%8D%E4%BC%9A%EF%BC%89"><span class="toc-text">最小覆盖子串（hard不会）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">【剑】无重复字符的最长子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95"><span class="toc-text">04 中心扩散法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">最长回文子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E3%80%90%E5%89%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="toc-text">05 【剑】螺旋矩阵（顺时针打印矩阵）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">算法流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E6%8E%92%E5%BA%8F"><span class="toc-text">06 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">【剑】数组中的逆序对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="toc-text">【剑】二维数组查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">二、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-text">01  链表定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">节点操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-text">添加节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">删除节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%93%BE%E8%A1%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">直接使用原来的链表来进行删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">设置一个虚拟头结点在进行删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8-O-1-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-text">用 O(1)的时间复杂度删除链表节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-text">设计链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E8%AE%BF%E9%97%AE%E9%93%BE%E8%A1%A8"><span class="toc-text">【剑】从尾到头访问链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">【剑】合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="toc-text">快慢指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">【剑】反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">【剑】链表中倒数第 k 个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">【剑】 删除排序链表中的重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%E4%B8%8D%E4%BF%9D%E7%95%99"><span class="toc-text">重复节点不保留</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%E5%8F%AA%E4%BF%9D%E7%95%99%E4%B8%80%E4%B8%AA"><span class="toc-text">重复节点只保留一个</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%EF%BC%88%E9%93%BE%E8%A1%A8%E6%89%BE%E7%8E%AF%E8%B7%AF%EF%BC%89"><span class="toc-text">【剑】链表中环的入口结点（链表找环路）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%EF%BC%89"><span class="toc-text">【剑】两个链表的第一个公共结点（链表相交）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">【剑】复杂链表的复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">三、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">【剑】第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">有效的字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text">快乐数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90H1%E3%80%91%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">【H1】无序数组的两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="toc-text">四数相加 II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">四、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97"><span class="toc-text">【剑】翻转单词序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">反转字符串中的单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-text">找出字符串中第一个匹配项的下标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">重复的子字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">五、栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">【剑】用栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text">用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">单队列实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">双队列实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%EF%BC%88%E6%9C%80%E5%B0%8F%E6%A0%88%EF%BC%89"><span class="toc-text">【剑】包含 min 函数的栈（最小栈）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-text">【剑】栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">逆波兰表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E4%B8%AA%E6%95%B0"><span class="toc-text">【剑】最小的 K 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">前 K 个高频元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%EF%BC%88%E6%9C%AA%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">【剑】滑动窗口最大值（单调队列）（未掌握）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">六、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-text">1 递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%A0%B9%E5%B7%A6%E5%8F%B3%EF%BC%89"><span class="toc-text">前序遍历（根左右）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%B7%A6%E6%A0%B9%E5%8F%B3%EF%BC%89"><span class="toc-text">中序遍历（左根右）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%B7%A6%E5%8F%B3%E6%A0%B9%EF%BC%89"><span class="toc-text">后序遍历（左右根）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">递归二叉树的返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-text">2 迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E6%A0%87%E8%AE%B0%E6%B3%95%E7%BB%9F%E4%B8%80%E6%A8%A1%E6%9D%BF-%E6%8E%A8%E8%8D%90"><span class="toc-text">01 标记法统一模板 (推荐)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">【剑】由遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-text">前序+中序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-text">后序+中序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">3 层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">【剑】二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="toc-text">二叉树的层序遍历 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">【剑】从上往下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-text">二叉树的层平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">N 叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">在每个树行中找最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">【剑】二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7-%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大&#x2F;最小深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">找树左下角的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%BC%E5%90%88"><span class="toc-text">4 综合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">【剑】二叉树的下一个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E9%95%9C%E5%83%8F%EF%BC%89"><span class="toc-text">【剑】翻转二叉树（镜像）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-text">相同的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">另一棵树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">【剑】树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">【剑】二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-text">左叶子之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">监控二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">【剑】二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E9%B8%BD"><span class="toc-text">【剑】二叉搜索树的最近公共祖先 (鸽)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%8D%E4%BC%9A%EF%BC%89"><span class="toc-text">【剑】序列化二叉树（不会）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9E%E6%BA%AF"><span class="toc-text">二叉树回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">路径总和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">5 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">6 二叉排序树 (二叉查找树、二叉搜索树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-text">查找（搜索）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">【剑】二叉搜索树的第 k 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">修剪二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-text">把二叉搜索树转换为累加树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">【剑】验证二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">【剑】二叉搜索树与双向链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-text">七、回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">1 回溯三部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">2 组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-text">组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-path-%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F%E7%9A%84%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96"><span class="toc-text">关于 path 元素数量的剪枝优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-path-%E5%85%83%E7%B4%A0%E6%80%BB%E5%92%8C%E7%9A%84%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96"><span class="toc-text">关于 path 元素总和的剪枝优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-text">组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-startIndex-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D"><span class="toc-text">使用 startIndex 同层去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unordererd-set-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D"><span class="toc-text">使用 unordererd_set 同层去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-text">组合总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">电话号码的字母组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-text">3 分割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-text">复原 IP 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-text">4 子集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86-II"><span class="toc-text">子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-startIndex-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D-1"><span class="toc-text">使用 startIndex 同层去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unordered-set-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D"><span class="toc-text">使用 unordered_set 同层去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">非递减子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unordered-set-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D-1"><span class="toc-text">使用 unordered_set 同层去重</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">5 排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">全排列（不含重复元素）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unordered-set-%E4%B8%8D%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D"><span class="toc-text">使用 unordered_set 不同层去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-vector-%E4%B8%8D%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">使用 vector 不同层去重（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">两种写法的性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E5%85%A8%E6%8E%92%E5%88%97-%EF%BC%88%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">【剑】全排列 （含重复元素）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unordered-set-%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D-2"><span class="toc-text">使用 unordered_set 同层去重</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98"><span class="toc-text">7 棋盘问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#N-%E7%9A%87%E5%90%8E"><span class="toc-text">N 皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-text">解数独</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2-1"><span class="toc-text">回溯三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A3%8B%E7%9B%98%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="toc-text">判断棋盘是否合法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">八、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%94%E9%83%A8%E6%9B%B2"><span class="toc-text">动态规划五部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A-dp-%E6%95%B0%E7%BB%84%EF%BC%88dp-table%EF%BC%89%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">确定 dp 数组（dp table）以及下标的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%EF%BC%88%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F%EF%BC%89"><span class="toc-text">确定递推公式（状态转移公式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp-%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">dp 数组如何初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F"><span class="toc-text">确定遍历顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BC-dp-%E6%95%B0%E7%BB%84"><span class="toc-text">举例推导 dp 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">【剑】斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89"><span class="toc-text">【剑】爬楼梯（跳台阶）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95"><span class="toc-text">【剑】跳台阶扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="toc-text">【剑】矩形覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-text">不同路径 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-text">【剑】礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%89"><span class="toc-text">【剑】整数拆分（剪绳子）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89"><span class="toc-text">剪绳子（进阶版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%A7%84%E5%BE%8B%E4%B8%8D%E5%A5%BD%E6%89%BE"><span class="toc-text">【剑】把数字翻译成字符串 (规律不好找)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E8%A7%84%E5%BE%8B%E4%B8%8D%E5%A5%BD%E6%89%BE"><span class="toc-text">不同的二叉搜索树 (规律不好找)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%83%8C%E5%8C%85"><span class="toc-text">01 背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4-dp-%E6%95%B0%E7%BB%84-01-%E8%83%8C%E5%8C%85"><span class="toc-text">二维 dp 数组 01 背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4-dp-%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">一维 dp 数组（滚动数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-text">最后一块石头的重量 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">目标和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-text">一和零</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E2%85%A1"><span class="toc-text">零钱兑换Ⅱ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A5"><span class="toc-text">组合总和 Ⅵ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">零钱兑换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">完全平方数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%8D%E6%87%82%EF%BC%89"><span class="toc-text">单词拆分（不懂）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">多重背包（略）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">子序列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-text">最长连续递增序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">最长重复子数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">九、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">分发饼干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-text">摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-%E4%BA%8C"><span class="toc-text">【剑】连续子数组的最大和 (二)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-2"><span class="toc-text">贪心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-3"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-4"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-5"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1"><span class="toc-text">跳跃游戏Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">K 次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-text">加油站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">柠檬水找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x-y-%E5%8C%BA%E9%97%B4%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">[x, y]区间相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-text">根据身高重建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-text">用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-text">无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-text">划分字母区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">合并区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">单调递增的数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">十、单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">每日温度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">下一个更大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II"><span class="toc-text">下一个更大元素 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-text">柱状图中最大的矩形</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%9B%BE"><span class="toc-text">十一、图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs-%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">dfs 搜索过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">所有可能的路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">广度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">路径压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">代码模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-1"><span class="toc-text">模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-text">省份数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-text">并查集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-1"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-1"><span class="toc-text">BFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-text">岛屿的最大面积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-2"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS-2"><span class="toc-text">BFS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">飞地的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-3"><span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-3"><span class="toc-text">BFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">被围绕的区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-text">大西洋水流问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="toc-text">岛屿的周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4"><span class="toc-text">钥匙和房间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">【剑】矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">【剑】 机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84"><span class="toc-text">寻找图中是否存在路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%9B%B0%E9%9A%BE%E9%A2%98%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">几个困难题（略）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E5%AD%A6"><span class="toc-text">十二、数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">【剑】数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">【剑】数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">【剑】位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">按位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">移位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">快速幂 + 快速乘法（难）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-text">【剑】不用加减乘除做加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">【剑】二进制中 1 的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-text">【剑】数值的整数次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-text">【剑】数组中只出现一次的两个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%B1%82-1-2-3-%E2%80%A6-n"><span class="toc-text">【剑】求 1+2+3+…+n</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%A8%A1%E6%8B%9F"><span class="toc-text">十三、模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%89%91%E3%80%91%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="toc-text">【剑】扑克牌顺子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/17862.html" title="3DGS总结">3DGS总结</a><time datetime="2024-05-04T16:00:00.000Z" title="发表于 2024-05-05 00:00:00">2024-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46692.html" title="2DGS">2DGS</a><time datetime="2024-04-11T16:00:00.000Z" title="发表于 2024-04-12 00:00:00">2024-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/8166.html" title="GaussianDreamer:通过桥接 2D 和 3D  Diffusion Model，实现从 Text 到 3D 高斯的快速生成">GaussianDreamer:通过桥接 2D 和 3D  Diffusion Model，实现从 Text 到 3D 高斯的快速生成</a><time datetime="2024-04-09T16:00:00.000Z" title="发表于 2024-04-10 00:00:00">2024-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46693.html" title="DreamGaussian:用于高效3D内容创建的生成式高斯泼溅">DreamGaussian:用于高效3D内容创建的生成式高斯泼溅</a><time datetime="2024-04-08T16:00:00.000Z" title="发表于 2024-04-09 00:00:00">2024-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/42610.html" title="GaussianEditor:使用高斯泼溅进行快速可控的 3D 编辑">GaussianEditor:使用高斯泼溅进行快速可控的 3D 编辑</a><time datetime="2024-04-08T16:00:00.000Z" title="发表于 2024-04-09 00:00:00">2024-04-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>