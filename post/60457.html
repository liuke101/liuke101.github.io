<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="零、导读术语声明式declaration声明式：告诉编译器某个东西的名称和类型。 123456789101112&#x2F;&#x2F;对象声明式extern int x;&#x2F;&#x2F;函数声明式std::size_t  NumDigits(int number);&#x2F;&#x2F;类声明式class Widget;&#x2F;&#x2F;模板声明式template &lt;typename T&gt;class GraphNode;  注意作者在这里把看基本">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="http://liuke101.github.io/post/60457.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="零、导读术语声明式declaration声明式：告诉编译器某个东西的名称和类型。 123456789101112&#x2F;&#x2F;对象声明式extern int x;&#x2F;&#x2F;函数声明式std::size_t  NumDigits(int number);&#x2F;&#x2F;类声明式class Widget;&#x2F;&#x2F;模板声明式template &lt;typename T&gt;class GraphNode;  注意作者在这里把看基本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg">
<meta property="article:published_time" content="2023-09-18T04:20:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.328Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/60457.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-18T04:20:00.000Z" title="发表于 2023-09-18 12:20:00">2023-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.328Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>136分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/60457.html#post-comment"><span class="waline-comment-count" data-path="/post/60457.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零、导读"><a href="#零、导读" class="headerlink" title="零、导读"></a>零、导读</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="声明式declaration"><a href="#声明式declaration" class="headerlink" title="声明式declaration"></a>声明式declaration</h3><p>声明式：告诉编译器某个东西的名称和类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象声明式</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明式</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span>  <span class="title">NumDigits</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板声明式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>;</span><br></pre></td></tr></table></figure>

<p>注意作者在这里把看基本类型看作对象（Obejct）。<br>顺带一提，size_t 本质是 unsigned int，是一个 typedef</p>
<h3 id="函数签名式signature"><a href="#函数签名式signature" class="headerlink" title="函数签名式signature"></a>函数签名式signature</h3><p>函数的声明揭示了其签名式。也就是<strong>参数和返回值</strong>。<br>一个函数的签名等同于该函数的类型。<br>C++ 对于签名的官方定义中并不包含函数的返回类型，这意味着<strong>函数的重载不能根据返回值判断</strong>。<font color="#ff0000">（本书把返回类型视为签名的一部分）</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fun</span><span class="params">()</span> <span class="comment">//error:has already been declared with return type &#x27;void&#x27;. </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义式definition"><a href="#定义式definition" class="headerlink" title="定义式definition"></a>定义式definition</h3><p>提供给编译器一些声明式所遗漏的细节：</p>
<p>对对象而言，定义式是编译器为此对象分配内存的地点。<br>对函数或函数模板而言，定义式提供了代码本体。<br>对类或类模板而言，定义式列出了它们的成员。</p>
<h3 id="初始化initialization"><a href="#初始化initialization" class="headerlink" title="初始化initialization"></a>初始化initialization</h3><p>是<strong>给对象赋初值</strong>的过程。  </p>
<p>对用户自定义类型的对象而言，初始化由构造函数执行。</p>
<ul>
<li><p><code>explicit</code>关键字 ：<br>可以阻止类型之间的隐式转换。<br>隐式转换可能带来意想不到的问题。<br><strong>除非必须使用隐式转换，否则就声明为<code>explicit</code></strong></p>
</li>
<li><p><code>copy构造函数和copy赋值运算符</code></p>
</li>
<li><p>比较好的方式是传<code>常引用</code>（const T&amp;）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载赋值运算符(=)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;); <span class="comment">//赋值运算符</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h3><p>C++没有接口，<strong>本书中的接口指的是一般性的设计概念</strong>，如：</p>
<ul>
<li>函数的签名（signature）</li>
<li>class的可访问元素（例如class的“public接口”“private接口”等）</li>
<li>针对某template类型参数需为有效的一个表达式（条款41）</li>
</ul>
<h2 id="本书命名习惯"><a href="#本书命名习惯" class="headerlink" title="本书命名习惯"></a>本书命名习惯</h2><ul>
<li>Left-Hand Side：lhs<br>左手端</li>
<li>Right-Hand Side：rhs<br>右手端</li>
<li>Ptr to Class：pc<br>指向对象的指针（如果指向一个名为widget的对象，则命名为pw，以此类推）</li>
<li>Ref to Class：rc<br>指向对象的引用（如果引用一个名为widget的对象，则命名为rw，以此类推）</li>
</ul>
<ul>
<li>member function：mf<br>成员函数</li>
<li>Constructor and Destructor：ctor和dtor<br>构造函数和析构函数</li>
</ul>
<h1 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>今天的 C++ 已经是个 <strong>多重范型编程语言</strong>，同时支持：</p>
<ul>
<li>过程形式（procedural）</li>
<li>面向对象（object-oriented）</li>
<li>函数形式（functional）</li>
<li>泛型形式（generic）</li>
<li>元编程形式（metaprogramming）</li>
</ul>
<p><strong>如何理解C++？</strong><br>将C++视为一个由相关语言组成的联邦而非单一语言，某个<strong>次语言 (sublanguage)</strong> 中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。</p>
<p><strong>主要的次语言：</strong></p>
<ol>
<li>传统的面向过程 C：说到底，C++仍然以 C 为基础，区块（blocks），语句（statements），预处理器（preprocessor），内置数据类型（built-in data type），数组（arrays），指针（pointers）等都来自于 C。当你用 C++ 时，就会发现 C 语言的局限：没有模板，没有异常，没有重载…</li>
<li>面向对象的 C++：包括构造函数，析构函数，封装，继承，多态。虚函数…</li>
<li>模板编程 Template C++：这是关于 C++ 的泛型编程。</li>
<li>标准库STL：是个 template 的程序库。</li>
</ol>
<blockquote>
<p>[!NOTE] C++高效编程守则视情况变化，取决于你使用C++的哪一部分</p>
<ul>
<li>对于来自 C 的内置数据类型，使用值传递比引用传递高效。</li>
<li>对于面向对象 C++、Template C++，由于用户自定义的数据类型构造函数和析构函数的存在，使用常引用传递往往更好。</li>
<li>对于 STL，迭代器和函数都是在 C 指针之上塑造出来的，所以对 STL 的迭代器和函数对象，对于的 C 的值传递守则再次适用。</li>
</ul>
</blockquote>
<p><strong>因此，C++斌不是一个带有一组守则的一体语言，他是从四个次语言组成的联邦政府。</strong></p>
<h2 id="条款02：尽量以const-enum-inline-替换-define"><a href="#条款02：尽量以const-enum-inline-替换-define" class="headerlink" title="条款02：尽量以const,enum,inline 替换 # define"></a>条款02：尽量以const,enum,inline 替换 # define</h2><blockquote>
<p>[!NOTE] 总结</p>
<ol>
<li>对于单纯常量，最好是以 const 对象或者 enums 替换 <code>#define</code>（C++11 使用 constexpr)</li>
<li>对于形似函数的宏（macros），最好改用 template inline 函数替换 <code>#define</code></li>
</ol>
</blockquote>
<h3 id="尽量以编译器替换预处理器"><a href="#尽量以编译器替换预处理器" class="headerlink" title="尽量以编译器替换预处理器"></a>尽量以编译器替换预处理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义是预处理器指令，在编译之前的预处理阶段就被展开了。记号名称ASPECT_PATIO可能未进入记号表，导致后续难以追踪。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_PATIO 1.653   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：以常量替换上述的宏，可以被编译器看到，记入记号表内</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio = <span class="number">1.653</span></span><br></pre></td></tr></table></figure>

<p>在原书写成时 C++11 中的 <code>constexpr</code> 还未诞生，现在一般认为应当用 <strong><code>constexpr</code></strong> 定义编译期常量来替代大部分的 <code>#define</code> 宏常量定义：<br>[[1 C++ Primer#【C++11】constexpr 变量]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol>
<li><strong>宏的特点</strong><br>在 C++中，宏通常被用来定义常量或者简单的函数。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE (x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>

<p>然而，尽管宏在某些情况下非常有用，但也存在一些缺点：</p>
<ul>
<li>缺乏类型检查：由于预处理器只进行文本替换，所以不会对宏进行类型检查。</li>
<li>可能导致意料之外的副作用：例如，调用 SQUARE (++x)将增加 x 两次，而不是预期的一次。</li>
<li>调试困难：因为宏扩展在编译时完成，所以在调试过程中，无法单步执行或查看宏的扩展。</li>
</ul>
<ol start="2">
<li><strong>constexpr 的特点</strong><br>constexpr 是 C++11 中引入的新特性，它<strong>允许在编译时计算表达式的值。这对于需要在编译时确定的常量和结果非常有用</strong>。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">square</span> <span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br></pre></td></tr></table></figure>

<p>与宏相比，constexpr 具有以下优势：</p>
<ul>
<li>类型安全, 易于调试：因为 constexpr 是编译器处理的，<strong>能提供类型检查以及调试信息</strong></li>
<li>避免副作用：如上面的例子，square (++x)将只增加 x 一次。</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p><strong>以常量替换<code>#define</code>，有两种特殊情况：</strong></p>
<ol>
<li><strong>定义常量指针</strong><br> 由于常量定义时通常放在头文件内（以便被不同的源码含入），有必要将指针本身声明为 const，即 int* const 形式。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若在头文件定义一个常量的 char* 的字符串，必须 const 两次：</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*  <span class="type">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string对象通常比char*更合适，所以上述authorName建议定义成这样：</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">authorName</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>class专属常量：static成员</strong><br>为了将常量的作用域限制在 class 内，你得让它成为 class 的一个成员，而<strong>为了确保常量至多只有一份实体。你必须让它成为一个 static 成员。</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">10</span>;  <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> numTurns = <span class="number">5</span>; <span class="comment">//C++11建议这样写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是你所看到的只是常量声明式，而非定义式。<strong>如果它是个 class 专属常量又是 static 且为整数类型（例如 ints，chars，bools），只要不取它们的地址，可以直接声明并使用它们 (无需提供定义式)。</strong></p>
<p>通常情况下 C++ 会要求对你所使用到的任何东西提供一个定义式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NumTurns的定义式应该放进一个实现文件（.cpp）而不是头文件(.h)</span></span><br><span class="line"><span class="comment">// 由于常量已在声明时获得初值，因此定义时不可以再获得初值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GamePlayer::NumTurns = <span class="number">9</span>;  <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GamePlayer::NumTurns;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!bug] static初始化时机<br>对于非const 的static数据成员，类内不提供初始值，只进行声明。在类外提供初始值<br>对于const的static数据成员，则需要在类内提供初始值。</p>
</blockquote>
<h3 id="enum-hack-补偿做法"><a href="#enum-hack-补偿做法" class="headerlink" title="enum hack 补偿做法"></a>enum hack 补偿做法</h3><p>当你在 class 编译期间需要一个 class 常量值，而编译器（错误的）不允许<strong>static 整数型 class 常量</strong>类内提供初始值时（存在于某些旧式编译器中的问题），则可以使用“enum hack”补偿做法</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns;  <span class="comment">//编译器错误的不允许提供初始值</span></span><br><span class="line">    	<span class="type">int</span> Array[NumTurns]; </span><br><span class="line">    	<span class="comment">//错误，因为编辑器坚持在编译期知道数组的大小，必须给ConstNumber初值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用的方法：“enum hack”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> Array[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其<strong>理论基础是：一个属于 enum 类型的数值可以充当 int 被使用</strong>。</p>
<p>enum hack 的行为某方面来说比较像 <code>#define</code> 而不是 const，有时候这就是想要的。例如取一个 const 的地址是合法的，而取一个 enum 的地址是非法的，而取一个 <code>#define</code> 的地址通常也不合法。<br>如果不想别人获得指针或者引用指向某个整形常量，enum 可以实现这个约束。</p>
<h3 id="template-inline-函数代替-define宏"><a href="#template-inline-函数代替-define宏" class="headerlink" title="template inline 函数代替 define宏"></a>template inline 函数代替 define宏</h3><p>使用<code>#define</code> 实现宏时，规定必须为宏中的所有实参加上小括号，即便如此可读性也不好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>并且这种方式在某些情况下不安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里，调用f之前，a的递增次数竟然取决于“它被拿来和谁比较”！</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line"><span class="function">CALL WITH <span class="title">MAX</span><span class="params">(++a, b)</span></span>;  <span class="comment">//a被累加二次</span></span><br><span class="line"><span class="function">CALL WITH <span class="title">MAX</span> <span class="params">(++a, b+<span class="number">10</span>)</span></span>;  <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p> <strong>使用template inline函数：更安全，更具可读性</strong><br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p>
<p>有了 const，enum，inline，我们对于预处理器（特别是 <code>#define</code>）的需求降低了，但并非完全消除。#include 仍然是必需品，而 <code>#ifdef</code>，<code>#ifndef</code> 也继续扮演着控制编译的重要角色。目前还没到预处理器全面退出的时候，但你应该明确地慎用它。</p>
<h2 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h2><blockquote>
<p>[!NOTE]<br>只要某值保持不变是事实，就声明为const，编译器确保强制执行约束。</p>
</blockquote>
<p><strong>用法：</strong></p>
<ol>
<li>const 指针和引用：[[1 C++ Primer#const限定符]]</li>
<li>const_iterator：[[1 C++ Primer#顺序容器迭代器]]</li>
<li>const成员函数：[[1 C++ Primer#const成员函数]]</li>
</ol>
<h2 id="条款-04：确定对象使用前已先被初始化"><a href="#条款-04：确定对象使用前已先被初始化" class="headerlink" title="条款 04：确定对象使用前已先被初始化"></a>条款 04：确定对象使用前已先被初始化</h2><blockquote>
<p>[!NOTE] 总结</p>
<ol>
<li>为内置对象进行手工初始化，因为 C++ 不保证初始化它们。</li>
<li>构造函数最好使用列表初始化，而不要在构造函数本体内使用赋值操作。列表初始化的成员变量，其排列顺序应该和它们在 class 中的声明次序相同。</li>
<li>对于类中的成员变量而言，两种方法完成初始化：类内初始化&#x2F;成员初始化列表</li>
<li>为免除跨编译单元的初始化次序问题，请以局部 static 对象替换非局部 static 对象。</li>
</ol>
</blockquote>
<ol>
<li>读取未初始化的值会导致不明确的行为。</li>
<li>c++ 初始化在不同语境表现不同，这些规则很复杂。</li>
<li><strong>最佳处理方法</strong>就是：<strong>永远在使用对象之前先将它初始化</strong>。<ul>
<li><strong>对于无任何成员的内置类型</strong>，必须手动完成初始化。</li>
<li><strong>对于非内置类型</strong>，初始化职责落在构造函数，那么规则是：确保每一个构造函数都将对象的每一个成员初始化。<ul>
<li><strong>规则很简单，重要的是别混淆了赋值和初始化：</strong><ul>
<li>构造函数中进行的是<strong>赋值</strong>（下图首先执行默认构造函数为变量设置初始值，然后在对他们赋予新值） <img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218068.png" alt="Pasted image 20231012153325"></li>
<li>C++规定对象的成员函数的<strong>初始化动作发生在进入构造函数本体之前</strong>。一个比较好的写法是在构造函数<strong>成员初始化列表</strong>中列出所有成员变量。<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218069.png" alt="Pasted image 20231012153355"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>只需要调用一次 copy 构造，通常效率更高（对于内置类型，初始化和赋值成本相同）</p>
</blockquote>
<p>另外，无参构造函数也可以使用成员初始化列表<br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218070.png" alt="Pasted image 20231012154128"><br>【C++11】 除了使用列表初始化，C++支持<strong>类内初始值</strong>对成员变量初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> textLength =  <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> lengthIsValid = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li>如果成员变量是 <code>const</code> 或者引用类型，它们一定需要初始化，不能被赋值。</li>
</ul>
<ol start="4">
<li><p><strong>不同编译单元内定义的非局部 static 对象的初始化次序。</strong> </p>
<ol>
<li>函数内的 static 对象成为局部 static 对象，其他为非局部 static 对象</li>
<li>所谓编译单元，是指产出单一目标文件的那些源码：基本上是单一源码文件（cpp）加上其所含入的头文件 (h)。</li>
</ol>
<p>  <strong>问题在于</strong>：如果某编译单内的某个非局部对象的初始化依赖于另一个编译单元内某个非局部对象，而这个对象可能尚未被初始化，然后就会导致未定义行为（ C++对“定义于不同编译单元内的非局部静态对象”的初始化次序并无明确定义，所以我们不能确定这个次序）。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File 1</span></span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>() &#123;</span><br><span class="line">        FileSystem disk = tfs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory tempDir;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面这个例子中，你无法确保位于不同编译单元内的 <code>tfs</code> 一定在 <code>tempDir</code> 之前初始化完成。</p>
</blockquote>
<p><strong>解决方法</strong>：<strong>将每一个非局部静态对象搬到自己专属函数中 (该对象在此函数内被声明为 static)，函数返回该该静态对象的引用</strong>，然后由用户调用这些函数，而不直接涉及这些对象。换句话说非局部静态对象被局部静态对象替换了。如果熟悉设计模式，想必认出来这是 <code>单例模式</code> 常见的实现手法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因为 C++ 保证：函数内的局部静态对象会在该函数第一次被调用时被初始化</strong>。这样保证你获得的引用将指向一个历经初始化的对象。更好的是，如果你不调用这个函数，绝不会引发构造和析构成本。</p>
<p>但从多线程来看，这使得系统带有不确定性，一个比较好的做法就是：在程序的单线程启动阶段手工调用所有的单例函数。</p>
<p>如果你的初始化存在对象 A 初始化依赖对象 B，对象 B 的初始化又依赖于对象 A，那什么也救不了，你该避免这种病态的情况。</p>
<h1 id="二、构造、析构和赋值运算"><a href="#二、构造、析构和赋值运算" class="headerlink" title="二、构造、析构和赋值运算"></a>二、构造、析构和赋值运算</h1><h3 id="条款-05：了解-C-默默编写并调用了哪些函数"><a href="#条款-05：了解-C-默默编写并调用了哪些函数" class="headerlink" title="条款 05：了解 C++ 默默编写并调用了哪些函数"></a>条款 05：了解 C++ 默默编写并调用了哪些函数</h3><p>当 C++ 处理过 empty class(空类) 之后，如果你没有声明，则编译器会主动为<strong>声明</strong>一个<strong>拷贝构造函数、拷贝复制操作符</strong>和一个<strong>析构函数</strong>，同时如果你没有声明任何构造函数，编译器也会为你声明一个 <strong>default 版本的拷贝构造函数</strong>，这些函数都是 <code>public</code> 且 <code>inline</code> 的(见条款 30)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器自动声明：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>() &#123;...&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">Epty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123;...&#125;  <span class="comment">//析构函数</span></span><br><span class="line">    </span><br><span class="line">    Empty&amp;<span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;rhs)&#123;...&#125;<span class="comment">//拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，上边说的是声明，只有当这些函数有调用需求的时候，编译器才会创建它们。但是编译器替你实现的函数可能在<strong>类内引用、类内指针、有 <code>const</code> 成员以及 virtual 类型属性</strong>的情形下会出问题。<br>比如以下情况：在该类中，我们有一个 string <strong>引用</strong>类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string&amp; nameValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p>
<ol>
<li>类中含有 <strong>const 成员</strong> (更改 const 成员是不合法的)。</li>
<li>基类中含有 <strong>private 的拷贝赋值运算符</strong>（因为要继承给子类，子类可可能无权调用基类的成员函数）。</li>
</ol>
<ul>
<li>对于拷贝构造函数，你要考虑到类内成员有没有<strong>深拷贝</strong>的需求，如果有的话就需要自己编写拷贝构造函数 &#x2F; 操作符，而不是把这件事情交给编译器来做。</li>
<li>对于析构函数，如果该类有多态需求，请主动将析构函数声明为 <code>virtual</code>，默认是非 virtual 的（具体请看条款 07） 。</li>
</ul>
<p>除了这些特殊的场景以外，如果不是及其简单的类型，请自己编写好<strong>构造、析构、拷贝构造和赋值操作符、移动构造和赋值操作符</strong>（C++11、如有必要）这六个函数。</p>
<h3 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝。"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝。" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝。"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝。</h3><p>承接上一条款，如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么你就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：</p>
<ul>
<li>将被禁止生成的函数声明为 <code>private</code> 并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。 </li>
<li>将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。</li>
</ul>
<p>【<strong>C++11】现在有了更好的做法</strong>: [[1 C++ Primer#【C++11】 &#x3D;delete删除函数]]</p>
<p>**我们可以直接使用 <code>= delete</code> 来删除拷贝构造函数，禁止编译器生成该函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="条款-07：为多态基类声明-virtual-析构函数"><a href="#条款-07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07：为多态基类声明 virtual 析构函数"></a>条款 07：为多态基类声明 virtual 析构函数</h3><blockquote>
<p>[!NOTE] 总结</p>
<ul>
<li>多态 base class 应该声明一个 virtual 析构函数。</li>
<li>如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性, 就不该声明 virtual 析构函数。</li>
</ul>
</blockquote>
<p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个<code>非虚析构函数</code>，其结果是未定义的，可能会无法完全销毁派生类新增的成员，造成内存泄漏。</p>
<p>消除这个问题的方法就是对基类使用 <code>虚析构函数</code>：它会消除整个对象</p>
<ul>
<li>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>需要注意的是，普通的类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价（额外存储的虚表指针会使类的体积变大。）</strong> 例如：考虑一个用来表示 2D 坐标点的 class<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    Point（<span class="type">int</span> x, <span class="type">int</span> y）;</span><br><span class="line">    ~<span class="built_in">Point</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果 int 占用占用 32bit（32 位位计算器中），那么 Point 对象占用 64bit。如果析构函数是 virtual，那么对象必须携带<strong>虚表指针</strong>（vptr，virtual table pointer）指向一个由函数指针构成的数组（即虚表），用来在运行期决定哪一个 virtual 函数应该被调用。<br>如果 Point 类内含有 virtual，其<strong>体积就会增加</strong>，因为额外存储的虚表指针：32位操作系统上，指针通常是4字节（32位）大小。64位操作系统上，指针通常是8字节（64位）大小。C++标准并没有强制规定指针的大小，因此具体的实现可能会有所不同。<br>此外， <strong>C++的 Point 对象也不能直接在 C 函数中使用</strong>，因为 C 没有虚表机制，也因此<strong>不再具有移植性</strong>。</li>
</ul>
<blockquote>
<p>[!NOTE] 虚表指针 vptr 和虚表<br>每一个带有 virtual 函数的 class 都有一个都有一个相应的 vptr。当对象调用某一 virtual 函数函数，实际被调用的函数取决于该对象的 vptr 所指所指的那个虚表——编译器在其中寻找适当的函数指针。</p>
</blockquote>
<ul>
<li>如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为 <code>final</code>（C++ 11）[[1 C++ Primer#【C++11】防止继承 final]]，这样禁止继承可以防止误继承造成上述问题。</li>
<li>编译器自动生成的析构函数是非虚的，所以多态基类必须将析构函数<strong>显式声明</strong>为 <code>virtual</code>。</li>
</ul>
<h3 id="条款-08：别让异常逃离析构函数"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数</h3><blockquote>
<p>[!NOTE] 总结</p>
<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
</blockquote>
<p>C++并不禁止析构函数抛出异常，但为了程序的可靠性，应当极力避免这种行为。<br>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p>
<p>![[01 C++八股#RAII]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        db.<span class="built_in">close</span>();    <span class="comment">// 该函数可能会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p>
<p>第一种：杀死程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 记录运行日志，以便调试</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p>
<p>第三种：重新设计接口，将异常的处理交给客户端完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个新设计的接口中，我们提供了 <code>close</code> 函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用 <code>close</code> 函数。</p>
<hr>
<p><strong>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</strong></p>
<p>析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。  </p>
<p>一个直观的解释：析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明抛出异常后的代码无法再继续执行，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃，这是每一个程序员都不想看到的。  </p>
<p><strong>话说回来，如果某些操作真的很容易抛出异常，如资源的归还等，并且你又不想把异常吞掉，那么就请把这些操作移到析构函数之外，提供一个普通函数做类似的清理工作，在析构函数中只负责记录，我们需要时刻保证析构函数能够执行到底。</strong></p>
<h3 id="条款-09：绝不在构造和析构过程中调用-virtual-函数"><a href="#条款-09：绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款 09：绝不在构造和析构过程中调用 virtual 函数"></a>条款 09：绝不在构造和析构过程中调用 virtual 函数</h3><p>子类对象开始创建时，首先调用的是基类的构造函数，<strong>在基类构造期间，该对象的类型是基类而不是子类</strong>。<br><strong>如果这时基类的构造函数中调用了 virtual 虚函数会被编译器解析至基类的虚函数版本，而不是子类的重写版本。若使用运行期类型信息（dynamic_cast 和 typeid）, 也会把对象视为基类对象。</strong> 面对这种情况，最安全的做法就是视这种情况不存在，等子类对象调用完自身的构造函数再进行其他操作。</p>
<p>而<strong>对于析构函数</strong>，首先析构子类，调用子类的虚函数，然后析构基类，调用的时基类的虚函数，并没有呈现多态。<strong>即析构函数中调用虚函数是没有意义的。</strong></p>
<hr>
<p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LogTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo) &#123;</span><br><span class="line">    <span class="built_in">LogTransaction</span>(logInfo);                           <span class="comment">// 更改为了非虚函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span> : <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(...)</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">CreateLogString</span>(...)) &#123; ... &#125;    <span class="comment">// 将信息传递给基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">CreateLogString</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此处的 <code>CreateLogString</code> 是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p>
<h3 id="条款-10：令-operator-返回一个-reference-to-this"><a href="#条款-10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款 10：令 operator &#x3D; 返回一个 reference to *this"></a>条款 10：令 operator &#x3D; 返回一个 reference to *this</h3><p>简单来说：这样做可以让你的赋值操作符实现连锁赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = z = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) <span class="comment">//返回类型是个 reference，</span></span><br><span class="line">    &#123;                                    <span class="comment">//指向当前对象。</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>；                   <span class="comment">//返回左侧对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个协议不仅适用于以上的标准赋值形式，也适用于所有<strong>赋值</strong>相关运算，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)  <span class="comment">//这个协议适用于</span></span><br><span class="line">    &#123;                                      <span class="comment">//+=、-+、*=等等。</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>；                     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs)             <span class="comment">//／此函数也适用，即使</span></span><br><span class="line">    &#123;                                      <span class="comment">//此一操作符的参数类型</span></span><br><span class="line">        ...                                <span class="comment">//不符协定。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>；                   </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <strong>bool 操作符</strong>重载的<strong>返回值</strong>有所不同，请留心，以免无限调用自身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  <span class="comment">//定义操作符的重载,如果！=，这里做相应修改即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;  <span class="comment">//不能return *this 否则无限调用自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>！=(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ！(*<span class="keyword">this</span> == other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，这只是个协议，并无强制性。如果不遵循它，代码一样可通过编译。然而这份协议被所有内置类型和标准程序库提供的类型如 string,. vector, complex, trl:: shared ptr 或即将提供的类型（见条款 54）共同遵守。因此除非你有一个标新立异的好理由，不然还是随众吧。</p>
<p>在设计接口时一个重要的原则是，<strong>让自己的接口和内置类型相同功能的接口尽可能相似</strong>，所以如果没有特殊情况，就请让你的赋值操作符的返回类型为<code>ObjectClass&amp;</code>类型并在代码中返回<code>*this</code>吧。</p>
<h3 id="条款-11：在-operator-中处理-“自我赋值”"><a href="#条款-11：在-operator-中处理-“自我赋值”" class="headerlink" title="条款 11：在 operator &#x3D; 中处理 “自我赋值”"></a>条款 11：在 operator &#x3D; 中处理 “自我赋值”</h3><p>自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要假借指针来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pa = *pb;              //pa和pb指向同一对象，便是自我赋值。</span><br><span class="line">arr[i] = arr[j];        //i和j相等，便是自我赋值</span><br></pre></td></tr></table></figure>

<p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator+=(const Widget&amp; rhs) &#123;</span><br><span class="line">    delete pRes;                          // 删除当前持有的资源</span><br><span class="line">    pRes = new Resource(*rhs.pRes);       // 复制传入的资源</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但若 <code>rhs</code> 和 <code>*this</code> 指向的是相同的对象，就会导致访问到已删除的数据。</p>
<p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator=(const Widget&amp; rhs) &#123;</span><br><span class="line">    if (this == &amp;rhs) return *this;        // 若是自我赋值，则不做任何事</span><br><span class="line"></span><br><span class="line">    delete pRes;</span><br><span class="line">    pRes = new Resource(*rhs.pRes);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator=(const Widget&amp; rhs) &#123;</span><br><span class="line">    Resource* pOrigin = pRes;             // 先记住原来的pRes指针</span><br><span class="line">    pRes = new Resource(*rhs.pRes);       // 复制传入的资源</span><br><span class="line">    delete pOrigin;                       // 删除原来的资源</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p>
<p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator=(const Widget&amp; rhs) &#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    std::swap(*this, temp);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator=(Widget rhs) &#123;</span><br><span class="line">    std::swap(*this, rhs);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>所谓 “每一个成分”，作者在这里其实想要提醒大家两点：</p>
<ul>
<li>当你给类多加了成员变量时，请不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果你忘记处理，编译器也不会报错。  </li>
<li>如果你的类有继承，那么在你为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是 private 的，所以你无法访问它们，你应该让子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span> : <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),                <span class="comment">// 调用基类的拷贝构造函数</span></span><br><span class="line">      <span class="built_in">priority</span>(rhs.priority) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);       <span class="comment">// 调用基类的拷贝赋值运算符</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，<strong>拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个</strong>，这虽然看上去是一个避免代码重复好方法，但是是荒谬的。其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。不要这么做！</p>
<h1 id="三、资源管理"><a href="#三、资源管理" class="headerlink" title="三、资源管理"></a>三、资源管理</h1><p><strong>所谓资源就是，一旦用了它，将来必须还给系统</strong>。如果不这样，糟糕的事情就会发生。C++程序中最常使用的资源就是动态分配内存（如果你分配内存却从来不曾归还它，会导致内存泄漏)，但内存只是你必须管理的众多资源之一。其他常见的资源还包括文件描述器 (file descriptors)、互斥锁 (mutex locks)、图形界面中的字型和笔刷、数据库连接、以及网络 sockets。 不论哪一种资源，重要的是，当你不再使用它时，必须将它还给系统。</p>
<h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>本条款的核心观点在于：以面向流程的方式管理资源（的获取和释放），总是会在各种意外出现时，丢失对资源的控制权并造成资源泄露。<br><strong>以面向过程的方式管理资源意味着，资源的获取和释放都分别被封装在函数中</strong>。这种管理方式意味着资源的索取者肩负着释放它的责任，但此时我们就要考虑一下以下几个问题：调用者是否总是会记得释放呢？调用者是否有能力保证合理地释放资源呢？不给调用者过多义务的设计才是一个良好的设计。</p>
<p>首先我们看一下哪些问题会让调用者释放资源的计划付诸东流：<br>假如我们将 delete 语句写在一个函数中，通过调用函数释放资源。很有很有可能前面出现一个过早的 <code>return</code> 语句或是之前某个语句抛出了异常。导致该函数无法执行，无法 delete 对象。<br>也许谨慎的编码可能能在这一时刻保证程序不犯错误，但无法保证软件接受维护时，其他人在 delete 语句之前加入的 return 语句或异常。</p>
<p><strong>为了保证资源的获取和释放一定会合理执行，我们把获取资源和释放资源的任务封装在一个对象中</strong>。当我们构造这个对象时资源自动获取，当我们不需要资源时，我们让对象析构。这便是 “RAII” 的想法，因为我们总是在获得一笔资源后于同一语句内初始化某个管理对象。无论控制流如何离开区块，一旦对象被销毁（比如离开对象的作用域）其析构函数会自动被调用。</p>
<hr>
<p>具体实践：智能指针</p>
<p>对于传统的<strong>堆资源管理</strong>，我们需要使用成对的 <code>new</code> 和 <code>delete</code>，这样若忘记 <code>delete</code> 就会造成内存泄露。<strong>因此，我们应尽可能以对象管理资源，并采用 RAII，让析构函数负责资源的释放。</strong></p>
<p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过转移所有权来管理 RAII 对象可以使用 <code>std::unique_ptr</code>，通过引用计数来管理 RAII 对象可以使用 <code>std::shared_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Investment* CreateInvestment();</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pUniqueInv2</span><span class="params">(std::move(pUniqueInv1))</span></span>;    <span class="comment">// 转移资源所有权</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv1</span><span class="params">(CreateInvestment())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv2</span><span class="params">(pSharedInv1)</span></span>;               <span class="comment">// 引用计数+1</span></span><br></pre></td></tr></table></figure>

<p>智能指针默认会自动 delete 所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器 deletor）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void GetRidOfInvestment(Investment*) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(GetRidOfInvestment)</span>*&gt; <span class="title">pUniqueInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pSharedInv</span><span class="params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="条款-14：在资源管理类中小心-copying-行为"><a href="#条款-14：在资源管理类中小心-copying-行为" class="headerlink" title="条款 14：在资源管理类中小心 copying 行为"></a>条款 14：在资源管理类中小心 copying 行为</h3><p>有些资源不是堆资源，不能用智能指针来管理。这时候需要建立自己的资源管理类。同样要遵循 RAII 原则</p>
<p>我们应该永远保持这样的思考：当一个 RAII 对象被复制，会发生什么事？</p>
<p><strong>选择一：禁止复制</strong></p>
<p>许多时候允许 RAII 对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p>
<p><strong>选择二：对底层资源祭出 “引用计数法”</strong></p>
<p>正如 <code>std::shared_ptr</code> 所做的那样，每一次复制对象就使引用计数 + 1，每一个对象离开定义域就调用析构函数使引用计数 - 1，直到引用计数为 0 就彻底销毁资源。</p>
<p><strong>选择三：复制底层资源</strong></p>
<p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p>
<p><strong>选择四：转移底层资源的所有权</strong></p>
<p>和 <code>std::unique_ptr</code> 的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p>
<h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问（转换为裸指针）和显式访问（解引用）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Investment* pRaw = pSharedInv.get();    // 显式访问原始资源</span><br><span class="line">Investment raw = *pSharedInv;           // 隐式访问原始资源</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Font &#123;</span><br><span class="line">public:</span><br><span class="line">    FontHandle Get() const &#123; return handle; &#125;       // 显式转换函数</span><br><span class="line">    operator FontHandle() const &#123; return handle; &#125;  // 隐式转换函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    FontHandle handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li><strong>APIs 往往要求访问原始资源（raw resources），所以每一个 RAII class 应该提供一个取得其所管理资源的方法。</strong></li>
<li><strong>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</strong></li>
</ol>
<h3 id="条款-16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采取相同形式"></a>条款 16：成对使用 new 和 delete 时要采取相同形式</h3><ul>
<li><p>当你使用 new（也就是通过 new 动态生成一个对象），有两件事发生。</p>
<ol>
<li>内存被分配出来（通过名为 operator new 的函数，见条款 49 和条款 51）</li>
<li>针对此内存会有一个（或更多）构造函数被调用。</li>
</ol>
</li>
<li><p>当你使用 delete，也有两件事发生：</p>
<ol>
<li>针对此内存会有一个（或更多）析构函数被调用，</li>
<li>然后内存才被释放（通过名为 operator delete 的函数，见条款 51）。<br>delete 的最大问题在于：即将被删除的内存之内究竟存有多少对象？这个问题的答案决定了有多少个析构函数必须被调用起来。<br>实际上这个问题可以更简单些：即将被删除的那个指针，所指的是单一对象或对象数组？这是个必不可缺的问题，因为单一对象的内存布局一般而言不同于数组的内存布局。<strong>更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便delete 知道需要调用多少次析构函数。单一对象的内存则没有这笔记录。：</strong><br><strong>当你对着一个指针使用 delete, 唯一能够让 delete 知道内存中是否存在一个“数组大小记录”的办法就是：由你来告诉它。</strong> 如果你使用 delete 时加上中括号(<code>[]</code> 方括号)，delete 便认定指针指向一个数组，否则它便认定指针指向单一对象。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std:string* stringPtr1 <span class="keyword">new</span> std::string;</span><br><span class="line">std:string* stringPtr2 <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;<span class="comment">//删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;<span class="comment">//删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure>

<p>遵守以下规则：</p>
<ul>
<li>如果你调用 new 时使用<code>[]</code>，你必须在对应调用 delete 时也使用 <code>[]</code>。如果你调用 new 时没有使用 <code>[]</code>，那么也不该在对应调用 delete 时使用 <code>[]</code>。</li>
<li>对于数组，不建议使用 typedef 行为，这会让使用者不记得去 <code>delete []</code>。对于这种情况，建议使用 <code>vector&lt;string&gt;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;    <span class="comment">// pal 是一个对象数组，而非单一对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;                             <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;                           <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="条款-17：以独立语句将-newed-对象放入智能指针"><a href="#条款-17：以独立语句将-newed-对象放入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象放入智能指针"></a>条款 17：以独立语句将 newed 对象放入智能指针</h3><p>假设有两个函数<code>priority</code>和<code>processWight</code>，其中<code>priority</code>函数返回处理程序的优先级，<code>processWidget</code>函数按照<code>priority</code>返回的优先级处理动态分配的<code>Widget</code>对象，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果按照如下方法调用<code>processWidget</code>函数，则有可能造成资源泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> <span class="built_in">Widget</span>()), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>这是因为编译器在生成<code>processWidget</code>函数调用码之前会核算即将被传递的各个实参，第二个实参是对<code>priority</code>函数的简单调用，而第一个实参包含两个部分：</p>
<ol>
<li>执行<code>new Widget()</code>表达式动态创建<code>Widget</code>对象。</li>
<li>调用<code>shared_ptr</code>类的构造函数并使用<code>Widget</code>对象的指针作为构造参数。</li>
</ol>
<p>所以，在调用<code>processWidget</code>函数之前编译器会做以下三件事情：</p>
<ol>
<li>执行<code>new Widget()</code>表达式动态创建<code>Widget</code>对象。</li>
<li>调用<code>shared_ptr</code>类的构造函数并使用<code>Widget</code>对象的指针作为构造参数。</li>
<li>调用<code>priority</code>函数生成优先级。</li>
</ol>
<p>以何种顺序执行以上三个步骤，C++ 语句并没有给出严格规定（Java 和 C# 中必须按规定的顺序完成参数的核算），具体由编译器来决定。</p>
<p>能够明确知道的是执行<code>new Widget</code>表达式肯定是在调用<code>shared_ptr</code>构造函数之前，但调用<code>priority</code>函数则有可能是在第 1、2、3 中任意一步执行。假设调用<code>priority</code>函数在第 2 步执行，将获得如下执行顺序：</p>
<ol>
<li>执行<code>new Widget()</code>表达式动态创建<code>Widget</code>对象。</li>
<li>调用<code>priority</code>函数生成优先级。</li>
<li>调用<code>shared_ptr</code>类的构造函数并使用<code>Widget</code>对象的指针作为构造参数。</li>
</ol>
<p>如果在调用<code>priority</code>函数的过程中发生了异常，那么<code>new Widget()</code>表达式返回的指针会被遗失，就有可能造成资源泄漏。原因是在【资源被创建】和【资源被管理对象接管】之间造成了异常干扰。</p>
<p><strong>解决办法：</strong> 使用分离语句，分别写出 (1)创建 Widget, (2)将它置入一个智能指针内，然后再把那个智能指针传给 processWidget:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget())</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>编译器对于<strong>跨越语句的各项操作</strong>没有重新排列的自由，只有在语句内才拥有某种自由度。</p>
<p>因此在上述代码中【（1）执行<code>new Widget()</code>表达式和（2）调用<code>shared_ptr</code>类的构造函数】与【对<code>priority</code>函数的调用】是在不同的语句中，被分隔开来了，所以编译器不得在它们之间任意选择执行次序。</p>
<p><strong>结论</strong></p>
<ol>
<li>以独立语句将 newed 对象存储于智能指针中，这样能够保证动态获取的资源一定能被资源管理对象接管，不会造成内存泄漏。</li>
<li>如果不这样做，一旦在【资源申请成功】和【资源管理对象接管资源】之间抛出了异常，就有可能产生难以察觉的资源泄漏。因为异常本身就在意料之外的错误，不容易复现，从而导致资源泄漏无法轻易定位。</li>
</ol>
<h1 id="四、设计与声明"><a href="#四、设计与声明" class="headerlink" title="四、设计与声明"></a>四、设计与声明</h1><h3 id="条款-18：让接口容易被正确使用，不易误使用"><a href="#条款-18：让接口容易被正确使用，不易误使用" class="headerlink" title="条款 18：让接口容易被正确使用，不易误使用"></a>条款 18：让接口容易被正确使用，不易误使用</h3><p>本条款告教你如何<strong>帮助你的客户在使用你的接口时避免他们犯错误</strong>。<br>在设计接口时，我们常常会错误地假设，接口的调用者<strong>拥有某些必要的知识来规避一些常识性的错误</strong>。但事实上，接口的调用者并不总是像正在设计接口的我们一样 “聪明” 或者知道接口实现的”内幕信息“，结果就是，我们错误的假设使接口表现得不稳定。这些不稳定因素可能是由于调用者缺乏某些先验知识，也有可能仅仅是代码上的粗心错误。<br>所以一个合理的接口，应该尽可能的从<strong>语法层面</strong>并在<strong>编译之时运行之前</strong>，帮助接口的调用者规避可能的风险。</p>
<p>如下， 设计一个日期类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考原文：https://blog.csdn.net/hualicuan/article/details/27526033</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> <span class="type">int</span> month, <span class="type">const</span> <span class="type">int</span> day, <span class="type">int</span> <span class="type">const</span> year) </span><br><span class="line">        : <span class="built_in">m_month</span>(month)</span><br><span class="line">        , <span class="built_in">m_day</span>(day)</span><br><span class="line">        , <span class="built_in">m_year</span>(year)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_day;</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">    <span class="type">int</span> m_year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>错误调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">29</span>, <span class="number">5</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">//调用顺序错乱，应该是 5, 29, 2014</span></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">//传入参数有误，2月没有30号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>外覆类型（wrapper）</strong> 提醒调用者传参错误检查，将参数的附加条件限制在<strong>类型本身</strong></li>
</ul>
<p>当调用者试图传入数字 “13” 来表达一个 “月份” 的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁——调用者只有在尝试过后才发现自己手残把 “12” 写成了 “13”。如果在设计参数类型时就把“月份” 这一类型抽象出来，比如使用 enum class（强枚举类型），就能帮助客户在编译时期就发现问题，把参数的附加条件限制在类型本身，可以让接口更易用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">const</span> <span class="type">int</span> day)</span> : m_day(day) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">const</span> <span class="type">int</span> month)</span> : m_month(month) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">const</span> <span class="type">int</span> year)</span> : m_year(year) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month &amp;month, <span class="type">const</span> Day &amp;day,  <span class="type">const</span> Year &amp;year) </span><br><span class="line">        : <span class="built_in">m_month</span>(month)</span><br><span class="line">        , <span class="built_in">m_day</span>(day)</span><br><span class="line">        , <span class="built_in">m_year</span>(year)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Day m_day;</span><br><span class="line">    Month m_month;</span><br><span class="line">    Year m_year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型错误得到预防，但值还是没有得到保障</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">//error,类型错误</span></span><br><span class="line"><span class="function">Date <span class="title">d3</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">2</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">//error,类型错误</span></span><br><span class="line"><span class="function">Date <span class="title">d4</span><span class="params">(Month(<span class="number">2</span>), Day(<span class="number">30</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<p>可通过设计对应的类型的值限制来达到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E_MON</span>&#123;JAN = <span class="number">1</span>, FEC, MAR, APR, MAY, JUN, JUL, AGU, SEP, OCT, NOV, DEC&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">const</span> E_MON month)</span> : m_month(month) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d4</span><span class="params">(Month(Month::E_MON::DEC), Day(<span class="number">30</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从<strong>语法层面</strong>限制调用者<strong>不能做的事</strong></li>
</ul>
<p>接口的调用者往往无意甚至没有意识到自己犯了个错误，所以接口的设计者必须在语法层面做出限制。一个比较常见的限制是加上<code>const</code>，比如在<code>operate*</code>的返回类型上加上<code>const</code>修饰，可以防止无意错误的赋值<code>if (a * b = c)</code>。</p>
<ul>
<li>接口应表现出与内置类型的一致性</li>
</ul>
<p>让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和 STL 应具备一致性，可以有效防止调用者犯错误。或者你有两个对象相乘的需求，那么你最好重载<code>operator*</code>而并非设计名为”multiply” 的成员函数。</p>
<ul>
<li>从语法层面限制调用者<strong>必须做的事</strong></li>
</ul>
<p><strong>别让接口的调用者总是记得做某些事情</strong>，接口的设计者应在假定他们<strong>总是忘记</strong>这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成纯虚函数并要求调用者继承该抽象类，强制他们去实现。在核心方法前后对设置和恢复环境的调用，则应由接口设计者操心。</p>
<p>当方法的调用者（我们的客户）责任越少，他们可能犯的错误也就越少。</p>
<p>请记住：<br>①好的接口易于正确使用，而难以错误使用。你应该在你的所有接口中为这个特性努力。<br>②使易于正确使用的方法包括在接口和行为兼容性上与内建类型保持一致。<br>③预防错误的方法包括创建新的类型，限定类型的操作，约束对象的值，以及消除客户的资源管理职责。<br>④尽量使用智能指针，避免跨 DLL 的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</p>
<h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>C++就像在其他 OOP (面向对象编程)语言一样，当你定义一个新 class, 也就定义了一个新 type。</p>
<p>几乎在设计每一个 class 时，都要面对如下问题：</p>
<p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p>
<p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p>
<p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p>
<p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p>
<p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为 <code>final</code>）。</p>
<p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p>
<p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为 <code>= delete</code>。</p>
<p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p>
<p><strong>什么是新 type 的 “未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p>
<p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p>
<p><strong>你真的需要一个新 Type 吗</strong>？如果只是定义新的 derived class 以便为既有的 class 添加机能，那么说不定单纯定义一或多个 non-member 函数或 templates, 更能够达到目标。</p>
<h3 id="条款-20：以-const-引用传参，而不应该是按值传参"><a href="#条款-20：以-const-引用传参，而不应该是按值传参" class="headerlink" title="条款 20：以  const 引用传参，而不应该是按值传参"></a>条款 20：以  const 引用传参，而不应该是按值传参</h3><blockquote>
<p>[!NOTE]</p>
<ul>
<li><strong>尽量以  const 引用传参，而不应该是按值传参。</strong><ul>
<li>前者通常比较高效，没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。</li>
<li>可避免对象切割（slicing）问题</li>
</ul>
</li>
<li>以上规则<strong>并不适用于内置类型，以及 STL 的选代器和函数对象</strong>。对它们而言，按值传递往往比较适当。</li>
</ul>
</blockquote>
<p>函数接口应该以<code>const</code>引用的形式传参，而不应该是按值传参，否则可能会有以下问题：</p>
<ul>
<li>按值传参涉及大量参数的复制，大量构造函数和析构函数的调用，比较昂贵。</li>
<li>如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。</li>
<li>按引用传递可以避免<strong>对象切割</strong>。<ul>
<li>比如一个函数的参数为父类（按值传递），调用时传入子类，那么子类对象会被视为一个父类对象，父类的拷贝构造函数调用。子类的特性全部被切割，只剩下一个父类对象。</li>
<li>如果按引用传递，则可以在函数内 cast 为为子类对象！通常将函数参数设计为父类指针，调用时可以传入子类指针。</li>
</ul>
</li>
<li>小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。</li>
</ul>
<h3 id="条款-21：必须返回对象时，别妄想返回其-reference"><a href="#条款-21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其 reference"></a>条款 21：必须返回对象时，别妄想返回其 reference</h3><p>这个条款的核心观点在于，不要把总返回值写成引用类型，作者在条款内部详细分析了各种可能发生的错误，无论是返回一个 stack 对象还是 heap 对象，在这里不再赘述。作者最后的结论是，如果必须按值返回，那就让他去吧，多一次拷贝也是没办法的事，最多就是指望着编译器来优化。</p>
<p>但是对于 C++11 以上的编译器，我们可以采用给类型编写 “转移构造函数” 以及使用<code>std::move()</code>函数更加优雅地<strong>消除由于拷贝造成的时间和空间的浪费。</strong></p>
<p><strong>请记住</strong></p>
<ul>
<li>函数的返回值如果是引用或指针类型，不能指向函数内的局部对象，局部对象被销毁后就变成了无定义行为。</li>
</ul>
<ul>
<li>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。条款 4 已经为 “在单线程环境中合理返回 reference 指向一个 local static 对象” 提供了一份设计实例。</li>
</ul>
<h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>先说结论——<strong>请对 class 内所有成员变量声明为 <code>private</code>，<code>private</code> 意味着对变量的封装。</strong> 但本条款提供的更有价值的信息在于不同的属性控制—— <code>public</code>, <code>private</code> 和 <code>protected</code> ——<strong>代表的设计思想</strong>。</p>
<p>简单的来说，把所有成员变量声明为 private 的好处有两点。</p>
<ul>
<li>首先，所有的变量都是 private 了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是语法一致性；</li>
<li>其次，对变量的封装（也就是对客户隐藏成员变量）意味着，<strong>可以尽量减小因类型内部改变造成的类外外代码的必要改动。</strong></li>
</ul>
<p>一旦所有变量都被封装了起来，外部无法直接获取，那么所有类的使用者（我们称为客户，客户也可能是未来的自己，也可能是别人）想利用私有变量实现自己的业务功能时，就<strong>必须通过我们留出的接口</strong>，这样的接口便充当了一层缓冲，将类型内部的升级和改动尽可能的对客户不可见——<strong>不可见就是不会产生影响</strong>，不会产生影响就不会要求客户更改类外的代码。因此，一个设计良好的类在内部产生改动后，对整个项目的影响只应是<strong>需要重新编辑而无需改动类外部的代码</strong>。</p>
<p>请记住：</p>
<ul>
<li><strong>将所有成员变量声明为 private，使用 getter setter 访问它</strong>。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性。</li>
<li><strong>protected 并不比 public 更具封装性</strong>。假设我们有一个 public 成员变量，最终改变了它，那么所有直接调用它的客户代码都将被破坏；假设我们有一个 protected 成员变量，最终改变了它，那么所有调用它的派生类都将被破坏。</li>
<li>从封装的角度看：只有两种访问权限：private（提供封装，也就是对客户隐藏成员变量）和其他（不提供封装）</li>
</ul>
<blockquote>
<p>[!NOTE] 封装<br>指的是将数据（通常是类的成员变量）和操作数据的函数（通常是类的成员函数）组合到一个单元中，并对外部隐藏数据的具体实现细节，只暴露必要的接口给外部代码。<br>通常将成员变量声明为 private，通过 public 成员函数提供对外的接口。</p>
</blockquote>
<h3 id="条款-23：宁以非成员、非友元函数替换成员函数"><a href="#条款-23：宁以非成员、非友元函数替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元函数替换成员函数"></a>条款 23：宁以非成员、非友元函数替换成员函数</h3><p>我宁愿多花一些口舌在这个条款上，一方面因为它真的很重要，另一方面是因为作者并没有把这个条款说的很清楚。</p>
<p>在一个类里，我愿把<strong>需要直接访问 private 成员的 public 和 protected 成员函数</strong>称为<strong>功能颗粒度较低的函数</strong>，原因很简单，他们涉及到对 private 成员的直接访问，说明他们处于封装表面的第一道防线。<br>由若干其他 public（或 protected）函数集成而来的 public 成员函数，我愿称之为<strong>颗粒度高的函数</strong>，因为他们集成了若干颗粒度较低的任务，这就是本条款所针对的对象——那些<strong>无需直接访问 private 成员</strong>，而只是<strong>若干 public 函数集成而来的 member 函数</strong>。<br>本条款告诉我们：这些函数应该尽可能放到类外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class WebBrowser &#123;          //  一个浏览器类</span><br><span class="line">public:</span><br><span class="line">    void clearCache();      // 清理缓存，直接接触私有成员</span><br><span class="line">    void clearHistory();    // 清理历史记录，直接接触私有成员</span><br><span class="line">    void clearCookies();    // 清理cookies，直接接触私有成员</span><br><span class="line"></span><br><span class="line">    void clearAll();           // 颗粒度较高的函数，在内部调用上边三个函数，不直接接触私有成员，本条款告诉我们这样的函数应该移至类外</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果高颗粒度函数设置为类内的成员函数，那么一方面他会破坏类的封装性，另一方面降低了函数的包裹弹性。</p>
<ol>
<li>类的封装性</li>
</ol>
<p>封装的作用是尽可能减小被封装成员的改变对类外代码的影响——我们希望类内的改变只影响有限的客户。一个量化某成员封装性好坏的简单方法是：看类内有多少（public 或 protected）函数直接访问到了这个成员，<strong>这样的函数越多，该成员的封装性就越差——该成员的改动对类外代码的影响就可能越大</strong>。<br>回到我们的问题，高颗粒度函数在设计之时，设计者的本意就是<strong>它不应直接访问任何私有成员</strong>，而只是公有成员的简单集成，这样会最大程度维护封装性，但很可惜，<strong>这样的愿望并没有在代码层面体现出来</strong>。这个类未来的维护者很可能忘记了这样的原始设定，而在此本应成为 “高颗粒度” 函数上大肆添加对私有成员的直接访问，这也就是为什么封装性可能会被间接损坏了。但设计为非成员函数就从语法上避免了这种可能性。</p>
<ol>
<li>函数的包裹弹性与设计方法</li>
</ol>
<p>将高颗粒度函数提取至类外部可以允许我们从<strong>更多维度组织代码结构</strong>，并<strong>优化编译依赖关系</strong>。我们用上边的例子说明什么是 “更多维度”。<code>clearAll（）</code> 函数是代码的设计者最初从浏览器的角度对低颗粒度函数做出的集成，但是如果从 “cache”、“history”、和“cookies” 的角度，我们又能够做出其他的集成。比如将 “搜索历史记录” 和“清理历史记录”集成为 “定向清理历史记录” 函数，将 “导出缓存” 和“清理缓存”集成为 “导出并清理缓存” 函数，这时，我们在浏览器类外做这样的集成会有更大的自由度。<br>通常利用一些工具类如<code>class CacheUtils</code>、<code>class HistoryUtils</code>中的 static 函数来实现；又或者采用不同 namespace 来明确责任，将不同的高颗粒度函数和浏览器类纳入不同 namespace 和头文件，当我们使用不同功能时就可以 include 不同的头文件，而不用在面对 cache 的需求时不可避免的将 cookies 的工具函数包含进来，降低编译依存性。这也是<code>namespace</code>可以跨文件带来的好处。</p>
<ul>
<li><strong>命名空间可以跨越多个源码文件而类则不可以。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在C++中，比较自然的做法是让ClearAll()函数成为一个non-member函数并且位于WebBrowser类所在的同一个命名空间(namespace)中。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;	</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;   <span class="comment">//核心机能</span></span><br><span class="line">       <span class="keyword">public</span> :</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">clearCookies</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// non-member函数，提供几乎所有客户都需要的核心机能</span></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">ClearAll</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">           wb.<span class="built_in">clearCache</span>();</span><br><span class="line">           wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">           wb.<span class="built_in">clearCookies</span>();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个像 WebBrowser 这样的类中可能有大量的便利函数，如书签便利函数、打印便利函数、cookies 管理有关的便利函数。通常，大多数客户只对其中某些感兴趣。为了防止多个便利函数之间发生编译相互依赖性，分离它们的最直接方法是将书签便利函数声明在一个头文件中，将 cookies 管理有关的便利函数声明在另一个头文件中，再将打印便利函数声明于第三个头文件中。如下所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件webbrowser.h，这个头文件针对WebBrowser类</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// ...   non-member函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头文件webbrowserbookmarks.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">// ...   与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头文件webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">// ...   与cookies管理相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要说的是，本条款讨论的是那些<strong>不直接接触私有成员的函数</strong>，<strong>如果你的 public(或 protected) 函数必须直接访问私有成员，那请忘掉这个条款</strong>，因为把那个函数移到类外所需做的工作就比上述情况远大得多了。</p>
<h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><blockquote>
<p>[!NOTE]<br>如果你需要为某个函数的<strong>所有</strong>参数（包括被 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个 非成员函数。</p>
</blockquote>
<p>这个条款告诉了我们<strong>操作符重载被重载为成员函数和非成员函数的区别</strong>。作者想给我们提个醒，如果我们在使用操作符时<strong>希望操作符的任意操作数都可能发生隐式类型转换</strong>，<strong>那么应该把该操作符重载成非成员函数。</strong></p>
<p>现在我们手头上拥有一个 <code>Rational</code> 类，并且它可以和 <code>int</code> 隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，我们需要重载乘法运算符来实现 <code>Rational</code> 对象之间的乘法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将运算符重载放在类中是行得通的，至少对于 <code>Rational</code> 对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf / oneEight;</span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>;    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>在调用 <code>operator*</code> 时，<code>int</code> 类型的变量会隐式转换为 <code>Rational</code> 对象，因此用 <code>Rational</code> 对象乘以 <code>int</code> 对象是合法的，但反过来则不是如此。</p>
<p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>希望这一条款能解释清楚操作符在作为成员函数与非成员函数时的区别。此条款并没有明确说明该法则只适用于操作符，但是除了操作符外，我实在想不到更合理的用途了。</p>
<p>题外话：如果你想禁止隐式类型转换的发生，请把你每一个单参数构造函数后加上关键字<code>explicit</code>。</p>
<h3 id="条款-25-考虑写出—个不抛异常的-swap-函数"><a href="#条款-25-考虑写出—个不抛异常的-swap-函数" class="headerlink" title="条款 25: 考虑写出—个不抛异常的 swap 函数"></a>条款 25: 考虑写出—个不抛异常的 swap 函数</h3><p>由于 <code>std::swap</code> 函数在 C++11 后改为了用 <code>std::move</code> 实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p>
<p>如果想为自定义类型实现自己的 swap 方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，由于外部函数并不能直接访问 <code>Widget</code> 的 private 成员变量，因此我们先是在类中定义了一个 public 成员函数，再由 <code>std::swap</code> 去调用这个成员函数。</p>
<p>然而若 <code>Widget</code> 和 <code>WidgetImpl</code> 是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的 swap 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="number">3</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望在对自定义对象进行操作时找到正确的 swap 函数重载版本，这时候如果再写成 <code>std::swap</code>，就会强制使用 STL 中的 swap 函数，无法满足我们的需求，因此需要改写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(obj1, obj2);</span><br></pre></td></tr></table></figure>

<p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的 swap 函数而非 STL 中的 swap 函数。</p>
<blockquote>
<p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。<br>函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p>
</blockquote>
<h1 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h1><p>大多数情况下，适当提出你的 classes (和 class templates)定义以及 functions(和 function templates)声明，是花费最多心力的两件事。一旦正确完成它们，相应的实现大多直截了当。尽管如此，还是有些东西需要小心。</p>
<ul>
<li>太快定义变量可能造成效率上的拖延；</li>
<li>过度使用转型 (cast)可能导致代码变慢又难维护，又招来微妙难解的错误；</li>
<li>返回对象“内部数据之号码牌 (handles)”可能会破坏封装并留给客户虚吊号码牌 (dangling handles); </li>
<li>未考虑异常带来的冲击则可能导致资源泄漏和数据败坏；</li>
<li>过度热心地 inlining 可能引起代码膨胀；</li>
<li>过度耦合 (coupling)则可能导致让人不满意的冗长构建时间 (build times)。</li>
</ul>
<p>所有这些问题都可避免，本章逐一解释各种做法。</p>
<h3 id="条款-26：尽可能延后变量定义式出现的时间"><a href="#条款-26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款 26：尽可能延后变量定义式出现的时间"></a>条款 26：尽可能延后变量定义式出现的时间</h3><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，<strong>避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</strong></p>
<p>延后变量定义式还有一个意义，在 [[#条款 04：确定对象使用前已先被初始化]]提到过，<strong>通过 “默认构造函数构造出一个对象然后对它赋值” 比 “直接在构造时指定初始值” 效率差。</strong><br>这让我们联想起本条款所谓“尽可能延后”的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 效率低</span><br><span class="line">std::string encrypted;</span><br><span class="line">encrypted = password;</span><br><span class="line"></span><br><span class="line">// 效率高，跳过无意义的默认构造过程</span><br><span class="line">std::string encrypted(password);</span><br></pre></td></tr></table></figure>

<p><strong>对于循环中变量的定义，我们一般有两种做法：</strong></p>
<ul>
<li>定义于循环外，在循环中赋值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于 i 的某个值;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p>
<ul>
<li>定义于循环内：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    Widget w(取决于 i 的某个值);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p>
<p>由于做法 A 会将变量的作用域扩大，对程序的可理解性和易维护性造成冲突。因此除非知道该变量的赋值成本比 “构造 + 析构” 成本低，或者对这段程序的效率要求非常高，否则<strong>建议使用做法 B。</strong></p>
<h3 id="条款-27-尽量少做转型动作"><a href="#条款-27-尽量少做转型动作" class="headerlink" title="条款 27: 尽量少做转型动作"></a>条款 27: 尽量少做转型动作</h3><ol>
<li>避免对 <code>*this</code> 进行转型</li>
</ol>
<p>有些场景下，需要在派生类的 virtual 函数中调用基类的版本的次函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码试图通过转型 <code>*this</code> 来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的 <code>Window</code> 副本并在该副本上调用函数，而非在原本的对象上调用函数。</p>
<p>上述代码的正确写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::<span class="built_in">OnResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>何时需要 dynamic_cast，以及避免 dynamic_cast 的方法</li>
</ol>
<p>(1) 何时需要 dynamic_cast?</p>
<p>通常当你想在一个你认定为 derived class 对象上执行 derived class 操作函数时，但是你的手上只有一个指向 base 的指针或引用时，你会想到使用 dynamic_cast 进行转型</p>
<p>(2) 如何不做转型，实现上述需求？</p>
<p>通常有两种做法可以解决上述问题：</p>
<ul>
<li>方法一：使用容器，并在其中存储直接指向 derived class 对象的指针 (通常是智能指针)，这样就避免了上述需求。  </li>
<li>方法二：在 base class 内提供 virtual 函数做你想对各个派生类想做的事情。这样可以使得你通过 base class 接口处理 “所有可能之各种派生类”。</li>
</ul>
<ol start="6">
<li><strong>绝对避免一连串的 dynamic_cast</strong></li>
</ol>
<p>一连串 dynamic_cast 的代码又大又慢，而且基础不稳，因为每次继承体系一有改变，所有这种代码必须再次进行检查看看是否需要修改。例如假如新的派生类，就要加新的分支。这样的代码应该使用 “基于 virtual 函数调用” 的东西取而代之。</p>
<p><strong>总结：</strong></p>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li>
<li>宁可使用 C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>
<h3 id="条款-28：避免返回-handles-指向对象内部成分"><a href="#条款-28：避免返回-handles-指向对象内部成分" class="headerlink" title="条款 28：避免返回 handles 指向对象内部成分"></a>条款 28：避免返回 handles 指向对象内部成分</h3><p>reference、指针、迭代器系统都是所谓的 handles(句柄，用来获得某个对象)。函数返回一个 handle，随之而来的便是 “减低对象封装性” 的风险。它也可能导致：虽调用 const 成员函数却造成对象状态被更改的风险。</p>
<ul>
<li><strong>绝对不该令成员函数返回一个指针指向 “访问级别较低”的成员函数</strong>。如果那么做，后者的访问级别就会提高到和前者相同。通过 public 函数函数访问 private 指针，那么这个指针也就与 public 指针访问级别无异了。</li>
<li>如果返回的是 const 指针呢，这样就可以避免成员变量被外部修改。但如果指向的目标被析构，指针就会变成一个空指针（空悬<br>虚吊（dangling）问题）</li>
<li>如果一定要返回一个成员变量，直接返回即可，不要使用指针或者引用。</li>
</ul>
<p>总结：</p>
<ul>
<li>避免返回 handles（包括 references、指针、选代器）指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const，并将发生 “虚吊句柄”（dangling handles）的可能性降至最低。</li>
</ul>
<h3 id="条款-29-为-“异常安全”-而努力是值得的"><a href="#条款-29-为-“异常安全”-而努力是值得的" class="headerlink" title="条款 29: 为 “异常安全” 而努力是值得的"></a>条款 29: 为 “异常安全” 而努力是值得的</h3><ol>
<li>异常安全的两个条件：当异常抛出时，①不泄漏任何资源；②不允许数据败坏；</li>
<li>解决资源泄漏：使用 “资源管理类”；</li>
<li>异常安全函数提供以下三个保证之一：①基本承诺：保证对象和数据结构，不保证程序状态；②强烈保证：程序状态不改变；③不抛掷承诺：总能完成功能（作用于内置类型上的所有操作都可做到）；</li>
<li>为做到强烈保证：①见第 2 条；②重新排列对象内语句次序的策略：不要为了表示某件事情发生而改变对象状态，除非那件事情真的发生了；</li>
<li>copy and swap 策略往往可以实现强烈保证：在对象的副本上完成修改后，再与原对象在一个不抛出异常的操作中置换（pimpl idiom 通过指针实现此策略）；</li>
<li>“强烈保证” 并非对所有函数都可实现或具备现实意义；</li>
<li>异常安全保证具有木桶效应；</li>
</ol>
<p>总结</p>
<ol>
<li>资源管理类不仅防止了资源泄漏，同时缩短原函数的语句，减少了数据败坏的复杂度；</li>
<li>尽量实现更高的异常安全保证等级。</li>
</ol>
<h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><ol>
<li>inlining 函数可以免除函数调用成本的开销，且编译器可对其执行语境相关的最优化，但要注意代码膨胀造成程序体积太大占用大量内存。即使拥有虚内存，inline 造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的击中率 (instruction cache hit rate), 以及伴随这些而来的效率损失。）</li>
<li>inline 的隐喻方式：将函数定义于 class 定义式内；明确声明方式：在其定义式前加上关键字 inline；</li>
<li>inline 函数通常一定被置于头文件内，因为 inlining 大部分情况下都是编译期行为；template 通常也被置于头文件内，因为大部分构建环境都是在编译期完成 动作；</li>
<li>如果一个 template 具现出来的函数都应该 inlined，则将此 template 声明为 inline，否则应避免此声明；</li>
<li>inline <strong>只是对编译器</strong>的一个<strong>申请</strong>，不是强制命令。大多数编译器如无法将要求的函数 inline 化，会给出一个警告信息；</li>
<li>慎重决定 inlining 施行范围：将大多数 inlining 限制在小型、被频繁调用的函数身上，以便于日后的调试和二进制升级。</li>
</ol>
<p>inline 函数有时候会被编译器拒绝 inline，导致 inline 失败：</p>
<ul>
<li>编译器通常不对 “通过函数指针而进行的调用” 实施 inlining，且需考虑后续代码维护用到函数指针的可能；</li>
<li><strong>构造函数和析构函数并不适合用于 inlining，往往会引起代码的膨胀</strong>（所不要随便地将构造函数和析构函数的定义体放在类声明中）；</li>
<li>inline 函数代码如发生改变，所有用到该 inline 函数的程序都必须重新编译；</li>
<li>大部分调试器都不能对 inline 函数进行调试；</li>
</ul>
<p>总结：</p>
<ol>
<li>如果 inline 函数不能增强性能，就避免使用它；</li>
<li>inline 修饰符用于解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题；</li>
<li>inline 函数本身不能是直接递归函数；</li>
<li>将成员函数的定义体放在类声明之中（隐喻方式）虽然能带来书写上的方便，但不是一种良好的编程风格；</li>
<li>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用，即 inline 是一种 “用于实现的关键字”；声明前可以加 inline 关键字，但不符合高质量 C++&#x2F;C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</li>
</ol>
<p>在 C++17 中，引入了一个新的 <code>inline</code> 用法，使静态成员变量可以在类中直接定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    static inline int theAge = 0;  // since C++17</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>include 头文件会在定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入该头文件的文件就得重新编译，任何使用该头文件的文件也必须重新编译。这样的连串编译依存关系 会对许多项目造成难以形容的灾难。</p>
<p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把 “将接口从实现中分离” 这件事做得很好。</p>
<p><strong>用 “声明的依存性” 替换“定义的依存性”：</strong></p>
<p>我们可以玩一个 “将对象实现细目隐藏于一个指针背后” 的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，<strong>一个只提供接口，另一个负责实现该接口</strong>，称作<strong>句柄类（handle class）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.hpp 负责声明类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.cpp 负责实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>() &#123;</span><br><span class="line">    pImpl = std::<span class="built_in">make_shared</span>&lt;PersonImpl&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pImpl-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，假如我们要修改 <code>Person</code> 的 private 成员，就只需要修改 <code>PersonImpl</code> 中的内容，而 <code>PersonImpl</code> 的具体实现是被隐藏起来的，对它的任何修改都不会使得 <code>Person</code> 客户端重新编译，真正实现了 “类的接口和实现分离”。</p>
<ul>
<li><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></li>
</ul>
<p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p>
<ul>
<li><strong>如果能够，尽量以类声明式替换类定义式：</strong></li>
</ul>
<p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                     <span class="comment">// 类的声明式</span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Data d)</span></span>; <span class="comment">// 此处并不需要得知类的定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为声明式和定义式提供不同的头文件：</strong></li>
</ul>
<p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span>            <span class="comment">// 这个头文件内声明 class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(Data d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此处的头文件命名方式 <code>&quot;datefwd.h&quot;</code> 取自标准库中的 <code>&lt;iosfwd&gt;</code>。</p>
<p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了将 <code>Person</code> 对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数 <code>Create</code> 用于创建对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但此时 <code>Create</code> 函数还无法使用，需要在派生类中给出 <code>Person</code> 类中的函数的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(...) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成 <code>Create</code> 函数的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;RealPerson&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p>
<p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p>
<h1 id="六、继承与面向对象设计"><a href="#六、继承与面向对象设计" class="headerlink" title="六、继承与面向对象设计"></a>六、继承与面向对象设计</h1><h3 id="条款-32：确定你的-public-继承保证了-is-a-关系"><a href="#条款-32：确定你的-public-继承保证了-is-a-关系" class="headerlink" title="条款 32：确定你的 public 继承保证了 is-a 关系"></a>条款 32：确定你的 public 继承保证了 is-a 关系</h3><p>is-a 意思是“是一种”<br>“public 继承”意味 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p>
<p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p>
<p>常见的例子是用 <code>Square</code> 类继承自 <code>Rectangle</code> 类，从几何学的角度来讲这很自然 (正方形是长方形的一种)，然而正方形的长宽是相等的，矩形却不是如此，因此 <code>Square</code> 类和 <code>Rectangle</code> 类也无法满足严格的 is-a 关系。</p>
<p>在确定是否需要 public 继承的时候，我们首先要搞清楚<strong>子类是否必须拥有父类每一个特性</strong>，如果不是，则无论生活经验是什么，都不能视作”is-a” 的关系。<strong>public 继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。</strong></p>
<h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p>
<p>考虑以下情形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称 <code>mf</code> 掩盖了来自基类的名称 <code>mf</code>。（即使函数有不同的参数类型或函数为 virtual 函数，也会被掩盖）</p>
<p>对于名称掩盖问题的一种方法是使用 <code>using</code> 关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>using</code> 关键字会将基类中所有使用到名称 <code>mf</code> 的函数全部包含在派生类中，包括其重载版本。</p>
<p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在 private 继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">mf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或转发函数（forwarding functions）。</li>
</ol>
<h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><p>没什么好说的，接口继承就是继承接口基类（抽象类）</p>
<p>令人意外的是，我们可以为 pure virtual 函数提供定义。C++并不会发出怨言，但调用它的唯一途径是“调用时明确指出其 class 名称”：使用 <code>BaseClass::func()</code></p>
<p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p>
<p>用非纯虚函数提供缺省的默认实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p>
<p>使用纯虚函数并提供默认实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DefaultFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DefaultFly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述写法可以替代为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::Fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> : <span class="keyword">public</span> Airplane &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Airplane::<span class="built_in">Fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条款-35：考虑-virtual-函数以外的其他选择"><a href="#条款-35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款 35：考虑 virtual 函数以外的其他选择"></a>条款 35：考虑 virtual 函数以外的其他选择</h3><p>C++ 的 virtual 函数让我们能方便地实现接口继承与实现继承，但同时也会让我们忽略可能的其他方案。本条款针对于 virtual 函数的功能设计了具有不同优缺点的替代方案。</p>
<p>假如你在设计一款游戏，涉及到各式角色的血量计算，但不同角色的计算方法是不同的，这时候将计算血量的函数<strong>声明为 virtual</strong> 似乎是再明白不过的做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NpcEvil</span>:<span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这的确是再<strong>明白不过的设计</strong>，但是从某个角度说却<strong>反而成了它的弱点</strong>。由千这个设计如此明显，你可能因此没有认真考虑其他替代方案。为了帮助你跳脱面向对象设计路上的常轨，让我们考虑其他一些解法。</p>
<hr>
<ul>
<li><strong>使用非虚接口手法 （NVI） 实现 Template Method 设计模式</strong>，令客户通过 pulic 非虚成员函数间接调用 private virtual 函数函数。</li>
</ul>
<p>有一个有趣的思想流派<strong>主张 virtual 函数应该几乎总是 private</strong>。这个流派建议：<strong>保留 <code>CalculateHealthValue</code> 为 public 成员函数，但让它成为 non-virtual，并调用一个 private virtual 函数（例如 <code>OnCalculateHealthValue</code>）进行实际工作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//这里写成inline的形式只是为了容易阅读，建议还是定义写在cpp中</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//做一些预处理工作</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> Result= <span class="built_in">OnCalculateHealthValue</span>();<span class="comment">//做真正的工作</span></span><br><span class="line">        <span class="comment">//做后处理工作</span></span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">OnCalculateHealthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//具体计算方法，可被重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NpcEvil</span>:<span class="keyword">public</span> Character </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">OnCalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这种设计方式：令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，称为 non-virtual interface （NVI）手法。</span></span><br></pre></td></tr></table></figure>

<p>值得注意的一点，<strong>C++ 允许 derived class 覆写 base class 的 private virtual 方法</strong>。看起来诡异，但这是真的。</p>
<p><strong>优点</strong></p>
<p>NVI 手法的一个优点是可以在调用 private virtual 函数前后做一些额外的事情（片段中标注的预处理，后处理），其实这也是封装带来的好处。</p>
<ul>
<li>预处理可以做的工作：锁定互斥器，制造运转日志记录项，验证 class 约束条件，验证函数先决条件等等。</li>
<li>后处理可以做的工作：互斥器解除锁定，验证函数的事后条件，再次验证 class 约束条件等等。</li>
<li>假如没有这一层封装，直接调用 virtual 函数，就没有任何好办法可以做这些事。</li>
</ul>
<p><strong>缺点</strong></p>
<p>在某些 class 继承体系中，virtual 函数必须调用其 base class 的版本，这就导致 virtual 函数必须是 protected 而不能是 private，有些时候 virtual 函数甚至一定得是 public。在这种情况下，non-virtual 成员函数和 virtual 成员函数都是 public 的，NVI 的 wrapper 手法显然就不成立了</p>
<hr>
<ul>
<li><strong>使用函数指针实现 Strategy 设计模式</strong><br>Strategy：策略</li>
</ul>
<p>NVI 手法对于 public virtual 函数而言是一个有趣的设计，但从某种设计角度来看，这仅仅多了一层装饰而已，毕竟我们还是使用 virtual 函数计算每一个角色的健康指数。另一种更具戏剧性的做法主张：<strong>人物健康指数的计算与人物类型无关，这样的计算完全不需要人物这个成分。</strong><br>例如我们可能要求每个人物的构造函数接受一个指针，指向一个健康计算函数，我们可以调用该函数进行实际计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = <span class="built_in">int</span>(*)(<span class="type">const</span> GameCharacter&amp;);    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><p>同一人物类型的不同实例 <code>可以有不同的健康计算函数</code>。只需提供不同的函数指针进行初始化。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>:<span class="keyword">public</span> GameCharacter</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span> <span class="params">(HealthCalcFunc hcf defaultHealthCalc)</span> : GameCharacter (hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span> <span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">//健康指数计算函数1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthslowly</span> <span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">//健康指数计算函数2</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebgl</span> <span class="params">(loseHealthQuickly)</span></span>;<span class="comment">//相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;<span class="comment">//不同的健康计算方式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>某已知人物的健康计算函数 <code>可在运行期变更</code>。只需提供类似 Setter 函数即可替换用于计算健康度的函数。<br>换句话说，健康计算函数不再是 <code>GameCharacter</code> 继承体系内的成员函数，它也无权使用非 public 成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供 public 访问函数。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<p>这种指针函数只能访问 class 的 public 成分，所以我们会遇到“需要以非成员函数访问 class 的的非 public 成分”的问题：<br>如果人物的健康可纯粹根据人物 public 接口得来的，这种设计没有问题，但如果需要 non-public 信息进行精确计算，就有问题了。 实际上任何时候当你将 class 内的某个机能由 non-member 函数实现，都会存在这样的额外难题。<br><strong>唯一能解决该问题的办法就是弱化 class 的封装</strong>，比如声明非成员函数为 friend，或者为函数的实现提供一些 public 访问函数。<br>运用函数指针替换虚函数，其优点（“每个对象可各自拥有自己的健康计算函数”和“可在运行期改变计算函数”）是否足以弥补缺点（例如可能必须降低 GameCharacter 封装性)，是你必须根据每个设计情况的不同而抉择的。</p>
<p>另一种思路：<br>把外部函数指针改成类成员函数指针可以同时享有这两个优点，并且不用弱化 class 的封装性。但这会导致 class 内部的函数冗杂，并且该健康计算函数不能再不同 class 中复用</p>
<hr>
<p><strong>藉由 <code>std::function</code> 完成 Strategy 模式</strong></p>
<p><code>std::function</code> 是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DefaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;        <span class="comment">// 缺省算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> HealthCalcFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">const</span> GameCharacter&amp;)&gt;;    <span class="comment">// 定义函数包装器类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = DefaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code> 就能展现出惊人的弹性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用返回值不同的函数</span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">CalcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara1</span><span class="params">(CalcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数对象（仿函数）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用某个成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line"><span class="function">GameCharacter <span class="title">chara2</span><span class="params">(std::bind(&amp;GameLevel::Health, currentLevel, std::placeholders::_1))</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>古典的 Strategy 模式：</strong></p>
<p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自 <code>HealthCalcFunc</code> 继承体系的对象：<br><strong>古典的 Strategy 模式：</strong></p>
<p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自 <code>HealthCalcFunc</code> 继承体系的对象：</p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218071.png" alt="Pasted image 20231024145858"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">Calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">Calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为 <code>HealthCalcFunc</code> 基类添加一个派生类即可。</p>
<h3 id="条款-36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款-36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款 36：绝不重新定义继承而来的 non-virtual 函数"></a>条款 36：绝不重新定义继承而来的 non-virtual 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;  <span class="comment">//重新定义继承而来的非虚函数，掩盖了Base::mf（条款33）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Derived x; <span class="comment">//x是Derived类型的对象。</span></span><br><span class="line"></span><br><span class="line">Base* pB = &amp;x;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();  <span class="comment">//调用Base::mf()</span></span><br><span class="line"></span><br><span class="line">Derived* pD = &amp;x;</span><br><span class="line">pD-&gt;<span class="built_in">mf</span>(); <span class="comment">//调用Derived::mf()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pB，pD 指针都通过对象 x 调用成员函数 mf，但要注意 mf 为非虚函数而且 Derived 有自己的定义的版本。所有调用了不同的函数。</p>
<p>原因是因为：<strong>非虚函数都是静态绑定</strong>（statically bound，又称前期绑定，early binding，见条款 37），由对象类型本身（称之静态类型）决定要调用的函数。</p>
<ul>
<li>由于 pB 被声明为一个 <code>Base*</code> 指针，通过该指针该指针调用的非虚函数永远是 Base 定义的版本，即使 pB 指向了子类。</li>
</ul>
<p>另一方面，<strong>虚函数是动态绑定</strong>（dynamically bound，又称后期绑定，late binding，见条款 37），决定因素不在对象本身，而在于 “指向该对象之指针” 当初的声明类型（称之动态类型）。</p>
<ul>
<li>如果 mf 是一个虚函数，那么两个指针都调用 <code>Derived::mf()</code>。因为 pB 和 pD 都指向类型为 D 的对象。</li>
</ul>
<h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们<strong>只讨论带有缺省参数值的虚函数。</strong></p>
<ul>
<li><strong>对象的静态类型</strong>：就是对象在程序中被<strong>声明时</strong>所采用的类型</li>
<li><strong>对象的动态类型</strong>：指<strong>目前</strong>所指对象的类型。</li>
<li>函数的静态绑定：调用一个静态绑定函数时，<strong>调用哪个类的函数取决于发出调用的那个对象的静态类型。</strong></li>
<li>函数的动态绑定：调用一个动态绑定函数时，调用哪个类的函数<strong>取决于发出调用的那个对象的动态类型。</strong></li>
<li><strong>非虚函数都是静态绑定</strong>（statically bound，又称前期绑定，early binding，见条款 37）</li>
<li><strong>虚函数是动态绑定</strong>（dynamically bound，又称后期绑定，late binding，见条款 37）</li>
<li><strong>缺省参数值是静态绑定</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制形状</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意这里已经违反了该条款，赋予了不同的缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//译注：请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下这个函数并不从其base继承缺省参数值。</span></span><br><span class="line">    <span class="comment">//但若以指针（或reference)调用此函数，可以不指定参数值，</span></span><br><span class="line">    <span class="comment">//因为动态绑定下这个函数会从其base继承缺省参数值。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>区分静态类型和动态类型：</strong><br>注意：本例中 ps, pc 和 pr 都被声明为 pointer-to-Shape 类型，所以它们都以它为静态类型。<strong>注意，不论它们真正指向什么，它们的静态类型都是 Shape*。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps; <span class="comment">//静态类型为Shape*，没有动态类型（因为没有指向任何对象）</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">//静态类型为Shape*，动态类型为Rectangle*</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;    <span class="comment">//静态类型为Shape*，动态类型为Circle*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态类型可在运行时改变</span></span><br><span class="line">ps = pc; <span class="comment">//ps的动态类型变为Circle*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数是动态绑定，也就是说调用一个virtual函数时，调用哪个类的函数实现取决于发出调用的那个对象的动态类型。</span></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>(ShapeColor::Green);    <span class="comment">// 调用Rectangle::Draw(Shape::Green)</span></span><br><span class="line">pc-&gt;<span class="built_in">Draw</span>(ShapeColor::Green);    <span class="comment">// 调用 Circle::Draw(Shape::Green)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pr的类型静态类型是Shape*，缺省参数值是静态绑定，所以：</span></span><br><span class="line"><span class="comment">//pr指向Rectangle，不传参，调用的不是Rectangle的缺省参数Green，而是基类的缺省参数</span></span><br><span class="line">pr-&gt;<span class="built_in">Draw</span>(); <span class="comment">//调用Rectangle::Draw(Shape::Red)</span></span><br></pre></td></tr></table></figure>

<p>最后这行代码结果显然是很奇怪的，调用的函数是 Rectangle 版本版本，传的缺省参数却是基类。</p>
<blockquote>
<p>[!question] 为什么 C++坚持以这种奇怪的方式来运作呢？<br>答案在于运行期效率。如果缺省参数值是动态绑定，编译器就必须有某种办法在运行期为 virtual 函数决定适当的参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序的执行速度和编译器实现上的简易度，C+做了这样的取舍，其结果就是你如今所享受的执行效率。但如果你没有注意本条款所揭示的忠告，很容易发生混淆。</p>
</blockquote>
<p>可以考虑条款 35 中列出的虚函数的替代设计，例如 NVI 手法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="type">const</span> </span>&#123; <span class="built_in">DoDraw</span>(color); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>总结：</p>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数——你唯一应该覆写的东西——却是动态绑定。</li>
</ul>
<h3 id="条款-38：通过复合塑膜出-has-a-关系，或-“根据某物实现出”"><a href="#条款-38：通过复合塑膜出-has-a-关系，或-“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑膜出 has-a 关系，或 “根据某物实现出”"></a>条款 38：通过复合塑膜出 has-a 关系，或 “根据某物实现出”</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218072.png" alt="Pasted image 20231025112716"></p>
<ol>
<li>两个类的关系除了继承之外，还有 “一个类的对象可以作为另一个类的成员”，我们称这种关系为 “类的复合（组合，Composition）”</li>
<li>public 继承是一种 is-a 的意义，复合也有它们的意义。复合意味着 has-a（有一个）或 is-implemented-in-terms-of （根据某物实现出）。</li>
<li><code>is-a</code>（是一种 和 <code>is-implemented-in-terms-of</code> （根据某物实现出） 的区分</li>
</ol>
<p>这两种关系其实是在不同领域的表现，如果对象只是你所塑造的世界中的某个物品，某些人物等，那这样的对象就属于<strong>应用域</strong>部分<br>如果对象需要负责你所塑造世界的细节部分，是规则的制定者和执行者，那这样的对象就属于<strong>实现域</strong>部分。<br>当对象处于应用域，它就是 has-a 的关系，当对象处于实现域，它就是 is-implemented-in-terms-of 的关系。  </p>
<h3 id="条款-39：明智而审慎地使用-private-继承"><a href="#条款-39：明智而审慎地使用-private-继承" class="headerlink" title="条款 39：明智而审慎地使用 private 继承"></a>条款 39：明智而审慎地使用 private 继承</h3><p>条款 32 中说到 <strong>public 继承是一种 is-a</strong> 关系。在这种继承体系下，编译器在必要时刻（为了让函数调用成功）会将 derived class 转换为 base class 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line">​</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">eat</span>(p); <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">eat</span>(s); <span class="comment">// 没问题，这里编译器将Student暗自转换为Person类型。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果 classes 之间的继承关系是 private, 编译器不会自动将 derived class 对象转换为 base class 对象。这和 public 继承的情况不同。这也就是为什么通过 s 调用 eat 会失败的原因。</li>
<li>由 private base class 继承而来的所有成员，在 derived class 中都会变成 private 属性，纵使它们在 base class 中原本是 protected 或 public 属性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> Person &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line">​</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">eat</span>(p); <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">eat</span>(s); <span class="comment">// 错误！！！s是private继承，编译器无法转换。</span></span><br></pre></td></tr></table></figure>

<p><strong>Private 继承的意义</strong></p>
<ul>
<li>private 继承意味着：is-implemented-in-terms-of （根据某物实现出）。private 继承可以看作纯粹是<code>为了实现细节</code>，它需要的不是类似 public 继承可以向外提供接口，仅仅是为了让 derived class 采用 base class 中已经具备的某种特性。derived 和 base 之间并没有什么直接意义上的联系。</li>
</ul>
<p><strong>那么当我们拥有 “用一个类去实现另一个类” 的需求的时候，如何在类的复合与 private 继承中做选择呢？</strong></p>
<ul>
<li>尽可能用复合，<strong>除非必要，不要采用 private 继承</strong>。</li>
<li>当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择 private 继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。</li>
</ul>
<p><strong>案例一：能用复合，就不要用 private</strong></p>
<p>假设我们需要写一个 Widget（控件）。这个控件需要按某一频率定时检查 Widget 的某些信息，换句话说需要定时地调用某个函数。为了少写新的代码，我们在其他程序中翻到了一个 Timer class。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Timer </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Timer(int tickFrequency);</span><br><span class="line">    virtual void onTick() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个定时器的功能是每隔一段时间就调用一次 onTick 函数。<br>为了让 Widget 重新定义 virtual 内的 virtual 函数，Widget 必须继承自 Timer。但此时不能使用 public 继承，<strong>因为 Widget 并不是个 Timer</strong>，所以我们必须以 private 形式继承 Timer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Widget : private Timer </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    virtual void onTick() const override;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 <strong>private 继承并不是唯一的选择方案</strong>，我们可以<strong>使用复合</strong>来替代这个方案。<br>只要在 Widget 内声明一个<strong>嵌套式 private class</strong>, 后者以 public 形式继承 Timer 并重新定义 onTick, 然后放一个这种类型的对象千 Widget 内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Widget </span><br><span class="line">&#123;</span><br><span class="line">private:  //private的</span><br><span class="line">    class WidgetTimer : public Timer </span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void onTick() const override;  //本应被目标类覆写的方法在嵌套类中实现，这样TargetClass的子类就无法覆写该方法。</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>该复合设计相比于 private 继承有两个优点：</strong></p>
<p><strong>当 Widget 拥有 derived class 时，你可能同时想阻止 derived class 重新定义 onTick。</strong>如果是 private 继承（Widget 继承了 Timer），那这个想法就不可能实现。（条款 35 曾说过：<strong>derived class 可以重新定义 private virtual 函数</strong>，即使它们不能调用它）。但如果 WidgetTimer 是 widget 内部的一个 private 成员并继承 Timer，Widget 的 derived classes 将无法取用 WidgetTimer，因此无法继承它或重新定义它的 virtual 函数。<br><strong>降低 widget 的编译依存性。</strong>如果继承 Timer，当 Widget 被编译时 Timer 的定义必须可见，所以定义 widget 的文件必须 #include Timer.h。如果 WidgetTimer 移出 Widget 之外，而 widget 内含指针指向一个 widgetTimer，widget 可以只带一个简单的 WidgetTimer 前置声明。（对大型系统而言非常重要）关于编译依存性的最小化，详见条款 31 。</p>
<p><strong>案例二：一个使用 private 的极端案例</strong></p>
<p>这种情况真是够激进的，只适用于你所处理的 class 不带任何数据时。这样的 <code>class 不存在任何成员函数或变量</code>。示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoWithEmpty</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    FEmpty Empty;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DemoWithEmpty DemoWithEmpty;</span><br><span class="line">    Empty Empty;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(Empty)&lt;&lt;<span class="string">&quot;\n&quot;</span>;  <span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(DemoWithEmpty)&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，一个不含任何成员的 class 的大小居然为 1。因为 C++ 规定凡是独立对象都必须有非零大小。所以你可以发现 sizeof（Empty）的大小为 1，而且几乎所有的编译器都这样做。至于为什么含一个 int 大小的 class 是 8，这涉及到内存对齐的问题，不必详细讨论。<br>或许你注意到了，独立对象才需要有非零大小，这意味着继承而来的 Empty class 大小可以不受约束:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FEmpty</span> &#123;&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoWithEmpty</span> :<span class="keyword">private</span> FEmpty&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DemoWithEmpty DemoWithEmpty;</span><br><span class="line">    Empty Empty;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(Empty)&lt;&lt;<span class="string">&quot;\n&quot;</span>;  <span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(DemoWithEmpty)&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DemoWithEmpty 所用大小正好等于一个 int 的大小，而这种表现就是所谓的 <strong><code>EBO（empty base optimization）空白基类最优化</code>。</strong>值得注意的是，EBO 一般在单一继承下才可行。</p>
<p>尽管有这些例外情况，让我们回到根本。大部分 class 并非 empty，这很少成为你使用 private 继承的理由。只有当你面对需要访问 base class 的 protected 成员或者覆写 virtual 函数时，private 继承才被纳入考虑。当你审视完所有方案，仍然认为 private 继承是最佳方法，才使用它。</p>
<p>总结：</p>
<ol>
<li>Private 继承意味 is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
<li>和复合（composition）不同，private 继承可以造成 empty base 最优化。这对致力于对象尺寸最小化的程序库开发者而言，可能很重要。</li>
</ol>
<h3 id="条款-40：明智而审慎地使用多继承"><a href="#条款-40：明智而审慎地使用多继承" class="headerlink" title="条款 40：明智而审慎地使用多继承"></a>条款 40：明智而审慎地使用多继承</h3><p>C++ 社群对多重继承（multiple inheritance MI）持有两类观点。</p>
<ul>
<li>单一继承是好的，但多重继承不值得使用。  </li>
<li>单一继承（single inheritance SI）是好的，多重继承更好。</li>
</ul>
<p>两种观点的比较与选择<br>观点一：<strong>多重继承不值得使用</strong></p>
<p>原因一：<strong>多重继承可能会引发歧义（ambiguity）行为。</strong> <strong>解决办法：指明调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 图书馆可借内容的基类。</span><br><span class="line">class BorrowableItem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void checkOut(); // 检查函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 一个电子小工具类。</span><br><span class="line">class ElectronicGadget</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    bool checkOut() const; // 检查函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Mp3播放器类。</span><br><span class="line">class MP3Player :</span><br><span class="line">public : BorrowableItem, </span><br><span class="line">public : ElectronicGadget </span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">// 这里会引发歧义，mp对象到底调用的是哪个checkout函数？</span><br><span class="line">mp.checkout();</span><br></pre></td></tr></table></figure>

<p>疑问：B<del>class 的 checkOut 函数是 public 的，E</del>class 的 checkOut 函数是 private 的，理应只有 B~class 的函数是可以调用，那为什么会引发歧义行为？<br>原因：这与 <strong>C++ 的解析机制</strong>有关（与解析（resolving）重载函数调用的规则相符）。在看到是否有个函数可取用之前，C++ 会首先确认这个函数是不是此调用的最佳匹配，<strong>找出最佳匹配函数后才检验其可取用性</strong>。在该例中，两个 checkOuts 有相同的匹配程度（因此才造成歧义），没有所谓最佳匹配。因此 <strong>ElectronicGadget::checkOut 的可取用性也就从未被编译器审查</strong> (是不是 public 对该问题也就没有影响, 还没到这一步就错了)。</p>
<p><strong>解决方法</strong>：如下调用即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定调用BorrowableItem的checkOut函数。</span></span><br><span class="line">mp.BorrowableItem::<span class="built_in">checkOut</span>();</span><br><span class="line"><span class="comment">// 错误行为！！！通过最佳匹配检查后发现，这个函数是个private函数。</span></span><br><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure>

<p><strong>原因二：要命的 “钻石型多重继承” 解决办法：virtual 继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">public</span> File &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">public</span> File &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>这种继承体系必须面对的一个问题是：<strong>是不是打算让 File class 内的成员变量经过每一条路径被复制？</strong><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404281218073.png" alt="Pasted image 20231025114955"><br>总结：</p>
<ol>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li>
<li>virtual 继承会增加大小，速度，初始化（赋值）复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具有实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及 <strong>“public 继承某个 Interface class”</strong> 和 <strong>“private 继承某个协助实现的 class”</strong> 的两相组合。</li>
</ol>
<h1 id="七、模板与泛型编程"><a href="#七、模板与泛型编程" class="headerlink" title="七、模板与泛型编程"></a><strong>七、模板与泛型编程</strong></h1><p>TODO</p>
<h3 id="条款-41：了解隐式接口和编译器多态"><a href="#条款-41：了解隐式接口和编译器多态" class="headerlink" title="条款 41：了解隐式接口和编译器多态"></a>条款 41：了解隐式接口和编译器多态</h3><p><strong>显式接口</strong>和<strong>运行期多态</strong></p>
<p>面向对象的世界总是以显式接口和运行期多态解决问题。</p>
<p>显式接口的构成：函数名称，参数类型，返回类型，常量性也包括编译器产生的 copy 构造函数和 copy assignment 操作符。(函数的签名式)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>:<span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Special&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NormalWidget</span>:<span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Normal&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BeginPlayWithWidget</span><span class="params">(Widget&amp; InWidget)</span> </span>&#123;</span><br><span class="line">    InWidget.<span class="built_in">Normalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpecialWidget SpecialWidget;</span><br><span class="line">    NormalWidget NormalWidget;</span><br><span class="line">    <span class="built_in">BeginPlayWithWidget</span>(SpecialWidget); <span class="comment">//Special</span></span><br><span class="line">    <span class="built_in">BeginPlayWithWidget</span>(NormalWidget);	<span class="comment">//Normal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样说 BeingPlayWithWidget 函数中的 InWidget</p>
<ul>
<li>由于 InWidget 类型被声明为 Widget，所以 InWidget 必须支持 Widget 接口。我们可以在源码中找到这个接口，看看它们是什么样子，所以我们称之为一个<strong>显式接口</strong>（explicit interface），也就是它在源码中的确可见。</li>
<li>由于 Widget 的 BeingPlayWithWidget(或者说某些成员函数) 函数是 virtual ，InWidget 将对此函数的调用表现出<strong>运行期多态</strong>（runtime polymorphism），也就是说将<strong>在运行期根据 InWidget 的动态类型决定究竟调用哪个函数。</strong></li>
</ul>
<p><strong>隐式接口</strong>和<strong>编译期多态</strong></p>
<p>templates 及泛型编程的世界，与面向对象的世界有根本的不同。在此世界显式接口和运行期多态仍然存在，但重要性降低。</p>
<p>隐式接口的构成： 有效表达式（valid expression）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void BeginPlayWithWidgetTemplate(T&amp; InT) &#123;</span><br><span class="line">    if (InT.Size() &gt; 0 &amp;&amp; InT != EClassType::None) &#123;</span><br><span class="line">        InT.Normalize();</span><br><span class="line">        std::cout &lt;&lt; InT.Size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 InT 来说</p>
<ul>
<li>InT 必须支持哪一种接口，是由函数体中对 InT 的操作决定的。从本例来看，InT 的类型 T 必须要支持 Normalize 、Size、不等比较等操作。看表面可能并非完全正确，但这组操作对于 T 类型的参数来说，是一定要支持的<strong>隐式接口</strong>（implicit interface）。</li>
<li>凡是涉及 InT 的任何函数调用，例如 operator&gt; 和 operator !&#x3D; 有可能造成 template 的具现化，使得这些调用得以成功，这样的行为发生在编译器。以<strong>不同的 template 参数具现化 function templates</strong> 会导致调用不同的函数，这便是所谓的<strong>编译期多态</strong>（compile-time polymorphism）。</li>
</ul>
<p>纵使你从未用过 templates，应该不陌生 “运行期多态” 和“编译期多态”之间的差异，因为它类似于“哪一个重载函数该被调用”（发生在编译期）和“哪一个 virtual 函数该被绑定”（发生在运行期）之间的差异。</p>
<p>隐式接口与显示接口不同，它不基于函数签名式，而是由<strong>有效表达式（valid expression）</strong>构成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void BeginPlayWithWidgetTemplate(T&amp; InT) &#123;</span><br><span class="line">    if (InT.Size() &gt; 0 &amp;&amp; InT != EClassType::None) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该例子中， T 类型的隐式接口有这些约束：</p>
<ol>
<li>T 必须提供名叫 Size 的成员函数，该函数返回一个整数值；  </li>
<li>T 必须支持 operator!&#x3D; 函数，用来与两个 T 对象，这里假设 EClassType 为 T 类型；<br>得益于操作符重载（operator overloading）带来的可能性，这两个约束都不需要满足。是的，T 必须支持 size 成员函数，然而这个函数也可能从 base class 继承而得。这个成员函数不需返回一个整数值，甚至不需返回一个数值类型。就此而言，它甚至不需要返回一个定义有 operator &gt; 的类型！它唯一需要做的是返回一个类型为 x 的对象，而 x 对象加上一个 int（10 的类型）必须能够调用一个 operator&gt;。这个 operator &gt; 不需要非得取得一个类型为 x 的参数不可，因为它也可以取得类型 Y 的参数，只要存在一个隐式转换能够将类型 x 的对象转换为类型 y 的对象！<br>同样道理，T 并不需要支持 operator!&#x3D;，因为以下这样也是可以的：operator！&#x3D; 接受一个类型为 x 的对象和一个类型为 Y 的对象，T 可被转换为 x 而 EClassType 的类型可被转换为 Y，这样就可以有效调用 operator !&#x3D;。</li>
</ol>
<p>总结：</p>
<ol>
<li>classes 和 templates 都支持接口（interfaces）和多态（polymorphism）。</li>
<li>对 classes 而言接口是显式的（explicit），<strong>以函数签名为中心</strong>。多态则是通过 virtual 函数发生于<strong>运行期</strong>。</li>
<li>对 template 参数而言，接口是隐式的（implicit），<strong>奠基于有效表达式</strong>。多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于<strong>编译期</strong>。</li>
</ol>
<h3 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 typename 的双重意义</h3><p>本条款首先提出一个问题：以下 template 声明式中，class 和 typename 有什么不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Widget;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Widgt;</span><br></pre></td></tr></table></figure>

<p>答案：没有不同。</p>
<p><strong>当我们声明 template 类型参数时， class 和 typename 的意义完全相同。</strong><br>某些程序员喜欢 class，因为可以少打几个字, 有些人 (比如作者本人) 比较喜欢 typename ，因为它<strong>暗示参数并非一定是个 class 类型</strong>。</p>
<p><strong>然而 C++ 并不总是把 class 和 typename 视为等价</strong>。有时候你一定得使用 typename。为了解其时机，我们必须先谈谈你可以在 template 内指涉（refer to）的两种名称： (嵌套) 从属名称和非从属名称 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void PrintContainer(const T&amp; Container) &#123;                                           //注意这不是有效的C++代码</span><br><span class="line">    if (Container.Size()&gt;0) &#123;</span><br><span class="line">        T::const_iterator iter(Container.begin()); //取得第一元素的迭代器  注意 iter</span><br><span class="line">        ++iter;                         </span><br><span class="line">        int value=*iter;                    //将该元素复制到某个int，注意 value</span><br><span class="line">        std::cout&lt;&lt;value&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中强调两个 local 变量：<strong>iter</strong> 和 <strong>value</strong>。<br>iter 的类型是<code>T::const_iterator</code>，实际是什么取决于 template 参数 T。template 内出现的名称如果依赖于某个 template 参数，我们就称之为<strong>从属名称</strong>（dependent names）。如果从属名称在 class 内呈嵌套状，我们就称之为<strong>嵌套从属名称</strong>（nested dependent names）。T::const_iterator 就是这样的名称，实际上它还是一个<strong>嵌套从属类型名称</strong>（nested dependent type name），也就是个<strong>嵌套从属名称</strong>并且<strong>指涉是什么类型</strong>。<br>value 的类型是 int 。它不依赖于任何 template 参数。我们便称之为非从属名称（non-dependent names）。</p>
<p><strong>嵌套从属名称可能导致解析（parsing）困难</strong></p>
<p>在我们知道 T 是什么之前，没有任何办法可以知道 T::const_iterator 是否为一个类型。而当编译器开始解析 template PrintContainer 时，尚未确知 T 是什么东西。 C++ 有个规则可以解析（resolve）此一歧义状态：<strong>如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是</strong>。所以缺省情况下嵌套从属名称不是类型。此规则有个例外，稍后我会提到。</p>
<p>再次回顾上述代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void PrintContainer(const T&amp; Container) &#123;                                           </span><br><span class="line">    if (Container.Size()&gt;0) &#123;</span><br><span class="line">        T::const_iterator iter(Container.begin());  //这个名称被假设为非类型</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在应该很清楚为什么这不是有效的 C++ 代码了吧。iter 声明式只有在 T::const_iterator 是个类型时才合理，但我们并没有告诉 C++ 说它是，于是 C++ 假设它不是。若要矫正这个形势，我们必须告诉 C++ 说 T::const iterator 是个类型。<strong>只要紧临它之前放置关键字 typename 即可：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void PrintContainer(const T&amp; Container)      //这是合法的C++代码 &#123;                                           </span><br><span class="line">    if (Container.Size()&gt;0) &#123;</span><br><span class="line">        typename T::const_iterator iter(Container.begin());  //ok</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般性规则很简单：<strong>任何时候当你想要在 template 中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字 typename。</strong>（再提醒一次，很快我会谈到一个例外。）</p>
<p><strong>typename 只被用来验明嵌套从属类型名称</strong>；其他名称不该有它存在。例如下面这个 function template，接受一个容器和一个 “指向该容器” 的选代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename C&gt;                 //允许使用&quot;typename&quot;（或&quot;class&quot;）</span><br><span class="line">void f(const C&amp;container，           //不允许使用&quot;typename&quot;</span><br><span class="line">typename C::iterator iter)；        //一定要使用&quot;typename&quot;</span><br></pre></td></tr></table></figure>

<p>上述的 C 并不是嵌套从属类型名称（它并非嵌套于任何 “取决于 template 参数” 的东西内），所以声明 container 时并不需要以 typename 为前导，但 C::iterator 是个嵌套从属类型名称，所以必须以 typename 为前导。</p>
<p>“typename 必须作为嵌套从属类型名称的前缀词” 这一规则的例外是：<strong>typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 member initialization list（成员初值列）中作为 base class 修饰符。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">public:</span><br><span class="line">    Message() = default;</span><br><span class="line">    explicit Message(std::string InText): Text(std::move(InText)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void SetText(std::string InText) &#123;</span><br><span class="line">        Text = std::move(InText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string GetText() &#123;</span><br><span class="line">        return Text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string Text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MessageContainer &#123;</span><br><span class="line">public:</span><br><span class="line">    typedef T ElementType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Printer : private MessageContainer&lt;T&gt;::ElementType &#123;//base classes list不使用typename</span><br><span class="line">public:</span><br><span class="line">    //使用 typename 表明是一个类型，而不是变量</span><br><span class="line">    //使用 typedef 给过长的类型起别名，方便。</span><br><span class="line">    typedef typename MessageContainer&lt;T&gt;::ElementType ElementType; </span><br><span class="line"></span><br><span class="line">    explicit Printer(): MessageContainer&lt;T&gt;::ElementType() &#123; //mem.init.list中不使用typename</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; typeid(ElementType).name() &lt;&lt; &quot;\n&quot;; //class Message</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Log(std::string Text) &#123;</span><br><span class="line">        ElementType::SetText(Text);</span><br><span class="line">        std::cout &lt;&lt; ElementType::GetText() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void TryWithPrinter() &#123;</span><br><span class="line">    Printer&lt;Message&gt; Printer;</span><br><span class="line">    Printer.Log(&quot;HelloWorld&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li>
<li>请使用关键字 typename 标识<strong>嵌套从属类型名称</strong>；但<strong>不得在 base class lists（基类列）</strong>或 <strong>member initialization lists（成员初值列）</strong>内以它作为 base class 修饰符。</li>
</ol>
<h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p>从一个例子入手，假设我们要设计游戏中人物的相关列表，比如 buff 列表，物品列表等等，一个显而易见的设计是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">class Buff &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Buff() = default;</span><br><span class="line">    virtual void Start() = 0;</span><br><span class="line">    virtual void End() = 0;</span><br><span class="line">    virtual void OnTick() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RedBuff : public Buff &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Start() override &#123;&#125;</span><br><span class="line">    virtual void End() override &#123;&#125;</span><br><span class="line">    virtual void OnTick() override &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BlueBuff : public Buff &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Start() override &#123;&#125;</span><br><span class="line">    virtual void End() override &#123;&#125;</span><br><span class="line">    virtual void OnTick() override &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Container &#123;</span><br><span class="line">public:</span><br><span class="line">    void Add(T Item) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Add&quot; &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        Data.insert(Item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Clear() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Clear&quot; &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        Data.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t Size() &#123;</span><br><span class="line">        return Data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::set&lt;T&gt; Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PlayerContainer : public Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void RemoveAll() &#123;</span><br><span class="line">      Clear();   //在此无法访问 Clear 函数,找不到标识符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void ShowAll() &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    PlayerContainer&lt;Buff*&gt; PlayerBuffContainer;</span><br><span class="line">    PlayerBuffContainer.Clear();</span><br><span class="line"></span><br><span class="line">    RedBuff* RedBuffOne = new RedBuff;</span><br><span class="line">    BlueBuff* BlueBuffOne = new BlueBuff;</span><br><span class="line">    PlayerBuffContainer.Add(RedBuffOne);</span><br><span class="line">    PlayerBuffContainer.Add(BlueBuffOne);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; PlayerBuffContainer.Size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行此代码，出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clear:找不到标识符!</span><br></pre></td></tr></table></figure>

<p>而出错的原因在于：</p>
<p>当编辑器遭遇 class template PlayerContainer 时，其实并不知道它究竟继承哪个 class。当然它继承的是 Container ，但其中的 T 是一个 template 参数，<strong>不到后来的具现化，是无法确切知道它是什么</strong>。而如果不知道 T 是什么，就不清楚 class Container 看起来像什么——更确切地说是没办法知道它是否有个 Clear 函数。<br>例如，如果有以下<strong>特化版</strong> class Container （模板全特化）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;                 //一个全特化的Container</span><br><span class="line">class Container&lt;Buff*&gt; &#123;   //它和一般的template相同，区别只在于它删掉了void Clear() 函数</span><br><span class="line">public:</span><br><span class="line"> void Add(T Item) &#123;</span><br><span class="line">     std::cout &lt;&lt; &quot;Add&quot; &lt;&lt; &quot;\n&quot;;</span><br><span class="line">     Data.insert(Item);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> size_t Size() &#123;</span><br><span class="line">     return Data.size();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//等价于</span><br><span class="line">template&lt;typename T=Buff*&gt;</span><br><span class="line">class Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">  .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，再让我们考虑 derived class PlayerContainer:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PlayerContainer : public Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line"> void RemoveAll() &#123;</span><br><span class="line">     Clear();   //如果T==Buff,这个函数不存在</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void ShowAll() &#123;</span><br><span class="line">     //...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正如注释所言，<strong>当 base class 被指定为 Container 时，这段代码将不合法！</strong>因为该版本的 Container template 类<strong>被特化</strong>，其中并<strong>不存在 Clear 函数</strong>，且由于编译器会<strong>优先考虑特化版本</strong>，意味着 Container 使用 Buff 具现化时类中只存在 Add、Size 函数，并未提供 Clear 函数。<br>这正是前面所说，为什么 C++ 拒绝在 PlayerContainer 访问 Clear 函数的原因：它知道 base classes templates 有可能被特化，而那个<strong>特化版本可能不提供和一般性 template 相同的接口。因此它往往拒绝在 base classes templates 寻找继承而来的名称</strong>。因此它往往拒绝在 templatized base classes（模板化基类，本例的 Container）内寻找继承而来的名称（本例的 Clear）。</p>
<p>所以，<strong>我们必须有某种办法令 C++” 不进入 templatized base classes 观察” 的行为失效</strong>。幸运的是，我们有三个解决办法：</p>
<ol>
<li>在 base class template 函数调用动作之前**加上 this-&gt;**。this 指针可以访问所有成员函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PlayerContainer : public Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void RemoveAll() &#123;</span><br><span class="line">      this -&gt; Clear();   //成立，假设Clear将被继承</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 using 声明式</strong>。可以告诉编译器进入 base class 作用域寻找函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PlayerContainer : public Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    using Container&lt;T&gt;::Clear; //告诉编译器，请他假设Clear位于base class内</span><br><span class="line">    void RemoveAll() &#123;</span><br><span class="line">       Clear();   </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（虽然 using 声明式在这里或在条款 33 都可有效运作，但两处解决的问题其实不相同。这里的情况并不是 base class 名称被 derived class 名称遮掩，而是编译器不进入 base class 作用域内查找，于是我们通过 using 告诉它，请它那么做。）  </p>
<ol start="3">
<li>明确指出被调用函数位于 base class 内。 (不推荐)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PlayerContainer : public Container&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void RemoveAll() &#123;</span><br><span class="line">      Container&lt;T&gt;::Clear();   //成立，假设Clear将被继承</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这往往是最不让人满意的一个解法，因为<strong>如果被调用的是 virtual 函数</strong>，上述的明确资格修饰（explicit qualification）会<strong>关闭 “virtual 绑定行为”</strong><br>从名称可视点的角度来看，上述每一个解法做的事情都相同：<strong>对编译器承诺 base class template 的任何特化版本都支持其泛化版本所提供的接口。如果承诺未被保证，编译器仍然会报错。</strong></p>
<p>总结：</p>
<ol>
<li><strong>可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 base class 资格修饰符完成。</strong></li>
</ol>
<h3 id="条款-44：将与参数无关的代码抽离-templates"><a href="#条款-44：将与参数无关的代码抽离-templates" class="headerlink" title="条款 44：将与参数无关的代码抽离 templates"></a>条款 44：将与参数无关的代码抽离 templates</h3><ul>
<li><strong>templates 是节省时间和避免代码重复的奇方妙法。</strong></li>
</ul>
<p>你不再需要键入 20 个类似的 classes 并且每一个都带有 20 个 成员函数，你只需要键入一个 class template，留给编译器去具现化那 20 个你需要的相关 classes 即可，而且对于 20 个函数中未被调用的，编译器不会自动生成。这样的技术是不是很伟大，呵呵。</p>
<ul>
<li>但这也很容易使得<strong>代码膨胀</strong>（code bloat），templates 产出码带着重复，或者几乎重复的代码，数据，或者两者。你可以通过：<strong>共性与变形分析</strong>（commonality and variability analysis）来避免代码膨胀。</li>
</ul>
<p>这个概念其实你早在使用，即使你从未写过一个 templates。当你编写某个函数时，你明白其中某些部分的实现码和另一个函数的实现码实质相同，你会很单纯的重复它们吗？当然不，你会抽出这两个函数相同的部分，放进第三个函数中，然后令原先两个函数调用这个新函数。也就是说：你分析了两个函数的共性和变形，把公共的部分搬到一个新的函数中去，变化的部分保留在原来的函数不动。对于 class 也是这个道理，如果你明白某些 class 和另一个 class 具有相同的部分，你也会把共性搬到一个新的 class。</p>
<ul>
<li>templates 的优化思路也是如此，以相同的方式避免重复，但其中有个窍门。在 non-template 代码中，重复很明确。然而<strong>在 template 代码中，重复是隐晦的，</strong>毕竟只存在一份 template 代码，所以你必须自己去感受 template 具现化时可能发生的重复。</li>
</ul>
<p>造成代码膨胀的一个典型的例子： <strong>template class 成员依赖 template 参数值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 典型例子</span><br><span class="line">template &lt;typename T, std::size_t n&gt;</span><br><span class="line">class SquareMatrix &#123;</span><br><span class="line">  public:</span><br><span class="line">    void invert();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;double, 5&gt; m1;</span><br><span class="line">SquareMatrix&lt;double, 10&gt; m2;</span><br></pre></td></tr></table></figure>

<p>会具现两份非常相似的代码，因为除了一个参数 5，一个参数 10，其他都完全一样</p>
<p><strong>改进</strong>一<strong>使用带参数值的函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SquareMatrixBase &#123;</span><br><span class="line">  protected:            // protected 保证只有本类/子类本身可以调用</span><br><span class="line">    void invert(std::size_t n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, std::size_t n&gt;</span><br><span class="line">class SquareMatrix  : private SquareMatrixBase&lt;T&gt; &#123; // private继承，derived 和base不是is-a关系，base只是帮助实现derived </span><br><span class="line">  private:</span><br><span class="line">    using SquareMatrixBase&lt;T&gt;::invert;  // derived class 会掩盖template base class的函数</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    inline void invert() &#123; this-&gt;invert(n);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，SquareMatrixBase 只对 “矩阵元素对象的类型” 参数化，不对矩阵的尺寸参数化。因此对于某给定元素类型，所有矩阵共享同一个 SquareMatrixBase 类。<br>SquareMatrixBase::invert 只是企图成为 “避免派生类代码重复” 的一种方法，所以它<strong>用 protected 替换 public</strong>。调用它而造成的额外成本应该是 0(因此派生类的 invert 调用基类版本的 invert 时是 inline 调用)。这里函数使用<code>this-&gt;</code>，否则<strong>模板化基类的函数名称会被派生类掩盖</strong>。注意这里是 <strong>private 继承</strong>，说明了这里的基类只是为了帮助派生类的实现，不是为了表现 SquareMatrixBase 和 SquareMatrix 的 is-a 关系。</p>
<p>目前为止一切都好，但还有一些问题没有解决：</p>
<p>SquareMatrixBase::invert 如何知道该操作什么数据？<br>虽然它从参数中知道矩阵尺寸，但它如何知道哪个矩阵的数据在哪儿？想必只有派生类知道。<br>派生类如何联络其基类做逆运算动作？</p>
<p>解决办法： <strong>令 SquareMatrixBase 存储一个指针，指向矩阵数值所在的内存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SquareMatrixBase &#123;</span><br><span class="line">public:</span><br><span class="line">    SquareMatrixBase(std::size_t InN, T* InData): N(InN), Data(InData) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void Invert() const &#123;</span><br><span class="line">        std::cout &lt;&lt; N &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::size_t N;  // 矩阵的大小</span><br><span class="line">    T* Data;        // 指向矩阵内容</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, size_t N&gt;</span><br><span class="line">class SquareMatrix : private SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    SquareMatrix()</span><br><span class="line">        : SquareMatrixBase&lt;T&gt;(N, Data) &#123;</span><br><span class="line">        Data = new T[N * N];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Invert() &#123;</span><br><span class="line">        SquareMatrixBase&lt;T&gt;::Invert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T* Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void TryWithMatrix() &#123;</span><br><span class="line">    SquareMatrix&lt;int, 5&gt; SquareMatrixFive;</span><br><span class="line">    SquareMatrixFive.Invert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是把每一个矩阵的数据放进 heap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, std::size_t n&gt;</span><br><span class="line">class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">    SquareMatrix () :  </span><br><span class="line">     SquareMatrixBase&lt;T&gt;(n, 0),             //将基类的数据指针设为null</span><br><span class="line">     pData(new T[n * n])   // 为矩阵内容分配内存, 将指向该内存的指出存储起来</span><br><span class="line">     &#123;this-&gt;setDataPtr(pData.get();)&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    boost::scoped_array&lt;T&gt;pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个条款只讨论由 non-type template parameters(非类型模板参数) 带来的膨胀，其实 type parameters (类型参数) 也会导致膨胀。</p>
<ol>
<li>比如在很多平台上，int 和 long 有相同的二进制表述，所以 <code>vector&lt;int&gt;</code> 和 <code>vector&lt; long &gt;</code> 的成员函数可能完全相同。  </li>
<li>同样的，大多数平台上，所有指针类型都有相同的二进制表述，因此凡模板持有指针者 (比如 <code>list&lt; int&gt;</code>、<code>list&lt; const int &gt;</code> 等)往往应该对每一个成员使用唯一一份底层实现。  </li>
<li>也就是说，如果你实现成员函数而它们操作强类型指针（T），你应该令它们调用另一个无类型指针 (void) 的函数，由后者完成实际工作。</li>
</ol>
<p>总结:</p>
<ol>
<li>Templates 生成多个 classes 和多个 functions，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li>
</ol>
<h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><p>所谓智能指针（smart pointer），是行为像指针的对象，并提供指针没有的机能：自动管理资源。但原始指针（raw pointer）做的很好的一件事是：支持隐式转换（implicit conversions）。比如 derived class 指针可以隐式转换为 base class 指针，指向 non-const 的指针可以转换为 指向 const 的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Top &#123;...&#125;</span><br><span class="line">class Middle: public Top &#123;...&#125;</span><br><span class="line">class Bottom:public Middle &#123;...&#125;</span><br><span class="line">Top* pt1 = new Middle;    //将Middle*转换为Top*</span><br><span class="line">Top* pt2 = new Bottom;    //将Bottom*转换为Top*</span><br><span class="line">const Top* pct2 = pt1;      //将Top*转换为const Top*</span><br></pre></td></tr></table></figure>

<p>而对于 template 具现的类，并不能很好的进行像原始指针一样的隐式转换，比如想把一个具现类转换为另一个具现类，这是不可以的，它们不存在像 derived-base 一样的关系，它们是完全不同的类。<strong>唯一的方式就是我们明确的编写构造函数。</strong></p>
<p>也许我们可以对于某个具现类，编写特定的构造函数去变成另一个具现类，但这存在一个问题。因为一个 template 可以被无限的具现，意味着我们要提供无限的构造函数。因此，更好的解决方法是：<strong>为它编写一个模板构造函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SmartPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    SmartPtr(const SmartPtr&lt;U&gt;&amp; Other) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但并不是所有的构造行为都是我们期望的，<strong>我们必须有能力对模板构造函数进行筛选和剔除</strong>。条款 41 提及的隐式接口是值得注意的，我们可以结合这点去进行约束。良好的接口设计可以避免不必要的构造，比如 shared_ptr 的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AutoPtr&#123;&#125;;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class WeakPtr&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SharedPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    explicit SharedPtr(Y* InPointer);</span><br><span class="line"></span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    explicit SharedPtr(SharedPtr&lt;Y&gt; const&amp; InR);</span><br><span class="line"></span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    explicit SharedPtr(WeakPtr&lt;Y&gt; const&amp; InR);</span><br><span class="line"></span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    explicit SharedPtr(AutoPtr&lt;Y&gt;&amp; InR);</span><br><span class="line"></span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    SharedPtr&amp; operator=(SharedPtr&lt;Y&gt; const&amp; InR);</span><br><span class="line"></span><br><span class="line">    template &lt;typename Y&gt;</span><br><span class="line">    SharedPtr&amp; operator=(AutoPtr&lt;Y&gt;&amp; InR);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>明确指出了可以进行转换的类型，要比上个版本的转换函数安全且容易甄别错误。此外，还可以看出，模板函数还可以被用于赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class shared_ptr &#123;</span><br><span class="line">public:</span><br><span class="line"> shared_ptr(T* ptr);  // 构造</span><br><span class="line"> shared_ptr(const shared_ptr&amp; ptr); // 拷贝构造</span><br><span class="line"> // 下面的泛化拷贝构造函数没有使用explicit，因为derived-&gt;base支持隐式转换</span><br><span class="line"> // 成员初始化列表使用U* ptr 赋值给T* ptr_,只有U-&gt;T存在隐式类型转换，此处才能编译成功，</span><br><span class="line"> // 正好满足Dervied可以转化为Base,反向却不行的约束</span><br><span class="line"> template&lt;U&gt;   // 泛化拷贝构造</span><br><span class="line"> shared_ptr(const shared_ptr&lt;U&gt;&amp; ptr) : ptr_(ptr.get()); </span><br><span class="line"> shared_ptr&amp; operator=(shared_ptr const&amp; ptr); // 拷贝赋值</span><br><span class="line"> template&lt;U&gt;  // 泛化拷贝赋值</span><br><span class="line"> shared_ptr&amp; operator=(shared_ptr&lt;U&gt; const&amp; ptr);</span><br><span class="line"> T* get() &#123;return ptr_&#125;;</span><br><span class="line">private:</span><br><span class="line"> T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>提及构造函数，其实模板构造函数并不会影响语言规则，如果你的程序需要一个拷贝构造函数，而你却没有声明它。编译器依旧会为你生成一个。尽管你已经声明了模板构造函数，但那是只对泛化类型而言的，如果你对一个非泛化类型机型拷贝构造，模板函数就失去了作用。所以最好的方式是：<strong>同时提供模板构造函数和正常构造函数。</strong></p>
<p>总结：</p>
<ol>
<li><strong>请使用 member function templates（成员函数模板）生成可接受所有兼容类型的函数。</strong></li>
<li><strong>如果你声明 member templates 用于泛化 copy 构造 或 泛化 assignment 操作，你还是需要声明正常的 copy 构造函数和 copy assignment 操作符。</strong></li>
</ol>
<h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>学习本条款前建议先熟悉一下条款 24。</p>
<p>条款 24 讨论了为什么只有 non-member 函数才有能力在所有实参身上实施隐式类型转换。那么，如果是 class template 情况下又会发生什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TRational &#123;</span><br><span class="line">public:</span><br><span class="line">    TRational(const T&amp; mNumerator, const T&amp; mDenominator):</span><br><span class="line">        Numerator(mNumerator), Denominator(mDenominator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    T GetNumerator() const &#123;</span><br><span class="line">        return Numerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T GetDenominator() const &#123;</span><br><span class="line">        return Denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T Numerator;</span><br><span class="line">    T Denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline TRational&lt;T&gt; operator*(const TRational&lt;T&gt;&amp; RationalOne, const TRational&lt;T&gt;&amp; RationalTwo) &#123;</span><br><span class="line">    return TRational&lt;T&gt;(RationalOne.GetNumerator() * RationalTwo.GetNumerator(),</span><br><span class="line">                     RationalOne.GetDenominator() * RationalTwo.GetDenominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void TryWithTRational() &#123;</span><br><span class="line">    const TRational&lt;int&gt; TempOne(1, 8);</span><br><span class="line">    const TRational&lt;int&gt; TempTwo(1, 2);</span><br><span class="line">    TRational&lt;int&gt; Result = TempOne * TempTwo; //很好</span><br><span class="line">    Result = Result * TempOne; //很好</span><br><span class="line">    Result = Result * 2; //错误</span><br><span class="line">    Result = 2 * Result; //错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像条款 24 所期望的那样，我们希望支持混合式算术运算。所以我们希望这段代码也能通过编译并正确运行，毕竟这段代码相比于条款 24 的代码，唯一不同的是 Rational 和 operator * 如今都成了 templates。<br>但事与愿违， 由于模板化带来了一些不同，导致编译器无法找到相应的函数进行调用，致使编译失败。<br>实际上编译器试图想出什么函数被名为 operator* 的 template 具现化。它知道它们应该可以 <em><em>“具现化某个名为 operator</em> 并接受两个 TRational 的参数”</em>* 的函数，但为了完成这一具现化的任务，它必须先算出 T 是什么。问题就在于它没有这个能力。<br>以 Result * 2 为例，Result 是一个类型为 TRational 的参数，所以编译器可以得知 T 为 int 。其他的参数就没这样顺利，2 是一个 int ，编译器如何从 int 推算出 TRational 的 T 是什么类型呢？你也许期待编译器用 TRational 进行构造，但这是不行的，因为在 template 实参推导过程中：<strong>从不将隐式类型转换函数纳入考虑。因为相应的隐式转换函数也需要知道 T 是什么类型才能被具现化。</strong></p>
<p>解决方法：<strong>template class 内的 friend 声明式可以指涉某个特定函数</strong>。</p>
<p>这意味 class Rational 可以声明 operator * 是它的一个 friend 函数。Class templates 并不倚赖 template 实参推导（后者只施行于 function templates 身上），所以<strong>编译器总是能够在 class Rational 具现化时得知 T</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TRational &#123;</span><br><span class="line">public:</span><br><span class="line">    friend TRational&lt;T&gt; operator*(const TRational&lt;T&gt;&amp; RationalOne, const TRational&lt;T&gt;&amp; RationalTwo);</span><br><span class="line">    //...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline TRational&lt;T&gt; operator*(const TRational&lt;T&gt;&amp; RationalOne, const TRational&lt;T&gt;&amp; RationalTwo) &#123;</span><br><span class="line">    return TRational&lt;T&gt;(RationalOne.GetNumerator() * RationalTwo.GetNumerator(),</span><br><span class="line">                     RationalOne.GetDenominator() * RationalTwo.GetDenominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void TryWithTRational() &#123;</span><br><span class="line">    const TRational&lt;int&gt; TempOne(1, 8);</span><br><span class="line">    const TRational&lt;int&gt; TempTwo(1, 2);</span><br><span class="line">    TRational&lt;int&gt; Result = TempOne * TempTwo; //很好</span><br><span class="line">    Result = Result * TempOne; //很好</span><br><span class="line">    Result = Result * 2;//OK</span><br><span class="line">    Result = 2 * Result; //Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 这段代码虽然可以通过编译，但是仍会有<strong>链接错误</strong>（稍后再说）<br>现在对<code>operator*</code>的混合式调用可以通过编译了，因为当对象 Result 被声明为一个 TRational，class TRational 于是被具现化出来，而作为过程的一部分，friend 函数<code>operator*</code>（接受 TRational 参数）也就被自动声明出来。 后者身为一个函数而非函数模板（function template），因此编译器可在调用它时使用隐式转换函数（例如 TRational 的 non-explicit 构造函数），而这便是混合式调中之所以成功的原因。<br>小技巧：当一个 class template 内，template 名称可以作为 template 声明 的简略表达形式，所以在 TRational 我们可以只写 Rational 而不必写 TRational，对于有很多参数的 template，这样可以节省一些时间，并让代码看起来干净，当然为了一致性，意义也并不大：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TRational &#123;</span><br><span class="line">public:</span><br><span class="line"> friend TRational operator*(const TRational&amp; RationalOne, const TRational&amp; RationalTwo);</span><br><span class="line"> //...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>那为什么会有链接错误呢？</strong></p>
<p>这是因为编译器虽然知道要调用这个函数，但该函数只被用 <strong>friend 声明于 template 内，并没有实际定义</strong>。可惜的是虽然声明式知道了 T 是 int，但是类外的函数模板仍不知道，因为它们并无实际关系。</p>
<p>解决办法就是：<em><em>将 operator</em> 的函数体从类外合并到 template 声明式中</em>* 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TRational &#123;</span><br><span class="line">public:</span><br><span class="line">    TRational(const T&amp; mNumerator =0, const T&amp; mDenominator=1):</span><br><span class="line">        Numerator(mNumerator), Denominator(mDenominator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    T GetNumerator() const &#123;</span><br><span class="line">        return Numerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T GetDenominator() const &#123;</span><br><span class="line">        return Denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    friend TRational operator*(const TRational&amp; RationalOne, const TRational&amp; RationalTwo) &#123;</span><br><span class="line">        return TRational&lt;T&gt;(RationalOne.GetNumerator() * RationalTwo.GetNumerator(),</span><br><span class="line">                 RationalOne.GetDenominator() * RationalTwo.GetDenominator());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T Numerator;</span><br><span class="line">    T Denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void TryWithTRational() &#123;</span><br><span class="line">    const TRational&lt;int&gt; TempOne(1, 8);</span><br><span class="line">    const TRational&lt;int&gt; TempTwo(1, 2);</span><br><span class="line">    TRational&lt;int&gt; Result = TempOne * TempTwo; //很好</span><br><span class="line">    Result = Result * TempOne; //很好</span><br><span class="line">    Result = Result * 2;//编译ok，运行ok too</span><br><span class="line">    Result = 2 * Result; //编译ok，运行ok too</span><br><span class="line">&#125;</span><br><span class="line">//终于，混合式运算的问题得到了解决！</span><br></pre></td></tr></table></figure>

<p>该解决方法的有趣之处在于：</p>
<p>虽然我们使用 friend 关键字，却和其传统用途：访问 class 的 non-public 成分不同。我们是<strong>为了让类型转换发生在所有可能的实参上，我们需要一个 non-member 函数</strong>，而<strong>为了使这个函数自动具现化，我们需要将它声明在 class 内部</strong>，而在 class 内部声明 non-member 函数的唯一有效方法就是：<strong>令它成为一个 friend。</strong></p>
<p>优化： <strong>令该 friend 函数调用另一个辅助函数</strong></p>
<p>一如条款 30 所说，<strong>定义于 class 内的函数都暗自成为 inline</strong>，包括像<code>operator*</code>这样的 friend 函数。你可以将这样的 inline 声明所带来的冲击最小化，做法是令<code>operator*</code>不做任何事情，<strong>只调用一个定义于 class 外部的辅助函数</strong>。在本条款的例子中，这样做并没有太大意义，因为<code>operator*</code>已经是个单行函数，但对更复杂的函数而言，那么做也许就有价值。“令 friend 函数调用辅助函数” 的做法的确值得细究一番。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TRational &#123;</span><br><span class="line">public:</span><br><span class="line">    friend TRational operator*(const TRational&amp; RationalOne, const TRational&amp; RationalTwo) &#123;</span><br><span class="line">        return OnMultiply(RationalOne,RationalTwo);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">TRational&lt;T&gt; OnMultiply(const TRational&lt;T&gt;&amp; RationalOne, const TRational&lt;T&gt;&amp; RationalTwo)&#123;</span><br><span class="line">    return TRational&lt;T&gt;(RationalOne.GetNumerator() * RationalTwo.GetNumerator(),</span><br><span class="line">                     RationalOne.GetDenominator() * RationalTwo.GetDenominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><strong>当我们编写一个 class template，而它所提供之与此 template 相关的函数支持所有参数隐式类型转换时，请将那些函数定义为 class template 内部的 friend 函数。</strong></li>
</ol>
<h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>第一次看该条款时，觉得云里雾里模模糊糊的，于是查了很多资料，其中觉得这一篇文章讲的最为清晰，由浅入深，结合书本一起看效果极佳。</p>
<p><a href="https://link.zhihu.com/?target=http://t.csdn.cn/eAPtl">原文链接：http://t.csdn.cn/eAPtl</a><br>除此之外还强烈建议阅读：<a href="https://link.zhihu.com/?target=http://t.csdn.cn/X2Hug">http://t.csdn.cn/X2Hug</a> 以及 Cpp 技术文章 08</p>
<p>注意：看本条款时请先熟悉<strong>模板特化</strong>、<strong>偏特化</strong>以及 <strong>typename 关键字</strong>。</p>
<p>我们知道，在 STL 中，容器与算法是分开的，彼此独立设计，容器与算法之间通过迭代器联系在一起。那么，算法是如何从迭代器类中萃取出容器元素的类型的？没错，这正是我们要说的 traits classes 的功能。 迭代器所指对象的类型，称为该迭代器的 value_type。我们来简单模拟一个迭代器 traits classes 的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class IterT&gt;</span><br><span class="line">struct my_iterator_traits &#123;</span><br><span class="line">    typedef typename IterT::value_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>my_iterator_traits 其实就是个类模板，其中包含一个类型的声明。有<code>typename</code>的基础，相信大家不难理解 <code>typedef typename IterT::value_type value_type;</code> 的含义：将迭代器的<code>value_type</code> 通过<code>typedef</code> 为 <code>value_type</code>。</p>
<p>对于<code>my_iterator_traits</code>，我们再声明一个偏特化版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class IterT&gt;</span><br><span class="line">struct my_iterator_traits&lt;IterT*&gt; &#123;</span><br><span class="line">    typedef IterT value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即如果 <code>my_iterator_traits</code> 的实参为指针类型时，直接使用指针所指元素类型作为 <code>value_type</code>。</p>
<p>为了测试 <code>my_iterator_traits</code> 能否正确萃取迭代器元素的类型，我们先编写以下的测试函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void fun(int a) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;fun(int) is called&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(double a) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;fun(double) is called&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(char a) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;fun(char) is called&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过函数重载的方式，来测试元素的类型。</p>
<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_iterator_traits&lt;vector&lt;int&gt;::iterator&gt;::value_type a;</span><br><span class="line">fun(a);  // 输出 fun(int) is called</span><br><span class="line">my_iterator_traits&lt;vector&lt;double&gt;::iterator&gt;::value_type b;</span><br><span class="line">fun(b);  // 输出 fun(double) is called</span><br><span class="line">my_iterator_traits&lt;char*&gt;::value_type c;</span><br><span class="line">fun(c);  // 输出 fun(char) is called</span><br></pre></td></tr></table></figure>

<p>为了便于理解，我们这里贴出 vector 迭代器声明代码的简化版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, ...&gt;</span><br><span class="line">class vector &#123;</span><br><span class="line">public:</span><br><span class="line">    class iterator &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef T value_type;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来解释 <code>my_iterator_traits::iterator&gt;::value_type a;</code> 语句的含义。<code>vector::iterator</code> 为<code>vector</code> 的迭代器，该迭代器包含了 <code>value_type</code> 的声明，由 vector 的代码可以知道该迭代器的<code>value_type</code> 即为 int 类型。</p>
<p>接着，<code>my_iterator_traits::iterator&gt;</code> 会采用 <code>my_iterator_traits</code> 的通用版本，即 <code>my_iterator_traits::iterator&gt;::value_type</code> 使用 <code>typename IterT::value_type</code> 这一类型声明，这里 <code>IterT</code> 为 <code>vector::iterator</code>，故整个语句萃取出来的类型为 int 类型。</p>
<p>对 double 类型的 vector 迭代器的萃取也是类似的过程。<br>而<code>my_iterator_traits&lt;char*&gt;::value_type</code>则使用<code>my_iterator_traits</code>的偏特化版本，直接返回 char 类型。<br>由此看来，通过<code>my_iterator_traits</code>，我们正确萃取出了迭代器所指元素的类型。</p>
<p>总结一下我们设计并实现一个 traits class 的过程：</p>
<p>1）确认若干我们希望将来可取得的类型相关信息，例如，对于上面的迭代器，我们希望取得迭代器所指元素的类型；<br>2）为该信息选择一个名称，例如，上面我们起名为 value_type；<br>3）提供一个 template 和一组特化版本（例如，我们上面的 my_iterator_traits），内容包含我们希望支持的类型相关信息。</p>
<h3 id="条款-48：认识-template-元编程"><a href="#条款-48：认识-template-元编程" class="headerlink" title="条款 48：认识 template 元编程"></a>条款 48：认识 template 元编程</h3><p><strong>template metaprogramming（TMP，模板元编程）</strong>：编写 template C++ 程序并执行于编译期的过程。</p>
<p>所谓模板元程序就是：<strong>以 C++ 写成，执行于 C++ 编译器内的程序</strong>。该程序执行后产生具现的代码，和正常代码一并加入编译。即元编程可以做到<strong>用代码去生成代码</strong>。</p>
<p>由于 template metaprograms <strong>执行于 C++ 编译期</strong>，因此可以将很多工作从运行期转移到编译期。如：</p>
<p>某些错误原本通常在运行期才能检测到，现在可在编译器找出来。<br>使用 TMP 的 C++ 程序可能在每一方面都更加高效：比如较小的可执行文件，较短的运行期，较少的内存需求。<br>注意：将工作移至编译期，会<strong>导致编译时间变长</strong></p>
<p>条款 47 实现一个 Move 函数的伪代码 , 曾提到可能存在编译问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename IteratorType&gt;</span><br><span class="line">    void Move(IteratorType&amp; Iterator, int Distance) &#123;</span><br><span class="line">        // 使用类型信息</span><br><span class="line">        if (typeid(IteratorTraits&lt;IteratorType&gt;::IteratorTag) == typeid(RandomAccessIteratorTag)) &#123;   </span><br><span class="line">            Iterator += Distance; //针对random access 迭代器使用迭代器算术运算</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (Distance &gt;= 0) &#123;  //针对其他迭代器类型,反复调用＋＋或－－</span><br><span class="line">                while (Distance--)++Iterator;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (Distance++)--Iterator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们这里根据迭代器类型进行不同的操作，或 +&#x3D;，或 ++，–，我们知道只有 Random Access Iterator 可以有 +&#x3D; 运算，但是 C++ 要求：<strong>编译器必须确保所有源码都有效，即使是不会执行的源码。</strong>也就是说编译器会拿着其他不支持 +&#x3D; 的迭代器，进入 if 语句先测试是否支持 +&#x3D; 运算，无效则会报错。<br>所以相比于要支持所有操作，Traits class 针对不同类型进行函数重载的做法显然更好。</p>
<p>TMP 已被证明是一个图灵完备（Turing-complete）机器</p>
<p>这意味着它可以计算任何事物，使用 TMP 你可以声明变量，执行循环，编写及调用函数… 但这些相对于正常的 C++ 的实现会有很大的不同。比如：TMP 并没有循环部件，所有的循环效果都由递归完成。</p>
<p>一个经典的初级案例—— 利用 TMP 在编译期计算阶乘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;unsigned N&gt;</span><br><span class="line">struct Factorial &#123;</span><br><span class="line">    static const int Value = N * Factorial&lt;N - 1&gt;::Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">struct Factorial&lt;0&gt; &#123;</span><br><span class="line">    static const int Value = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void TryWithFactorial() &#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;10&gt;::Value &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和所有递归行为一样，我们<strong>需要一个特殊情况来结束递归</strong>。对于 TMP 而言就是<strong>使用 tmeplate 的特化版本</strong> Factorial&lt;0&gt; 。 正如 TryWithFactorial 函数所使用的，只要你声明 Factorial::Value 就可以得到 N 阶乘值。当然这里存在值溢出的问题。</p>
<p>总结：</p>
<ol>
<li>Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP 可被用来生成基于政策选择组合（based on combination of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。</li>
</ol>
<h1 id="八、定制-new-和-delete"><a href="#八、定制-new-和-delete" class="headerlink" title="八、定制 new 和 delete"></a>八、定制 new 和 delete</h1><p>TODO</p>
<h3 id="条款-49：了解-new-handler-行为"><a href="#条款-49：了解-new-handler-行为" class="headerlink" title="条款 49：了解 new-handler 行为"></a>条款 49：了解 new-handler 行为</h3><p>当你调用 operator new 函数，程序无法满足某一内存需求时，它会抛出异常。老旧的编译器会返回 null 指针。而抛出异常之前，程序会先调用一个 operator new 错误处理函数，名叫 <code>new-handler</code>。</p>
<p><strong>new-handler 是一个 typedef</strong>，指向一个无参数值无返回值的函数。我们可以通过 set_new_handler 函数去指定客户想要的 new-handler。<br>set_new_handler 函数接受一个新的 new-handler 参数，返回被替换掉的 new-handler 函数。</p>
<p>一个设计良好的 new-handler 函数必须考虑以下几点：</p>
<ol>
<li><strong>提供更多的可被使用的内存。</strong>这可以保证下次在 operator new 内部尝试分配内存时能够成功。实现这个策略的一种方法是在程序的开始阶段分配一大块内存，然后在第一次调用 new-handler 的时候释放它。  </li>
<li>安装一个不同的 new-handler。如果当前的 new-handler 不能够为你提供更多的内存，可能另外一个 new-handler 可以。如果是这样，可以在当前的 new-handler 的位置上安装另外一个 new-handler（通过调用 set_new_handler）。下次 operator new 调用 new-handler 函数的时候，它会调用最近安装的。（这个主题的一个变种是一个使用 new_handler 来修改它自己的行为，所以在下次触发这个函数的时候，它就会做一些不同的事情。达到这个目的的一个方法是让 new_handler 修改影响 new-handler 行为的 static 数据, 命名空间数据或者全局数据。）  </li>
<li>卸载 new-handler，也就是为 set_new_handler 传递 null 指针。如果没有安装 new-handler，operator new 在内存分配失败的时候会抛出异常。  </li>
<li>抛出 bad-alloc，或派生自 bad-alloc 的异常。  </li>
<li>没有返回值，<strong>调用 abort 或者 exit</strong>。</li>
</ol>
<p>有时候你或许希望以不同的方式处理内存分配的情况，比如按不同的 class 进行处理，但是 C++ 并不支持为每一个 class 提供专属版本的 new_handler，好在我们可以模仿这一行为，只要我们为 class 实现自己的 set_new_handler 函数 和 operator new 函数即可。</p>
<ul>
<li>对于 set_new_handler ，我们根据参照默认实现即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static std::new_handler SetNewHandler(std::new_handler NewHandler) throw() &#123;</span><br><span class="line">        const std::new_handler OldHandler=std::set_new_handler(NewHandler);</span><br><span class="line">        CurrentHandler=OldHandler;</span><br><span class="line">        return OldHandler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 operator new，我们要做以下事情。</li>
</ul>
<p>调用标准版 set_new_handler 安装我们自定义的 new-handler，将返回的标准版 new-handler 保存起来。 调用标准版 operator new。如果标准版 operator new 异常，那么会调用我们自定义的 new-handler 处理函数。 调用标准版 set_new_handler 重新安装标准版的 new-handler。</p>
<p>为了确保可以重新安装标准版 new-handler，我们可以采用条款 13 所说<code>以对象管理资源</code>的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class NewController &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit NewController(std::new_handler InHandler): Handler(InHandler) &#123;&#125;</span><br><span class="line">​</span><br><span class="line">    ~NewController() &#123;</span><br><span class="line">        std::set_new_handler(Handler);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">private:</span><br><span class="line">    std::new_handler Handler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以 operator new 实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void* operator new(std::size_t Size) throw(std::bad_alloc) &#123;</span><br><span class="line">    NewController(std::set_new_handler(CurrentHandler));</span><br><span class="line">    return ::operator new(Size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述代码还是不够简洁，每一个 class 都要自己实现一个 set_new_handler 和 operator new 版本。一个更好的方式是<code>使用 template 进行模板编程，然后根据不同 class 进行特化和具现化</code>。完整实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class NewHandlerSupport &#123;</span><br><span class="line">public:</span><br><span class="line">    static std::new_handler SetNewHandler(std::new_handler NewHandler) throw() &#123;</span><br><span class="line">        const std::new_handler OldHandler = std::set_new_handler(NewHandler);</span><br><span class="line">        CurrentHandler = OldHandler;</span><br><span class="line">        return OldHandler;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    void* operator new(std::size_t Size) throw(std::bad_alloc) &#123;</span><br><span class="line">        NewController(std::set_new_handler(CurrentHandler));</span><br><span class="line">        return ::operator new(Size);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static std::new_handler CurrentHandler;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">std::new_handler  NewHandlerSupport&lt;T&gt;::CurrentHandler = nullptr;</span><br><span class="line">​</span><br><span class="line">class FDemo:public  NewHandlerSupport&lt;FDemo&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">inline void TryWithNew() &#123;</span><br><span class="line">    FDemo::SetNewHandler([]() &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;内存不够啦&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    FDemo *Demos=new FDemo[1000123123100000]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>当 operator new 无法满足内存申请时，它会不断调用 new-handler 函数，直到找到足够内存或异常退出。</strong> 当然，你想说为什么我们需要 template？我们似乎并没有使用到模板参数，是的，T 的确不被需要，我们只是希望，继承自 NewHandlerSupport 的 class 拥有各自的 CurrentHandler 成员。类型参数只是用来区分不同的派生类，<strong>然后 template 机制会自动为每一个 T 具现化一份 CurrentHandler 成员，即使它是 static 的。</strong> 也许你的焦虑还来自于 template class 导致的多重继承，可以先看看条款 40。</p>
<p>总结：</p>
<ol>
<li><strong>set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</strong></li>
<li><strong>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</strong></li>
</ol>
<h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a><strong>条款 50：了解 new 和 delete 的合理替换时机</strong></h3><p>替换缺省 new&#x2F;delete 的三个常见原因：</p>
<ol>
<li>用来检测运行上的错误。自定义 new 分配超额内存，在额外空间放置特定签名 &#x2F; byte pattern。在 delete 时检查是否不变；反之，肯定存在 “overruns”（写入点在分配区块尾部之后）或 “unferruns”（写入点在分配区块头部之前），delete 也可 log 那个指针。 2. 为了强化效能。缺省版 new&#x2F;delete 必然比定制版 new&#x2F;delete 效率低。 3. 为了收集使用上的统计数据。自定义 new&#x2F;delete 可以收集内存使用习惯与使用寿命。</li>
</ol>
<p>当一定要写相关 new&#x2F;delete 代码时，参考成熟的开源代码十分必要（条款 54&#x2F;55：TR1 及 Boost 的 Pool 库）。</p>
<p>本条款的主题是，了<strong>解何时可在 “全局性的” 或 “class 专属的” 基础上合理替换缺省的 new 和 delete</strong>。在这之前，先对答案做一些摘要：</p>
<ul>
<li>为了检测运用错误（如前所述）。</li>
<li>为了收集动态分配内存的使用统计信息（如前所述）。</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省内存管理 s 器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位。</li>
<li>为了将相关对象成簇集中。降低 “内存页错误”（page fault）的频率，new&#x2F;delete 的 “placement 版本”（条款 52）有可能完成。</li>
<li>为了获得非传统的行为。</li>
</ul>
<p>总结：</p>
<ol>
<li><strong>有许多理由需要写个自定的 new 和 delete，包括改善性能，对 heap 运用错误进行调用，收集 heap 使用信息。</strong></li>
</ol>
<h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a><strong>条款 52：写了 placement new 也要写 placement delete</strong></h3><p>1.<code>placement new</code> 和 <code>placement delete</code> 在 C++ 中并不常见，如果不熟悉也不用太焦虑。 请回忆一下条款 16 和 17，当你写一个 new 表达式时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String* Str = new String(&quot;Hello&quot;)；</span><br></pre></td></tr></table></figure>

<p>共有两个函数被调用：一个是用以分配内存的 <strong>operator new</strong>，一个是 <strong>String 的 default 构造函数</strong>。<br>假如第一个函数调用成功，第二个函数却抛出异常。那么运行期系统必须回收第一个函数分配的内存，否则就会发生资源泄漏。在这个时候，客户没有能力归还内存，因为如果 String 构造函数抛出异常，str 尚未被赋值，客户手上也就没有指针指向该被归还的内存。取消步骤一并恢复旧观的责任因此落到 C++ 运行期系统身上。 运行期系统就会调用步骤一所调用的 operator new 的相应 operator delete 版本，前提是，<strong>系统必须知道哪一个 operator delete 该被调用</strong>，因为可能存在多个 operator delete 函数（可能接受不同的参数列表）。</p>
<ol start="2">
<li>对于<code>placement new/delete</code> ，它们接受额外的参数 。当人们谈及 placement new 时，大多数是指具有唯一额外实参 void* 的 operator new，少数时候才是指具有任意额外实参的 operator new。</li>
</ol>
<p><strong>当抛出异常时，运行期系统会寻找参数个数和类型都与 operator new 相同的某个 operator delete</strong>。比如 operator new 额外接受一个 string 参数，那么 operator delete 也需要提供一个额外的 string 参数。如果并没有这样的 operator delete 函数，那么系统什么也不会做，内存就会泄漏掉。</p>
<ol start="3">
<li>值得注意的是，<strong>placement delete 只有在 placement new 的调用构造函数异常时才会被系统调用</strong> (即使我们可以显式调用 placement new，)。即使你对一个用 placement new 申请出的指针使用 delete，也绝不会调用 placement delete。这意味着额外的参数并不提供实际的作用。</li>
</ol>
<p>所以，如果要处理 placement new 相关的内存泄漏问题，我们<strong>必须同时提供一个正常版本的 delete 和 placement 版本的 delete</strong>。前者用于构造期间无异常抛出，后者用于构造期间有异常抛出。</p>
<p>除此之外，还要注意<strong>同名函数遮掩调用的问题</strong></p>
<p>当你为 class 声明了 placement new 时，客户是无法使用标准版的 operator new 的，因为 derived class 声明的 operator new 会遮掩标准版本和 base class 版本。 所以如果你需要的客户在使用标准版本不受影响，也<strong>需要同时提供标准版的定义</strong>。</p>
<p>满足以上注意事项的一个简单做法是，<code>建立一个 base class</code>，内含所有标准版本的 new&#x2F;delete，凡是想以写 placement 版本的 class 都可以继承自它，并使用 <code>using 声明式</code>使得标准版本在类中可见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class FNewDeleteSupport &#123;</span><br><span class="line">public:</span><br><span class="line">    // normal new/delete</span><br><span class="line">    static void* operator new (std::size_t Size) throw(std::bad_alloc) &#123;</span><br><span class="line">        return ::operator new(Size);</span><br><span class="line">    &#125;</span><br><span class="line">    static void operator delete (void* RawMemory) throw() &#123;</span><br><span class="line">        ::operator delete(RawMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    //placement new/delete</span><br><span class="line">    static void* operator new (std::size_t Size,void *Ptr) throw() &#123;</span><br><span class="line">        return ::operator new(Size,Ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void operator delete (void* RawMemory,void *Ptr) throw() &#123;</span><br><span class="line">        ::operator delete(RawMemory,Ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    //nothrow new/delete</span><br><span class="line">    static void* operator new (std::size_t Size,const std::nothrow_t&amp; Nothrow) throw() &#123;</span><br><span class="line">        return ::operator new(Size,Nothrow);</span><br><span class="line">    &#125;</span><br><span class="line">    static void operator delete (void* RawMemory,const std::nothrow_t&amp; Nothrow) throw() &#123;</span><br><span class="line">        ::operator delete(RawMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class FDemo:public FNewDeleteSupport &#123;</span><br><span class="line">public:</span><br><span class="line">    using FNewDeleteSupport::operator new;</span><br><span class="line">    using FNewDeleteSupport::operator delete;</span><br><span class="line">​</span><br><span class="line">    //custom new/delete</span><br><span class="line">    static void* operator new (std::size_t Size,std::string User) throw(std::bad_alloc) &#123;</span><br><span class="line">        std::cout&lt;&lt;User&lt;&lt;&quot;使用了内存&quot;;</span><br><span class="line">        return ::operator new(Size);</span><br><span class="line">    &#125;</span><br><span class="line">    static void operator delete (void* RawMemory,std::string User) throw() &#123;</span><br><span class="line">        ::operator delete(RawMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ol>
<li>当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</li>
<li>当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们的正常版本。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/60457.html">http://liuke101.github.io/post/60457.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/10844.html" title="UE实时渲染"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UE实时渲染</div></div></a></div><div class="next-post pull-right"><a href="/post/42467.html" title="HLSL ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HLSL ShaderLab</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/37796.html" title="STL标准库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="title">STL标准库</div></div></a></div><div><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">模板与泛型编程</div></div></a></div><div><a href="/post/60549.html" title="C++精粹"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-18</div><div class="title">C++精粹</div></div></a></div><div><a href="/post/3834.html" title="Effective Modern C++"><img class="cover" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">Effective Modern C++</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 图片存储在github仓库，建议使用VPN访问本站。 2. 文章摘自个人obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E5%AF%BC%E8%AF%BB"><span class="toc-text">零、导读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8Fdeclaration"><span class="toc-text">声明式declaration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%BC%8Fsignature"><span class="toc-text">函数签名式signature</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%BC%8Fdefinition"><span class="toc-text">定义式definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96initialization"><span class="toc-text">初始化initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3Interface"><span class="toc-text">接口Interface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E5%91%BD%E5%90%8D%E4%B9%A0%E6%83%AF"><span class="toc-text">本书命名习惯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-text">一、让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-text">条款01：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define"><span class="toc-text">条款02：尽量以const,enum,inline 替换 # define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BB%A5%E7%BC%96%E8%AF%91%E5%99%A8%E6%9B%BF%E6%8D%A2%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">尽量以编译器替换预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">特殊情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-hack-%E8%A1%A5%E5%81%BF%E5%81%9A%E6%B3%95"><span class="toc-text">enum hack 补偿做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-inline-%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF-define%E5%AE%8F"><span class="toc-text">template inline 函数代替 define宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><span class="toc-text">条款 03：尽可能使用 const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">条款 04：确定对象使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">二、构造、析构和赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-05%EF%BC%9A%E4%BA%86%E8%A7%A3-C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">条款 05：了解 C++ 默默编写并调用了哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%E3%80%82"><span class="toc-text">条款 06：若不想使用编译器自动生成的函数，就该明确拒绝。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款 07：为多态基类声明 virtual 析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款 08：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0"><span class="toc-text">条款 09：绝不在构造和析构过程中调用 virtual 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-10%EF%BC%9A%E4%BB%A4-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-text">条款 10：令 operator &#x3D; 返回一个 reference to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-11%EF%BC%9A%E5%9C%A8-operator-%E4%B8%AD%E5%A4%84%E7%90%86-%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-text">条款 11：在 operator &#x3D; 中处理 “自我赋值”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-text">条款 12：复制对象时勿忘其每一个成分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">三、资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-text">条款 13：以对象管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83-copying-%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款 14：在资源管理类中小心 copying 行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">条款 15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-text">条款 16：成对使用 new 和 delete 时要采取相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">条款 17：以独立语句将 newed 对象放入智能指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-text">四、设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%AF%AF%E4%BD%BF%E7%94%A8"><span class="toc-text">条款 18：让接口容易被正确使用，不易误使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-19%EF%BC%9A%E8%AE%BE%E8%AE%A1-class-%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1-type"><span class="toc-text">条款 19：设计 class 犹如设计 type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-20%EF%BC%9A%E4%BB%A5-const-%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E5%8F%82"><span class="toc-text">条款 20：以  const 引用传参，而不应该是按值传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><span class="toc-text">条款 21：必须返回对象时，别妄想返回其 reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA-private"><span class="toc-text">条款 22：将成员变量声明为 private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E3%80%81%E9%9D%9E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 23：宁以非成员、非友元函数替换成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 24：若所有参数皆需类型转换，请为此采用非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E2%80%94%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="toc-text">条款 25: 考虑写出—个不抛异常的 swap 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">五、实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">条款 26：尽可能延后变量定义式出现的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-text">条款 27: 尽量少做转型动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E-handles-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-text">条款 28：避免返回 handles 指向对象内部成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-29-%E4%B8%BA-%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D-%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-text">条款 29: 为 “异常安全” 而努力是值得的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3-inlining-%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-text">条款 30：透彻了解 inlining 的里里外外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-text">条款 31：将文件间的编译依存关系降至最低</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">六、继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E4%BF%9D%E8%AF%81%E4%BA%86-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-text">条款 32：确定你的 public 继承保证了 is-a 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款 33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35%EF%BC%9A%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-text">条款 35：考虑 virtual 函数以外的其他选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="toc-text">条款 36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">条款 37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E8%86%9C%E5%87%BA-has-a-%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%88%96-%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-text">条款 38：通过复合塑膜出 has-a 关系，或 “根据某物实现出”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 39：明智而审慎地使用 private 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 40：明智而审慎地使用多继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">七、模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%9A%E6%80%81"><span class="toc-text">条款 41：了解隐式接口和编译器多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">条款 42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款 43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-templates"><span class="toc-text">条款 44：将与参数无关的代码抽离 templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">条款 45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8-traits-classes-%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">条款 47：请使用 traits classes 表现类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-48%EF%BC%9A%E8%AE%A4%E8%AF%86-template-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">条款 48：认识 template 元编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete"><span class="toc-text">八、定制 new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-49%EF%BC%9A%E4%BA%86%E8%A7%A3-new-handler-%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款 49：了解 new-handler 行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-text">条款 50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-52%EF%BC%9A%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete"><span class="toc-text">条款 52：写了 placement new 也要写 placement delete</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/33227.html" title="《仓鼠球！GO!》"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408242348371.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《仓鼠球！GO!》"/></a><div class="content"><a class="title" href="/post/33227.html" title="《仓鼠球！GO!》">《仓鼠球！GO!》</a><time datetime="2024-08-17T16:00:00.000Z" title="发表于 2024-08-18 00:00:00">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3834.html" title="Effective Modern C++"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250023909.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57053.html" title="Lua精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250021603.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua精粹"/></a><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46645.html" title="GAS精粹"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202408250017189.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAS精粹"/></a><div class="content"><a class="title" href="/post/46645.html" title="GAS精粹">GAS精粹</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>