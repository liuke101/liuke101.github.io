<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective Modern C++ | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第 1 章类型推导C++98 有一套类型推导的规则：用于函数模板的规则。C++11 修改了其中的一些规则并增加了两套规则，一套用于 auto，一套用于 decltype。C++14 扩展了 auto 和 decltype 可能使用的范围。 类型推导随处可见：在函数模板调用中，在大多数 auto 出现的地方，在 decltype 表达式出现的地方，以及 C++14 中令人费解的应用 decltype">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern C++">
<meta property="og:url" content="http://liuke101.github.io/post/3834.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="第 1 章类型推导C++98 有一套类型推导的规则：用于函数模板的规则。C++11 修改了其中的一些规则并增加了两套规则，一套用于 auto，一套用于 decltype。C++14 扩展了 auto 和 decltype 可能使用的范围。 类型推导随处可见：在函数模板调用中，在大多数 auto 出现的地方，在 decltype 表达式出现的地方，以及 C++14 中令人费解的应用 decltype">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2024-01-18T04:20:00.000Z">
<meta property="article:modified_time" content="2024-08-07T17:04:52.277Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/3834.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective Modern C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-08 01:04:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective Modern C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-07T17:04:52.277Z" title="更新于 2024-08-08 01:04:52">2024-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>108分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective Modern C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/3834.html#post-comment"><span class="waline-comment-count" data-path="/post/3834.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第-1-章类型推导"><a href="#第-1-章类型推导" class="headerlink" title="第 1 章类型推导"></a>第 1 章类型推导</h1><p>C++98 有一套类型推导的规则：用于函数模板的规则。C++11 修改了其中的一些规则并增加了两套规则，一套用于 <code>auto</code>，一套用于 <code>decltype</code>。C++14 扩展了 <code>auto</code> 和 <code>decltype</code> 可能使用的范围。</p>
<p>类型推导随处可见：在函数模板调用中，在大多数 <code>auto</code> 出现的地方，在 <code>decltype</code> 表达式出现的地方，以及 C++14 中令人费解的应用 <code>decltype(auto)</code> 的地方。</p>
<p>本章解释了模板类型推导是如何工作的，<code>auto</code> 是如何依赖类型推导的，以及 <code>decltype</code> 是如何按照它自己那套独特的规则工作的。它甚至解释了你该如何强制编译器使类型推导的结果可视，这能让你确认编译器的类型推导是否按照你期望的那样进行。</p>
<h2 id="条款一：理解模板类型推导"><a href="#条款一：理解模板类型推导" class="headerlink" title="条款一：理解模板类型推导"></a>条款一：理解模板类型推导</h2><blockquote>
<p>[!NOTE] </p>
<ul>
<li>在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略</li>
<li>对于万能引用的推导，左值实参会被特殊对待</li>
<li>对于传值类型推导，<code>const</code> 和 <code>volatile</code> 实参会被认为是  <code>non-const</code> 的和  <code>non-volatile</code> 的</li>
<li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用</li>
</ul>
</blockquote>
<p><code>auto</code> 是建立在模板类型推导的基础上的。但是当模板类型推导规则应用于 <code>auto</code> 环境时，有时不如应用于 template 时那么直观。由于这个原因，真正理解 <code>auto</code> 基于的模板类型推导的方方面面非常重要。</p>
<p>下面讲解会以该模板为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);                        <span class="comment">//从expr中推导T和ParamType</span></span><br></pre></td></tr></table></figure>

<p>假设 <code>x</code> 是 int 类型，<code>T</code> 被推导为 int。<code>T</code> 的推导类型和 <code>x</code> 类型一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//用变量expr调用f</span></span><br></pre></td></tr></table></figure>

<p>但有时情况并非总是如此，<code>T</code> 的类型推导不仅取决于 <code>expr</code> 的类型，也取决于 <code>ParamType</code> 的类型。这里有三种情况：</p>
<ul>
<li><code>ParamType</code> 是一个指针或引用，但不是万能引用</li>
<li><code>ParamType</code> 是一个万能引用</li>
<li><code>ParamType</code> 既不是指针也不是引用</li>
</ul>
<p>我们下面将分成三个情景来讨论这三种情况</p>
<h3 id="情景一：ParamType-是一个指针或引用，但不是通用引用"><a href="#情景一：ParamType-是一个指针或引用，但不是通用引用" class="headerlink" title="情景一：ParamType 是一个指针或引用，但不是通用引用"></a>情景一：<code>ParamType</code> 是一个指针或引用，但不是通用引用</h3><p>在这种情况下，类型推导会这样进行：</p>
<ol>
<li>如果 <code>expr</code> 的类型是一个引用，忽略引用部分</li>
<li>然后 <code>expr</code> 的类型与 <code>ParamType</code> 进行模式匹配来决定 &#96;T</li>
</ol>
<p>举个例子，如果这是我们的模板，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;               <span class="comment">//ParamType是一个引用</span></span><br></pre></td></tr></table></figure>
<p>我们声明这些变量，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//【情景一】rx是指向作为const int的x的引用</span></span><br></pre></td></tr></table></figure>
<p>在不同的调用中，对 <code>param</code> 和 <code>T</code> 推导的类型会是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//【情景一】T是const int而不是const int&amp;，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>将一个 <code>const</code> 对象传递给以 <code>T&amp;</code> 类型为形参的模板安全的：对象的常量性会被保留为 <code>T</code> 的一部分。</p>
<p><strong>在第三个例子中，注意即使 <code>rx</code> 的类型是一个引用，<code>T</code> 也会被推导为一个非引用，这是因为 <code>rx</code> 的引用性（reference-ness）在类型推导中会被忽略。</strong></p>
<p><strong>如果我们将 <code>f</code> 的形参类型 <code>T&amp;</code> 改为 <code>const T&amp;</code>，情况有所变化</strong>，但不会变得那么出人意料。<code>cx</code> 和 <code>rx</code> 的 <code>const</code> ness 依然被遵守，但是因为现在我们假设 <code>param</code> 是常量引用，<code>const</code> 不再被推导为 <code>T</code> 的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//param现在是reference-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;               <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;              <span class="comment">//【情景一】如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//【情景一】T是int而不是int&amp;，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>同之前一样，<code>rx</code> 的引用性（reference-ness）在类型推导中被忽略了</p>
<p><strong>如果 <code>param</code> 是一个指针（或者指向 <code>const</code> 的指针）而不是引用，情况本质上也一样。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;               <span class="comment">//param现在是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//同之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;             <span class="comment">//【情景一】px是指向作为const int的x的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//【情景一】T是const int而不是const int*，param的类型是const int*</span></span><br></pre></td></tr></table></figure>

<h3 id="情景二：ParamType-是一个万能引用"><a href="#情景二：ParamType-是一个万能引用" class="headerlink" title="情景二：ParamType 是一个万能引用"></a>情景二：<code>ParamType</code> 是一个万能引用</h3><ul>
<li>如果 <code>expr</code> 是左值，<code>T</code> 被推导为左值引用 <code>T&amp;&amp;</code>，<code>ParamType</code> 会发生引用折叠，也被推导为<strong>左值引用</strong>。</li>
<li>如果 <code>expr</code> 是右值，就使用正常的（也就是<strong>情景一</strong>）推导规则</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p><a href="../5.RRefMovSemPerfForw/item24.md">Item24</a> 详细解释了为什么这些例子是像这样发生的。</p>
<h3 id="情景三：ParamType-既不是指针也不是引用"><a href="#情景三：ParamType-既不是指针也不是引用" class="headerlink" title="情景三：ParamType 既不是指针也不是引用"></a>情景三：<code>ParamType</code> 既不是指针也不是引用</h3><p>当 <code>ParamType</code> 既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//以传值的方式处理param</span></span><br></pre></td></tr></table></figure>
<p>这意味着无论传递什么 <code>param</code> 都会成为它的一份拷贝——一个完整的新对象。事实上 <code>param</code> 成为一个新对象这一行为会影响 <code>T</code> 如何从 <code>expr</code> 中推导出结果。</p>
<ol>
<li>和之前一样，如果 <code>expr</code> 的类型是一个引用，忽略这个引用部分</li>
<li>如果忽略 <code>expr</code> 的引用性（reference-ness）之后，<code>expr</code> 是一个 <code>const</code>，那就再忽略 <code>const</code>。如果它是 <code>volatile</code>，也忽略 <code>volatile</code>。（<code>volatile</code> 对象不常见，它通常用于驱动程序的开发中。关于 <code>volatile</code> 的细节请参见 <a href="../7.TheConcurrencyAPI/item40.md">Item40</a>）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T和param的类型都是int</span></span><br></pre></td></tr></table></figure>

<p>注意即使 <code>cx</code> 和 <code>rx</code> 表示 <code>const</code> 值，<code>param</code> 也不是 <code>const</code>。这是有意义的。<code>param</code> 是一个完全独立于 <code>cx</code> 和 <code>rx</code> 的对象——是 <code>cx</code> 或 <code>rx</code> 的一个拷贝， <code>expr</code> 不可修改并不意味着它的拷贝也不能被修改。</p>
<p><strong>⭐注意，只有在传值给形参时才会忽略 <code>const</code>（和 <code>volatile</code>）</strong></p>
<p>考虑这样的情况，<code>expr</code> 是一个 <code>const char* const</code> 指针，通过传值传递给 <code>param</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//仍然以传值的方式处理param</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr =         <span class="comment">//ptr是一个常量指针，指向常量对象 </span></span><br><span class="line">    <span class="string">&quot;Fun with pointers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(ptr);                         <span class="comment">//T和param的类型都是const char*</span></span><br></pre></td></tr></table></figure>
<p>根据类型推导的第三条规则，<code>ptr</code> 自身的常量性将会被省略（即省略后界面的const）</p>
<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>上面的内容几乎覆盖了模板类型推导的大部分内容，但这里还有一些小细节值得注意，<strong>比如数组类型不同于指针类型，虽然它们两个有时候是可互换的</strong>。关于这个错觉最常见的例子是，<strong>在很多上下文中数组会退化为指向它的第一个元素的指针。</strong> 这样的退化允许像这样的代码可以被编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;asdasf&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * ptrToName = name;          <span class="comment">//数组退化为指针</span></span><br></pre></td></tr></table></figure>

<p><strong>在C++中数组形参会视作指针形参：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span> param[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span>* param)</span></span>;    <span class="comment">//等价</span></span><br></pre></td></tr></table></figure>

<p>因为数组形参会视作指针形参，所以传值给模板的一个数组类型会被推导为一个指针类型。这意味着在模板函数 <code>f</code> 的调用中，它的类型形参 <code>T</code> 会被推导为 <code>const char*</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                        <span class="comment">//传值形参的模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;asdasf&quot;</span>;    </span><br><span class="line"><span class="built_in">f</span>(name);                                <span class="comment">//name是一个数组，但是T被推导为const char*</span></span><br></pre></td></tr></table></figure>

<p>但是现在难题来了，虽然函数不能声明形参为真正的数组，但是<strong>可以</strong>接受指向数组的<strong>引用</strong>！所以我们修改 <code>f</code> 为传引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;                       <span class="comment">//传引用形参的模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;asdasf&quot;</span>;    </span><br><span class="line"><span class="built_in">f</span>(name);                                <span class="comment">//传数组给f</span></span><br></pre></td></tr></table></figure>

<p><code>T</code> 被推导为了真正的数组！这个类型包括了数组的大小，在这个例子中 <code>T</code> 被推导为 <code>const char[13]</code>，<code>f</code> 的形参（对这个数组的引用）的类型则为 <code>const char (&amp;)[13]</code>。</p>
<p>有趣的是，可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在编译期间返回一个数组大小的常量值（数组形参没有名字，因为我们只关心数组的大小）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;                     <span class="comment">//关于</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span>      <span class="comment">//constexpr</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                       <span class="comment">//和noexcept</span></span><br><span class="line">    <span class="keyword">return</span> N;                                           <span class="comment">//的信息</span></span><br><span class="line">&#125;                                                       <span class="comment">//请看下面</span></span><br></pre></td></tr></table></figure>

<p>在 <a href="../3.MovingToModernCpp/item15.md">Item15</a> 提到将一个函数声明为 <code>constexpr</code> 使得结果在编译期间可用。这使得我们可以用一个花括号声明一个数组，然后第二个数组可以使用第一个数组的大小作为它的大小，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> keyVals[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">35</span> &#125;;             <span class="comment">//keyVals有七个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mappedVals[<span class="built_in">arraySize</span>(keyVals)];                     <span class="comment">//mappedVals也有七个</span></span><br></pre></td></tr></table></figure>

<p><strong>当然作为一个现代 C++程序员，你自然应该想到使用 <code>std::array</code> 而不是内置的数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, arraySize(keyVals)&gt; mappedVals;         <span class="comment">//mappedVals的大小为7</span></span><br></pre></td></tr></table></figure>

<p>至于 <code>arraySize</code> 被声明为 <code>noexcept</code>，会使得编译器生成更好的代码，具体的细节请参见 <a href="../3.MovingToModernCpp/item14.md">Item14</a>。</p>
<h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3><p><strong>在 C++中不只是数组会退化为指针，函数类型也会退化为一个函数指针，我们对于数组类型推导的全部讨论都可以应用到函数类型推导和退化为函数指针上来。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是一个函数，</span></span><br><span class="line">                                    <span class="comment">//类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                   <span class="comment">//传值给f1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;                  <span class="comment">//传引用给f2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                       <span class="comment">//param被推导为指向函数的指针，</span></span><br><span class="line">                                    <span class="comment">//类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                       <span class="comment">//param被推导为指向函数的引用，</span></span><br><span class="line">                                    <span class="comment">//类型是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<p>这个实际上没有什么不同，但是如果你知道数组退化为指针，你也会知道函数退化为指针。</p>
<p>模板类型推导本身就有很多细节，数组和函数退化为指针更是让其变得复杂。有时你只需要编译器告诉你推导出的类型是什么。 <a href="../1.DeducingTypes/item4.md">item4</a>, 会告诉你如何让编译器这么做。</p>
<h2 id="条款二：理解-auto-类型推导"><a href="#条款二：理解-auto-类型推导" class="headerlink" title="条款二：理解 auto 类型推导"></a>条款二：理解 <code>auto</code> 类型推导</h2><blockquote>
<p>[!NOTE] Title</p>
<ul>
<li><code>auto</code> 类型推导通常和模板类型推导相同，但是 <code>auto</code> 类型推导假定花括号初始化代表 <code>std::initializer_list</code>，而模板类型推导不这样做</li>
<li>在 C++14 中 <code>auto</code> 允许出现在函数返回值或者<em>lambda</em>函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是 <code>auto</code> 类型推导</li>
</ul>
</blockquote>
<p><strong><code>auto</code> 类型推导除了一个例外（花括号初始化），其他情况都和模板类型推导一样。</strong></p>
<h3 id="与模板类型推导的共同点"><a href="#与模板类型推导的共同点" class="headerlink" title="与模板类型推导的共同点"></a>与模板类型推导的共同点</h3><p><code>auto</code> 类型推导和模板类型推导有一个直接的映射关系。它们之间可以通过一个非常规范非常系统化的转换流程来转换彼此。</p>
<p>在 <a href="../1.DeducingTypes/item2.md">Item1</a> 中，模板类型推导使用下面这个函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParmaType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);   <span class="comment">//编译器使用 expr 推导 T 和 ParamType 的类型。</span></span><br></pre></td></tr></table></figure>

<p><strong>当一个变量使用 <code>auto</code> 进行声明时，<code>auto</code> 扮演了模板中 <code>T</code> 的角色，变量的类型说明符扮演了 <code>ParamType</code> 的角色。</strong><br>考虑这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;       <span class="comment">//x的类型说明符是 auto 自己</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x; <span class="comment">//x的类型说明符是 const auto</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx=cx; <span class="comment">//x的类型说明符是 const auto&amp;</span></span><br></pre></td></tr></table></figure>

<p><a href="6%20Effective%20Modern%20C++.md">Item1</a> 基于 <code>ParamType</code> ——在函数模板中 <code>param</code> 的类型说明符——的不同特征，把模板类型推导分成三个部分来讨论。在使用 <code>auto</code> 作为类型说明符的变量声明中，类型说明符代替了 <code>ParamType</code>，因此 Item1 描述的三个情景稍作修改就能适用于auto：</p>
<ul>
<li>情景一：类型说明符是一个指针或引用但不是万能</li>
<li>情景二：类型说明符一个万能引用</li>
<li>情景三：类型说明符既不是指针也不是引用</li>
</ul>
<p><strong><code>auto</code> 类型推导和模板类型推导几乎一样的工作（适用于条款一讨论的所有方面）。</strong></p>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>我们从一个简单的例子开始，如果你想声明一个带有初始值 27 的 <code>int</code>，有多种语法选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> x3 = &#123; <span class="number">27</span> &#125;;</span><br><span class="line"><span class="type">int</span> x4&#123; <span class="number">27</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>但是 <a href="../2.Auto/item5.md">Item5</a> 解释了使用 <code>auto</code> 说明符代替指定类型说明符的好处，所以我们应该很乐意把上面声明中的 <code>int</code> 替换为 <code>auto</code>，我们会得到这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这些声明都能通过编译，但是他们不像替换之前那样有相同的意义。前面两个语句确实声明了一个类型为 <code>int</code> 值为 27 的变量，<strong>但是后面两个声明了一个存储一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code> 类型的变量。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;                   <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;                    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;               <span class="comment">//类型是std::initializer_list&lt;int&gt;，</span></span><br><span class="line">                                <span class="comment">//值是&#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;                  <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>
<p><strong>这就造成了 <code>auto</code> 类型推导不同于模板类型推导的特殊情况。当用 <code>auto</code> 声明的变量使用花括号进行初始化，<code>auto</code> 类型推导推出的类型则为 <code>std::initializer_list&lt;T&gt;</code>。</strong></p>
<p>如果这样的一个类型不能被成功推导（比如花括号里面包含的是不同类型的变量），编译器会拒绝这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;        <span class="comment">//错误！无法推导std::initializer_list&lt;T&gt;中的T</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>x5</code> 使用花括号的方式进行初始化，<code>x5</code> 必须被推导为 <code>std::initializer_list&lt;T&gt;</code>，这个模板会被某种类型 <code>T</code> 实例化，所以这意味着 <code>T</code> 也会被推导。推导落入了这里发生的第二种类型推导——模板类型推导的范围。在这个例子中推导之所以失败，是因为在花括号中的值并不是同一种类型。</p>
<p>对于花括号的处理是 <code>auto</code> 类型推导和模板类型推导唯一不同的地方。当使用 <code>auto</code> 声明的变量使用花括号的语法进行初始化的时候，会推导出 <code>std::initializer_list&lt;T&gt;</code> 的实例化，但是对于模板类型推导这样就行不通：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;;         <span class="comment">//x的类型是std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//带有与x的声明等价的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//形参声明的模板</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);               <span class="comment">//错误！不能推导出T</span></span><br></pre></td></tr></table></figure>
<p>然而如果在模板中指定 <code>T</code> 是 <code>std::initializer_list&lt;T&gt;</code> 而留下未知 <code>T</code>, 模板类型推导就能正常工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);               <span class="comment">//T被推导为int，initList的类型为</span></span><br><span class="line">                                <span class="comment">//std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此 <code>auto</code> 类型推导和模板类型推导的真正区别在于，<code>auto</code> 类型推导假定花括号表示 <code>std::initializer_list</code> 而模板类型推导不会这样（确切的说是不知道怎么办）。</p>
<p><strong>如果你使用花括号的方式进行初始化你就得记住这个例外以免犯错，在 C++11 编程中一个典型的错误就是偶然使用了 <code>std::initializer_list&lt;T&gt;</code> 类型的变量，这个陷阱也导致了很多 C++程序员抛弃花括号初始化，只有不得不使用的时候再做考虑。（在 <a href="../3.MovingToModernCpp/item7.md">Item7</a> 讨论了必须使用时该怎么做）</strong></p>
<p>对于 C++11 故事已经说完了。但是对于 C++14 故事还在继续，<strong>C++14 允许 <code>auto</code> 用于函数返回值并会被推导（参见 <a href="../1.DeducingTypes/item3.md">Item3</a>），而且 C++14 的<em>lambda</em>函数也允许在形参声明中使用 <code>auto</code>。但是在这些情况下 <code>auto</code> 实际上使用<mark style="background: #FFB8EBA6;">模板类型推导</mark>的那一套规则在工作，而不是 <code>auto</code> 类型推导</strong>，所以说下面这样的代码不会通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;         <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在 C++14 的 lambda 函数中这样使用 auto 也不能通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> resetV = </span><br><span class="line">    [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="comment">//C++14</span></span><br><span class="line">…</span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);            <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br></pre></td></tr></table></figure>


<h2 id="条款三：理解-decltype"><a href="#条款三：理解-decltype" class="headerlink" title="条款三：理解 decltype"></a>条款三：理解 <code>decltype</code></h2><p><code>decltype(expr)</code> 会返回表达式的类型。但有时返回的不是我们期望的结果。</p>
<p>暂时略，很容易晕。</p>
<h1 id="第-2-章-auto"><a href="#第-2-章-auto" class="headerlink" title="第 2 章 auto"></a>第 2 章 <code>auto</code></h1><h2 id="条款五：优先考虑-auto-而非显式类型声明"><a href="#条款五：优先考虑-auto-而非显式类型声明" class="headerlink" title="条款五：优先考虑 auto 而非显式类型声明"></a>条款五：优先考虑 <code>auto</code> 而非显式类型声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br></pre></td></tr></table></figure>
<p>如果忘记了初始化 <code>x</code>，那么 <code>x</code> 的值是不确定的。</p>
<h3 id="避免未初始化的无效变量"><a href="#避免未初始化的无效变量" class="headerlink" title="避免未初始化的无效变量"></a>避免未初始化的无效变量</h3><p><strong>使用 <code>auto</code> 初始化变量，可以避免忘记初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1;                         <span class="comment">//潜在的未初始化的变量</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">auto</span> x2;                        <span class="comment">//错误！必须要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="number">0</span>;                    <span class="comment">//没问题，x已经定义了</span></span><br></pre></td></tr></table></figure>

<h3 id="更简洁的语法"><a href="#更简洁的语法" class="headerlink" title="更简洁的语法"></a>更简洁的语法</h3><p>因为使用 <a href="6%20Effective%20Modern%20C++.md">Item2</a> 所述的 <code>auto</code> 类型推导技术，它甚至能表示一些只有编译器才知道的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于std::unique_ptr指向的Widget类型的比较函数</span></span><br><span class="line"><span class="keyword">auto</span> derefUPLess = </span><br><span class="line">    [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1,<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2)       </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> *p1 &lt; *p2; </span><br><span class="line">    &#125;;                      </span><br></pre></td></tr></table></figure>

<p>C++14 中lambda表达式中的形参也可以使用 <code>auto</code>，这样语法更简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> derefLess =                                <span class="comment">//C++14版本</span></span><br><span class="line">    [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1,                          <span class="comment">//被任何像指针一样的东西</span></span><br><span class="line">       <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)                          <span class="comment">//指向的值的比较函数</span></span><br><span class="line">    &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure>


<p>我们可以不使用 <code>auto</code> 写出 C++11 版的 <code>derefUPLess</code>，方法是 <code>std::funtion</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;)&gt;</span><br><span class="line">derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1,</span><br><span class="line">                 <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2)</span><br><span class="line">                &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure>
<p>相比于 <code>auto</code> 实现的缺点：</p>
<ul>
<li>语法冗长</li>
<li><code>std::function</code> 方法比 <code>auto</code> 方法要更耗空间且更慢，还可能有 out-of-memory 异常：用 <code>auto</code> 声明的变量保存一个和闭包一样类型的（新）闭包，因此使用了与闭包相同大小存储空间。实例化 <code>std::function</code> 并声明一个对象这个对象将会有固定的大小。这个大小可能不足以存储一个闭包，这个时候 <code>std::function</code> 的构造函数将会在堆上面分配内存来存储，这就造成了使用 <code>std::function</code> 比 <code>auto</code> 声明变量会消耗更多的内存。（也可以使用 <code>std::bind</code> 来生成一个闭包，但在 <a href="../6.LambdaExpressions/item34.md">Item34</a> 我会尽我最大努力说服你使用<em>lambda</em>表达式代替 <code>std::bind</code>)</li>
</ul>
<h3 id="避免类型不匹配"><a href="#避免类型不匹配" class="headerlink" title="避免类型不匹配"></a>避免类型不匹配</h3><p>使用 <code>auto</code> 除了可以避免未初始化的无效变量，省略冗长的声明类型，直接保存闭包外，它还有一个好处是可以避免类型快捷方式（type shortcuts）有关的问题。你将看到这样的代码——甚至你会这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line"><span class="type">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p><code>v.size()</code> 的标准返回类型是 <code>std::vector&lt;int&gt;::size_type</code>，但是只有少数开发者意识到这点。<code>std::vector&lt;int&gt;::size_type</code> 实际上被指定为无符号整型，所以很多人都认为用 <code>unsigned</code> 就足够了，这会有问题隐患。</p>
<p>所以使用 <code>auto</code> 可以确保你不需要浪费时间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz =v.<span class="built_in">size</span>();                      <span class="comment">//sz的类型是std::vector&lt;int&gt;::size_type</span></span><br></pre></td></tr></table></figure>

<h3 id="对源码可读性的影响"><a href="#对源码可读性的影响" class="headerlink" title="对源码可读性的影响"></a>对源码可读性的影响</h3><p><strong>在某些情况下如果你的专业判断告诉你使用显式类型声明比 <code>auto</code> 要更清晰更易维护，那你就不必再坚持使用 <code>auto</code>。</strong></p>
<p>事实是显式指定类型通常只会引入一些微妙的错误，无论是在正确性还是效率方面。而且，如果初始化表达式的类型改变，则 <code>auto</code> 推导出的类型也会改变，这意味着使用 <code>auto</code> 可以帮助我们完成一些重构工作。举个例子，如果一个函数返回类型被声明为 <code>int</code>，但是后来你认为将它声明为 <code>long</code> 会更好，调用它作为初始化表达式的变量会自动改变类型，但是如果你不使用 <code>auto</code> 你就不得不在源代码中挨个找到调用地点然后修改它们。</p>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>正如 <a href="6%20Effective%20Modern%20C++.md">Item2</a> 和 <a href="../2.Auto/item6.md">6</a> 讨论的，<code>auto</code> 类型的变量可能会踩到一些陷阱。</p>
<h2 id="条款六：auto-推导若非己愿，使用显式类型初始化惯用法"><a href="#条款六：auto-推导若非己愿，使用显式类型初始化惯用法" class="headerlink" title="条款六：auto 推导若非己愿，使用显式类型初始化惯用法"></a>条款六：<code>auto</code> 推导若非己愿，使用显式类型初始化惯用法</h2><p>在 <a href="6%20Effective%20Modern%20C++.md">Item5</a> 中解释了比起显式指定类型使用 <code>auto</code> 声明变量有若干技术优势，但是有时当你想向左转 <code>auto</code> 却向右转。举个例子，假如我有一个函数，参数为 <code>Widget</code>，返回一个 <code>std::vector&lt;bool&gt;</code>，这里的 <code>bool</code> 表示 <code>Widget</code> 是否提供一个独有的特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br></pre></td></tr></table></figure>
<p>更进一步假设第 5 个元素表示 <code>Widget</code> 是否具有高优先级，我们可以写这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="type">bool</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w高优先级吗？</span></span><br><span class="line">…</span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriority);         <span class="comment">//根据它的优先级处理w</span></span><br></pre></td></tr></table></figure>
<p>这个代码没有任何问题。它会正常工作，但是如果我们使用 <code>auto</code> 代替 <code>highPriority</code> 的显式指定类型做一些看起来很无害的改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w高优先级吗？</span></span><br></pre></td></tr></table></figure>
<p>情况变了。所有代码仍然可编译，但是行为不再可预测：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(w,highPriority);          <span class="comment">//未定义行为！</span></span><br></pre></td></tr></table></figure>
<p>为什么呢？使用 <code>auto</code> 后 <code>highPriority</code> 不再是 <code>bool</code> 类型。虽然从概念上来说 <code>std::vector&lt;bool&gt;</code> 意味着存放 <code>bool</code>，但是 <code>std::vector&lt;bool&gt;</code> 的 <code>operator[]</code> 不会返回容器中元素的引用（这就是 <code>std::vector::operator[]</code> 可返回<strong>除了 <code>bool</code> 以外</strong>的任何类型），取而代之它返回一个 <code>std::vector&lt;bool&gt;::reference</code> 的对象。<br>在显式指定 bool 返回值类型时，<code>std::vector&lt;bool&gt;::reference</code> 的类型转换为bool 类型。</p>
<p><strong>显式类型初始器惯用法使用 <code>auto</code> 声明一个变量，然后对表达式强制类型转换（<em>cast</em>）得出你期望的推导结果。</strong> 举个例子，我们将这个惯用法施加到 <code>highPriority</code> 上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="第-3-章移步现代-C"><a href="#第-3-章移步现代-C" class="headerlink" title="第 3 章移步现代 C++"></a>第 3 章移步现代 C++</h1><p><strong>CHAPTER 3 Moving to Modern C++</strong></p>
<h2 id="条款七：区别使用-和-创建对象"><a href="#条款七：区别使用-和-创建对象" class="headerlink" title="条款七：区别使用 () 和 {} 创建对象"></a>条款七：区别使用 <code>()</code> 和 <code>&#123;&#125;</code> 创建对象</h2><p><strong>Item 7: Distinguish between <code>()</code> and <code>&#123;&#125;</code> when creating objects</strong></p>
<p>一般来说，C++11初始化值要用圆括号 <code>()</code> 或者花括号<code>&#123;&#125;</code>括起来，或者放到等号<code>=</code>的右边：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;               <span class="comment">//使用圆括号初始化</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;              <span class="comment">//使用&quot;=&quot;初始化</span></span><br><span class="line"><span class="type">int</span> z&#123; <span class="number">0</span> &#125;;             <span class="comment">//统一初始化, 使用花括号初始化，简称【括号初始化】</span></span><br><span class="line"><span class="type">int</span> z = &#123; <span class="number">0</span> &#125;;          <span class="comment">//使用&quot;=&quot;和花括号,C++通常把它视作和只有花括号一样</span></span><br></pre></td></tr></table></figure>

<p>C++11 使用<strong>统一初始化（<em>uniform initialization</em>）</strong> 来整合这些混乱且不适于所有情景的初始化语法，所谓统一初始化是指在任何涉及初始化的地方都使用单一的初始化语法。<strong>在 C++中这三种方式都被看做是初始化表达式，但是只有花括号任何地方都能被使用。</strong></p>
<ul>
<li><p>括号初始化让你可以表达以前表达不出的东西。使用花括号，创建并指定一个容器的初始元素变得很容易：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;  <span class="comment">//v初始内容为1,3,5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>括号初始化也能被用于为非静态数据成员指定默认初始值。C++11 允许”&#x3D;”初始化不加花括号也拥有这种能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x&#123; <span class="number">0</span> &#125;;                 <span class="comment">//没问题，x初始值为0</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;                  <span class="comment">//也可以</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;                   <span class="comment">//错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一方面，不可拷贝的对象（例如 <code>std::atomic</code> ——见 <a href="../7.TheConcurrencyAPI/item40.md">Item40</a>）可以使用花括号初始化或者圆括号初始化，但是不能使用”&#x3D;”初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123; <span class="number">0</span> &#125;;      <span class="comment">//没问题</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>;        <span class="comment">//没问题</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>;       <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>括号表达式还有一个少见的特性，即它不允许内置类型间隐式的变窄转换（<em>narrowing conversion</em>）</strong>。</p>
<ul>
<li>如果一个使用了括号初始化的表达式的值，不能保证由被初始化的对象的类型来表示，代码就不会通过编译。</li>
<li>使用圆括号和”&#x3D;”的初始化不检查是否转换为变窄转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum1&#123; x + y + z &#125;;          <span class="comment">//错误！double的和可能不能表示为int</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(x + y +z)</span></span>;             <span class="comment">//可以编译（表达式的值被截为int）</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z;           <span class="comment">//可以编译</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>另一个值得注意的特性是括号表达式对于 C++最令人头疼的解析问题有天生的免疫性。（译注：所谓最令人头疼的解析即<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Most_vexing_parse">Most_vexing_parse</a>）C++规定任何<em>可以被解析</em>为一个声明的东西<em>必须被解析</em>为声明。这个规则的副作用是让很多程序员备受折磨：他们可能想创建一个使用默认构造函数构造的对象，却不小心变成了函数声明。问题的根源是如果你调用带参构造函数，你可以这样做：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;                  <span class="comment">//使用实参10调用Widget的一个构造函数</span></span><br></pre></td></tr></table></figure>
<p>但是如果你尝试使用相似的语法调用 <code>Widget</code> 无参构造函数，它就会变成函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;                    <span class="comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span></span><br></pre></td></tr></table></figure>
<p>由于函数声明中形参列表不能带花括号，所以<strong>使用花括号初始化表明你想调用默认构造函数构造对象就没有问题：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;                    <span class="comment">//调用没有参数的构造函数构造对象</span></span><br></pre></td></tr></table></figure>


<p>括号初始化的<strong>缺点</strong>是有时它有一些令人惊讶的行为。这些行为使得括号初始化、<code>std::initializer_list</code> 和构造函数参与重载决议时本来就不清不楚的暧昧关系进一步混乱。把它们放到一起会让看起来应该左转的代码右转。举个例子，<a href="6%20Effective%20Modern%20C++.md">Item2</a> 解释了当 <code>auto</code> 声明的变量使用花括号初始化，变量类型会被推导为 <code>std::initializer_list</code>，但是使用相同内容的其他初始化方式会产生更符合直觉的结果。<strong>所以，你越喜欢用 <code>auto</code>，你就越不能用括号初始化。</strong></p>
<blockquote>
<p>作者在这里讨论了<code>std::initializer_list</code>使用括号初始化出现的问题，略</p>
</blockquote>
<p>结论：</p>
<ol>
<li>如果你要加入 <code>std::initializer_list</code> 构造函数，请三思而后行。</li>
<li>作为一个类库使用者，你必须认真的在花括号和圆括号之间选择一个来创建对象。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。<ol>
<li>默认使用花括号初始化的开发者主要被适用面广、禁止变窄转换、免疫 C++最令人头疼的解析这些优点所吸引。这些开发者知道在一些情况下（比如给定一个容器大小和一个初始值创建 <code>std::vector</code>）要使用圆括号。</li>
<li>默认使用圆括号初始化的开发者主要被 C++98 语法一致性、避免 <code>std::initializer_list</code> 自动类型推导、避免不会不经意间调用 <code>std::initializer_list</code> 构造函数这些优点所吸引。这些开发者也承认有时候只能使用花括号（比如创建一个包含着特定值的容器）。</li>
<li>关于花括号初始化和圆括号初始化哪种更好大家没有达成一致，所以<strong>我的建议是选择一种并坚持使用它。</strong></li>
</ol>
</li>
</ol>
<p>如果你是一个模板的作者，花括号和圆括号创建对象就更麻烦了。通常不能知晓哪个会被使用。举个例子，假如你想创建一个接受任意数量的参数来创建的对象。使用可变参数模板（<em>variadic template</em>）可以非常简单的解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,            <span class="comment">//要创建的对象类型</span></span><br><span class="line">         <span class="keyword">typename</span>... Ts&gt;        <span class="comment">//要使用的实参的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create local T object from params...</span><br><span class="line">    …</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在现实中我们有两种方式实现这个伪代码（关于 <code>std::forward</code> 请参见 <a href="../5.RRefMovSemPerfForw/item25.md">Item25</a>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">localObject</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>;             <span class="comment">//使用圆括号</span></span><br><span class="line">T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;;             <span class="comment">//使用花括号</span></span><br></pre></td></tr></table></figure>
<p>考虑这样的调用代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">…</span><br><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>如果 <code>doSomeWork</code> 创建 <code>localObject</code> 时使用的是圆括号，<code>std::vector</code> 就会包含 10 个元素。如果 <code>doSomeWork</code> 创建 <code>localObject</code> 时使用的是花括号，<code>std::vector</code> 就会包含 2 个元素。哪个是正确的？<code>doSomeWork</code> 的作者不知道，只有调用者知道。</p>
<p>这正是标准库函数 <code>std::make_unique</code> 和 <code>std::make_shared</code>（参见 <a href="../4.SmartPointers/item21.md">Item21</a>）面对的问题。它们的解决方案是使用圆括号，并被记录在文档中作为接口的一部分。（注：更灵活的设计——允许调用者决定从模板来的函数应该使用圆括号还是花括号——是有可能的。详情参见 <a target="_blank" rel="noopener" href="http://akrzemi1.wordpress.com/">Andrzej’s C++ blog</a> 在 2013 年 6 月 5 日的文章，“<a target="_blank" rel="noopener" href="http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/">Intuitive interface — Part I.</a>”）</p>
<p><strong>请记住：</strong></p>
<ul>
<li>花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于 C++最令人头疼的解析有天生的免疫性</li>
<li>在构造函数重载决议中，编译器会尽最大努力将括号初始化与 <code>std::initializer_list</code> 参数匹配，即便其他构造函数看起来是更好的选择</li>
<li>对于数值类型的 <code>std::vector</code> 来说使用花括号初始化和圆括号初始化会造成巨大的不同</li>
<li>在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战。</li>
</ul>
<h2 id="条款八：优先考虑-nullptr-而非-0-和-NULL"><a href="#条款八：优先考虑-nullptr-而非-0-和-NULL" class="headerlink" title="条款八：优先考虑 nullptr 而非 0 和 NULL"></a>条款八：优先考虑 <code>nullptr</code> 而非 <code>0</code> 和 <code>NULL</code></h2><p><strong>Item 8: Prefer <code>nullptr</code> to <code>0</code> and <code>NULL</code></strong></p>
<ul>
<li>优先考虑 <code>nullptr</code> 而非 <code>0</code> 和 <code>NULL</code></li>
<li>避免重载指针和整型</li>
</ul>
<h2 id="条款九：优先考虑别名声明-using-而非-typedef-s"><a href="#条款九：优先考虑别名声明-using-而非-typedef-s" class="headerlink" title="条款九：优先考虑别名声明 using 而非 typedef s"></a>条款九：优先考虑别名声明 <code>using</code> 而非 <code>typedef</code> s</h2><p><strong>Item 9: Prefer alias declarations to <code>typedef</code> s</strong></p>
<p>我相信每个人都同意使用 STL 容器是个好主意，并且我希望 <a href="../4.SmartPointers/item18.md">Item18</a> 能说服你让你觉得使用 <code>std:unique_ptr</code> 也是个好主意，但我猜没有人喜欢写上几次 <code>std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;</code> 这样的类型，它可能会让你患上腕管综合征的风险大大增加。</p>
<p>避免上述医疗悲剧也很简单，引入 <code>typedef</code> 即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line">    std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;</span><br><span class="line">    UPtrMapSS; </span><br></pre></td></tr></table></figure>
<p>但 <code>typedef</code> 是 C++98 的东西。虽然它可以在 C++11 中工作，但是 C++11 也提供了一个别名声明（<em>alias declaration</em>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UPtrMapSS =</span><br><span class="line">    std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>由于这里给出的 <code>typedef</code> 和别名声明做的都是完全一样的事情，我们有理由想知道会不会出于一些技术上的原因两者有一个更好。</p>
<p><strong>有一个地方使用别名声明吸引人的理由是存在的：模板。特别地，别名声明可以被模板化（这种情况下称为别名模板<em>alias template</em>s）但是 <code>typedef</code> 不能。</strong> 这使得 C++11 程序员可以很直接的表达一些 C++98 中只能把 <code>typedef</code> 嵌套进模板化的 <code>struct</code> 才能表达的东西。考虑一个链表的别名，链表使用自定义的内存分配器，<code>MyAlloc</code>。使用别名模板，这真是太容易了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                            <span class="comment">//MyAllocList&lt;T&gt;是</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">                                                <span class="comment">//的同义词</span></span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;                         <span class="comment">//用户代码</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>typedef</code>，你就只能从头开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                            <span class="comment">//MyAllocList&lt;T&gt;是</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;                            <span class="comment">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;      <span class="comment">//的同义词  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;                   <span class="comment">//用户代码</span></span><br></pre></td></tr></table></figure>

<p>更糟糕的是，如果你想使用在一个模板内使用 <code>typedef</code> 声明一个链表对象，而这个对象又使用了模板形参，你就不得不在 <code>typedef</code> 前面加上 <code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                              <span class="comment">//Widget&lt;T&gt;含有一个</span></span><br><span class="line"><span class="keyword">private</span>:                                    <span class="comment">//MyAllocLIst&lt;T&gt;对象</span></span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;     <span class="comment">//作为数据成员</span></span><br><span class="line">    …</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>这里 <code>MyAllocList&lt;T&gt;::type</code> 使用了一个类型，这个类型依赖于模板参数 <code>T</code>。因此 <code>MyAllocList&lt;T&gt;::type</code> 是一个依赖类型（<em>dependent type</em>），在 C++很多讨人喜欢的规则中的一个提到必须要在依赖类型名前加上 <code>typename</code>。</p>
<p>如果使用别名声明定义一个 <code>MyAllocList</code>，就不需要使用 <code>typename</code>（同时省略麻烦的“<code>::type</code>”后缀）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;   <span class="comment">//同之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyAllocList&lt;T&gt; list;                        <span class="comment">//没有“typename”</span></span><br><span class="line">    …                                           <span class="comment">//没有“::type”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对你来说，<code>MyAllocList&lt;T&gt;</code>（使用了模板别名声明的版本）可能看起来和 <code>MyAllocList&lt;T&gt;::type</code>（使用 <code>typedef</code> 的版本）一样都应该依赖模板参数 <code>T</code>，但是你不是编译器。当编译器处理 <code>Widget</code> 模板时遇到 <code>MyAllocList&lt;T&gt;</code>（使用模板别名声明的版本），它们知道 <code>MyAllocList&lt;T&gt;</code> 是一个类型名，因为 <code>MyAllocList</code> 是一个别名模板：它<strong>一定</strong>是一个类型名。因此 <code>MyAllocList&lt;T&gt;</code> 就是一个<strong>非依赖类型</strong>（<em>non-dependent type</em>），就不需要也不允许使用 <code>typename</code> 修饰符。</p>
<p>当编译器在 <code>Widget</code> 的模板中看到 <code>MyAllocList&lt;T&gt;::type</code>（使用 <code>typedef</code> 的版本），它不能确定那是一个类型的名称。因为可能存在一个 <code>MyAllocList</code> 的它们没见到的特化版本，那个版本的 <code>MyAllocList&lt;T&gt;::type</code> 指代了一种不是类型的东西。那听起来很不可思议，但不要责备编译器穷尽考虑所有可能。因为人确实能写出这样的代码。</p>
<p>举个例子，一个误入歧途的人可能写出这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wine</span> &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;                          <span class="comment">//当T是Wine</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocList</span>&lt;Wine&gt; &#123;           <span class="comment">//特化MyAllocList</span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">WineType</span>             <span class="comment">//参见Item10了解  </span></span><br><span class="line">    &#123; White, Red, Rose &#125;;           <span class="comment">//&quot;enum class&quot;</span></span><br><span class="line"></span><br><span class="line">    WineType type;                  <span class="comment">//在这个类中，type是</span></span><br><span class="line">    …                               <span class="comment">//一个数据成员！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就像你看到的，<code>MyAllocList&lt;Wine&gt;::type</code> 不是一个类型。如果 <code>Widget</code> 使用 <code>Wine</code> 实例化，在 <code>Widget</code> 模板中的 <code>MyAllocList&lt;Wine&gt;::type</code> 将会是一个数据成员，不是一个类型。在 <code>Widget</code> 模板内，<code>MyAllocList&lt;T&gt;::type</code> 是否表示一个类型取决于 <code>T</code> 是什么，这就是为什么编译器会坚持要求你在前面加上 <code>typename</code>。</p>
<p>如果你尝试过模板元编程（<em>template metaprogramming</em>，TMP），你一定会碰到取模板类型参数然后基于它创建另一种类型的情况。举个例子，给一个类型 <code>T</code>，如果你想去掉 <code>T</code> 的常量修饰和引用修饰（<code>const</code> - or reference qualifiers），比如你想把 <code>const std::string&amp;</code> 变成 <code>std::string</code>。又或者你想给一个类型加上 <code>const</code> 或变为左值引用，比如把 <code>Widget</code> 变成 <code>const Widget</code> 或 <code>Widget&amp;</code>。（如果你没有用过模板元编程，太遗憾了，因为如果你真的想成为一个高效 C++程序员，你需要至少熟悉 C++在这方面的基本知识。你可以看看在 <a href="../5.RRefMovSemPerfForw/item23.md">Item23</a>，<a href="../5.RRefMovSemPerfForw/item27.md">27</a> 里的 TMP 的应用实例，包括我提到的类型转换）。</p>
<p>C++11 在<em>type traits</em>（类型特性）中给了你一系列工具去实现类型转换，如果要使用这些模板请包含头文件 <code>&lt;type_traits&gt;</code>。里面有许许多多<em>type traits</em>，也不全是类型转换的工具，也包含一些可预测接口的工具。给一个你想施加转换的类型 <code>T</code>，结果类型就是 <code>std::</code> transformation <code>&lt;T&gt;::type</code>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type          <span class="comment">//从const T中产出T</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type      <span class="comment">//从T&amp;和T&amp;&amp;中产出T</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type  <span class="comment">//从T中产出T&amp;</span></span><br></pre></td></tr></table></figure>
<p>注释仅仅简单的总结了类型转换做了什么，所以不要太随便的使用。在你的项目使用它们之前，你最好看看它们的详细说明书。</p>
<p>尽管写了一些，但我这里不是想给你一个关于<em>type traits</em>使用的教程。注意类型转换尾部的 <code>::type</code>。如果你在一个模板内部将他们施加到类型形参上（实际代码中你也总是这么用），你也需要在它们前面加上 <code>typename</code>。至于为什么要这么做是因为这些 C++11 的<em>type traits</em>是通过在 <code>struct</code> 内嵌套 <code>typedef</code> 来实现的。是的，它们使用类型同义词（译注：根据上下文指的是使用 <code>typedef</code> 的做法）技术实现，而正如我之前所说这比别名声明要差。</p>
<p>关于为什么这么实现是有历史原因的，但是我们跳过它（我认为太无聊了），因为标准委员会没有及时认识到别名声明是更好的选择，所以直到 C++14 它们才提供了使用别名声明的版本。这些别名声明有一个通用形式：对于 C++11 的类型转换 <code>std::</code> transformation <code>&lt;T&gt;::type</code> 在 C++14 中变成了 <code>std::</code> transformation <code>_t</code>。举个例子或许更容易理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type          <span class="comment">//C++11: const T → T </span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;              <span class="comment">//C++14 等价形式</span></span><br><span class="line"></span><br><span class="line">std::remove_reference&lt;T&gt;::type      <span class="comment">//C++11: T&amp;/T&amp;&amp; → T </span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;          <span class="comment">//C++14 等价形式</span></span><br><span class="line"></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type  <span class="comment">//C++11: T → T&amp; </span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;      <span class="comment">//C++14 等价形式</span></span><br></pre></td></tr></table></figure>
<p>C++11 的的形式在 C++14 中也有效，但是我不能理解为什么你要去用它们。就算你没办法使用 C++14，使用别名模板也是小儿科。只需要 C++11 的语言特性，甚至每个小孩都能仿写，对吧？如果你有一份 C++14 标准，就更简单了，只需要复制粘贴：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="type">add_lvalue_reference_t</span> =</span><br><span class="line">  <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type; </span><br></pre></td></tr></table></figure>
<p>看见了吧？不能再简单了。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><code>typedef</code> 不支持模板化，但是别名声明支持。</li>
<li>别名模板避免了使用“<code>::type</code>”后缀，而且在模板中使用 <code>typedef</code> 还需要在前面加上 <code>typename</code></li>
<li>C++14 提供了 C++11 所有<em>type traits</em>转换的别名声明版本</li>
</ul>
<h2 id="条款十：优先考虑限域-enum-而非未限域-enum"><a href="#条款十：优先考虑限域-enum-而非未限域-enum" class="headerlink" title="条款十：优先考虑限域 enum 而非未限域 enum"></a>条款十：优先考虑限域 <code>enum</code> 而非未限域 <code>enum</code></h2><p><strong>Item 10: Prefer scoped <code>enum</code> s to unscoped <code>enum</code> s</strong></p>
<p>通常来说，在花括号中声明一个名字会限制它的作用域在花括号之内。但这对于 C++98 风格的 <code>enum</code> 中声明的枚举名（译注：<em>enumerator</em>，连同下文“枚举名”都指<em>enumerator</em>）是不成立的。这些枚举名的名字（译注：<em>enumerator</em> names，连同下文“名字”都指 names）属于包含这个 <code>enum</code> 的作用域，这意味着作用域内不能含有相同名字的其他东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;   <span class="comment">//black, white, red在</span></span><br><span class="line">                                    <span class="comment">//Color所在的作用域</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误! white早已在这个作用</span></span><br><span class="line">                                    <span class="comment">//域中声明</span></span><br></pre></td></tr></table></figure>
<p>这些枚举名的名字泄漏进它们所被定义的 <code>enum</code> 在的那个作用域，这个事实有一个官方的术语：未限域枚举 (<em>unscoped <code>enum</code></em>)。在 C++11 中它们有一个相似物，限域枚举 (<em>scoped <code>enum</code></em>)，它不会导致枚举名泄漏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">//black, white, red</span></span><br><span class="line">                                        <span class="comment">//限制在Color域内</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                     <span class="comment">//没问题，域内没有其他“white”</span></span><br><span class="line"></span><br><span class="line">Color c = white;                        <span class="comment">//错误，域中没有枚举名叫white</span></span><br><span class="line"></span><br><span class="line">Color c = Color::white;                 <span class="comment">//没问题</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                  <span class="comment">//也没问题（也符合Item5的建议）</span></span><br></pre></td></tr></table></figure>
<p>因为限域 <code>enum</code> 是通过“<code>enum class</code>”声明，所以它们有时候也被称为枚举类 (<em><code>enum</code> classes</em>)。</p>
<p><strong>使用限域 <code>enum</code> 来减少命名空间污染，这是一个足够合理使用它而不是它的同胞未限域 <code>enum</code> 的理由。</strong></p>
<p><strong>其实限域 <code>enum</code> 还有第二个吸引人的优点：在它的作用域中，枚举名是强类型，不存在任何隐式转换可以将限域 <code>enum</code> 中的枚举名转化为任何其他类型。而未限域 <code>enum</code> 中的枚举名会隐式转换为整型（现在，也可以转换为浮点类型）</strong>。</p>
<p><strong>似乎比起非限域 <code>enum</code> 而言，限域 <code>enum</code> 有第三个好处，因为限域 <code>enum</code> 可以被前置声明。也就是说，它们可以不指定枚举名直接声明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>;         <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;   <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>
<p>在C++98 <code>enum</code> 的前置声明是不被允许的。在 C++11 中，非限域 <code>enum</code> 也可以被前置声明，但是只有在做一些其他工作后才能实现：</p>
<p>限域 <code>enum</code> 的底层类型总是已知的，而对于非限域 <code>enum</code>，你可以指定它。<br>默认情况下，限域枚举的底层类型是 <code>int</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>;                  <span class="comment">//底层类型是int</span></span><br></pre></td></tr></table></figure>
<p>如果默认的 <code>int</code> 不适用，你可以重写它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span>;   <span class="comment">//Status的底层类型</span></span><br><span class="line">                                    <span class="comment">//是std::uint32_t</span></span><br><span class="line">                                    <span class="comment">//（需要包含 &lt;cstdint&gt;）</span></span><br></pre></td></tr></table></figure>
<p>不管怎样，编译器都知道限域 <code>enum</code> 中的枚举名占用多少字节。</p>
<p>要为非限域 <code>enum</code> 指定底层类型，你可以同上，结果就可以前向声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint8_t</span>;   <span class="comment">//非限域enum前向声明</span></span><br><span class="line">                            <span class="comment">//底层类型为</span></span><br><span class="line">                            <span class="comment">//std::uint8_t</span></span><br></pre></td></tr></table></figure>
<p>底层类型说明也可以放到 <code>enum</code> 定义处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span> &#123; good = <span class="number">0</span>,</span><br><span class="line">                                   failed = <span class="number">1</span>,</span><br><span class="line">                                   incomplete = <span class="number">100</span>,</span><br><span class="line">                                   corrupt = <span class="number">200</span>,</span><br><span class="line">                                   audited = <span class="number">500</span>,</span><br><span class="line">                                   indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">                                 &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="选择非限域-enum-的情况"><a href="#选择非限域-enum-的情况" class="headerlink" title="选择非限域 enum 的情况"></a>选择非限域 <code>enum</code> 的情况</h3><p>限域 <code>enum</code> 避免命名空间污染而且不接受荒谬的隐式类型转换，但它并非万事皆宜，你可能会很惊讶听到<strong>至少有一种情况下非限域 <code>enum</code> 是很有用的。那就是牵扯到 C++11 的 <code>std::tuple</code> 的时候</strong>。比如在社交网站中，假设我们有一个<em>tuple</em>保存了用户的名字，email 地址，声望值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo =                <span class="comment">//类型别名，参见Item9</span></span><br><span class="line">    std::tuple&lt;std::string,     <span class="comment">//名字</span></span><br><span class="line">               std::string,     <span class="comment">//email地址</span></span><br><span class="line">               std::<span class="type">size_t</span>&gt; ;   <span class="comment">//声望</span></span><br></pre></td></tr></table></figure>
<p>虽然注释说明了 tuple 各个字段对应的意思，但当你在另一文件遇到下面的代码那之前的注释就不是那么有用了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserInfo uInfo;                 <span class="comment">//tuple对象</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(uInfo);	<span class="comment">//获取第一个字段</span></span><br></pre></td></tr></table></figure>
<p>作为一个程序员，你有很多工作要持续跟进。你应该记住第一个字段代表用户的 email 地址吗？我认为不。可以使用非限域 <code>enum</code> 将名字和字段编号关联起来以避免上述需求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"></span><br><span class="line">UserInfo uInfo;                         <span class="comment">//同之前一样</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo);    <span class="comment">//啊，获取用户email字段的值</span></span><br></pre></td></tr></table></figure>
<p>之所以它能正常工作是因为 <code>UserInfoFields</code> 中的枚举名隐式转换成 <code>std::size_t</code> 了，其中 <code>std::size_t</code> 是 <code>std::get</code> 模板实参所需的。</p>
<p>对应的限域 <code>enum</code> 版本就很啰嗦了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line"></span><br><span class="line">UserInfo uInfo;                         <span class="comment">//同之前一样</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val =</span><br><span class="line">    std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;</span><br><span class="line">        (uInfo);</span><br></pre></td></tr></table></figure>
<p>为避免这种冗长的表示，我们可以写一个函数传入枚举名并返回对应的 <code>std::size_t</code> 值，但这有一点技巧性。<code>std::get</code> 是一个模板（函数），需要你给出一个 <code>std::size_t</code> 值的模板实参（注意使用 <code>&lt;&gt;</code> 而不是 <code>()</code>），因此将枚举名变换为 <code>std::size_t</code> 值的函数必须<strong>在编译期</strong>产生这个结果。如 <a href="../3.MovingToModernCpp/item15.md">Item15</a> 提到的，那必须是一个 <code>constexpr</code> 函数。</p>
<p>事实上，它也的确该是一个 <code>constexpr</code> 函数模板，因为它应该能用于任何 <code>enum</code>。如果我们想让它更一般化，我们还要泛化它的返回类型。较之于返回 <code>std::size_t</code>，我们更应该返回枚举的底层类型。这可以通过 <code>std::underlying_type</code> 这个<em>type trait</em>获得。（参见 <a href="6%20Effective%20Modern%20C++.md">Item9</a> 关于<em>type trait</em>的内容）。最终我们还要再加上 <code>noexcept</code> 修饰（参见 <a href="../3.MovingToModernCpp/item14.md">Item14</a>），因为我们知道它肯定不会产生异常。根据上述分析最终得到的 <code>toUType</code> 函数模板在编译期接受任意枚举名并返回它的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::underlying_type&lt;E&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span></span><br><span class="line">                    std::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++14 中，<code>toUType</code> 还可以进一步用 <code>std::underlying_type_t</code>（参见 <a href="6%20Effective%20Modern%20C++.md">Item9</a>）代替 <code>typename std::underlying_type&lt;E&gt;::type</code> 打磨：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;                <span class="comment">//C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">underlying_type_t</span>&lt;E&gt;</span></span><br><span class="line"><span class="function">    <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以再用 C++14 <code>auto</code>（参见 <a href="6%20Effective%20Modern%20C++.md">Item3</a>）打磨一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;                <span class="comment">//C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">    <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管它怎么写，<code>toUType</code> 现在允许这样访问 tuple 的字段了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>
<p>这仍然比使用非限域 <code>enum</code> 要写更多的代码，但同时它也避免命名空间污染，防止不经意间使用隐式转换。大多数情况下，你应该会觉得多敲几个（几行）字符作为避免使用未限域枚举这种老得和 2400 波特率猫同时代技术的代价是值得的。</p>
<p><strong>记住</strong></p>
<ul>
<li>C++98 的 <code>enum</code> 即非限域 <code>enum</code>。</li>
<li>限域 <code>enum</code> 的枚举名仅在 <code>enum</code> 内可见。要转换为其它类型只能使用<em>cast</em>。</li>
<li>非限域&#x2F;限域 <code>enum</code> 都支持底层类型说明语法，限域 <code>enum</code> 底层类型默认是 <code>int</code>。非限域 <code>enum</code> 没有默认底层类型。</li>
<li>限域 <code>enum</code> 总是可以前置声明。非限域 <code>enum</code> 仅当指定它们的底层类型时才能前置。</li>
</ul>
<h2 id="条款十一：优先考虑使用deleted函数而非使用未定义的私有声明"><a href="#条款十一：优先考虑使用deleted函数而非使用未定义的私有声明" class="headerlink" title="条款十一：优先考虑使用deleted函数而非使用未定义的私有声明"></a>条款十一：优先考虑使用<em>deleted</em>函数而非使用未定义的私有声明</h2><p><strong>Item 11: Prefer deleted functions to private undefined ones.</strong></p>
<p>如果你写的代码要被其他人使用，你不想让他们调用某个特殊的函数，你通常不会声明这个函数。无声明，不函数。简简单单！但有时 C++会给你自动声明一些函数，如果你想防止客户调用这些函数，事情就不那么简单了。</p>
<p>上述场景见于特殊的成员函数，即当有必要时 C++自动生成的那些函数。<a href="../3.MovingToModernCpp/item17.md">Item17</a> 详细讨论了这些函数，但是现在，我们只关心拷贝构造函数和拷贝赋值运算符重载。本节主要致力于讨论 C++98 中那些被 C++11 所取代的最佳实践，而且在 C++98 中，你想要禁止使用的成员函数，几乎总是拷贝构造函数或者赋值运算符，或者两者都是。</p>
<p>在 C++98 中防止调用这些函数的方法是将它们声明为私有（<code>private</code>）成员函数并且不定义。举个例子，在 C++ 标准库<em>iostream</em>继承链的顶部是模板类 <code>basic_ios</code>。所有<em>istream</em>和<em>ostream</em>类都继承此类（直接或者间接）。拷贝<em>istream</em>和<em>ostream</em>是不合适的，因为这些操作应该怎么做是模棱两可的。比如一个 <code>istream</code> 对象，代表一个输入值的流，流中有一些已经被读取，有一些可能马上要被读取。如果一个<em>istream</em>被拷贝，需要拷贝将要被读取的值和已经被读取的值吗？解决这个问题最好的方法是不定义这个操作。直接禁止拷贝流。</p>
<p>要使这些<em>istream</em>和<em>ostream</em>类不可拷贝，<code>basic_ios</code> 在 C++98 中是这样声明的（包括注释）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; );           <span class="comment">// not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将它们声明为私有成员可以防止客户端调用这些函数。故意不定义它们意味着假如还是有代码用它们（比如成员函数或者类的友元 <code>friend</code>），就会在链接时引发缺少函数定义（<em>missing function definitions</em>）错误。</p>
<p>在 C++11 中有一种更好的方式达到相同目的：用“<code>= delete</code>”将拷贝构造函数和拷贝赋值运算符标记为<strong><em>deleted</em>函数</strong>（译注：一些文献翻译为“删除的函数”）。上面相同的代码在 C++11 中是这样声明的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>删除这些函数（译注：添加”<code>= delete</code>“）和声明为私有成员可能看起来只是方式不同，别无其他区别。其实还有一些实质性意义。<em>deleted</em>函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用<em>deleted</em>函数也不能通过编译。这是较之 C++98 行为的一个改进，C++98 中不正确的使用这些函数在链接时才被诊断出来。</p>
<p>通常，<em>deleted</em>函数被声明为 <code>public</code> 而不是 <code>private</code>。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查<em>deleted</em>状态前检查它的访问性。当客户端代码调用一个私有的<em>deleted</em>函数，一些编译器只会给出该函数是 <code>private</code> 的错误（译注：而没有诸如该函数被<em>deleted</em>修饰的错误），即使函数的访问性不影响它是否能被使用。所以值得牢记，如果要将老代码的“私有且未定义”函数替换为<em>deleted</em>函数时请一并修改它的访问性为 <code>public</code>，这样可以让编译器产生更好的错误信息。</p>
<p><em>deleted</em>函数还有一个重要的优势是<strong>任何</strong>函数都可以标记为<em>deleted</em>，而只有成员函数可被标记为 <code>private</code>。（译注：从下文可知“任何”是包含普通函数和成员函数等所有可声明函数的地方，而 <code>private</code> 方法只适用于成员函数）假如我们有一个非成员函数，它接受一个整型参数，检查它是否为幸运数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++有沉重的 C 包袱，使得含糊的、能被视作数值的任何类型都能隐式转换为 <code>int</code>，但是有一些调用可能是没有意义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>)) …         <span class="comment">//字符&#x27;a&#x27;是幸运数？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>)) …        <span class="comment">//&quot;true&quot;是?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="number">3.5</span>)) …         <span class="comment">//难道判断它的幸运之前还要先截尾成3？</span></span><br></pre></td></tr></table></figure>
<p>如果幸运数必须真的是整型，我们该禁止这些调用通过编译。</p>
<p>其中一种方法就是创建<em>deleted</em>重载函数，其参数就是我们想要过滤的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;       <span class="comment">//原始版本</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">//拒绝char</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">//拒绝bool</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;  <span class="comment">//拒绝float和double</span></span><br></pre></td></tr></table></figure>
<p>(上面 <code>double</code> 重载版本的注释说拒绝 <code>float</code> 和 <code>double</code> 可能会让你惊讶，但是请回想一下：将 <code>float</code> 转换为 <code>int</code> 和 <code>double</code>，C++更喜欢转换为 <code>double</code>。使用 <code>float</code> 调用 <code>isLucky</code> 因此会调用 <code>double</code> 重载版本，而不是 <code>int</code> 版本。好吧，它也会那么去尝试。事实是调用被删除的 <code>double</code> 重载版本不能通过编译。不再惊讶了吧。)</p>
<p>虽然<em>deleted</em>函数不能被使用，但它们还是存在于你的程序中。也即是说，重载决议会考虑它们。这也是为什么上面的函数声明导致编译器拒绝一些不合适的函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>)) …     <span class="comment">//错误！调用deleted函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>)) …    <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="number">3.5f</span>)) …    <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>另一个<em>deleted</em>函数用武之地（<code>private</code> 成员函数做不到的地方）是禁止一些模板的实例化。假如你要求一个模板仅支持原生指针（尽管<a href="../4.SmartPointers/item18.md">第四章</a>建议使用智能指针代替原生指针）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指针的世界里有两种特殊情况。一是 <code>void*</code> 指针，因为没办法对它们进行解引用，或者加加减减等。另一种指针是 <code>char*</code>，因为它们通常代表 C 风格的字符串，而不是正常意义下指向单个字符的指针。这两种情况要特殊处理，在 <code>processPointer</code> 模板里面，我们假设正确的函数应该拒绝这些类型。也即是说，<code>processPointer</code> 不能被 <code>void*</code> 和 <code>char*</code> 调用。</p>
<p>要想确保这个很容易，使用 <code>delete</code> 标注模板实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>现在如果使用 <code>void*</code> 和 <code>char*</code> 调用 <code>processPointer</code> 就是无效的，按常理说 <code>const void*</code> 和 <code>const char*</code> 也应该无效，所以这些实例也应该标注 <code>delete</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>如果你想做得更彻底一些，你还要删除 <code>const volatile void*</code> 和 <code>const volatile char*</code> 重载版本，另外还需要一并删除其他标准字符类型的重载版本：<code>std::wchar_t</code>，<code>std::char16_t</code> 和 <code>std::char32_t</code>。</p>
<p>有趣的是，如果类里面有一个函数模板，你可能想用 <code>private</code>（经典的 C++98 惯例）来禁止这些函数模板实例化，但是不能这样做，因为不能给特化的成员模板函数指定一个不同于主函数模板的访问级别。如果 <code>processPointer</code> 是类 <code>Widget</code> 里面的模板函数，你想禁止它接受 <code>void*</code> 参数，那么通过下面这样 C++98 的方法就不能通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;                          <span class="comment">//错误！</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题是模板特例化必须位于一个命名空间作用域，而不是类作用域。<em>deleted</em>函数不会出现这个问题，因为它不需要一个不同的访问级别，且他们可以在类外被删除（因此位于命名空间作用域）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; … &#125;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;                                          <span class="comment">//还是public，</span></span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;  <span class="comment">//但是已经被删除了</span></span><br></pre></td></tr></table></figure>
<p>事实上 C++98 的最佳实践即声明函数为 <code>private</code> 但不定义是在做 C++11 <em>deleted</em>函数要做的事情。作为模仿者，C++98 的方法不是十全十美。它不能在类外正常工作，不能总是在类中正常工作，它的罢工可能直到链接时才会表现出来。所以请坚定不移的使用<em>deleted</em>函数。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>比起声明函数为 <code>private</code> 但不定义，使用<em>deleted</em>函数更好</li>
<li>任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）</li>
</ul>
<h2 id="条款十二：使用-override-声明重写函数"><a href="#条款十二：使用-override-声明重写函数" class="headerlink" title="条款十二：使用 override 声明重写函数"></a>条款十二：使用 <code>override</code> 声明重写函数</h2><p><strong>Item 12: Declare overriding functions <code>override</code></strong></p>
<p>在 C++面向对象的世界里，涉及的概念有类，继承，虚函数。这个世界最基本的概念是派生类的虚函数<strong>重写</strong>基类同名函数。令人遗憾的是虚函数重写可能一不小心就错了。似乎这部分语言的设计理念是不仅仅要遵守墨菲定律，还应该尊重它。</p>
<p>虽然“重写（<em>overriding</em>）”听起来像“重载（<em>overloading</em>）”，然而两者完全不相关，所以让我澄清一下，正是虚函数重写机制的存在，才使我们可以通过基类的接口调用派生类的成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>;          <span class="comment">//基类虚函数</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>;          <span class="comment">//重写Base::doWork</span></span><br><span class="line">    …                               <span class="comment">//（这里“virtual”是可以省略的）</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Base&gt; upb =         <span class="comment">//创建基类指针指向派生类对象</span></span><br><span class="line">    std::<span class="built_in">make_unique</span>&lt;Derived&gt;();    <span class="comment">//关于std::make_unique</span></span><br><span class="line">…                                   <span class="comment">//请参见Item21</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">upb-&gt;<span class="built_in">doWork</span>();                      <span class="comment">//通过基类指针调用doWork，</span></span><br><span class="line">                                    <span class="comment">//实际上是派生类的doWork</span></span><br><span class="line">                                    <span class="comment">//函数被调用</span></span><br></pre></td></tr></table></figure>
<p>要想重写一个函数，必须满足下列要求：</p>
<ul>
<li>基类函数必须是 <code>virtual</code></li>
<li>基类和派生类函数名必须完全一样（除非是析构函数)</li>
<li>基类和派生类函数形参类型必须完全一样</li>
<li>基类和派生类函数常量性 <code>const</code> ness 必须完全一样</li>
<li>基类和派生类函数的返回值和异常说明（<em>exception specifications</em>）必须兼容</li>
</ul>
<p>除了这些 C++98 就存在的约束外，C++11 又添加了一个：</p>
<ul>
<li>函数的引用限定符（<em>reference qualifiers</em>）必须完全一样。成员函数的引用限定符是 C++11 很少抛头露脸的特性，所以如果你从没听过它无需惊讶。它可以限定成员函数只能用于左值或者右值。成员函数不需要 <code>virtual</code> 也能使用它们：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;    <span class="comment">//只有*this为左值的时候才能被调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;   <span class="comment">//只有*this为右值的时候才能被调用</span></span><br><span class="line">&#125;; </span><br><span class="line">…</span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;    <span class="comment">//工厂函数（返回右值）</span></span><br><span class="line">Widget w;               <span class="comment">//普通对象（左值）</span></span><br><span class="line">…</span><br><span class="line">w.<span class="built_in">doWork</span>();             <span class="comment">//调用被左值引用限定修饰的Widget::doWork版本</span></span><br><span class="line">                        <span class="comment">//（即Widget::doWork &amp;）</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>();  <span class="comment">//调用被右值引用限定修饰的Widget::doWork版本</span></span><br><span class="line">                        <span class="comment">//（即Widget::doWork &amp;&amp;）</span></span><br></pre></td></tr></table></figure>
后面我还会提到引用限定符修饰成员函数，但是现在，只需要记住如果基类的虚函数有引用限定符，派生类的重写就必须具有相同的引用限定符。如果没有，那么新声明的函数还是属于派生类，但是不会重写父类的任何函数。</li>
</ul>
<p>这么多的重写需求意味着哪怕一个小小的错误也会造成巨大的不同。代码中包含重写错误通常是有效的，但它的意图不是你想要的。因此你不能指望当你犯错时编译器能通知你。比如，下面的代码是完全合法的，咋一看，还很有道理，但是它没有任何虚函数重写——没有一个派生类函数联系到基类函数。你能识别每种情况的错误吗，换句话说，为什么派生类函数没有重写同名基类函数？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要一点帮助吗？</p>
<ul>
<li><p><code>mf1</code> 在 <code>Base</code> 基类声明为 <code>const</code>，但是 <code>Derived</code> 派生类没有这个常量限定符</p>
</li>
<li><p><code>mf2</code> 在 <code>Base</code> 基类声明为接受一个 <code>int</code> 参数，但是在 <code>Derived</code> 派生类声明为接受 <code>unsigned int</code> 参数</p>
</li>
<li><p><code>mf3</code> 在 <code>Base</code> 基类声明为左值引用限定，但是在 <code>Derived</code> 派生类声明为右值引用限定</p>
</li>
<li><p><code>mf4</code> 在 <code>Base</code> 基类没有声明为 <code>virtual</code> 虚函数</p>
</li>
</ul>
<p>你可能会想，“哎呀，实际操作的时候，这些 warnings 都能被编译器探测到，所以我不需要担心。”你说的可能对，也可能不对。就我目前检查的两款编译器来说，这些代码编译时没有任何 warnings，即使我开启了输出所有 warnings。（其他编译器可能会为这些问题的部分输出 warnings，但不是全部。）</p>
<p>由于正确声明派生类的重写函数很重要，但很容易出错，C++11 提供一个方法让你可以显式地指定一个派生类函数是基类版本的重写：将它声明为 <code>override</code>。还是上面那个例子，我们可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码不能编译，当然了，因为这样写的时候，编译器会抱怨所有与重写有关的问题。这也是你想要的，以及为什么要在所有重写函数后面加上 <code>override</code>。</p>
<p>使用 <code>override</code> 的代码编译时看起来就像这样（假设我们的目的是 <code>Derived</code> 派生类中的所有函数重写 <code>Base</code> 基类的相应虚函数）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;          <span class="comment">//可以添加virtual，但不是必要</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>注意在这个例子中 <code>mf4</code> 有别于之前，它在 <code>Base</code> 中的声明有 <code>virtual</code> 修饰，所以能正常工作。大多数和重写有关的错误都是在派生类引发的，但也可能是基类的不正确导致。</p>
<p>比起让编译器（译注：通过 warnings）告诉你想重写的而实际没有重写，不如给你的派生类重写函数全都加上 <code>override</code>。如果你考虑修改修改基类虚函数的函数签名，<code>override</code> 还可以帮你评估后果。如果派生类全都用上 <code>override</code>，你可以只改变基类函数签名，重编译系统，再看看你造成了多大的问题（即，多少派生类不能通过编译），然后决定是否值得如此麻烦更改函数签名。没有 <code>override</code>，你只能寄希望于完善的单元测试，因为，正如我们所见，派生类虚函数本想重写基类，但是没有，编译器也没有探测并发出诊断信息。</p>
<p>C++既有很多关键字，C++11 引入了两个上下文关键字（<em>contextual keywords</em>），<code>override</code> 和 <code>final</code>（向虚函数添加 <code>final</code> 可以防止派生类重写。<code>final</code> 也能用于类，这时这个类不能用作基类）。这两个关键字的特点是它们是保留的，它们只是位于特定上下文才被视为关键字。对于 <code>override</code>，它只在成员函数声明结尾处才被视为关键字。这意味着如果你以前写的代码里面已经用过<strong>override</strong>这个名字，那么换到 C++11 标准你也无需修改代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Warning</span> &#123;         <span class="comment">//C++98潜在的传统类代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">override</span><span class="params">()</span></span>;    <span class="comment">//C++98和C++11都合法（且含义相同）</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于 <code>override</code> 想说的就这么多，但对于成员函数引用限定（<em>reference qualifiers</em>）还有一些内容。我之前承诺我会在后面提供更多的关于它们的资料，现在就是”后面”了。</p>
<p>如果我们想写一个函数只接受左值实参，我们声明一个 non- <code>const</code> 左值引用形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(Widget&amp; w)</span></span>;    <span class="comment">//只接受左值Widget对象</span></span><br></pre></td></tr></table></figure>
<p>如果我们想写一个函数只接受右值实参，我们声明一个右值引用形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(Widget&amp;&amp; w)</span></span>;   <span class="comment">//只接受右值Widget对象</span></span><br></pre></td></tr></table></figure>
<p>成员函数的引用限定可以很容易的区分一个成员函数被哪个对象（即 <code>*this</code>）调用。它和在成员函数声明尾部添加一个 <code>const</code> 很相似，暗示了调用这个成员函数的对象（即 <code>*this</code>）是 <code>const</code> 的。</p>
<p>对成员函数添加引用限定不常见，但是可以见。举个例子，假设我们的 <code>Widget</code> 类有一个 <code>std::vector</code> 数据成员，我们提供一个访问函数让客户端可以直接访问它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;   <span class="comment">//“using”的信息参见Item9</span></span><br><span class="line">    …</span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是最具封装性的设计，只给外界保留一线光。但先把这个放一边，思考一下下面的客户端代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>();  <span class="comment">//拷贝w.values到vals1</span></span><br></pre></td></tr></table></figure>
<p><code>Widget::data</code> 函数的返回值是一个左值引用（准确的说是 <code>std::vector&lt;double&gt;&amp;</code>）,<br>因为左值引用是左值，所以 <code>vals1</code> 是从左值初始化的。因此 <code>vals1</code> 由 <code>w.values</code> 拷贝构造而得，就像注释说的那样。</p>
<p>现在假设我们有一个创建 <code>Widget</code> s 的工厂函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们想用 <code>makeWidget</code> 返回的 <code>Widget</code> 里的 <code>std::vector</code> 初始化一个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();   <span class="comment">//拷贝Widget里面的值到vals2</span></span><br></pre></td></tr></table></figure>
<p>再说一次，<code>Widgets::data</code> 返回的是左值引用，还有，左值引用是左值。所以，我们的对象（<code>vals2</code>）得从 <code>Widget</code> 里的 <code>values</code> 拷贝构造。这一次，<code>Widget</code> 是 <code>makeWidget</code> 返回的临时对象（即右值），所以将其中的 <code>std::vector</code> 进行拷贝纯属浪费。最好是移动，但是因为 <code>data</code> 返回左值引用，C++的规则要求编译器不得不生成一个拷贝。（这其中有一些优化空间，被称作“as if rule”，但是你依赖编译器使用这个优化规则就有点傻。）（译注：“as if rule”简单来说就是在不影响程序的“外在表现”情况下做一些改变）</p>
<p>我们需要的是指明当 <code>data</code> 被右值 <code>Widget</code> 对象调用的时候结果也应该是一个右值。现在就可以使用引用限定，为左值 <code>Widget</code> 和右值 <code>Widget</code> 写一个 <code>data</code> 的重载函数来达成这一目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp;              <span class="comment">//对于左值Widgets,</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> values; &#125;              <span class="comment">//返回左值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp;              <span class="comment">//对于右值Widgets,</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;   <span class="comment">//返回右值</span></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意 <code>data</code> 重载的返回类型是不同的，左值引用重载版本返回一个左值引用（即一个左值），右值引用重载返回一个临时对象（即一个右值）。这意味着现在客户端的行为和我们的期望相符了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>();              <span class="comment">//调用左值重载版本的Widget::data，</span></span><br><span class="line">                                    <span class="comment">//拷贝构造vals1</span></span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();   <span class="comment">//调用右值重载版本的Widget::data, </span></span><br><span class="line">                                    <span class="comment">//移动构造vals2</span></span><br></pre></td></tr></table></figure>
<p>这真的很棒，但别被这结尾的暖光照耀分心以致忘记了该条款的中心。这个条款的中心是只要你在派生类声明想要重写基类虚函数的函数，就加上 <code>override</code>。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>为重写函数加上 <code>override</code></li>
<li>成员函数引用限定让我们可以区别对待左值对象和右值对象（即 <code>*this</code>)</li>
</ul>
<h2 id="条款十三：优先考虑-const-iterator-而非-iterator"><a href="#条款十三：优先考虑-const-iterator-而非-iterator" class="headerlink" title="条款十三：优先考虑 const_iterator 而非 iterator"></a>条款十三：优先考虑 <code>const_iterator</code> 而非 <code>iterator</code></h2><p><strong>Item 13: Prefer <code>const_iterators</code> to <code>iterators</code></strong></p>
<p>STL <code>const_iterator</code> 等价于指向常量的指针（pointer-to- <code>const</code>）。它们都指向不能被修改的值。标准实践是能加上 <code>const</code> 就加上，这也指示我们需要一个迭代器时只要没必要修改迭代器指向的值，就应当使用 <code>const_iterator</code>。</p>
<p>上面的说法对 C++11 和 C++98 都是正确的，但是在 C++98 中，标准库对 <code>const_iterator</code> 的支持不是很完整。首先不容易创建它们，其次就算你有了它，它的使用也是受限的。假如你想在 <code>std::vector&lt;int&gt;</code> 中查找第一次出现 1983（C++代替 C with classes 的那一年）的位置，然后插入 1998（第一个 ISO C++标准被接纳的那一年）。如果<em>vector</em>中没有 1983，那么就在<em>vector</em>尾部插入。在 C++98 中使用 <code>iterator</code> 可以很容易做到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">…</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it =</span><br><span class="line">    std::<span class="built_in">find</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>

<p>但是这里 <code>iterator</code> 真的不是一个好的选择，因为这段代码不修改 <code>iterator</code> 指向的内容。用 <code>const_iterator</code> 重写这段代码是很平常的，但是在 C++98 中就不是了。下面是一种概念上可行但是不正确的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::iterator IterT;               <span class="comment">//typedef</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::const_iterator ConstIterT;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">…</span><br><span class="line">ConstIterT ci =</span><br><span class="line">    std::<span class="built_in">find</span>(<span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()),  <span class="comment">//cast</span></span><br><span class="line">              <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()),    <span class="comment">//cast</span></span><br><span class="line">              <span class="number">1983</span>);</span><br><span class="line"></span><br><span class="line">values.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);    <span class="comment">//可能无法通过编译，</span></span><br><span class="line">                                                <span class="comment">//原因见下</span></span><br></pre></td></tr></table></figure>

<p><code>typedef</code> 不是强制的，但是可以让代码中的<em>cast</em>更好写。（你可能想知道为什么我使用 <code>typedef</code> 而不是 <a href="6%20Effective%20Modern%20C++.md">Item9</a> 提到的别名声明，因为这段代码在演示 C++98 做法，别名声明是 C++11 加入的特性）</p>
<p>之所以 <code>std::find</code> 的调用会出现类型转换是因为在 C++98 中 <code>values</code> 是 non- <code>const</code> 容器，没办法简简单单的从 non- <code>const</code> 容器中获取 <code>const_iterator</code>。严格来说类型转换不是必须的，因为用其他方法获取 <code>const_iterator</code> 也是可以的（比如你可以把 <code>values</code> 绑定到 reference-to- <code>const</code> 变量上，然后再用这个变量代替 <code>values</code>），但不管怎么说，从 non- <code>const</code> 容器中获取 <code>const_iterator</code> 的做法都有点别扭。</p>
<p>当你费劲地获得了 <code>const_iterator</code>，事情可能会变得更糟，因为 C++98 中，插入操作（以及删除操作）的位置只能由 <code>iterator</code> 指定，<code>const_iterator</code> 是不被接受的。这也是我在上面的代码中，将 <code>const_iterator</code>（我那么小心地从 <code>std::find</code> 搞出来的东西）转换为 <code>iterator</code> 的原因，因为向 <code>insert</code> 传入 <code>const_iterator</code> 不能通过编译。</p>
<p>老实说，上面的代码也可能无法编译，因为没有一个可移植的从 <code>const_iterator</code> 到 <code>iterator</code> 的方法，即使使用 <code>static_cast</code> 也不行。甚至传说中的牛刀 <code>reinterpret_cast</code> 也杀不了这条鸡。（它不是 C++98 的限制，也不是 C++11 的限制，只是 <code>const_iterator</code> 就是不能转换为 <code>iterator</code>，不管看起来对它们施以转换是有多么合理。）不过有办法生成一个 <code>iterator</code>，使其指向和 <code>const_iterator</code> 指向相同，但是看起来不明显，也没有广泛应用，在这本书也不值得讨论。除此之外，我希望目前我陈述的观点是清晰的：<code>const_iterator</code> 在 C++98 中会有很多问题，不如它的兄弟（译注：指 <code>iterator</code>）有用。最终，开发者们不再相信能加 <code>const</code> 就加它的教条，而是只在实用的地方加它，C++98 的 <code>const_iterator</code> 不是那么实用。</p>
<p>所有的这些都在 C++11 中改变了，现在 <code>const_iterator</code> 既容易获取又容易使用。容器的成员函数 <code>cbegin</code> 和 <code>cend</code> 产出 <code>const_iterator</code>，甚至对于 non- <code>const</code> 容器也可用，那些之前使用<em>iterator</em>指示位置（如 <code>insert</code> 和 <code>erase</code>）的 STL 成员函数也可以使用 <code>const_iterator</code> 了。使用 C++11 <code>const_iterator</code> 重写 C++98 使用 <code>iterator</code> 的代码也稀松平常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;                                <span class="comment">//和之前一样</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> it =                                               <span class="comment">//使用cbegin</span></span><br><span class="line">	std::<span class="built_in">find</span>(values.<span class="built_in">cbegin</span>(), values.<span class="built_in">cend</span>(), <span class="number">1983</span>);<span class="comment">//和cend</span></span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>
<p>现在使用 <code>const_iterator</code> 的代码就很实用了！</p>
<p>唯一一个 C++11 对于 <code>const_iterator</code> 支持不足（译注：C++14 支持但是 C++11 的时候还没）的情况是：当你想写最大程度通用的库，并且这些库代码为一些容器和类似容器的数据结构提供 <code>begin</code>、<code>end</code>（以及 <code>cbegin</code>，<code>cend</code>，<code>rbegin</code>，<code>rend</code> 等）作为<strong>非成员函数</strong>而不是成员函数时。其中一种情况就是原生数组，还有一种情况是一些只由自由函数组成接口的第三方库。（译注：自由函数<em>free function</em>，指的是非成员函数，即一个函数，只要不是成员函数就可被称作<em>free function</em>）最大程度通用的库会考虑使用非成员函数而不是假设成员函数版本存在。</p>
<p>举个例子，我们可以泛化下面的 <code>findAndInsert</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container,            <span class="comment">//在容器中查找第一次</span></span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> V&amp; targetVal,      <span class="comment">//出现targetVal的位置，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> V&amp; insertVal)</span>      <span class="comment">//然后在那插入insertVal</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cbegin;</span><br><span class="line">    <span class="keyword">using</span> std::cend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container),  <span class="comment">//非成员函数cbegin</span></span><br><span class="line">                        <span class="built_in">cend</span>(container),    <span class="comment">//非成员函数cend</span></span><br><span class="line">                        targetVal);</span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以在 C++14 工作良好，但是很遗憾，C++11 不在良好之列。由于标准化的疏漏，C++11 只添加了非成员函数 <code>begin</code> 和 <code>end</code>，但是没有添加 <code>cbegin</code>，<code>cend</code>，<code>rbegin</code>，<code>rend</code>，<code>crbegin</code>，<code>crend</code>。C++14 修订了这个疏漏。</p>
<p>如果你使用 C++11，并且想写一个最大程度通用的代码，而你使用的 STL 没有提供缺失的非成员函数 <code>cbegin</code> 和它的朋友们，你可以简单的写下你自己的实现。比如，下面就是非成员函数 <code>cbegin</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);   <span class="comment">//解释见下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能很惊讶非成员函数 <code>cbegin</code> 没有调用成员函数 <code>cbegin</code> 吧？我也是。但是请跟逻辑走。这个 <code>cbegin</code> 模板接受任何代表类似容器的数据结构的实参类型 <code>C</code>，并且通过 reference-to- <code>const</code> 形参 <code>container</code> 访问这个实参。如果 <code>C</code> 是一个普通的容器类型（如 <code>std::vector&lt;int&gt;</code>），<code>container</code> 将会引用一个 <code>const</code> 版本的容器（如 <code>const std::vector&lt;int&gt;&amp;</code>）。对 <code>const</code> 容器调用非成员函数 <code>begin</code>（由 C++11 提供）将产出 <code>const_iterator</code>，这个迭代器也是模板要返回的。用这种方法实现的好处是就算容器只提供 <code>begin</code> 成员函数（对于容器来说，C++11 的非成员函数 <code>begin</code> 调用这些成员函数）不提供 <code>cbegin</code> 成员函数也没问题。那么现在你可以将这个非成员函数 <code>cbegin</code> 施于只直接支持 <code>begin</code> 的容器。</p>
<p>如果 <code>C</code> 是原生数组，这个模板也能工作。这时，<code>container</code> 成为一个 <code>const</code> 数组的引用。C++11 为数组提供特化版本的非成员函数 <code>begin</code>，它返回指向数组第一个元素的指针。一个 <code>const</code> 数组的元素也是 <code>const</code>，所以对于 <code>const</code> 数组，非成员函数 <code>begin</code> 返回指向 <code>const</code> 的指针（pointer-to- <code>const</code>）。在数组的上下文中，所谓指向 <code>const</code> 的指针（pointer-to- <code>const</code>），也就是 <code>const_iterator</code> 了。</p>
<p>回到最开始，本条款的中心是鼓励你只要能就使用 <code>const_iterator</code>。最原始的动机——只要它有意义就加上 <code>const</code> ——是 C++98 就有的思想。但是在 C++98，它（译注：<code>const_iterator</code>）只是一般有用，到了 C++11，它就是极其有用了，C++14 在其基础上做了些修补工作。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>优先考虑 <code>const_iterator</code> 而非 <code>iterator</code></li>
<li>在最大程度通用的代码中，优先考虑非成员函数版本的 <code>begin</code>，<code>end</code>，<code>rbegin</code> 等，而非同名成员函数</li>
</ul>
<h2 id="条款十四：如果函数不抛出异常请使用-noexcept"><a href="#条款十四：如果函数不抛出异常请使用-noexcept" class="headerlink" title="条款十四：如果函数不抛出异常请使用 noexcept"></a>条款十四：如果函数不抛出异常请使用 <code>noexcept</code></h2><p><strong>Item 14: Declare functions <code>noexcept</code> if they won’t emit exceptions</strong></p>
<p>在 C++98 中，异常说明（<em>exception specifications</em>）是喜怒无常的野兽。你不得不写出函数可能抛出的异常类型，如果函数实现有所改变，异常说明也可能需要修改。改变异常说明会影响客户端代码，因为调用者可能依赖原版本的异常说明。编译器不会在函数实现，异常说明和客户端代码之间提供一致性保障。大多数程序员最终都认为不值得为 C++98 的异常说明做得如此麻烦。</p>
<p>在 C++11 标准化过程中，大家一致认为异常说明真正有用的信息是一个函数是否会抛出异常。非黑即白，一个函数可能抛异常，或者不会。这种”可能-绝不”的二元论构成了 C++11 异常说的基础，从根本上改变了 C++98 的异常说明。（C++98 风格的异常说明也有效，但是已经标记为 deprecated（废弃））。在 C++11 中，无条件的 <code>noexcept</code> 保证函数不会抛出任何异常。</p>
<p>关于一个函数是否已经声明为 <code>noexcept</code> 是接口设计的事。函数的异常抛出行为是客户端代码最关心的。调用者可以查看函数是否声明为 <code>noexcept</code>，这个可以影响到调用代码的异常安全性（<em>exception safety</em>）和效率。就其本身而言，函数是否为 <code>noexcept</code> 和成员函数是否 <code>const</code> 一样重要。当你知道这个函数不会抛异常而没加上 <code>noexcept</code>，那这个接口说明就有点差劲了。</p>
<p>不过这里还有给不抛异常的函数加上 <code>noexcept</code> 的动机：它允许编译器生成更好的目标代码。要想知道为什么，了解 C++98 和 C++11 指明一个函数不抛异常的方式是很有用了。考虑一个函数 <code>f</code>，它保证调用者永远不会收到一个异常。两种表达方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//C++98风格，没有来自f的异常</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//C++11风格，没有来自f的异常</span></span><br></pre></td></tr></table></figure>
<p>如果在运行时，<code>f</code> 出现一个异常，那么就和 <code>f</code> 的异常说明冲突了。在 C++98 的异常说明中，调用栈（the <em>call stack</em>）会展开至 <code>f</code> 的调用者，在一些与这地方不相关的动作后，程序被终止。C++11 异常说明的运行时行为有些不同：调用栈只是<strong>可能</strong>在程序终止前展开。</p>
<p>展开调用栈和<strong>可能</strong>展开调用栈两者对于代码生成（code generation）有非常大的影响。在一个 <code>noexcept</code> 函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈（the runtime stack）处于可展开状态；也不需要保证当异常离开 <code>noexcept</code> 函数时，<code>noexcept</code> 函数中的对象按照构造的反序析构。而标注“<code>throw()</code>”异常声明的函数缺少这样的优化灵活性，没加异常声明的函数也一样。可以总结一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//极尽所能优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//较少优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;           <span class="comment">//较少优化</span></span><br></pre></td></tr></table></figure>
<p>这是一个充分的理由使得你当知道它不抛异常时加上 <code>noexcept</code>。</p>
<p>还有一些函数更符合这个情况。移动操作是绝佳的例子。假如你有一份 C++98 代码，里面用到了 <code>std::vector&lt;Widget&gt;</code>。<code>Widget</code> 通过 <code>push_back</code> 一次又一次的添加进 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">…</span><br><span class="line">Widget w;</span><br><span class="line">…                   <span class="comment">//用w做点事</span></span><br><span class="line">vw.<span class="built_in">push_back</span>(w);    <span class="comment">//把w添加进vw</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>假设这个代码能正常工作，你也无意修改为 C++11 风格。但是你确实想要 C++11 移动语义带来的性能优势，毕竟这里的类型是可以移动的（move-enabled types）。因此你需要确保 <code>Widget</code> 有移动操作，可以手写代码也可以让编译器自动生成，当然前提是能满足自动生成的条件（参见 <a href="../3.MovingToModernCpp/item17.md">Item17</a>）。</p>
<p>当新元素添加到 <code>std::vector</code>，<code>std::vector</code> 可能没地方放它，换句话说，<code>std::vector</code> 的大小（size）等于它的容量（capacity）。这时候，<code>std::vector</code> 会分配一个新的更大块的内存用于存放其中元素，然后将元素从老内存区移动到新内存区，然后析构老内存区里的对象。在 C++98 中，移动是通过复制老内存区的每一个元素到新内存区完成的，然后老内存区的每个元素发生析构。这种方法使得 <code>push_back</code> 可以提供很强的异常安全保证：如果在复制元素期间抛出异常，<code>std::vector</code> 状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。</p>
<p>在 C++11 中，一个很自然的优化就是将上述复制操作替换为移动操作。但是很不幸运，这会破坏 <code>push_back</code> 的异常安全保证。如果<strong>n</strong>个元素已经从老内存移动到了新内存区，但异常在移动第<strong>n+1</strong>个元素时抛出，那么 <code>push_back</code> 操作就不能完成。但是原始的 <code>std::vector</code> 已经被修改：有<strong>n</strong>个元素已经移动走了。恢复 <code>std::vector</code> 至原始状态也不太可能，因为从新内存移动到老内存本身又可能引发异常。</p>
<p>这是个很严重的问题，因为老代码可能依赖于 <code>push_back</code> 提供的强烈的异常安全保证。因此，C++11 版本的实现不能简单的将 <code>push_back</code> 里面的复制操作替换为移动操作，除非知晓移动操作绝不抛异常，这时复制替换为移动就是安全的，唯一的副作用就是性能得到提升。</p>
<p><code>std::vector::push_back</code> 受益于“如果可以就移动，如果必要则复制”策略，并且它不是标准库中唯一采取该策略的函数。C++98 中还有一些函数（如 <code>std::vector::reverse</code>，<code>std::deque::insert</code> 等）也受益于这种强异常保证。对于这个函数只有在知晓移动不抛异常的情况下用 C++11 的移动操作替换 C++98 的复制操作才是安全的。但是如何知道一个函数中的移动操作是否产生异常？答案很明显：它检查这个操作是否被声明为 <code>noexcept</code>。（这个检查非常弯弯绕。像是 <code>std::vector::push_back</code> 之类的函数调用 <code>std::move_if_noexcept</code>，这是个 <code>std::move</code> 的变体，根据其中类型的移动构造函数是否为 <code>noexcept</code> 的，视情况转换为右值或保持左值（参见 <a href="../5.RRefMovSemPerfForw/item23.md">Item23</a>）。反过来，<code>std::move_if_noexcept</code> 查阅 <code>std::is_nothrow_move_constructible</code> 这个<em>type trait</em>，基于移动构造函数是否有 <code>noexcept</code>（或者 <code>throw()</code>）的设计，编译器设置这个<em>type trait</em>的值。）</p>
<p><code>swap</code> 函数是 <code>noexcept</code> 的另一个绝佳用地。<code>swap</code> 是 STL 算法实现的一个关键组件，它也常用于拷贝运算符重载中。它的广泛使用意味着对其施加不抛异常的优化是非常有价值的。有趣的是，标准库的 <code>swap</code> 是否 <code>noexcept</code> 有时依赖于用户定义的 <code>swap</code> 是否 <code>noexcept</code>。比如，数组和 <code>std::pair</code> 的 <code>swap</code> 声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N],</span></span></span><br><span class="line"><span class="params"><span class="function">          T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;  <span class="comment">//见下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些函数<strong>视情况</strong><code>noexcept</code>：它们是否 <code>noexcept</code> 依赖于 <code>noexcept</code> 声明中的表达式是否 <code>noexcept</code>。假设有两个 <code>Widget</code> 数组，交换数组操作为 <code>noexcept</code> 的前提是数组中的元素交换是 <code>noexcept</code> 的，即 <code>Widget</code> 的 <code>swap</code> 是 <code>noexcept</code>。因此 <code>Widget</code> 的 <code>swap</code> 的作者决定了交换 <code>widget</code> 的数组是否 <code>noexcept</code>。对于 <code>Widget</code> 的交换是否 <code>noexcept</code> 决定了对于 <code>Widget</code> 数组的交换是否 <code>noexcept</code>，以及其他交换，比如 <code>Widget</code> 的数组的数组的交换是否 <code>noexcept</code>。类似地，交换两个含有 <code>Widget</code> 的 <code>std::pair</code> 是否 <code>noexcept</code> 依赖于 <code>Widget</code> 的 <code>swap</code> 是否 <code>noexcept</code>。事实上交换高层次数据结构是否 <code>noexcept</code> 取决于它的构成部分的那些低层次数据结构是否 <code>noexcept</code>，这激励你只要可以就提供 <code>noexcept</code> <code>swap</code> 函数（译注：因为如果你的函数不提供 <code>noexcept</code> 保证，其它依赖你的高层次 <code>swap</code> 就不能保证 <code>noexcept</code>）。</p>
<p>现在，我希望你能为 <code>noexcept</code> 提供的优化机会感到高兴，同时我还得让你缓一缓别太高兴了。优化很重要，但是正确性更重要。我在这个条款的开头提到 <code>noexcept</code> 是函数接口的一部分，所以仅当你保证一个函数实现在长时间内不会抛出异常时才声明 <code>noexcept</code>。如果你声明一个函数为 <code>noexcept</code>，但随即又后悔了，你没有选择。你可以从函数声明中移除 <code>noexcept</code>（即改变它的接口），这理所当然会影响客户端代码。你可以改变实现使得这个异常可以避免，再保留原版本（现在来看不正确的）异常说明。如果你这么做，在异常试图离开这个函数时程序将会终止。或者你就顺从了既有实现，舍弃了激起你兴趣的东西，从一开始就改变实现。这些选择都不尽人意。</p>
<p>这个问题的本质是实际上大多数函数都是异常中立（<em>exception-neutral</em>）的。这些函数自己不抛异常，但是它们内部的调用可能抛出。此时，异常中立函数允许那些抛出异常的函数在调用链上更进一步直到遇到异常处理程序，而不是就地终止。异常中立函数决不应该声明为 <code>noexcept</code>，因为它们可能抛出那种“让它们过吧”的异常（译注：也就是说在当前这个函数内不处理异常，但是又不立即终止程序，而是让调用这个函数的函数处理异常。）因此大多数函数缺少 <code>noexcept</code> 设计。</p>
<p>然而，一些函数很自然的不应该抛异常，更进一步——尤其是移动操作和 <code>swap</code> ——使其 <code>noexcept</code> 有重大意义，只要可能就应该将它们实现为 <code>noexcept</code>。（STL 对容器的移动操作的接口规范里缺少 <code>noexcept</code>。然而实现者可以增强 STL 函数的异常说明，实际上，至少有些容器的移动操作已被声明为 <code>noexcept</code>，这些做法就是本条例所给建议的好示例。发现了容器移动操作可以写成不抛异常的之后，实现者经常将这些操作声明为 <code>noexcept</code> 的，尽管标准并没有要求他们这么做。）老实说，当你确保函数决不抛异常的时候，一定要将它们声明为 <code>noexcept</code>。</p>
<p>请注意我说有些函数有<strong>自然的</strong><code>noexcept</code> 实现法。为了 <code>noexcept</code> 而扭曲函数实现来达成目的是本末倒置。是把马车放到马前，是一叶障目不见泰山。是… 选择你喜欢的比喻吧。（译注：几个英语熟语，都是想说明“本末倒置”。）如果一个简单的函数实现可能引发异常（比如调用一个可能抛异常的函数），而你为了讨好调用者隐藏了这个（比如捕获所有异常，然后替换为状态码或者特殊返回值），这不仅会使你的函数实现变得复杂，还会让调用点的代码变得复杂。调用者可能不得不检查状态码或特殊返回值。而这些复杂的运行时开销（比如额外的分支，大的函数给指令缓存带来的压力等）可能超出 <code>noexcept</code> 带来的性能提升，再加上你会悲哀的发现这些代码又难读又难维护。那是糟糕的软件工程化。</p>
<p>对于一些函数，使其成为 <code>noexcept</code> 是很重要的，它们应当默认如是。在 C++98，允许内存释放（memory deallocation）函数（即 <code>operator delete</code> 和 <code>operator delete[]</code>）和析构函数抛出异常是糟糕的代码设计，C++11 将这种作风升级为语言规则。默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式 <code>noexcept</code>。因此它们不需要声明 <code>noexcept</code>。（这么做也不会有问题，只是不合常规）。析构函数非隐式 <code>noexcept</code> 的情况仅当类的数据成员（包括继承的成员还有继承成员内的数据成员）明确声明它的析构函数可能抛出异常（如声明“<code>noexcept(false)</code>”）。这种析构函数不常见，标准库里面没有。如果一个对象的析构函数可能被标准库使用（比如在容器内或者被传给一个算法），析构函数又可能抛异常，那么程序的行为是未定义的。</p>
<p>值得注意的是一些库接口设计者会区分有宽泛契约（<strong>wild contracts</strong>）和严格契约（<strong>narrow contracts</strong>）的函数。有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束。（“不管程序状态如何”和“不设约束”对已经行为未定义的程序无效。比如 <code>std::vector::size</code> 有宽泛契约，但是并不保证如果你把一块随机内存转换为一个 <code>std::vector</code>，在这块内存上调用它会有合理的表现。转换的结果是未定义的，所以包含这个转换的程序也无法保证表现合理）宽泛契约的函数决不表现出未定义行为。</p>
<p>反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。</p>
<p>如果你写了一个有宽泛契约的函数并且你知道它不会抛异常，那么遵循这个条款给它声明一个 <code>noexcept</code> 是很容易的。对于严格契约的函数，情况就有点微妙了。举个例子，假如你在写一个形参为 <code>std::string</code> 的函数 <code>f</code>，并且假定这个函数 <code>f</code> 很自然的决不引发异常。这就表明 <code>f</code> 应该被声明为 <code>noexcept</code>。</p>
<p>现在假如 <code>f</code> 有一个前置条件：类型为 <code>std::string</code> 的参数的长度不能超过 32 个字符。如果现在调用 <code>f</code> 并传给它一个大于 32 字符的 <code>std::string</code>，函数行为将是未定义的，因为<strong>根据定义</strong>违反了前置条件，导致了未定义行为。<code>f</code> 没有义务去检查前置条件，它假设这些前置条件都是满足的。（调用者有责任确保参数字符不超过 32 字符等这些假设有效。）即使有前置条件，将 <code>f</code> 声明为 <code>noexcept</code> 似乎也是合适的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//前置条件：</span></span><br><span class="line">                                        <span class="comment">//s.length() &lt;= 32 </span></span><br></pre></td></tr></table></figure>
<p>假定 <code>f</code> 的实现者在函数里面检查前置条件冲突。虽然检查是没有必要的，但是也没禁止这么做，检查前置条件可能也是有用的，比如在系统测试时。debug 一个抛出的异常一般都比跟踪未定义行为起因更容易。那么怎么报告前置条件冲突使得测试工具或客户端错误处理程序能检测到它呢？简单直接的做法是抛出“precondition was violated”异常，但是如果 <code>f</code> 声明了 <code>noexcept</code>，这就行不通了；抛出一个异常会导致程序终止。因为这个原因，区分严格&#x2F;宽泛契约库设计者一般会将 <code>noexcept</code> 留给宽泛契约函数。</p>
<p>作为结束语，让我详细说明一下之前的观察，即编译器不会为函数实现和异常规范提供一致性保障。考虑下面的代码，它是完全正确的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>;           <span class="comment">//函数定义另在一处</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">setup</span>();               <span class="comment">//设置要做的工作</span></span><br><span class="line"> …                      <span class="comment">//真实工作</span></span><br><span class="line"> <span class="built_in">cleanup</span>();             <span class="comment">//执行清理动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>doWork</code> 声明为 <code>noexcept</code>，即使它调用了 non- <code>noexcept</code> 函数 <code>setup</code> 和 <code>cleanup</code>。看起来有点矛盾，其实可以猜想 <code>setup</code> 和 <code>cleanup</code> 在文档上写明了它们决不抛出异常，即使它们没有写上 <code>noexcept</code>。至于为什么明明不抛异常却不写 <code>noexcept</code> 也是有合理原因的。比如，它们可能是用 C 写的库函数的一部分。（即使一些函数从 C 标准库移动到了 <code>std</code> 命名空间，也可能缺少异常规范，<code>std::strlen</code> 就是一个例子，它没有声明 <code>noexcept</code>。）或者它们可能是 C++98 库的一部分，它们不使用 C++98异常规范，到了C++11还没有修订。</p>
<p>因为有很多合理原因解释为什么 <code>noexcept</code> 依赖于缺少 <code>noexcept</code> 保证的函数，所以 C++允许这些代码，编译器一般也不会给出 warnings。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><code>noexcept</code> 是函数接口的一部分，这意味着调用者可能会依赖它</li>
<li><code>noexcept</code> 函数较之于 non- <code>noexcept</code> 函数更容易优化</li>
<li><code>noexcept</code> 对于移动语义，<code>swap</code>，内存释放函数和析构函数非常有用</li>
<li>大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是 <code>noexcept</code></li>
</ul>
<h2 id="条款十五：尽可能的使用-constexpr"><a href="#条款十五：尽可能的使用-constexpr" class="headerlink" title="条款十五：尽可能的使用 constexpr"></a>条款十五：尽可能的使用 <code>constexpr</code></h2><p><strong>Item 15: Use <code>constexpr</code> whenever possible</strong></p>
<p>如果要给 C++11 颁一个“最令人困惑新词”奖，<code>constexpr</code> 十有八九会折桂。当用于对象上面，它本质上就是 <code>const</code> 的加强形式，但是当它用于函数上，意思就大不相同了。有必要消除困惑，因为你绝对会用它的，特别是当你发现 <code>constexpr</code> “正合吾意”的时候。</p>
<p>从概念上来说，<code>constexpr</code> 表明一个值不仅仅是常量，还是编译期可知的。这个表述并不全面，因为当 <code>constexpr</code> 被用于函数的时候，事情就有一些细微差别了。为了避免我毁了结局带来的 surprise，我现在只想说，你不能假设 <code>constexpr</code> 函数的结果是 <code>const</code>，也不能保证它们的（译注：返回）值是在编译期可知的。最有意思的是，这些是<strong>特性</strong>。关于 <code>constexpr</code> 函数返回的结果不需要是 <code>const</code>，也不需要编译期可知这一点是<strong>良好的</strong>行为！</p>
<p>不过我们还是先从 <code>constexpr</code> 对象开始说起。这些对象，实际上，和 <code>const</code> 一样，它们是编译期可知的。（技术上来讲，它们的值在翻译期（translation）决议，所谓翻译不仅仅包含是编译（compilation）也包含链接（linking），除非你准备写 C++的编译器和链接器，否则这些对你不会造成影响，所以你编程时无需担心，把这些 <code>constexpr</code> 对象值看做编译期决议也无妨的。）</p>
<p>编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。对于那些嵌入式系统的开发者，这个特性是相当重要的。更广泛的应用是“其值编译期可知”的常量整数会出现在需要“整型常量表达式（<strong>integral constant expression</strong>）的上下文中，这类上下文包括数组大小，整数模板参数（包括 <code>std::array</code> 对象的长度），枚举名的值，对齐修饰符（译注：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/alignas"><code>alignas(val)</code></a>），等等。如果你想在这些上下文中使用变量，你一定会希望将它们声明为 <code>constexpr</code>，因为编译器会确保它们是编译期可知的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;                             <span class="comment">//non-constexpr变量</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">//错误！sz的值在</span></span><br><span class="line">                                    <span class="comment">//编译期不可知</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, sz&gt; data1;          <span class="comment">//错误！一样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">//没问题，10是</span></span><br><span class="line">                                    <span class="comment">//编译期可知常量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize2&gt; data2;  <span class="comment">//没问题, arraySize2是constexpr</span></span><br></pre></td></tr></table></figure>
<p>注意 <code>const</code> 不提供 <code>constexpr</code> 所能保证之事，因为 <code>const</code> 对象不需要在编译期初始化它的值。<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;                            <span class="comment">//和之前一样</span></span><br><span class="line">…</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> arraySize = sz;         <span class="comment">//没问题，arraySize是sz的const复制</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize&gt; data;   <span class="comment">//错误，arraySize值在编译期不可知</span></span><br></pre></td></tr></table></figure></p>
<p> 简而言之，所有 <code>constexpr</code> 对象都是 <code>const</code>，但不是所有 <code>const</code> 对象都是 <code>constexpr</code>。如果你想编译器保证一个变量有一个值，这个值可以放到那些需要编译期常量（compile-time constants）的上下文的地方，你需要的工具是 <code>constexpr</code> 而不是 <code>const</code>。</p>
<p>涉及到 <code>constexpr</code> 函数时，<code>constexpr</code> 对象的使用情况就更有趣了。如果实参是编译期常量，这些函数将产出编译期常量；如果实参是运行时才能知道的值，它们就将产出运行时值。这听起来就像你不知道它们要做什么一样，那么想是错误的，请这么看：</p>
<ul>
<li><code>constexpr</code> 函数可以用于需求编译期常量的上下文。如果你传给 <code>constexpr</code> 函数的实参在编译期可知，那么结果将在编译期计算。如果实参的值在编译期不知道，你的代码就会被拒绝。</li>
<li>当一个 <code>constexpr</code> 函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。这意味着你不需要两个函数，一个用于编译期计算，一个用于运行时计算。<code>constexpr</code> 全做了。</li>
</ul>
<p>假设我们需要一个数据结构来存储一个实验的结果，而这个实验可能以各种方式进行。实验期间风扇转速，温度等等都可能导致亮度值改变，亮度值可以是高，低，或者无。如果有<strong>n</strong>个实验相关的环境条件，它们每一个都有三个状态，最终可以得到的组合有 3<sup>n</sup>个。储存所有实验结果的所有组合需要足够存放 3<sup>n</sup>个值的数据结构。假设每个结果都是 <code>int</code> 并且<strong>n</strong>是编译期已知的（或者可以被计算出的），一个 <code>std::array</code> 是一个合理的选择。我们需要一个方法在编译期计算 3<sup>n</sup>。C++标准库提供了 <code>std::pow</code>，它的数学功能正是我们所需要的，但是，对我们来说，这里还有两个问题。第一，<code>std::pow</code> 是为浮点类型设计的，我们需要整型结果。第二，<code>std::pow</code> 不是 <code>constexpr</code>（即，不保证使用编译期可知值调用而得到编译期可知的结果），所以我们不能用它作为 <code>std::array</code> 的大小。</p>
<p>幸运的是，我们可以应需写个 <code>pow</code>。我将展示怎么快速完成它，不过现在让我们先看看它应该怎么被声明和使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span>                                   <span class="comment">//pow是绝不抛异常的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span>         <span class="comment">//constexpr函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> …                                          <span class="comment">//实现在下面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numConds = <span class="number">5</span>;                <span class="comment">//（上面例子中）条件的个数</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, pow(3, numConds)&gt; results;  <span class="comment">//结果有3^numConds个元素</span></span><br></pre></td></tr></table></figure>
<p>回忆下 <code>pow</code> 前面的 <code>constexpr</code> 不表明 <code>pow</code> 返回一个 <code>const</code> 值，它只说了如果 <code>base</code> 和 <code>exp</code> 是编译期常量，<code>pow</code> 的值可以被当成编译期常量使用。如果 <code>base</code> 和&#x2F;或 <code>exp</code> 不是编译期常量，<code>pow</code> 结果将会在运行时计算。这意味着 <code>pow</code> 不止可以用于像 <code>std::array</code> 的大小这种需要编译期常量的地方，它也可以用于运行时环境：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> base = <span class="built_in">readFromDB</span>(<span class="string">&quot;base&quot;</span>);     <span class="comment">//运行时获取这些值</span></span><br><span class="line"><span class="keyword">auto</span> exp = <span class="built_in">readFromDB</span>(<span class="string">&quot;exponent&quot;</span>); </span><br><span class="line"><span class="keyword">auto</span> baseToExp = <span class="built_in">pow</span>(base, exp);    <span class="comment">//运行时调用pow函数</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>constexpr</code> 函数必须能在编译期值调用的时候返回编译期结果，就必须对它的实现施加一些限制。这些限制在 C++11 和 C++14 标准间有所出入。</p>
<p>C++11 中，<code>constexpr</code> 函数的代码不超过一行语句：一个 <code>return</code>。听起来很受限，但实际上有两个技巧可以扩展 <code>constexpr</code> 函数的表达能力。第一，使用三元运算符“<code>?:</code>”来代替 <code>if</code> - <code>else</code> 语句，第二，使用递归代替循环。因此 <code>pow</code> 可以像这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样没问题，但是很难想象除了使用函数式语言的程序员外会觉得这样硬核的编程方式更好。在 C++14 中，<code>constexpr</code> 函数的限制变得非常宽松了，所以下面的函数实现成为了可能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span>   <span class="comment">//C++14</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i) result *= base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>constexpr</code> 函数限制为只能获取和返回<strong>字面值类型</strong>，这基本上意味着那些有了值的类型能在编译期决定。在 C++11 中，除了 <code>void</code> 外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是 <code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    : x(xVal), y(yVal)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Point</code> 的构造函数可被声明为 <code>constexpr</code>，因为如果传入的参数在编译期可知，<code>Point</code> 的数据成员也能在编译器可知。因此这样初始化的 <code>Point</code> 就能为 <code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;  <span class="comment">//没问题，constexpr构造函数</span></span><br><span class="line">                                <span class="comment">//会在编译期“运行”</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;  <span class="comment">//也没问题</span></span><br></pre></td></tr></table></figure>
<p>类似的，<code>xValue</code> 和 <code>yValue</code> 的<em>getter</em>（取值器）函数也能是 <code>constexpr</code>，因为如果对一个编译期已知的 <code>Point</code> 对象（如一个 <code>constexpr</code> <code>Point</code> 对象）调用<em>getter</em>，数据成员 <code>x</code> 和 <code>y</code> 的值也能在编译期知道。这使得我们可以写一个 <code>constexpr</code> 函数，里面调用 <code>Point</code> 的<em>getter</em>并初始化 <code>constexpr</code> 的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span></span></span><br><span class="line"><span class="function">Point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,   <span class="comment">//调用constexpr</span></span><br><span class="line">             (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span> &#125;; <span class="comment">//成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);      <span class="comment">//使用constexpr函数的结果</span></span><br><span class="line">                                            <span class="comment">//初始化constexpr对象</span></span><br></pre></td></tr></table></figure>
<p>这太令人激动了。它意味着 <code>mid</code> 对象通过调用构造函数，<em>getter</em>和非成员函数来进行初始化过程就能在只读内存中被创建出来！它也意味着你可以在模板实参或者需要枚举名的值的表达式里面使用像 <code>mid.xValue() * 10</code> 的表达式！（因为 <code>Point::xValue</code> 返回 <code>double</code>，<code>mid.xValue() * 10</code> 也是个 <code>double</code>。浮点数类型不可被用于实例化模板或者说明枚举名的值，但是它们可以被用来作为产生整数值的大表达式的一部分。比如，<code>static_cast&lt;int&gt;(mid.xValue() * 10)</code> 可以被用来实例化模板或者说明枚举名的值。）它也意味着以前相对严格的编译期完成的工作和运行时完成的工作的界限变得模糊，一些传统上在运行时的计算过程能并入编译时。越多这样的代码并入，你的程序就越快。（然而，编译会花费更长时间）</p>
<p>在 C++11 中，有两个限制使得 <code>Point</code> 的成员函数 <code>setX</code> 和 <code>setY</code> 不能声明为 <code>constexpr</code>。第一，它们修改它们操作的对象的状态，并且在 C++11 中，<code>constexpr</code> 成员函数是隐式的 <code>const</code>。第二，它们有 <code>void</code> 返回类型，<code>void</code> 类型不是 C++11 中的字面值类型。这两个限制在 C++14 中放开了，所以 C++14 中 <code>Point</code> 的<em>setter</em>（赋值器）也能声明为 <code>constexpr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125; <span class="comment">//C++14</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125; <span class="comment">//C++14</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在也能写这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回p相对于原点的镜像</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result;                   <span class="comment">//创建non-const Point</span></span><br><span class="line">    result.<span class="built_in">setX</span>(-p.<span class="built_in">xValue</span>());       <span class="comment">//设定它的x和y值</span></span><br><span class="line">    result.<span class="built_in">setY</span>(-p.<span class="built_in">yValue</span>());</span><br><span class="line">    <span class="keyword">return</span> result;                  <span class="comment">//返回它的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;          <span class="comment">//和之前一样</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =         <span class="comment">//reflectedMid的值</span></span><br><span class="line">    <span class="built_in">reflection</span>(mid);                  <span class="comment">//(-19.1, -16.5)在编译期可知</span></span><br></pre></td></tr></table></figure>
<p>本条款的建议是尽可能的使用 <code>constexpr</code>，现在我希望大家已经明白缘由：<code>constexpr</code> 对象和 <code>constexpr</code> 函数可以使用的范围比 non- <code>constexpr</code> 对象和函数大得多。使用 <code>constexpr</code> 关键字可以最大化你的对象和函数可以使用的场景。</p>
<p>还有个重要的需要注意的是 <code>constexpr</code> 是对象和函数接口的一部分。加上 <code>constexpr</code> 相当于宣称“我能被用在 C++要求常量表达式的地方”。如果你声明一个对象或者函数是 <code>constexpr</code>，客户端程序员就可能会在那些场景中使用它。如果你后面认为使用 <code>constexpr</code> 是一个错误并想移除它，你可能造成大量客户端代码不能编译。（为了 debug 或者性能优化而添加 I&#x2F;O 到一个函数中这样简单的动作可能就导致这样的问题，因为 I&#x2F;O 语句一般不被允许出现在 <code>constexpr</code> 函数里）“尽可能”的使用 <code>constexpr</code> 表示你需要长期坚持对某个对象或者函数施加这种限制。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><code>constexpr</code> 对象是 <code>const</code>，它被在编译期可知的值初始化</li>
<li>当传递编译期可知的值时，<code>constexpr</code> 函数可以产出编译期可知的结果</li>
<li><code>constexpr</code> 对象和函数可以使用的范围比 non- <code>constexpr</code> 对象和函数要大</li>
<li><code>constexpr</code> 是对象和函数接口的一部分</li>
</ul>
<h2 id="条款十六：让-const-成员函数线程安全"><a href="#条款十六：让-const-成员函数线程安全" class="headerlink" title="条款十六：让 const 成员函数线程安全"></a>条款十六：让 <code>const</code> 成员函数线程安全</h2><p><strong>Item 16: Make <code>const</code> member functions thread safe</strong></p>
<p>如果我们在数学领域中工作，我们就会发现用一个类表示多项式是很方便的。在这个类中，使用一个函数来计算多项式的根是很有用的，也就是多项式的值为零的时候（译者注：通常也被叫做零点，即使得多项式值为零的那些取值）。这样的一个函数它不会更改多项式。所以，它自然被声明为 <code>const</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType =           <span class="comment">//数据结构保存多项式为零的值</span></span><br><span class="line">          std::vector&lt;<span class="type">double</span>&gt;;  <span class="comment">//（“using” 的信息查看条款9）</span></span><br><span class="line">    …</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>计算多项式的根是很复杂的，因此如果不需要的话，我们就不做。如果必须做，我们肯定不想再做第二次。所以，如果必须计算它们，就缓存多项式的根，然后实现 <code>roots</code> 来返回缓存的值。下面是最基本的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;               <span class="comment">//如果缓存不可用</span></span><br><span class="line">            …                               <span class="comment">//计算根</span></span><br><span class="line">                                            <span class="comment">//用rootVals存储它们</span></span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;    <span class="comment">//初始化器（initializer）的</span></span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;           <span class="comment">//更多信息请查看条款7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从概念上讲，<code>roots</code> 并不改变它所操作的 <code>Polynomial</code> 对象。但是作为缓存的一部分，它也许会改变 <code>rootVals</code> 和 <code>rootsAreValid</code> 的值。这就是 <code>mutable</code> 的经典使用样例，这也是为什么它是数据成员声明的一部分。</p>
<p>假设现在有两个线程同时调用 <code>Polynomial</code> 对象的 <code>roots</code> 方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Polynomial p;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------ Thread 1 ------*/</span>      <span class="comment">/*-------- Thread 2 --------*/</span></span><br><span class="line"><span class="keyword">auto</span> rootsOfp = p.<span class="built_in">roots</span>();      <span class="keyword">auto</span> valsGivingZero = p.<span class="built_in">roots</span>();</span><br></pre></td></tr></table></figure>

<p>这些用户代码是非常合理的。<code>roots</code> 是 <code>const</code> 成员函数，那就表示着它是一个读操作。在没有同步的情况下，让多个线程执行读操作是安全的。它最起码应该做到这点。在本例中却没有做到线程安全。因为在 <code>roots</code> 中，这些线程中的一个或两个可能尝试修改成员变量 <code>rootsAreValid</code> 和 <code>rootVals</code>。这就意味着在没有同步的情况下，这些代码会有不同的线程读写相同的内存，这就是数据竞争（<em>data race</em>）的定义。这段代码的行为是未定义的。</p>
<p>问题就是 <code>roots</code> 被声明为 <code>const</code>，但不是线程安全的。<code>const</code> 声明在 C++11 中与在 C++98 中一样正确（检索多项式的根并不会更改多项式的值），因此需要纠正的是线程安全的缺乏。</p>
<p>解决这个问题最普遍简单的方法就是——使用 <code>mutex</code>（互斥量）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;       <span class="comment">//锁定互斥量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!rootsAreValid) &#123;                   <span class="comment">//如果缓存无效</span></span><br><span class="line">            …                                   <span class="comment">//计算/存储根值</span></span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;                                           <span class="comment">//解锁互斥量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootsVals &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>std::mutex m</code> 被声明为 <code>mutable</code>，因为锁定和解锁它的都是 non- <code>const</code> 成员函数。在 <code>roots</code>（<code>const</code> 成员函数）中，<code>m</code> 却被视为 <code>const</code> 对象。</p>
<p><del>值得注意的是，因为 <code>std::mutex</code> 是一种只可移动类型（<em>move-only type</em>，一种可以移动但不能复制的类型），所以将 <code>m</code> 添加进 <code>Polynomial</code> 中的副作用是使 <code>Polynomial</code> 失去了被复制的能力。不过，它仍然可以移动。</del> （译者注：实际上 <code>std::mutex</code> 既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的。）</p>
<p>在某些情况下，互斥量的副作用显会得过大。例如，如果你所做的只是计算成员函数被调用了多少次，使用 <code>std::atomic</code> 修饰的计数器（保证其他线程视它的操作为不可分割的整体，参见 <a href="../7.TheConcurrencyAPI/item40.md">item40</a>）通常会是一个开销更小的方法。（然而它是否轻量取决于你使用的硬件和标准库中互斥量的实现。）以下是如何使用 <code>std::atomic</code> 来统计调用次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;                                   <span class="comment">//2D点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span>  <span class="comment">//noexcept的使用</span></span></span><br><span class="line"><span class="function">    </span>&#123;                                           <span class="comment">//参考条款14</span></span><br><span class="line">        ++callCount;                            <span class="comment">//atomic的递增</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>与 <code>std::mutex</code> 一样，<code>std::atomic</code> 是只可移动类型，所以在 <code>Point</code> 中存在 <code>callCount</code> 就意味着 <code>Point</code> 也是只可移动的。</del>（译者注：与 <code>std::mutex</code> 类似的，实际上 <code>std::atomic</code> 既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的。）</p>
<p>因为对 <code>std::atomic</code> 变量的操作通常比互斥量的获取和释放的消耗更小，所以你可能会过度倾向与依赖 <code>std::atomic</code>。例如，在一个类中，缓存一个开销昂贵的 <code>int</code>，你就会尝试使用一对 <code>std::atomic</code> 变量而不是互斥量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cachedValue = val1 + val2;              <span class="comment">//第一步</span></span><br><span class="line">            cacheValid = <span class="literal">true</span>;                      <span class="comment">//第二步</span></span><br><span class="line">            <span class="keyword">return</span> cachedValid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">bool</span>&gt; cacheValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">int</span>&gt; cachedValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是可行的，但难以避免有时出现重复计算的情况。考虑：</p>
<ul>
<li>一个线程调用 <code>Widget::magicValue</code>，将 <code>cacheValid</code> 视为 <code>false</code>，执行这两个昂贵的计算，并将它们的和分配给 <code>cachedValue</code>。</li>
<li>此时，第二个线程调用 <code>Widget::magicValue</code>，也将 <code>cacheValid</code> 视为 <code>false</code>，因此执行刚才完成的第一个线程相同的计算。（这里的“第二个线程”实际上可能是其他<strong>几个</strong>线程。）</li>
</ul>
<p>这种行为与使用缓存的目的背道而驰。将 <code>cachedValue</code> 和 <code>CacheValid</code> 的赋值顺序交换可以解决这个问题，但结果会更糟：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cacheValid = <span class="literal">true</span>;                      <span class="comment">//第一步</span></span><br><span class="line">            <span class="keyword">return</span> cachedValue = val1 + val2;       <span class="comment">//第二步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>cacheValid</code> 是 false，那么：</p>
<ul>
<li>一个线程调用 <code>Widget::magicValue</code>，刚执行完将 <code>cacheValid</code> 设置 <code>true</code> 的语句。</li>
<li>在这时，第二个线程调用 <code>Widget::magicValue</code>，检查 <code>cacheValid</code>。看到它是 <code>true</code>，就返回 <code>cacheValue</code>，即使第一个线程还没有给它赋值。因此返回的值是不正确的。</li>
</ul>
<p>这里有一个坑。对于需要同步的是单个的变量或者内存位置，使用 <code>std::atomic</code> 就足够了。不过，一旦你需要对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量。对于 <code>Widget::magicValue</code> 是这样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;   <span class="comment">//锁定m</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cachedValue = val1 + val2;</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                                           <span class="comment">//解锁m</span></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cachedValue;                    <span class="comment">//不再用atomic</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheValid&#123; <span class="literal">false</span> &#125;;           <span class="comment">//不再用atomic</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，这个条款是基于，多个线程可以同时在一个对象上执行一个 <code>const</code> 成员函数这个假设的。如果你不是在这种情况下编写一个 <code>const</code> 成员函数——你可以<strong>保证</strong>在一个对象上永远不会有多个线程执行该成员函数——该函数的线程安全是无关紧要的。比如，为独占单线程使用而设计的类的成员函数是否线程安全并不重要。在这种情况下，你可以避免因使用互斥量和 <code>std::atomics</code> 所消耗的资源，以及包含它们的类<del>只能使用移动语义</del>（译者注：既不能移动也不能复制）带来的副作用。然而，这种线程无关的情况越来越少见，而且很可能会越来越少。可以肯定的是，<code>const</code> 成员函数应支持并发执行，这就是为什么你应该确保 <code>const</code> 成员函数是线程安全的。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>确保 <code>const</code> 成员函数线程安全，除非你<strong>确定</strong>它们永远不会在并发上下文（<em>concurrent context</em>）中使用。</li>
<li>使用 <code>std::atomic</code> 变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。</li>
</ul>
<h2 id="条款十七：理解特殊成员函数的生成"><a href="#条款十七：理解特殊成员函数的生成" class="headerlink" title="条款十七：理解特殊成员函数的生成"></a>条款十七：理解特殊成员函数的生成</h2><p><strong>Item 17: Understand special member function generation</strong></p>
<p>在 C++术语中，<strong>特殊成员函数</strong>是指 C++自己生成的函数。C++98 有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符。当然在这里有些细则要注意。这些函数仅在需要的时候才生成，比如某个代码使用它们但是它们没有在类中明确声明。默认构造函数仅在类完全没有构造函数的时候才生成。（防止编译器为某个类生成构造函数，但是你希望那个构造函数有参数）生成的特殊成员函数是隐式 public 且 <code>inline</code>，它们是非虚的，除非相关函数是在派生类中的析构函数，派生类继承了有虚析构函数的基类。在这种情况下，编译器为派生类生成的析构函数是虚的。</p>
<p>但是你早就知道这些了。好吧好吧，都说古老的历史：美索不达米亚，商朝，FORTRAN，C++98。但是时代改变了，C++生成特殊成员的规则也改变了。要留意这些新规则，知道什么时候编译器会悄悄地向你的类中添加成员函数，因为没有什么比这件事对 C++高效编程更重要。</p>
<p>C++11 特殊成员函数俱乐部迎来了两位新会员：移动构造函数和移动赋值运算符。它们的签名是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);               <span class="comment">//移动构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);    <span class="comment">//移动赋值运算符</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>掌控它们生成和行为的规则类似于拷贝系列。移动操作仅在需要的时候生成，如果生成了，就会对类的 non-static 数据成员执行逐成员的移动。那意味着移动构造函数根据 <code>rhs</code> 参数里面对应的成员移动构造出新 non-static 部分，移动赋值运算符根据参数里面对应的 non-static 成员移动赋值。移动构造函数也移动构造基类部分（如果有的话），移动赋值运算符也是移动赋值基类部分。</p>
<p>现在，当我对一个数据成员或者基类使用移动构造或者移动赋值时，没有任何保证移动一定会真的发生。逐成员移动，实际上，更像是逐成员移动<strong>请求</strong>，因为对<strong>不可移动类型</strong>（即对移动操作没有特殊支持的类型，比如大部分 C++98 传统类）使用“移动”操作实际上执行的是拷贝操作。逐成员移动的核心是对对象使用 <code>std::move</code>，然后函数决议时会选择执行移动还是拷贝操作。<a href="../5.RRefMovSemPerfForw/item23.md">Item23</a> 包括了这个操作的细节。本条款中，简单记住如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作就好了。</p>
<p>像拷贝操作情况一样，如果你自己声明了移动操作，编译器就不会生成。然而它们生成的精确条件与拷贝操作的条件有点不同。</p>
<p>两个拷贝操作是独立的：声明一个不会限制编译器生成另一个。所以如果你声明一个拷贝构造函数，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造函数，代码用到拷贝构造函数时编译器就会生成它。上述规则在 C++98 和 C++11 中都成立。</p>
<p>两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数。</p>
<p>再进一步，如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。这种限制的解释是如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适。</p>
<p>这是另一个方向。声明移动操作（构造或赋值）使得编译器禁用拷贝操作。（编译器通过给拷贝操作加上<em>delete</em>来保证，参见 <a href="6%20Effective%20Modern%20C++.md">Item11</a>。）（译注：禁用的是自动生成的拷贝操作，对于用户声明的拷贝操作不受影响）毕竟，如果逐成员移动对该类来说不合适，也没有理由指望逐成员拷贝操作是合适的。听起来会破坏 C++98 的某些代码，因为 C++11 中拷贝操作可用的条件比 C++98 更受限，但事实并非如此。C++98 的代码没有移动操作，因为 C++98 中没有移动对象这种概念。只有一种方法能让老代码使用用户声明的移动操作，那就是使用 C++11 标准然后添加这些操作，使用了移动语义的类必须接受 C++11 特殊成员函数生成规则的限制。</p>
<p>也许你早已听过_Rule of Three_规则。这个规则告诉我们如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个。它来源于长期的观察，即用户接管拷贝操作的需求几乎都是因为该类会做其他资源的管理，这也几乎意味着（1）无论哪种资源管理如果在一个拷贝操作内完成，也应该在另一个拷贝操作内完成（2）类的析构函数也需要参与资源的管理（通常是释放）。通常要管理的资源是内存，这也是为什么标准库里面那些管理内存的类（如会动态内存管理的 STL 容器）都声明了“<em>the big three</em>”：拷贝构造，拷贝赋值和析构。</p>
<p><em>Rule of Three</em>带来的后果就是只要出现用户定义的析构函数就意味着简单的逐成员拷贝操作不适用于该类。那意味着如果一个类声明了析构，拷贝操作可能不应该自动生成，因为它们做的事情可能是错误的。在 C++98 提出的时候，上述推理没有得倒足够的重视，所以 C++98 用户声明析构函数不会左右编译器生成拷贝操作的意愿。C++11 中情况仍然如此，但仅仅是因为限制拷贝操作生成的条件会破坏老代码。</p>
<p><em>Rule of Three</em>规则背后的解释依然有效，再加上对声明拷贝操作阻止移动操作隐式生成的观察，使得 C++11 不会为那些有用户定义的析构函数的类生成移动操作。</p>
<p>所以仅当下面条件成立时才会生成移动操作（当需要时）：</p>
<ul>
<li>类中没有拷贝操作</li>
<li>类中没有移动操作</li>
<li>类中没有用户定义的析构</li>
</ul>
<p>有时，类似的规则也会扩展至拷贝操作上面，C++11 抛弃了已声明拷贝操作或析构函数的类的拷贝操作的自动生成。这意味着如果你的某个声明了析构或者拷贝的类依赖自动生成的拷贝操作，你应该考虑升级这些类，消除依赖。假设编译器生成的函数行为是正确的（即逐成员拷贝类 non-static 数据是你期望的行为），你的工作很简单，C++11 的<code>= default</code>就可以表达你想做的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    … </span><br><span class="line">    ~<span class="built_in">Widget</span> ();                              <span class="comment">//用户声明的析构函数</span></span><br><span class="line">    …                                       <span class="comment">//默认拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span> (<span class="type">const</span> Widget&amp;) = <span class="keyword">default</span>;        <span class="comment">//的行为还可以</span></span><br><span class="line"></span><br><span class="line">    Widget&amp;                                 <span class="comment">//默认拷贝赋值运算符</span></span><br><span class="line">        <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;) = <span class="keyword">default</span>; <span class="comment">//的行为还可以</span></span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法通常在多态基类中很有用，即通过操作的是哪个派生类对象来定义接口。多态基类通常有一个虚析构函数，因为如果它们非虚，一些操作（比如通过一个基类指针或者引用对派生类对象使用<code>delete</code>或者<code>typeid</code>）会产生未定义或错误结果。除非类继承了一个已经是<em>virtual</em>的析构函数，否则要想析构函数为虚函数的唯一方法就是加上<code>virtual</code>关键字。通常，默认实现是对的，<code>= default</code>是一个不错的方式表达默认实现。然而用户声明的析构函数会抑制编译器生成移动操作，所以如果该类需要具有移动性，就为移动操作加上<code>= default</code>。声明移动会抑制拷贝生成，所以如果拷贝性也需要支持，再为拷贝操作加上<code>= default</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span> () = <span class="keyword">default</span>;              <span class="comment">//使析构函数 virtual</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span> (Base&amp;&amp;) = <span class="keyword">default</span>;                 <span class="comment">//支持移动</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span> (<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;            <span class="comment">//支持拷贝</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，就算编译器乐于为你的类生成拷贝和移动操作，生成的函数也如你所愿，你也应该手动声明它们然后加上<code>= default</code>。这看起来比较多余，但是它让你的意图更明确，也能帮助你避免一些微妙的 bug。比如，你有一个类来表示字符串表，即一种支持使用整数 ID 快速查找字符串值的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringTable</span> () &#123;&#125;</span><br><span class="line">    …                   <span class="comment">//插入、删除、查找等函数，但是没有拷贝/移动/析构功能</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设这个类没有声明拷贝操作，没有移动操作，也没有析构，如果它们被用到编译器会自动生成。没错，很方便。</p>
<p>后来需要在对象构造和析构中打日志，增加这种功能很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringTable</span> ()</span><br><span class="line">    &#123; <span class="built_in">makeLogEntry</span> (<span class="string">&quot;Creating StringTable object&quot;</span>); &#125;    <span class="comment">//增加的</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StringTable</span> ()                                      <span class="comment">//也是增加的</span></span><br><span class="line">    &#123; <span class="built_in">makeLogEntry</span> (<span class="string">&quot;Destroying StringTable object&quot;</span>); &#125;</span><br><span class="line">    …                                               <span class="comment">//其他函数同之前一样</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; values;              <span class="comment">//同之前一样</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看起来合情合理，但是声明析构有潜在的副作用：它阻止了移动操作的生成。然而，拷贝操作的生成是不受影响的。因此代码能通过编译，运行，也能通过功能（译注：即打日志的功能）测试。功能测试也包括移动功能，因为即使该类不支持移动操作，对该类的移动请求也能通过编译和运行。这个请求正如之前提到的，会转而由拷贝操作完成。它意味着对<code>StringTable</code>对象的移动实际上是对对象的拷贝，即拷贝里面的<code>std::map&lt;int, std::string&gt;</code>对象。拷贝<code>std::map&lt;int, std::string&gt;</code>对象很可能比移动慢<strong>几个数量级</strong>。简单的加个析构就引入了极大的性能问题！对拷贝和移动操作显式加个<code>= default</code>，问题将不再出现。</p>
<p>受够了我喋喋不休的讲述 C++11 拷贝移动规则了吧，你可能想知道什么时候我才会把注意力转入到剩下两个特殊成员函数，默认构造函数和析构函数。现在就是时候了，但是只有一句话，因为它们几乎没有改变：它们在 C++98 中是什么样，在 C++11 中就是什么样。</p>
<p>C++11 对于特殊成员函数处理的规则如下：</p>
<ul>
<li><strong>默认构造函数</strong>：和 C++98 规则相同。仅当类不存在用户声明的构造函数时才自动生成。</li>
<li><strong>析构函数</strong>：基本上和 C++98 相同；稍微不同的是现在析构默认<code>noexcept</code>（参见 <a href="6%20Effective%20Modern%20C++.md">Item14</a>）。和 C++98 一样，仅当基类析构为虚函数时该类析构才为虚函数。</li>
<li><strong>拷贝构造函数</strong>：和 C++98 运行时行为一样：逐成员拷贝 non-static 数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。</li>
<li><strong>拷贝赋值运算符</strong>：和 C++98 运行时行为一样：逐成员拷贝赋值 non-static 数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。</li>
<li><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>：都对非 static 数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。</li>
</ul>
<p>注意没有“成员函数<strong>模版</strong>阻止编译器生成特殊成员函数”的规则。这意味着如果<code>Widget</code>是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西构造 Widget</span></span><br><span class="line">    <span class="built_in">Widget</span> (<span class="type">const</span> T&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西赋值给 Widget</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器仍会生成移动和拷贝操作（假设正常生成它们的条件满足），即使可以模板实例化产出拷贝构造和拷贝赋值运算符的函数签名。（当<code>T</code>为<code>Widget</code>时。）很可能你会觉得这是一个不值得承认的边缘情况，但是我提到它是有道理的，<a href="../5.RRefMovSemPerfForw/item26.md">Item26</a> 将会详细讨论它可能带来的后果。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。</li>
<li>移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。</li>
<li>拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是<em>delete</em>。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是<em>delete</em>。当用户声明了析构函数，拷贝操作的自动生成已被废弃。</li>
<li>成员函数模板不抑制特殊成员函数的生成。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/3834.html">http://liuke101.github.io/post/3834.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/post/57053.html" title="Lua精粹"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lua精粹</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/41177.html" title="模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">模板与泛型编程</div></div></a></div><div><a href="/post/37796.html" title="STL标准库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="title">STL标准库</div></div></a></div><div><a href="/post/60549.html" title="C++精粹"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141644.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-18</div><div class="title">C++精粹</div></div></a></div><div><a href="/post/60457.html" title="Effective C++"><img class="cover" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404292141674.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="title">Effective C++</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">第 1 章类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%80%EF%BC%9A%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">条款一：理解模板类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E4%B8%80%EF%BC%9AParamType-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8"><span class="toc-text">情景一：ParamType 是一个指针或引用，但不是通用引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E4%BA%8C%EF%BC%9AParamType-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-text">情景二：ParamType 是一个万能引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E4%B8%89%EF%BC%9AParamType-%E6%97%A2%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-text">情景三：ParamType 既不是指针也不是引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82"><span class="toc-text">数组实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82"><span class="toc-text">函数实参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%EF%BC%9A%E7%90%86%E8%A7%A3-auto-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">条款二：理解 auto 类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-text">与模板类型推导的共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%A4%96"><span class="toc-text">例外</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%89%EF%BC%9A%E7%90%86%E8%A7%A3-decltype"><span class="toc-text">条款三：理解 decltype</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-auto"><span class="toc-text">第 2 章 auto</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%94%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91-auto-%E8%80%8C%E9%9D%9E%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">条款五：优先考虑 auto 而非显式类型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%A0%E6%95%88%E5%8F%98%E9%87%8F"><span class="toc-text">避免未初始化的无效变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">更简洁的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">避免类型不匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%BA%90%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">对源码可读性的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%B7%E9%98%B1"><span class="toc-text">陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AD%EF%BC%9Aauto-%E6%8E%A8%E5%AF%BC%E8%8B%A5%E9%9D%9E%E5%B7%B1%E6%84%BF%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-text">条款六：auto 推导若非己愿，使用显式类型初始化惯用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3-C"><span class="toc-text">第 3 章移步现代 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%83%EF%BC%9A%E5%8C%BA%E5%88%AB%E4%BD%BF%E7%94%A8-%E5%92%8C-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">条款七：区别使用 () 和 {} 创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AB%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91-nullptr-%E8%80%8C%E9%9D%9E-0-%E5%92%8C-NULL"><span class="toc-text">条款八：优先考虑 nullptr 而非 0 和 NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B9%9D%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E-using-%E8%80%8C%E9%9D%9E-typedef-s"><span class="toc-text">条款九：优先考虑别名声明 using 而非 typedef s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%99%90%E5%9F%9F-enum-%E8%80%8C%E9%9D%9E%E6%9C%AA%E9%99%90%E5%9F%9F-enum"><span class="toc-text">条款十：优先考虑限域 enum 而非未限域 enum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%9D%9E%E9%99%90%E5%9F%9F-enum-%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">选择非限域 enum 的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%80%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8deleted%E5%87%BD%E6%95%B0%E8%80%8C%E9%9D%9E%E4%BD%BF%E7%94%A8%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E"><span class="toc-text">条款十一：优先考虑使用deleted函数而非使用未定义的私有声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8-override-%E5%A3%B0%E6%98%8E%E9%87%8D%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">条款十二：使用 override 声明重写函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%89%EF%BC%9A%E4%BC%98%E5%85%88%E8%80%83%E8%99%91-const-iterator-%E8%80%8C%E9%9D%9E-iterator"><span class="toc-text">条款十三：优先考虑 const_iterator 而非 iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E5%9B%9B%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E8%AF%B7%E4%BD%BF%E7%94%A8-noexcept"><span class="toc-text">条款十四：如果函数不抛出异常请使用 noexcept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%BA%94%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8-constexpr"><span class="toc-text">条款十五：尽可能的使用 constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E5%85%AD%EF%BC%9A%E8%AE%A9-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">条款十六：让 const 成员函数线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%83%EF%BC%9A%E7%90%86%E8%A7%A3%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-text">条款十七：理解特殊成员函数的生成</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28207.html" title="UE输入系统">UE输入系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28208.html" title="UE伤害系统">UE伤害系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>