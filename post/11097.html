<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>描边 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="0 轮廓线渲染方法在 《RTR3》 中，作者分成了 5 种类型：  基于观察方向 $V$ 和表面法线 $N$ 。 通过观察方向和表面法线点乘结果来得到轮廓线信息。简单快速，但局限性大。   过程式几何轮廓线渲染：法线外拓 + Cull Front   核心是两个 Pass： 第一个 Pass 只渲染背面并且让轮廓可见（比如通过顶点外扩）； 第二个 Pass 正常渲染正面。快速有效，适应于大多数表面">
<meta property="og:type" content="article">
<meta property="og:title" content="描边">
<meta property="og:url" content="http://liuke101.github.io/post/11097.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="0 轮廓线渲染方法在 《RTR3》 中，作者分成了 5 种类型：  基于观察方向 $V$ 和表面法线 $N$ 。 通过观察方向和表面法线点乘结果来得到轮廓线信息。简单快速，但局限性大。   过程式几何轮廓线渲染：法线外拓 + Cull Front   核心是两个 Pass： 第一个 Pass 只渲染背面并且让轮廓可见（比如通过顶点外扩）； 第二个 Pass 正常渲染正面。快速有效，适应于大多数表面">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2024-05-18T16:05:04.000Z">
<meta property="article:modified_time" content="2024-05-18T16:05:08.326Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/11097.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '描边',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-19 00:05:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">描边</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-18T16:05:04.000Z" title="发表于 2024-05-19 00:05:04">2024-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-18T16:05:08.326Z" title="更新于 2024-05-19 00:05:08">2024-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="描边"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/11097.html#post-comment"><span class="waline-comment-count" data-path="/post/11097.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-轮廓线渲染方法"><a href="#0-轮廓线渲染方法" class="headerlink" title="0 轮廓线渲染方法"></a>0 轮廓线渲染方法</h1><p>在 《RTR3》 中，作者分成了 5 种类型：</p>
<ol>
<li><strong>基于观察方向 $V$ 和表面法线 $N$</strong> 。<ul>
<li>通过观察方向和表面法线点乘结果来得到轮廓线信息。简单快速，但局限性大。</li>
</ul>
</li>
<li><strong>过程式几何轮廓线渲染</strong>：法线外拓 + Cull Front  <ul>
<li>核心是两个 Pass：<ul>
<li>第一个 Pass 只渲染背面并且让轮廓可见（比如通过顶点外扩）；</li>
<li>第二个 Pass 正常渲染正面。快速有效，适应于大多数表面平滑的模型，但不适合立方体等平整模型。</li>
</ul>
</li>
</ul>
</li>
<li><strong>基于图像处理</strong>。<ul>
<li>可以适用于任何种类的模型。但是一些深度和法线变化很小的轮廓无法检测出来，如桌子上一张纸。</li>
</ul>
</li>
<li><strong>基于轮廓边检测</strong><ul>
<li>上述方法无法控制轮廓线的风格渲染，例如水墨风格等，<strong>使用该方法可以进行风格化渲染</strong>。缺点是实现相对复杂，会有动画连贯性问题，因为是逐帧单独提取轮廓，所以帧与帧之间会出现跳跃性。</li>
<li><mark style="background: #FFB8EBA6;">检测一条边是否是轮廓边的方法</mark>：检查这条边相邻的两个三角面片是否满足：$(n_0·v&gt; 0) ≠ (n_1·v &gt; 0)$。<ul>
<li>$n_0$ 和 $n_1$ 表示两个相邻三角面片的法向，$v$ 是从视角到该边上任意顶点的方向。<strong>本质是检查相邻两个三角是否一个面向视角，另一个背向视角</strong>。可以使用几何着色器实现该功能</li>
</ul>
</li>
</ul>
</li>
<li><strong>混合上述方法</strong>。例如，首先找到精确的轮廓线，把模型和轮廓边渲染到纹理中，再使用图像处理识别轮廓线，并在图像空间进行风格化渲染。</li>
</ol>
<h2 id="1-基于观察方向和表面法线"><a href="#1-基于观察方向和表面法线" class="headerlink" title="1 基于观察方向和表面法线"></a>1 基于观察方向和表面法线</h2><p>通过观察方向 $V$ 和表面法线 $N$ 点乘结果来得到轮廓线信息。简单快速，但局限性大。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004720.png" alt="Pasted image 20230725171335|550"></p>
<blockquote>
<p>Edge&#x3D;0.5 时</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004721.png" alt="Pasted image 20230725161022|750"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> NdotV = dot(N,V);</span><br><span class="line"><span class="built_in">float</span> color = step(_Edge, NdotV); <span class="comment">//_Edge越大线越粗，_Edge大于NdotV返回0</span></span><br></pre></td></tr></table></figure>

<h2 id="2-模板测试描边"><a href="#2-模板测试描边" class="headerlink" title="2 模板测试描边"></a>2 模板测试描边</h2><p>模板测试选项设置思路很灵活，我这里只写了一种设置方法。</p>
<ul>
<li><strong>模板缓冲区设置</strong><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stencil </span><br><span class="line">&#123;</span><br><span class="line">    Ref <span class="number">0</span></span><br><span class="line">    Comp Equal   </span><br><span class="line">    Pass IncrSat <span class="comment">//通过则stencilBuffer Value加1</span></span><br><span class="line">    Fail Keep    <span class="comment">//保留当前缓冲区中的内容，即stencilBUfferValue不变</span></span><br><span class="line">    ZFail keep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>第一个 pass</strong> ：渲染前屏幕上所有像素的 stencil 值都是默认值 0，在该 pass 的 fragment shader 结束后，所有进行了渲染的像素都通过了 Ref 0 和 Comp Equal 的测试，并执行 Pass IncrSat 将 stencil 值加 1。</li>
<li><strong>第二个 Pass</strong> ：<ul>
<li><strong>把每个顶点沿法线方向外扩。方案如下：</strong><ul>
<li><strong>在模型&#x2F;世界空间外扩</strong>：<strong>远近描边的粗细不同</strong>。造成这个问题的原因：在裁剪之前做的变换，最后长度都会符合世界空间下因为相机透视造成的近大远小的效果。实际上还要考虑许多因素，详情看矫正篇。</li>
<li><strong>【矫正】 [[#描边粗细解决方案]]</strong></li>
</ul>
</li>
<li>随后设置法线的 z 分量，对其归一化后再将顶点沿其方向扩张，得到扩张后的顶点坐标。对法线的处理是为了尽可能避免背面扩张后的顶点挡住正面的面片。</li>
<li><strong>最后</strong>，我们把顶点从视角空间变换到裁剪空间。进行同样的 stencil 测试，上一个 pass 渲染过的像素 stencil 值已经变为 1，无法通过 Ref 0+Comp Equal 测试，那么现在只会在放大后的既是 stencil 值仍然为 0 的边缘区域进行渲染。</li>
</ul>
</li>
<li>缺陷：两个模型重叠部分没有描边，无解<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004722.png" alt="Pasted image 20230726153538|450"></li>
</ul>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/StencilTestOutline&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;MainTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [HDR]_EdgeColor(<span class="string">&quot;EdgeColor&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        _EdgeScale(<span class="string">&quot;EdgeScale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.01</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stencil</span><br><span class="line">        &#123;</span><br><span class="line">            Ref <span class="number">0</span></span><br><span class="line">            Comp Equal</span><br><span class="line">            Pass IncrSat <span class="comment">//通过则stencilBufferValue加1</span></span><br><span class="line">            Fail Keep <span class="comment">//保留当前缓冲区中的内容，即stencilBUfferValue不变</span></span><br><span class="line">            ZFail keep</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HLSLINCLUDE</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _EdgeColor;</span><br><span class="line">        <span class="type">float</span> _EdgeScale;</span><br><span class="line">        <span class="type">float</span> _OutlineSpace;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        <span class="title function_">TEXTURE2D</span><span class="params">(_MainTex)</span>;</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float4 positionOS : POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float3 normalOS: NORMAL;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float4 positionCS : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float3 normal : TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Shading&quot;</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;SRPDefaultUnlit&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            Varyings vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o = (Varyings)<span class="number">0</span>;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">                o.uv = i.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float4 MainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                float4 finalColor = MainTex;</span><br><span class="line">                <span class="keyword">return</span> finalColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Outline&quot;</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            Varyings vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o = (Varyings)<span class="number">0</span>;</span><br><span class="line">                o.uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//模型空间描边，远近粗细不同</span></span><br><span class="line">                i.positionOS.xyz += normalize(i.normalOS) * _EdgeScale;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _EdgeColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-过程式几何轮廓线渲染"><a href="#3-过程式几何轮廓线渲染" class="headerlink" title="3 过程式几何轮廓线渲染"></a>3 过程式几何轮廓线渲染</h2><p>其实就是把前面的<strong>模板测试换成了剔除操作</strong>。快速有效，适应于大多数表面平滑的模型，但<strong>不适合立方体</strong>等平整模型。</p>
<ul>
<li>核心是两个 Pass：<ul>
<li>第一个 Pass 剔除正面，只渲染背面。进行顶点外扩。</li>
<li>第二个 Pass 正常渲染正面。</li>
</ul>
</li>
</ul>
<p><strong>如果直接使用顶点法线进行顶点外扩，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。</strong> 为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们<strong>首先对顶点法线的 z 分量（即 normal 值，TBN 的N）进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。</strong> 这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">normal.z = <span class="number">-0.5</span>;</span><br><span class="line">normal = normalize(normal);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004723.png" alt="Pasted image 20230726155053|450"></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/ProceduralGeometryOutline&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;MainTex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [HDR]_EdgeColor(<span class="string">&quot;EdgeColor&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        _EdgeScale(<span class="string">&quot;EdgeScale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _NormalZ(<span class="string">&quot;NormalZ&quot;</span>, Range(<span class="number">-1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HLSLINCLUDE</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _EdgeColor;</span><br><span class="line">        <span class="type">float</span> _EdgeScale;</span><br><span class="line">        <span class="type">float</span> _OutlineSpace;</span><br><span class="line">        <span class="type">float</span> _NormalZ;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        <span class="title function_">TEXTURE2D</span><span class="params">(_MainTex)</span>;</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float4 positionOS : POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float3 normalOS: NORMAL;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            float4 positionCS : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float3 normal : TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Outline&quot;</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;SRPDefaultUnlit&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            Cull Front</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            Varyings vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o = (Varyings)<span class="number">0</span>;</span><br><span class="line">                o.uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">                i.normalOS.z =_NormalZ;</span><br><span class="line">                i.positionOS.xyz += normalize(i.normalOS) * _EdgeScale;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _EdgeColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;Shading&quot;</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            Varyings vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o = (Varyings)<span class="number">0</span>;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">                o.uv = i.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float4 MainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                float4 finalColor = MainTex;</span><br><span class="line">                <span class="keyword">return</span> finalColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-边缘检测"><a href="#4-边缘检测" class="headerlink" title="4 边缘检测"></a>4 边缘检测</h2><h3 id="后处理边缘检测"><a href="#后处理边缘检测" class="headerlink" title="后处理边缘检测"></a>后处理边缘检测</h3><p>如果相邻像素之间存在明显差别的颜色、亮度、纹理等属性，我们就会认为它门之间应该有一条边界。这张相邻像素之间的差值可以用<strong>梯度（gradient）</strong> 表示。边缘处的梯度绝对值比较大。</p>
<p>边缘检测的原理其实就是用一个特定的卷积核去对一张图像卷积，得到梯度值，再根据梯度值的大小去判断是否为边界。</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004724.png" alt="dae617ea28bf736d24c53f850d391047_MD5"></p>
<blockquote>
<p>注意这些算子不满足线性可分，不能使用高斯模糊使用的优化方法</p>
</blockquote>
<p>3 种常见的边缘检测算子如图所示，它们都<strong>包含了两个方向的卷积核 $G_x$ $G_y$，分别用于检测水平方向和竖直方向上的边缘信息</strong>。在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $g_x$, 和 $g_y$,, 而整体的梯度可按下面的公式计算而得:<br>$$<br>G&#x3D;\sqrt{g_{x}^{2}+g_{y}^{2}}<br>$$<br><strong>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根号操作:</strong><br>$$<br>G&#x3D;\mid g_{x}\mid+\mid g_{y}\mid<br>$$<br>当得到梯度 G 后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点)。</p>
<h4 id="Sobel-算子描边描边"><a href="#Sobel-算子描边描边" class="headerlink" title="Sobel 算子描边描边"></a>Sobel 算子描边描边</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luminance亮度公式，计算得到像素的亮度值</span></span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">luminance</span>(<span class="params">float3 color</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sobel算子计算当前像素的梯度值</span></span><br><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">Sobel</span>(<span class="params">Varyings i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Sobel算子</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> GX[<span class="number">9</span>] = &#123;</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> GY[<span class="number">9</span>] = &#123;</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> texColor; <span class="comment">//像素亮度值</span></span><br><span class="line">    <span class="built_in">float</span> gx, gy; <span class="comment">//像素的梯度值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++)</span><br><span class="line">    &#123;</span><br><span class="line">        texColor = luminance(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_BlitTexture, i.uv[it]).rgb);</span><br><span class="line">        gx += texColor * GX[it];</span><br><span class="line">        gy += texColor * GY[it];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//float g = sqrt(gx * gx + gy * gy); //总梯度值</span></span><br><span class="line">    <span class="built_in">float</span> G = abs(gx) + abs(gy); <span class="comment">//总梯度值(替代开根号，性能好)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="优化：基于深度法线纹理"><a href="#优化：基于深度法线纹理" class="headerlink" title="优化：基于深度法线纹理"></a>优化：基于深度法线纹理</h4><p><strong>上面方法的缺陷</strong>：这种方法下如果两个物体颜色等信息接近，就检测不出来了。另外直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的描边，如模型的纹理和阴影等位置也被描边。<br><strong>优化</strong>：创建适用于所有几何体和颜色的有效轮廓着色器的解决方案是<strong>考虑颜色、法线向量和&#x2F;或深度不连续性</strong>。在<strong>深度法线纹理</strong>上进行边缘检测，这些图像不会受纹理和光照影响，而仅仅保存了当前渲染物体的模型信息。<br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004725.png" alt="Pasted image 20230728173213"></p>
<p><strong>使用 Robert 算子:</strong><br><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004727.png" alt="Pasted image 20230728195227"><br>Roberts 算子的本质是计算左上角和右下角的插值，乘以右上角和左下角的插值，作为评估边缘的依据。冯乐乐入门精要书中就是按这样的方式，取对角方向的深度或法线，比较它们之间的差值，如果超过某个阈值（参数控制），就认为他们之间存在一条边。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别计算对角线上两个纹理值的差值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">CheckSame</span><span class="params">(float4 center, float4 sample)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//并不需要使用真正的法线值，xy分量就可以比较出差异</span></span><br><span class="line">    float2 centerNormal = center.xy; </span><br><span class="line">    <span class="type">float</span> centerDepth = center.z;</span><br><span class="line">    float2 sampleNormal = sample.xy;</span><br><span class="line">    <span class="type">float</span> sampleDepth = sample.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//法线的不同</span></span><br><span class="line">    float2 diffNormal = <span class="built_in">abs</span>(centerNormal-sampleNormal)*_SensitivityNormals;</span><br><span class="line">    <span class="type">int</span> isSameNormal = (diffNormal.x+diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">    <span class="comment">//深度的不同</span></span><br><span class="line">    <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth-sampleDepth)*_SensitivityDepth;</span><br><span class="line">    <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSameNormal*isSameDepth?<span class="number">1.0</span>:<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">frag</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float4 sample1;</span><br><span class="line">    float4 sample2;</span><br><span class="line">    float4 sample3;</span><br><span class="line">    float4 sample4;</span><br><span class="line">    sample1.xy = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture, sampler_CameraNormalsTexture, i.uv[<span class="number">1</span>]).rg;</span><br><span class="line">    sample1.z = Linear01Depth(SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv[<span class="number">1</span>]).r,_ZBufferParams);</span><br><span class="line">   </span><br><span class="line">    sample2.xy = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture, sampler_CameraNormalsTexture, i.uv[<span class="number">2</span>]).rg;</span><br><span class="line">    sample2.z = Linear01Depth(SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv[<span class="number">2</span>]).r,_ZBufferParams);</span><br><span class="line"></span><br><span class="line">    sample3.xy = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture, sampler_CameraNormalsTexture, i.uv[<span class="number">3</span>]).rg;</span><br><span class="line">    sample3.z = Linear01Depth(SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv[<span class="number">3</span>]).r,_ZBufferParams);</span><br><span class="line"></span><br><span class="line">    sample4.xy = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture, sampler_CameraNormalsTexture, i.uv[<span class="number">4</span>]).rg;</span><br><span class="line">    sample4.z = Linear01Depth(SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv[<span class="number">4</span>]).r,_ZBufferParams);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> edge = <span class="number">1.0</span>;</span><br><span class="line">    edge *= CheckSame(sample1, sample2);</span><br><span class="line">    edge *= CheckSame(sample3, sample4);</span><br><span class="line"></span><br><span class="line">    float4 withEdgeColor = lerp(_EdgeColor,SAMPLE_TEXTURE2D(_BlitTexture, sampler_BlitTexture, i.uv[<span class="number">0</span>]),edge);</span><br><span class="line">    float4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgesOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2D-边缘检测"><a href="#2D-边缘检测" class="headerlink" title="2D 边缘检测"></a>2D 边缘检测</h3><p>采样像素周围的点，如果有一个点透明度为 0，就说明是边缘</p>
<p>2D 常用。也可用于 2D 的边缘光。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float4 <span class="title function_">UnlitFragment</span><span class="params">(Varyings i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">	float4 mainTex = i.color * SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 采样周围4个点</span></span><br><span class="line">	float2 up_uv = i.uv + float2(<span class="number">0</span>, <span class="number">1</span>) * _LineWidth * <span class="number">1</span> / <span class="number">10</span> * _MainTex_ST.xy;</span><br><span class="line">	float2 down_uv = i.uv + float2(<span class="number">0</span>, <span class="number">-1</span>) * _LineWidth * <span class="number">1</span> / <span class="number">10</span> * _MainTex_ST.xy;</span><br><span class="line">	float2 left_uv = i.uv + float2(<span class="number">-1</span>, <span class="number">0</span>) * _LineWidth * <span class="number">1</span> / <span class="number">10</span> * _MainTex_ST.xy;</span><br><span class="line">	float2 right_uv = i.uv + float2(<span class="number">1</span>, <span class="number">0</span>) * _LineWidth * <span class="number">1</span> / <span class="number">10</span> * _MainTex_ST.xy;</span><br><span class="line">	<span class="comment">// 如果有一个点透明度为0 说明是边缘</span></span><br><span class="line">	float4 up = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, up_uv);</span><br><span class="line">	float4 down = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, down_uv);</span><br><span class="line">	float4 left = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, left_uv);</span><br><span class="line">	float4 right = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, right_uv);</span><br><span class="line">	<span class="type">float</span> w = up.a * down.a * left.a * right.a;</span><br><span class="line">	<span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">		mainTex.rgb = lerp(_LineColor * _Intensity, mainTex.rgb, w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mainTex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-SDF-描边（鸽）"><a href="#5-SDF-描边（鸽）" class="headerlink" title="5 SDF 描边（鸽）"></a>5 SDF 描边（鸽）</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398656596">Signed Distance Field 与 Multi-channel signed distance field - hebh 的文章 - 知乎</a>（SDF 介绍）</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113190695">用 SDF 处理卡通内描线的锯齿问题 - flashyiyi 的文章 - 知乎</a></li>
</ul>
<p>关于 SDF 我在之前的文章中有过分析：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398656596">何博航：Signed Distance Field 与 Multi-channel signed distance field</a></p>
<p>之前也在 UE4 中实现过，但是还是刚接触 Unity Shader 没几天，对 shaderlab 还不熟悉。这里主要参考了前辈的文章，在其基础上稍作修改：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26217154">拳四郎：Signed Distance Field</a></p>
<p>描边结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004728.png" alt="5babaf79a82fcafdfc07dfa7529f2dcd_MD5"></p>
<p>原理其实很简单，这里的圆是在 shader 中根据 SDF 值绘制的。SDF 值在边界处接近 0，于是我们就通过 SDF 的 fwidth 值与当前像素的 SDF 值去判断，因为 fwidth 为相邻像素的 SDF 差值和，那么必然很小。所以判断的结果用于 lerp，就可以检测哪里的 SDF 值接近 0，亦即检测到轮廓。而 aa 也是简单地用 smoothstep 处理就好。</p>
<p>给出完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;OutlineShader/sdfOutline&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _BackgroundColor (&quot;BackgroundColor&quot;, Color) = (0, 0, 0, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"> #include &quot;UnityCG. cginc&quot;</span><br><span class="line"></span><br><span class="line">            float sdfCircle(float2 coord, float2 center, float radius)</span><br><span class="line">            &#123;</span><br><span class="line">                float2 offset = coord - center;</span><br><span class="line">                return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 render(float d, float3 color, float stroke) </span><br><span class="line">            &#123;</span><br><span class="line">                float anti = fwidth(d) * 1.0;</span><br><span class="line">                float4 colorLayer = float4(color, 1.0 - smoothstep(-anti, anti, d));</span><br><span class="line">                bool flag = step(0.000001, stroke);</span><br><span class="line">                float4 strokeLayer = float4(float3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));</span><br><span class="line">                return float4(lerp(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a) * flag + colorLayer * (1 - flag);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 screenPos : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">                o.screenPos = ComputeScreenPos(o.pos);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float2 pixelPos = (i.screenPos.xy / i.screenPos.w) * _ScreenParams.xy;</span><br><span class="line">                float a = sdfCircle(pixelPos, float2(0.5, 0.5) * _ScreenParams.xy, 100);</span><br><span class="line">                float4 layer1 = render(a, _Color, fwidth(a) * 2.0);</span><br><span class="line">                return lerp(_BackgroundColor, layer1, layer1.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-基于轮廓边检测的方法（鸽）"><a href="#6-基于轮廓边检测的方法（鸽）" class="headerlink" title="6 基于轮廓边检测的方法（鸽）"></a>6 基于轮廓边检测的方法（鸽）</h2><p>再来回顾一下之前所述的原理：</p>
<p>检查这条边相邻的两个三角面片是否满足：(n0·v&gt; 0) ≠ (n1·v &gt; 0)。这里 n0 和 n1 分别表示两个相邻三角面片的法向，v 是从视角到该边上任意顶点的方向。本质是检查相邻两个三角是否一个面向视角，另一个背向视角。</p>
<p>于是这里我想到用几何着色器去做，但是不知道怎么获得相邻的三角面片，在 OpenGL 中有 GL_LINES_ADJACENCY 去得到线段以及相邻顶点，就正好四个顶点两个相邻面片，从而可以去处理。但是 Unity Shader 中我没有找到怎么做。但是在谷歌中搜索出了一个解决方法： <a target="_blank" rel="noopener" href="https://forum.unity.com/threads/does-unity-support-triangleadj-in-geometry-shaders.930306/">https://forum.unity.com/threads/does-unity-support-triangleadj-in-geometry-shaders.930306/</a></p>
<p>先给他的链接，还没来得及细看：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Milun/unity-solidwire-shader/blob/master/Assets/Shaders/SolidWire.shader">https://github.com/Milun/unity-solidwire-shader/blob/master/Assets/Shaders/SolidWire.shader</a></p>
<p>（物体空间外拓，视角空间外拓，裁剪空间外拓）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/019&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Diffuse (&quot;漫反射&quot;, Color) = (1,1,1,1)</span><br><span class="line">        _Outline (&quot;外廓粗细&quot;, Range(0,0.05)) = 0.02</span><br><span class="line">        _OutlineColor (&quot;外廓颜色&quot;, Color) = (0,0,0,0)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            //定义Pass名，用于重复使用该Pass</span><br><span class="line">            Name &quot;Outline&quot;</span><br><span class="line">            //渲染前面</span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            float _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex :SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                //描边=顶点在法线上偏移 * 颜色</span><br><span class="line">                </span><br><span class="line">                //物体空间法线外拓</span><br><span class="line">                //v.vertex.xyz += v.normal * _Outline;</span><br><span class="line">                //o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                //视角空间法线外拓</span><br><span class="line">                //float4 pos = mul(UNITY_MATRIX_V,mul(unity_ObjectToWorld,v.vertex));</span><br><span class="line">                //float3 normal = normalize (mul((float3x3)UNITY_MATRIX_IT_MV,v.normal));</span><br><span class="line">                //pos = pos + float4(normal,0) * _Outline;</span><br><span class="line">                //o.vertex = mul(UNITY_MATRIX_P,pos);</span><br><span class="line"></span><br><span class="line">                //裁剪空间法线外拓</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                float3 normal = normalize (mul((float3x3)UNITY_MATRIX_IT_MV,v.normal));</span><br><span class="line">                float2 viewNoraml = TransformViewToProjection(normal.xy);</span><br><span class="line">                o.vertex.xy += viewNoraml * _Outline;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 frag(v2f i):SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return _OutlineColor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">        //引入光照</span><br><span class="line">        #include &quot;Lighting.cginc&quot; </span><br><span class="line">             </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                float3 worldPos : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">        float4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                //顶点位置</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //法线方向</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                //世界坐标</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex);</span><br><span class="line">                //纹理坐标缩放偏移</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">              </span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // 纹理采样</span><br><span class="line">                fixed4 albedo = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                //光源方向</span><br><span class="line">                fixed3 worldLightDir = UnityWorldSpaceLightDir (i.worldPos);</span><br><span class="line"></span><br><span class="line">                //漫反射光=入射光线强度*纹素值*材质的漫反射系数* 映射值为正数(表面法线方向 · 光源方向)</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * _Diffuse.rgb * (dot(worldLightDir,i.worldNormal)*0.5+0.5);</span><br><span class="line"></span><br><span class="line">                //环境光</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                return fixed4(color,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="法线外拓总结"><a href="#法线外拓总结" class="headerlink" title="法线外拓总结"></a>法线外拓总结</h1><p>法线外拓 + 深度测试 Always（存在：模型自身会穿透自身和物体将会永远再最前面问题，一般不使用这种方案）<br>法线外拓 + Cull Front<br>法线外拓 + ZWrite Off（存在：两个模型重叠部分没有描边的问题：控制渲染队列解决）<br>法线外拓 + 模板测试（存在：两个模型重叠部分没有描边的问题：无解）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427742656">法线不是连续的时候，描边就会中断的问题</a></p>
<p><strong>计算法线，最基础方案</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata_base v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      v.vertex.xyz += v.normal * _OutlineWidth;</span><br><span class="line">      o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无论相机距离物体多远或者观察视角的变化，都让描边的宽度保持等比例的近似方法解决</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">	float3 clipNormal = <span class="built_in">mul</span>((float3x3) UNITY_MATRIX_VP, <span class="built_in">mul</span>((float3x3) UNITY_MATRIX_M, v.normal));</span><br><span class="line">	o.vertex.xy += <span class="built_in">normalize</span>(clipNormal).xy * _OutlineWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="法线外拓"><a href="#法线外拓" class="headerlink" title="法线外拓"></a>法线外拓</h1><p>通常做卡通以及二次元渲染的时候接触得较早的就是描边需求, 而描边需求在大多数情况下都会通过两种方法实现:**</p>
<ol>
<li>全屏后处理,</li>
<li>法线外拓,</li>
</ol>
<p>不过由于全屏后处理较难应付复杂的逐单位需求. 所以在调整一段时间的法线外拓后, 将自己的思考过程以本文章的形式记录下来. <a target="_blank" rel="noopener" href="https://github.com/striter/Unity3D-ToolChain_StriteR">GitHub - striter&#x2F;Unity3D-ToolChain_StriteR</a></p>
<ul>
<li>MenuItem 工作流: WorkFlow&#x2F;Art&#x2F;Mesh Smooth Normal Generator</li>
<li>编辑器脚本: EWSmoothNormalGenerator. cs</li>
<li>Shader 代码: Outline. shader</li>
</ul>
<h2 id="法线外拓原理"><a href="#法线外拓原理" class="headerlink" title="法线外拓原理"></a><strong>法线外拓原理</strong></h2><p>在原始模型的基础上通过第二个渲染生成一个更大的模型并叠加.</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004729.jpg" alt="6051af478121a79f27447e8ed65c7950_MD5"></p>
<p>A 的做法则是在 vertex 阶段朝着发现位置做顶点位置偏移, 一份基础法线外拓 shader 就做好了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line">	half3 positionOS : POSITION;</span><br><span class="line">	half3 normalOS:NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">	float4 positionCS:SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    half3 positionOS=v.positionOS;</span><br><span class="line">    half3 normalOS=normalize(v.normalOS);</span><br><span class="line">    positionOS+=normalOS*_OutlineWidth;</span><br><span class="line">    o.positionCS=TransformObjectToHClip(positionOS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 frag(v2f i)</span><br><span class="line">&#123;</span><br><span class="line">    return _OutlineColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常叠加的方式有好几种:</p>
<ul>
<li>Multi Pass Shader (URP 需要特殊处理)</li>
<li>单个 MeshRender 挂多个 Material (模型无 SubMesh 的情况)</li>
<li>两个 MeshRenderer 同步 Transform</li>
</ul>
<p>与使用第二种方式原模型叠加后的结果</p>
<h2 id="平滑法线"><a href="#平滑法线" class="headerlink" title="平滑法线"></a>平滑法线</h2><p>在上文的基础下测试后其实可以发现, 在遇到法线断裂 (多套光照光滑组) 的情况下, 描边的效果将会有较大的瑕疵.</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004730.jpg" alt="376c11d3477511c8181c2383b85a5ae7_MD5"></p>
<p>问题的原因在于法线不连续. 解决方法则是生成一套连续的法线数据供描边采样.</p>
<p>通过 Unity 内置的 <strong>Mesh</strong> class, 可以获取原始模型的数据并制作与储存成新的 asset 资源.</p>
<p>平滑法线的生成流程:</p>
<ol>
<li>对于每个顶点位置 (position), 收集该坐标相关的所有相同位置顶点 (vertex) 的法线数据.</li>
<li>将相关的法线数据相加并归一化后再赋回原始的所有顶点.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static Vector3[] GenerateSmoothNormals(Mesh _srcMesh)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3[] verticies = _srcMesh.vertices;</span><br><span class="line">    Vector3[] normals = _srcMesh.normals;</span><br><span class="line">    Vector3[] smoothNormals = normals.DeepCopy();</span><br><span class="line">    var groups = verticies.Select((vertex, index) =&gt; new KeyValuePair&lt;Vector3, int&gt;(vertex, index)).GroupBy(pair =&gt; pair.Key);</span><br><span class="line">    foreach (var group in groups)</span><br><span class="line">    &#123;</span><br><span class="line">        if (group.Count() == 1)</span><br><span class="line">            continue;</span><br><span class="line">        Vector3 smoothNormal = Vector3.zero;</span><br><span class="line">        foreach (var index in group)</span><br><span class="line">            smoothNormal += normals[index.Value];</span><br><span class="line">        smoothNormal = smoothNormal.normalized;</span><br><span class="line">        foreach (var index in group)</span><br><span class="line">            smoothNormals[index.Value] = smoothNormal;</span><br><span class="line">    &#125;</span><br><span class="line">    return smoothNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将生成的法线数据赋值到 <strong>Tangents 数组</strong>内, 即可采样描边.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normalOS=normalize(v.tangentOS.xyz);</span><br></pre></td></tr></table></figure>

<p>赋值到 tangents 的原因是: 对于骨骼动画模型 (SkinnedMeshRenderer), Unity 黑盒在计算动画时, 将 normal 跟 nangent 一并计算成最终数据 (原本是是要 tangent 用于做法线贴图).</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004731.jpg" alt="3855d666eb9609e1252ae36f9345a20e_MD5"></p>
<p><strong>使用重新生成的法线数据 (可选)</strong></p>
<p>在多数卡通游戏制作流程中, 模型的光照组由于各种调整失去了连续性, 以在这种情况下使用调整后的 normal 数据并不能很好的生成描边数据.</p>
<p>通过顶点以及 UV 重新生成三角面并获取法线, 可以生成垂直于面片的法线会有部分改善.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static Vector3[]RenegerateNormals(int[] _indices, Vector3[] _verticies)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3[] normals = new Vector3[_verticies.Length];</span><br><span class="line">    GTrianglePolygon[] polygons = GetPolygons(_indices);</span><br><span class="line">    foreach(var polygon in polygons)</span><br><span class="line">    &#123;</span><br><span class="line">        GTriangle triangle = new GTriangle(polygon.GetVertices(_verticies));</span><br><span class="line">        Vector3 normal = triangle.normal;</span><br><span class="line">        foreach (var index in polygon)</span><br><span class="line">            normals[index] += normal;</span><br><span class="line">    &#125;</span><br><span class="line">    normals=normals.Select(normal =&gt; normal.normalized).ToArray();</span><br><span class="line">    return normals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static GTrianglePolygon[] GetPolygons(int[] _indices)</span><br><span class="line">&#123;</span><br><span class="line">    GTrianglePolygon[] polygons = new GTrianglePolygon[_indices.Length / 3];</span><br><span class="line">    for (int i = 0; i &lt; polygons.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int startIndex = i * 3;</span><br><span class="line">        int triangle0 = _indices[startIndex];</span><br><span class="line">        int triangle1 = _indices[startIndex + 1];</span><br><span class="line">        int triangle2 = _indices[startIndex + 2];</span><br><span class="line">        polygons[i] = new GTrianglePolygon(triangle0, triangle1, triangle2);</span><br><span class="line">    &#125;</span><br><span class="line">    return polygons;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct GTrianglePolygon</span><br><span class="line">&#123;</span><br><span class="line">    public int index0;</span><br><span class="line">    public int index1;</span><br><span class="line">    public int index2;</span><br><span class="line"></span><br><span class="line">    public GTrianglePolygon(int _index0, int _index1, int _index2)</span><br><span class="line">    &#123;</span><br><span class="line">        index0 = _index0;</span><br><span class="line">        index1 = _index1;</span><br><span class="line">        index2 = _index2;</span><br><span class="line">    &#125;</span><br><span class="line">    public (T v0, T v1, T v2) GetVertices&lt;T&gt;(IList&lt;T&gt; _vertices) =&gt; (_vertices[index0], _vertices[index1],_vertices[index2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct GTriangle</span><br><span class="line">&#123;</span><br><span class="line">    public Triangle&lt;Vector3&gt; triangle;</span><br><span class="line">    public Vector3 normal;</span><br><span class="line">    public Vector3 uOffset;</span><br><span class="line">    public Vector3 vOffset;</span><br><span class="line">    public GTriangle((Vector3 v0,Vector3 v1,Vector3 v2) _tuple) : this(_tuple.v0,_tuple.v1,_tuple.v2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GTriangle(Vector3 _vertex0, Vector3 _vertex1, Vector3 _vertex2)</span><br><span class="line">    &#123;</span><br><span class="line">        triangle = new Triangle&lt;Vector3&gt;(_vertex0, _vertex1, _vertex2);</span><br><span class="line">        uOffset = _vertex1-_vertex0;</span><br><span class="line">        vOffset = _vertex2-_vertex0;</span><br><span class="line">        normal= Vector3.Cross(uOffset,vOffset);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="更平滑的数据"><a href="#更平滑的数据" class="headerlink" title="更平滑的数据"></a><strong>更平滑的数据</strong></h2><p>上述方法存在瑕疵 (法线连续性不足), 若对描边有更细致的精度需求, 最好的方法则是通过建模软件修改法线方向, 也可以在生成的 Mesh 基础上对模型进行调整, 例如在工作流内有一份内置的模型编辑器 (WorkFlow&#x2F;Art&#x2F;MeshEditor)(操作未优化, 比较反人类), 亦或者将 Mesh 导出 (通过 FBXExporter) 后编辑.</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004732.jpg" alt="6919279c4f518d580bc69f4d13d92833_MD5"></p>
<h2 id="UV-储存描边数据"><a href="#UV-储存描边数据" class="headerlink" title="UV 储存描边数据"></a>UV 储存描边数据</h2><p>由于占用了 Tangent 的数据, 若遇到<strong>蒙皮数据</strong>, <strong>法线贴图</strong>与<strong>平滑描边</strong>共存的情况, 在原始的则需要特殊处理, 后续在网上翻阅资料后发现可以参考法线贴图的做法, 将切线空间数据存储到 UV0-9 的信息里, 通过 TBN 矩阵反乘处理即可用于采样.</p>
<p>数据构建 (C#):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static Vector3[] GenerateSmoothNormals(Mesh _srcMesh, bool _convertToTangentSpace)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3[] verticies = _srcMesh.vertices;</span><br><span class="line">    var groups = verticies.Select((vertex, index) =&gt; new KeyValuePair&lt;Vector3, int&gt;(vertex, index)).GroupBy(pair =&gt; pair.Key);</span><br><span class="line">    Vector3[] normals =  RenegerateNormals(_srcMesh.triangles,verticies);</span><br><span class="line">    Vector3[] smoothNormals = normals.DeepCopy();</span><br><span class="line">    foreach (var group in groups)</span><br><span class="line">    &#123;</span><br><span class="line">        if (group.Count() == 1)</span><br><span class="line">            continue;</span><br><span class="line">        Vector3 smoothNormal = Vector3.zero;</span><br><span class="line">        foreach (var index in group)</span><br><span class="line">            smoothNormal += normals[index.Value];</span><br><span class="line">        smoothNormal = smoothNormal.normalized;</span><br><span class="line">        foreach (var index in group)</span><br><span class="line">            smoothNormals[index.Value] = smoothNormal;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过构建TBN矩阵,将平滑法线数据转到切线空间内</span><br><span class="line">    if (_convertToTangentSpace)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector4[] tangents = _srcMesh.tangents;</span><br><span class="line">        for (int i = 0; i &lt; smoothNormals.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 tangent = tangents[i].ToVector3().normalized;</span><br><span class="line">            Vector3 normal = normals[i].normalized;</span><br><span class="line">            Vector3 biNormal = Vector3.Cross(normal, tangent).normalized * tangents[i].w;</span><br><span class="line">            Matrix3x3 tbnMatrix = Matrix3x3.identity;</span><br><span class="line">            tbnMatrix.SetRow(0, tangent);</span><br><span class="line">            tbnMatrix.SetRow(1, biNormal);</span><br><span class="line">            tbnMatrix.SetRow(2, normal);</span><br><span class="line">            smoothNormals[i] = tbnMatrix * smoothNormals[i].normalized;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return smoothNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据采样 (Shader Vertex):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float3 normalOS=0;</span><br><span class="line">#if _NORMALSAMPLE_UV1</span><br><span class="line">normalOS=normalize(v.uv1);</span><br><span class="line">#elif _NORMALSAMPLE_UV2</span><br><span class="line">normalOS=normalize(v.uv2);</span><br><span class="line">//34567...</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">float3x3 TBNOS=float3x3(v.tangentOS.xyz,cross(v.normalOS,v.tangentOS.xyz)*v.tangentOS.w,v.normalOS);</span><br><span class="line">normalOS=mul(normalOS,TBNOS);</span><br></pre></td></tr></table></figure>

<h2 id="内描边剔除"><a href="#内描边剔除" class="headerlink" title="内描边剔除"></a><strong>内描边剔除</strong></h2><p>通常内描边可以呈现物体的几何形状, 但是在某些情况下 (粗描边, 几何嵌套程度过高), 内描边会带来明显的瑕疵感.</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004733.jpg" alt="7b27a0af6c7bfa4c715f261fb097bb33_MD5"></p>
<p>解决方案通常是通过将法线外拓的内描边遮盖后, 再通过贴图采样的内描边解决, 而 Stencil 则是解决法线外拓造成的内描边方式之一.</p>
<p>通过在渲染上层模型时赋值指定的 Stencil, 在渲染描边时通过 Stencil 比较丢弃多余的像素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//模型Shader的Stencil参考</span><br><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">	Ref 1</span><br><span class="line">	Comp Always</span><br><span class="line">	Pass Replace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//描边Shader的Stencil参考</span><br><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">	Ref 1</span><br><span class="line">	Comp NotEqual</span><br><span class="line">	Pass Keep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004734.jpg" alt="da4bff1c945dd342f6a73da19b015f35_MD5"></p>
<h2 id="自适应描边"><a href="#自适应描边" class="headerlink" title="自适应描边"></a><strong>自适应描边</strong></h2><p>由于法线拓展在<strong>模型空间</strong>, 将会受到透视矩阵的影响, 最明显的问题就是<strong>近大远小</strong>, 对此可以通过将法线外拓放到屏幕空间 (剪裁空间) 进行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float4 clipPosition=TransformObjectToHClip(positionOS);</span><br><span class="line">float3 normalCS =  mul((float3x3)UNITY_MATRIX_MVP, normalOS);</span><br><span class="line">float2 screenOffset =normalize(normalCS.xy)/_ScreenParams.xy*clipPosition.w;</span><br><span class="line">clipPosition.xy+=screenOffset*INSTANCE(_OutlineWidth);</span><br><span class="line">o.positionCS = clipPosition;</span><br></pre></td></tr></table></figure>

<h2 id="屏幕距离自适应描边"><a href="#屏幕距离自适应描边" class="headerlink" title="屏幕距离自适应描边"></a><strong>屏幕距离自适应描边</strong></h2><p>获取 eyeDepth, invlerp 获取归一值, 再 lerp 到对应的大小区间即可, 同时也可以支持<strong>近小远大</strong>的需求.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float4 positionVS=TransformObjectToView(positionOS).z;</span><br><span class="line">float eyeDepth=positionVS.z*positionVS.w;</span><br><span class="line">float depthAlpha=saturate(invlerp(5,100,eyeDepth));</span><br><span class="line">float finalWidth=lerp(5,1,depthAlpha)*INSTANCE(_OutlineWidth);</span><br><span class="line">o.positionCS=TransformObjectToHClip( positionOS+normalOS*finalWidth);</span><br></pre></td></tr></table></figure>

<h2 id="相关拓展"><a href="#相关拓展" class="headerlink" title="相关拓展"></a>相关拓展</h2><ul>
<li>逐顶点需求如描边粗细控制以及颜色描边, 通过增加额外的顶点数据信息即可.</li>
<li>可以通过增加第二套低模绘制描边以降低超高精度模型的渲染开销, 可同时应用到深度渲染中.</li>
<li>在 URP 管线下原生的 Multi Pass Feature 由于缺失原材质信息支持很难应付不同需求, 通过 ScriptableRenderFeature 对目标材质进行指定额外 Pass 的绘制并保留原生的材质信息. 即可实现如同 Built-in 管线相同的 Multi Pass Shader (可以参考工程内的 <strong>SRF_MultiPass</strong>).</li>
</ul>
<h1 id="描边粗细解决方案"><a href="#描边粗细解决方案" class="headerlink" title="描边粗细解决方案"></a>描边粗细解决方案</h1><h2 id="最简单描边"><a href="#最简单描边" class="headerlink" title="最简单描边"></a>最简单描边</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    //世界空间，背面延法线方向扩充</span><br><span class="line">    worldPos += worldNormal *_OutlineWidth;</span><br><span class="line"></span><br><span class="line">    o.vertex = UnityWorldToClipPos(worldPos);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004735.jpg" alt="5217b250b750575752edd12a55ef2319_MD5"></p>
<p>带来的问题，描边的粗细与物体距相机的距离有关，当物体离相机很近时，会显得描边很粗；</p>
<p>问题为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004736.jpg" alt="fe7ab9fbc65105f10d7813d397053860_MD5"></p>
<p>原因主要为法线的宽度是在世界空间进行计算的，没有考虑透视的影响；</p>
<h3 id="“考虑-Scale”"><a href="#“考虑-Scale”" class="headerlink" title="“考虑 Scale”"></a>“考虑 Scale”</h3><p>当在世界空间下计算描边时，如果描边有缩放会遇到缩放带来的描边粗细问题；即描边粗细不随 scale 变化；</p>
<p>此时只需要将 scale 从 model 矩阵中抽取出来计算即可（不考虑剪切）；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    half3 worldNormal = normalize(mul((float3x3)unity_WorldToObject, v.normal));</span><br><span class="line">    half3 scaleFactor = float3(length(unity_ObjectToWorld._m00_m10_m20), length(unity_ObjectToWorld._m01_m11_m21), length(unity_ObjectToWorld._m02_m12_m22));</span><br><span class="line">    worldPos += worldNormal *_OutlineWidth * scaleFactor;</span><br><span class="line"></span><br><span class="line">    o.vertex = UnityWorldToClipPos(worldPos);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="裁剪空间描边"><a href="#裁剪空间描边" class="headerlink" title="裁剪空间描边"></a>裁剪空间描边</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    //裁剪空间，需要乘以o.vertex.w，避免归一化带来的影响；</span><br><span class="line">    float3 ndcNormal = normalize(mul(UNITY_MATRIX_VP, worldNormal)) * o.vertex.w;</span><br><span class="line"></span><br><span class="line">    o.vertex.xy += ndcNormal.xy * _OutlineWidth;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004737.jpg" alt="2768aebc45af89f0f50b3f6eda7fe7b1_MD5"></p>
<p>带来的问题，描边的粗细与相机的长宽比有关，需要考虑相机 aspect 的影响；</p>
<h2 id="考虑相机-aspect"><a href="#考虑相机-aspect" class="headerlink" title="考虑相机 aspect"></a>考虑相机 aspect</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    float3 ndcNormal = normalize(mul(UNITY_MATRIX_VP, worldNormal)) * o.vertex.w;</span><br><span class="line"></span><br><span class="line">    //考虑屏幕长宽比</span><br><span class="line">    o.vertex.xy += ndcNormal.xy * _OutlineWidth*_ScreenParams.y*rcp(_ScreenParams.xy);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004738.jpg" alt="ac6d05b087f05dee4aed45f3050f6107_MD5"></p>
<p>带来的问题，描边不随距离变化了，但当物体离相机比较远时，会显得很粗；</p>
<p>问题为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004739.jpg" alt="2fe12f4370b131d1b842d693bb5e4dc2_MD5"></p>
<p>解决方法为：物体距相机近时，描边的粗细保持不变；物体距相机近时，描边的粗细随物体大小变化；</p>
<h2 id="综合考虑下的结果"><a href="#综合考虑下的结果" class="headerlink" title="综合考虑下的结果"></a>综合考虑下的结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    float3 ndcNormal = normalize(mul(UNITY_MATRIX_VP, worldNormal)) * o.vertex.w;</span><br><span class="line"></span><br><span class="line">    o.vertex.xy += ndcNormal.xy * _OutlineWidth*_ScreenParams.y*rcp(_ScreenParams.xy);</span><br><span class="line"></span><br><span class="line">    float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    worldPos += worldNormal *_OutlineWidth;</span><br><span class="line">    </span><br><span class="line">    //相机到物体的距离</span><br><span class="line">    float dist = distance(unity_ObjectToWorld._m03_m13_m23, _WorldSpaceCameraPos);</span><br><span class="line"></span><br><span class="line">    float4 farVertex = UnityWorldToClipPos(worldPos);</span><br><span class="line">    //0.2 is magical number</span><br><span class="line">    o.vertex = lerp(o.vertex, farVertex, saturate(dist*0.2));</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202405190004740.jpg" alt="431108acfa16e9066c8e086f03b67f5b_MD5"></p>
<p>至此，一个相对完善的描边粗细解决方案就诞生了~~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/11097.html">http://liuke101.github.io/post/11097.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/57613.html" title="溶解特效"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">溶解特效</div></div></a></div><div class="next-post pull-right"><a href="/post/46138.html" title="雾"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">雾</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/42466.html" title="CG ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">CG ShaderLab</div></div></a></div><div><a href="/post/17861.html" title="Renderer Feature"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-14</div><div class="title">Renderer Feature</div></div></a></div><div><a href="/post/42467.html" title="HLSL ShaderLab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">HLSL ShaderLab</div></div></a></div><div><a href="/post/19285.html" title="材质脚本控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="title">材质脚本控制</div></div></a></div><div><a href="/post/14314.html" title="深度法线纹理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-19</div><div class="title">深度法线纹理</div></div></a></div><div><a href="/post/46138.html" title="雾"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-19</div><div class="title">雾</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E8%BD%AE%E5%BB%93%E7%BA%BF%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95"><span class="toc-text">0 轮廓线渲染方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E8%A7%82%E5%AF%9F%E6%96%B9%E5%90%91%E5%92%8C%E8%A1%A8%E9%9D%A2%E6%B3%95%E7%BA%BF"><span class="toc-text">1 基于观察方向和表面法线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%8F%8F%E8%BE%B9"><span class="toc-text">2 模板测试描边</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%87%E7%A8%8B%E5%BC%8F%E5%87%A0%E4%BD%95%E8%BD%AE%E5%BB%93%E7%BA%BF%E6%B8%B2%E6%9F%93"><span class="toc-text">3 过程式几何轮廓线渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-text">4 边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-text">后处理边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sobel-%E7%AE%97%E5%AD%90%E6%8F%8F%E8%BE%B9%E6%8F%8F%E8%BE%B9"><span class="toc-text">Sobel 算子描边描边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-text">优化：基于深度法线纹理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-text">2D 边缘检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-SDF-%E6%8F%8F%E8%BE%B9%EF%BC%88%E9%B8%BD%EF%BC%89"><span class="toc-text">5 SDF 描边（鸽）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9F%BA%E4%BA%8E%E8%BD%AE%E5%BB%93%E8%BE%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E9%B8%BD%EF%BC%89"><span class="toc-text">6 基于轮廓边检测的方法（鸽）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E5%A4%96%E6%8B%93%E6%80%BB%E7%BB%93"><span class="toc-text">法线外拓总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E5%A4%96%E6%8B%93"><span class="toc-text">法线外拓</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E5%A4%96%E6%8B%93%E5%8E%9F%E7%90%86"><span class="toc-text">法线外拓原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%BB%91%E6%B3%95%E7%BA%BF"><span class="toc-text">平滑法线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%B9%B3%E6%BB%91%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">更平滑的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV-%E5%82%A8%E5%AD%98%E6%8F%8F%E8%BE%B9%E6%95%B0%E6%8D%AE"><span class="toc-text">UV 储存描边数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%8F%8F%E8%BE%B9%E5%89%94%E9%99%A4"><span class="toc-text">内描边剔除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E6%8F%8F%E8%BE%B9"><span class="toc-text">自适应描边</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E8%B7%9D%E7%A6%BB%E8%87%AA%E9%80%82%E5%BA%94%E6%8F%8F%E8%BE%B9"><span class="toc-text">屏幕距离自适应描边</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95"><span class="toc-text">相关拓展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%8F%E8%BE%B9%E7%B2%97%E7%BB%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">描边粗细解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BE%B9"><span class="toc-text">最简单描边</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E8%80%83%E8%99%91-Scale%E2%80%9D"><span class="toc-text">“考虑 Scale”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BE%B9"><span class="toc-text">裁剪空间描边</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%9B%B8%E6%9C%BA-aspect"><span class="toc-text">考虑相机 aspect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E8%80%83%E8%99%91%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">综合考虑下的结果</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/18785.html" title="【图形系统02】光栅化"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292307530.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【图形系统02】光栅化"/></a><div class="content"><a class="title" href="/post/18785.html" title="【图形系统02】光栅化">【图形系统02】光栅化</a><time datetime="2024-09-28T16:00:00.000Z" title="发表于 2024-09-29 00:00:00">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/32783.html" title="【公式推导03】光照向量"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292237904.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【公式推导03】光照向量"/></a><div class="content"><a class="title" href="/post/32783.html" title="【公式推导03】光照向量">【公式推导03】光照向量</a><time datetime="2024-08-05T16:00:00.000Z" title="发表于 2024-08-06 00:00:00">2024-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/49886.html" title="光线追踪理论"><img src="https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404292358872.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="光线追踪理论"/></a><div class="content"><a class="title" href="/post/49886.html" title="光线追踪理论">光线追踪理论</a><time datetime="2024-07-14T16:00:00.000Z" title="发表于 2024-07-15 00:00:00">2024-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/21838.html" title="冯乐乐入门精要笔记">冯乐乐入门精要笔记</a><time datetime="2024-05-18T16:45:45.000Z" title="发表于 2024-05-19 00:45:45">2024-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46138.html" title="雾">雾</a><time datetime="2024-05-18T16:05:48.000Z" title="发表于 2024-05-19 00:05:48">2024-05-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>