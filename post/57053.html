<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lua精粹 | 游戏江湖</title><meta name="author" content="灵玉"><meta name="copyright" content="灵玉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[!NOTE] 约定在本书中，我们使用  双引号表示字符串常量（如 &quot;literal strings&quot;） 单引号表示单个字符（如 &#39;a&#39;），用作模式的字符串也会被单引号引起来，例如 &#39;[%w_]*&#39;。 符号&lt;--&gt;表示两者完全等价：   一、特性程序段我们将Lua语言执行的每一段代码（例如，一个文件或交互模式下的一行）称为一个程序段">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua精粹">
<meta property="og:url" content="http://liuke101.github.io/post/57053.html">
<meta property="og:site_name" content="游戏江湖">
<meta property="og:description" content="[!NOTE] 约定在本书中，我们使用  双引号表示字符串常量（如 &quot;literal strings&quot;） 单引号表示单个字符（如 &#39;a&#39;），用作模式的字符串也会被单引号引起来，例如 &#39;[%w_]*&#39;。 符号&lt;--&gt;表示两者完全等价：   一、特性程序段我们将Lua语言执行的每一段代码（例如，一个文件或交互模式下的一行）称为一个程序段">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png">
<meta property="article:published_time" content="2023-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T17:07:00.328Z">
<meta property="article:author" content="灵玉">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png"><link rel="shortcut icon" href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232138939.png"><link rel="canonical" href="http://liuke101.github.io/post/57053.html"><link rel="preconnect" href="//cdn.jsdmirror.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6wt4eQbcmYIioyaSsUswEjImObRq1GoUZP_ZRoEoOXc"/><meta name="msvalidate.01" content="9315C074B7CC1C8996DDD5A9533EF368"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d08ce745bb272195666f030857b5f8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"QTHLKKVLAS","apiKey":"7f01e97a350ca196bda1df9cd9168b30","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 灵玉","link":"链接: ","source":"来源: 游戏江湖","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#804bfb","bgDark":"#804bfb","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdmirror.com/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lua精粹',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 01:07:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏江湖"><span class="site-name">游戏江湖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Lua精粹</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T17:07:00.328Z" title="更新于 2024-08-09 01:07:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Lua精粹"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/57053.html#post-comment"><span class="waline-comment-count" data-path="/post/57053.html"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>[!NOTE] 约定<br>在本书中，我们使用</p>
<ul>
<li>双引号表示字符串常量（如 <code>&quot;literal strings&quot;</code>）</li>
<li>单引号表示单个字符（如 <code>&#39;a&#39;</code>），用作模式的字符串也会被单引号引起来，例如 <code>&#39;[%w_]*&#39;</code>。</li>
<li>符号<code>&lt;--&gt;</code>表示两者完全等价：</li>
</ul>
</blockquote>
<h1 id="一、特性"><a href="#一、特性" class="headerlink" title="一、特性"></a>一、特性</h1><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><p>我们将Lua语言执行的<strong>每一段代码</strong>（例如，一个文件或交互模式下的一行）称为一个<strong>程序段（ <em>Chunk</em> ）</strong>，即一组命令或表达式组成的序列。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释格式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    块注释</span></span><br><span class="line"><span class="comment">    块注释</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>

<p>在注释一段代码时，一个常见的技巧是将这些代码放入 <code>--[[</code> 和 <code>--]]</code> 之间，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">print(10)   --被注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<p>当我们需要重新启用这段代码时，只需在第一行行首添加一个连字符即可（即开头连续三个<code>-</code>）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">---[[ </span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>)   -取消注释，可以</span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>
<p>解释：在第一个示例中，第一行的 <code>--[[</code> 表示一段多行注释的开始，直到遇到两个连续的右括号这段多行注释才会结束，因而尽管最后一行有两个连续的连字符，但由于这两个连字符在最后两个右方括号之前，所以仍然被注释掉了。在第二个示例中，由于第一行的 <code>---[[</code> 实际是单行注释，因此最后一行实际上也是一条独立的单行注释（最后的两个连续右方括号没有与之匹配的 <code>--[[</code>），print并没有被注释掉。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ol>
<li>Lua语言中的标识符（或名称）是由任意字母、数字和下画线组成的字符串（注意，不能以数字开头），例如：<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054121.png" alt="Pasted image 20240628220654|250"></li>
<li>下画线+大写字母”（例如 <code>_VERSION</code>）组成的标识符通常被Lua语言用作特殊用途，应避免将其用作其他用途。通常会将“下画线+小写字母”用作哑变量（Dummy variable）。</li>
<li>以下是Lua语言的保留字（reserved word），它们不能被用作标识符：<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054122.png" alt="Pasted image 20240628220617"><blockquote>
<p>Lua语言是对大小写敏感的，因而虽然 and 是保留字，但是And和AND就是两个不同的标识符。</p>
</blockquote>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>lua 和 C 语言一样，对<strong>大小写字符敏感</strong></li>
<li>句尾分号是可省略的，以下四种写法等价<img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054123.png" alt="Pasted image 20240628221458|450"></li>
<li>数组下标从 1 开始</li>
<li>不支持函数重载，如果有多个同名函数，只会调用最后声明的函数。</li>
<li><code>#</code> 用于获取指定变量的长度，例如 <code>string</code>，<code>table</code> 等。<code>#</code> 获取长度不准确（当序列中存在 nil 值时），推荐使用迭代器遍历 <code>for pairs</code></li>
<li>只有 nil 和 false 被认为是假值</li>
</ol>
<h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1 变量类型"></a>1 变量类型</h2><p>Lua语言是一种动态类型语言，在这种语言中没有类型定义，每个值都带有其自身的类型信息。任何变量都可以相互赋值</p>
<ul>
<li><p><strong>获取变量类型：</strong><code>type(a)</code></p>
<ul>
<li><code>type()</code> 的返回值是 string 类型，可以通过 <code>type(type(a))</code> 验证</li>
</ul>
</li>
<li><p><strong>值类型</strong>：<code>nil</code> <code>boolean</code> <code>number</code> <code>string</code> </p>
<ul>
<li><code>nil</code> 即 null，访问未声明的变量不会报错，默认为 <code>nil</code>。它的主要作用就是与其他所有值进行区分，即将 nil 视为无效值</li>
<li><code>boolean</code> 即 bool，<code>true</code> or <code>false</code>。<strong>在 lua 中，任何值都可以用于条件测试，除了 false 和 nil 外都视为真。注意，lua 把零和空字符都视为真</strong>。</li>
<li>所有的数值都是 <code>number</code> (数值)   类型，<ul>
<li>Lua5.2 及之前默认为双精度浮点型</li>
<li>从Lua 5.3版本开始，Lua语言为数值格式提供了两种选择：被称为 <code>integer</code> 的64位整型和被称为 <code>float</code> 的双精度浮点类型</li>
<li>对于资源受限的平台，我们可以将Lua 5.3编译为精简 <em>Lua</em> （ <em>Small Lua</em> ）模式，在该模式中使用32位整型和单精度浮点类型</li>
</ul>
</li>
<li><code>string</code> 为字符串，可以使用 <code>&#39;&#39;</code> 或 <code>&quot;&quot;</code>，lua 中没有 char 类型。string 是不可变值，不能直接修改其中某个字符，但是可以通过创建一个新字符串实现功能。</li>
</ul>
</li>
<li><p><strong>引用类型</strong>: <code>function</code> <code>table</code> <code>userdata</code> <code>thread</code></p>
</li>
</ul>
<p>引用类型默认为浅拷贝：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">local</span> b = a;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span>;  <span class="comment">-- 修改b也会影响a</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>]); <span class="comment">-- 100</span></span><br></pre></td></tr></table></figure>

<p><code>userdata</code> 类型允许把任意的C语言数据保存在Lua语言变量中。<code>userdata</code> 类型除了赋值和相等性测试外，没有其他预定义的操作。<code>userdata</code> 被用来表示由应用或C语言编写的库所创建的新类型。例如，标准I&#x2F;O库使用用户数据来表示打开的文件。我们会在后面涉及CAPI时再讨论更多的相关内容。</p>
<h2 id="2-全局变量与局部变量"><a href="#2-全局变量与局部变量" class="headerlink" title="2 全局变量与局部变量"></a>2 全局变量与局部变量</h2><ul>
<li><p>全局变量（Global Variable）无须声明即可使用，使用未经初始化的全局变量也不会导致错误。当使用未经初始化的全局变量时，得到的结果是nil。</p>
</li>
<li><p>当把nil赋值给全局变量时，Lua会回收该全局变量的内存（Lua 不区分未初始化变量和被赋值为 nil 的变量）</p>
</li>
<li><p>默认声明的变量都是全局变量</p>
</li>
<li><p>局部变量关键字： <code>local</code></p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> d = i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment">--打印 nil</span></span><br></pre></td></tr></table></figure>

<p>Lua语言中有一种常见的用法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = foo</span><br></pre></td></tr></table></figure>
<p>这段代码声明了一个局部变量foo，然后用全局变量foo对其赋初值（局部变量foo只有在声明之后才能被访问）。这个用法在需要提高对foo的访问速度时很有用。当其他函数改变了全局变量foo的值，而代码段又需要保留foo的原始值时，这个用法也很有用，尤其是在进行运行时动态替换（monkey patching，猴子补丁）时。即使其他代码把 foo动态替换成了其他函数，在local foo&#x3D;foo语句之前的所有代码使用的还都是原先的 foo函数？</p>
<p>局部变量的生效范围仅限于声明它的代码块。如果 <code>local</code> 在代码块外部使用呢？</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">-- 打印 123</span></span><br></pre></td></tr></table></figure>

<p>那么这和全局变量有什么区别？这和多脚本执行有关：脚本 B 可以访问脚本 A 声明的全局变量，但不能访问 local 变量</p>
<h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>Lua语言中的全局变量不需要声明就可以使用，可以通过元表来<strong>发现访问不存在全局变量的情况</strong>。</p>
<p>一种方法是简单地检测所有对全局表中不存在键的访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>, &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(_, n)</span></span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;尝试写入未声明变量&quot;</span>, ..n, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_, n)</span></span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;尝试读取未声明变量&quot;</span>, ..n, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span>,   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码执行后，所有试图对不存在全局变量的访问都将引发一个错误。</p>
<p>如何声明一个新的变量？<br>方法一：使用函数 <code>rawset</code>，它可以绕过元方法</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">decalre</span> <span class="params">(name, val)</span></span></span><br><span class="line">    <span class="built_in">rawset</span>(<span class="built_in">_G</span>, name, val <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其中，or 和 false 保证新变量一定会得到一个不为nil的值。 </p>
<p>方法二：<br>更简单的方法是把对新全局变量的赋值限制在仅能在函数内进行，而代码段外层的代码则被允许自由赋值。<br><strong>要检查赋值是否在主代码段中必须用到调试库</strong>。调用函数 <code>debug.getinfo(2,&quot;S&quot;)</code> 将返回一个表，其中的字段 <code>what</code> 表示调用元方法的函数是主代码段还是普通的Lua函数还是C函数。使用该函数，可以将 <code>__newindex</code> 元方法重写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, name, val)</span></span></span><br><span class="line">    <span class="keyword">local</span> w = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;S&quot;</span>).what</span><br><span class="line">    <span class="keyword">if</span> w ~= <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;尝试写入未声明变量&quot;</span>, ..name, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">rawset</span>(t, name, val)</span><br></pre></td></tr></table></figure>

<p><strong>如果要测试一个变量是否存在，并不能简单地将它与nil比较</strong>。因为如果它为nil，那么访问就会引发一个错误。这时，应该使用rawget来绕过元方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &#x27;var&#x27; 未被声明</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">rawget</span>(<span class="built_in">_G</span>, var) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="3-多变量赋值"><a href="#3-多变量赋值" class="headerlink" title="3 多变量赋值"></a>3 多变量赋值</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line"><span class="built_in">print</span>(a, b, c)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多变量赋值</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<h2 id="4-string-操作"><a href="#4-string-操作" class="headerlink" title="4  string 操作"></a>4  <code>string</code> 操作</h2><ol>
<li><code>#</code> 获取字符串长度 (包含空格)</li>
</ol>
<ul>
<li>英文字母长度为 1</li>
<li>汉字长度为 3</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;hello&quot;</span>) <span class="comment">-- 输出5</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;你好&quot;</span>) <span class="comment">-- 输出6</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>长字符串&#x2F;多行字符串 <code>[[]]</code></p>
<ul>
<li>使用转义字符 <code>\n</code></li>
<li>使用双中括号 <code>[[]]</code><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\nworld&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span><span class="string">[[你好世界]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span><span class="string">[[你好</span></span><br><span class="line"><span class="string">世界]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出如下</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">你好世界</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line">世界</span><br></pre></td></tr></table></figure>
有时字符串中可能有类似 <code>a=b[c[i]]</code> 这样的内容（注意其中的<code>]]</code>），或者，字符串中可能有被注释掉的代码。为了应对这些情况，可以在两个左方括号之间加上任意数量的等号，如<code>[===[</code>。这样，字符串常量只有在遇到了包含相同数量等号的两个右方括号时才会结束（就前例而言，即<code>]===]</code>）。Lua语言的语法扫描器会忽略所含等号数量不相同的方括号。通过选择恰当数量的等号，就可以在无须修改原字符串的情况下声明任意的字符串常量了。<br>对注释而言，这种机制也同样有效。例如，我们可以使用<code>--[=[</code>和<code>]=]</code>来进行长注释，从而降低了对内部已经包含注释的代码进行注释的难度。</li>
</ul>
</li>
<li><p>字符串拼接 <code>..</code> 或 <code>string.format()</code> 方法</p>
<ul>
<li>支持不同类型变量拼接</li>
<li>当在 number 后紧接着使用字符串连接时，必须使用空格将它们分开，否则Lua语言会把第一个点当成小数点。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(s1..s2)</span><br><span class="line"><span class="comment">-- hello123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s %d&quot;</span>, s1, s2)) </span><br><span class="line"><span class="comment">-- hello 123</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>其他类型转字符串 <code>tostring(x)</code></li>
</ol>
</li>
</ol>
<p><code>print()</code> 支持所有类型，都会自动转换为字符串。使用 <code>tostring()</code> 可以手动转换</p>
<ol start="5">
<li>其他方法<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 大写转小写</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">upper</span>(str) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小写转大写</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>(str) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 翻转字符串</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">reverse</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串模式匹配</span></span><br><span class="line"><span class="comment">-- 返回两个值，第一个是首字母位置，第二个是尾字母位置</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">find</span>(str, <span class="string">&quot;ab&quot;</span>)</span><br><span class="line"><span class="comment">-- 将第一个字符串中的&quot;l&quot;替换为&quot;.&quot;, 第二个返回值返回替换的次数</span></span><br><span class="line"><span class="built_in">string</span>.gshub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子字符串</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(str, <span class="number">2</span>) <span class="comment">-- 从第二个字符开始截取</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(str, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">-- 从第二个字符开始截取到第三个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串重复</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">rep</span>(str, <span class="number">2</span>) <span class="comment">-- 重复两次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串替换</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(str, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">-- 将a替换为c,返回替换后的字符串和替换次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符转ASCII码</span></span><br><span class="line">a = <span class="built_in">string</span>.<span class="built_in">byte</span>(str, <span class="number">2</span>) <span class="comment">-- 返回第二个字符的ASCII码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ASCII码转字符</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">char</span>(a) </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-table-表"><a href="#6-table-表" class="headerlink" title="6  table 表"></a>6  <code>table</code> 表</h2><ul>
<li><p>表（Table）是Lua语言中最主要（事实上也是<strong>唯一的</strong>）和强大的数据结构，Lua语言也使用表来表示包（package）和其他对象。当调用函数math.sin时，我们可能认为是“调用了math库中函数sin”；而对于Lua语言来说，其实际含义是“以字符串”sin”为键检索表math”。</p>
</li>
<li><p>Lua语言中的表要么是值要么是变量，它们都是对象（ <em>object</em> ）。可以认为，表是一种动态分配的对象，程序只能操作指向表的引用（或指针）。除此以外，Lua语言不会进行隐藏的拷贝或创建新的表</p>
</li>
<li><p>当程序中没有对 table 的引用时，该 table 会被自动 GC</p>
</li>
<li><p>所有的复杂类型都是 <code>table</code> 类型，<strong>存储键值对，类似 C++中的 map</strong></p>
</li>
<li><p>元素用 <code>&#123;&#125;</code> 组织</p>
</li>
<li><p>table 是动态对象，可按需增长</p>
</li>
</ul>
<h3 id="表索引"><a href="#表索引" class="headerlink" title="表索引"></a>表索引</h3><p>表本质上是一种辅助数组，这种数组不仅可以使用 number 作为索引，也可以使用 string 或其他任意类型的值作为索引（nil 除外）。</p>
<p>当把表当作结构体使用时，可以把索引当作成员名称使用（<code>a.name</code> 等价于 <code>a[&quot;name&quot;]</code>）。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a.x = <span class="number">10</span> </span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line">a[<span class="string">&quot;x&quot;</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>对Lua语言而言，这两种形式是等价且可以自由混用的，为了方便阅读，可以按一下方式表示 table：</p>
<ul>
<li>形如<code>a.name</code>的点分形式说明表是被当作结构体使用的，此时表实际上是由固定的、预先定义的键组成的集合；</li>
<li>形如 <code>a[&quot;name&quot;]</code> 的字符串索引形式则说明了表可以使用任意字符串作为键，并且出于某种原因我们操作的是指定的键。</li>
</ul>
<p>初学者常常会混淆 <code>a.x</code> 和 <code>a[x]</code>。实际上，<code>a.x</code> 代表的是 <code>a[&quot;x&quot;]</code>，即由字符串 <code>&quot;x&quot;</code> 索引的表；而 <code>a[x]</code> 则是指由变量 <code>x</code> 对应的值索引的表。</p>
<h3 id="表构造器"><a href="#表构造器" class="headerlink" title="表构造器"></a>表构造器</h3><p>两种方式构造表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--列表式</span></span><br><span class="line">days =&#123;<span class="string">&quot;Sunday&quot;</span>，<span class="string">&quot;Monday&quot;</span>，<span class="string">&quot;Tuesday&quot;</span>，<span class="string">&quot;Wednesday&quot;</span><span class="string">&quot;Thursday&quot;</span>，<span class="string">&quot;Friday&quot;</span>，<span class="string">&quot;Saturday&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(day[<span class="number">4</span>]) <span class="comment">--Wednesday</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--初始化记录式</span></span><br><span class="line">a = &#123;x=<span class="number">10</span>, y=<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a.x = <span class="number">10</span></span><br><span class="line">a.y = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>不过，这两种构造器都有各自的局限。例如，使用这两种构造器时，不能使用负数索引初始化表元素，也不能使用不符合规范的标识符作为索引。<br>对于这类需求，可以使用另一种<strong>更加通用的构造器</strong>，即通过方括号 <code>[]</code>括起来的表达式显式地指定每一个索引：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = &#123;[<span class="string">&quot;+&quot;</span>] = <span class="string">&quot;add&quot;</span>, [<span class="string">&quot;-&quot;</span>] = <span class="string">&quot;sub&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--访问</span></span><br><span class="line">names[<span class="string">&quot;-&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这种构造器虽然冗长，但却非常灵活，不管是记录式构造器还是列表式构造器均是其特殊形式。例如，下面的表达式就相互等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;x=<span class="number">0</span>，y=<span class="number">0</span>&#125;  <span class="comment">--&#123;[&quot;x&quot;]=0，[&quot;y&quot;]=0&#125;</span></span><br><span class="line">&#123;<span class="string">&quot;r&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;b&quot;</span>&#125; <span class="comment">--&#123;[1]=&quot;r&quot;，[2]=&quot;g&quot;，[3]=&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后一个元素后可以加逗号，是可选的</p>
<h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><p>由表标准库提供</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>() <span class="comment">-- 向序列的指定位置插入一个元素，其他元素依次后移。如果不指定位置默认插入末尾</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>() <span class="comment">-- 删除并返回序列指定位置的元素，然后将其后的元素向前移动。如果不指定位置，该函数会删除序列的最后一个元素。</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>()   <span class="comment">-- 排序,默认为升序</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(B, <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> <span class="keyword">return</span> a &gt; b <span class="keyword">end</span>) <span class="comment">-- 降序排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.move(a,f,e,t) <span class="comment">--lua5.3新增，将表a中从索引f到e的元素（包含索引f和索引e对应的元素本身）移动到位置t</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span>() <span class="comment">--合并</span></span><br><span class="line"><span class="built_in">table</span>.pack()   <span class="comment">--打包, 将基本类型值（number和string）打包为二进制string</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">unpack</span>() <span class="comment">--解包， 从二进制string中提取这些值</span></span><br></pre></td></tr></table></figure>

<p>函数table.move还支持使用一个表作为可选的参数。当带有可选的表作为参数时，该函数将第一个表中的元素移动到第二个表中。例如，<code>table.move（a,1,#a,1,&#123;&#125;）</code> 返回列表a的一个克隆（clone）（通过将列表a中的所有元素拷贝到新列表中），<code>table.move（a,1, #a , #b+1,b）</code> 将列表a中的所有元素复制到列表b的末尾</p>
<p><strong>打包解包</strong>：pack把参数列表转换成Lua语言中一个真实的列表（一个表），而unpack则把Lua语言中的真实的列表（一个表）转换成一组返回值，进而可以作为另一个函数的参数被使用。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--等价</span></span><br><span class="line">f = <span class="built_in">string</span>.<span class="built_in">find</span></span><br><span class="line">a = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(f(<span class="built_in">table</span>.<span class="built_in">unpack</span>(a)))</span><br></pre></td></tr></table></figure>

<p>通常，函数table.unpack使用长度操作符获取返回值的个数，因而该函数只能用于序列。不过，如果有需要，也可以显式地限制返回元素的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(table.unpack(&#123;&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;&#125;, 2, 3))</span><br><span class="line">-- 打印范围2-3 即 &quot;Mon&quot;,&quot;Tue&quot;</span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>使用 <code>table</code> 实现各种数据结构</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在Lua语言中，简单地使用整数来索引 <code>table</code> 即可实现数组</p>
<ul>
<li>lua 的数组下标（索引）默认从 1 开始，Lua 的标准库和 <code>#</code> 运算符都遵循这个管理（实际上可以使用其他任何值来作为数组的起始索引，但会破坏标准库和 <code>#</code>运算符的机制 ）</li>
<li>数组大小不是固定的，可按需增长</li>
<li><code>nil</code> 会截断数组，导致无法遍历后序元素</li>
</ul>
<p><strong>声明数组：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一维数组</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 二维数组</span></span><br><span class="line">b = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义数组索引（不要滥用）：</strong></p>
<ul>
<li>使用 <code>[x] = var</code> 指定索引 x 对应变量 var<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; [<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">-1</span>] = <span class="number">4</span>, <span class="number">5</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>]) <span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">-1</span>])<span class="comment">-- 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于lua数组下标从1开始计算，a中的索引0和-1对应的数被忽略，剩下的元素按顺序排列</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>]) <span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>]) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>]) <span class="comment">-- 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#a)   <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>把每个节点用一个表来表示（也只能用表表示），链接则为一个包含指向其他表的引用的简单表字段。<br>例如，让我们实现一个单链表（singly-linked list），其中每个节点具有两个字段value和next。最简单的变量就是根节点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--根节点</span></span><br><span class="line">list = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在表头插入值为v的元素</span></span><br><span class="line">list = &#123;<span class="built_in">next</span> = list, value = v&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--遍历链表</span></span><br><span class="line"><span class="keyword">local</span> l = list</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> l <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(l.value)</span><br><span class="line">    l = l.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>诸如双向链表（doubly-linked list）或环形表（circular list）等其他类型的链表也很容易实现。不过，由于通常无须链表即可用更简单的方式来表示数据，所以在Lua语言中很少需要用到这些数据结构。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>我们可以使用 <code>t=&#123;&#125;</code> 来表示栈，Push 操作可以使用 <code>table.insert（t,x）</code> 实现，Pop 操作可以使用 <code>table.remove（t）</code> 实现，调用 <code>table.insert（t,1,x）</code> 可以实现在栈的顶部进行插入，调用 <code>table.remove（t,1）</code> 可以从栈的顶部移除 </p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字典声明(两种写法等价)</span></span><br><span class="line"><span class="keyword">local</span> myDictionary = &#123; name = <span class="string">&quot;John&quot;</span>, age = <span class="number">25</span> &#125;</span><br><span class="line"><span class="keyword">local</span> myDictionary = &#123;[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;John&quot;</span>, [<span class="string">&quot;age&quot;</span>] = <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问value(两种写法等价)</span></span><br><span class="line"><span class="built_in">print</span>(myDictionary.name) <span class="comment">--如果key值是数字，则不支持这种写法</span></span><br><span class="line"><span class="built_in">print</span>(myDictionary[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改value(两种写法等价)</span></span><br><span class="line">myDictionary.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">myDictionary[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加, 当原字典不存在该键时，自动添加该键值对</span></span><br><span class="line">myDictionary[<span class="string">&quot;new&quot;</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line">myDictionary[<span class="string">&quot;name&quot;</span>] = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h2 id="7-metatable-元表"><a href="#7-metatable-元表" class="headerlink" title="7  metatable 元表"></a>7  <code>metatable</code> 元表</h2><p>在 Lua 中，<code>metatable</code> 是一种特殊的 <code>table</code> ，用于定义其他 <code>table</code> 的行为。通过设置某个 <code>table</code> 的 <code>metatable</code>，你可以控制该 <code>table</code> 的一些操作，例如对 <code>table</code> 进行加法、乘法等操作时的行为。</p>
<ul>
<li>任何 <code>table</code> 都可以作为另一个 <code>table</code> 的元表</li>
<li>任何 <code>table</code> 都可以有自己的元表</li>
<li>当对 <code>table</code> 进行一些操作时，就会执行元表中的元方法</li>
<li>Lua中的每一个值都可以有元表，使用 Lua 只能为 <code>table</code> 设置元表；如果要为其他类型的值设置元表，则必须通过C代码或调试库完成。</li>
</ul>
<p><strong>元方法 (MetaMethod)：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__add(a, b)                     对应表达式 a + b</span><br><span class="line">__sub(a, b)                     对应表达式 a - b</span><br><span class="line">__mul(a, b)                     对应表达式 a * b</span><br><span class="line">__div(a, b)                     对应表达式 a / b</span><br><span class="line">__mod(a, b)                     对应表达式 a % b</span><br><span class="line">__pow(a, b)                     对应表达式 a ^ b</span><br><span class="line">__unm(a)                        对应表达式 -a</span><br><span class="line">__concat(a, b)                  对应表达式 a .. b</span><br><span class="line">__len(a)                        对应表达式 <span class="meta">#a</span></span><br><span class="line">__eq(a, b)                      对应表达式 a == b</span><br><span class="line">__lt(a, b)                      对应表达式 a &lt; b</span><br><span class="line">__le(a, b)                      对应表达式 a &lt;= b</span><br><span class="line">__index(a, b)                   对应表达式 a.b</span><br><span class="line">__newindex(a, b, c)             对应表达式 a.b = c</span><br><span class="line">__call(a, ...)                  对应表达式 <span class="built_in">a</span>(...)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">MetaTable =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">-- 当 MyTable 被当作 string 操作时，调用此方法</span></span><br><span class="line">    <span class="comment">-- 默认会将 MyTable 传入第一个参数</span></span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span> <span class="params">(table)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">table</span>.name</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 当 MyTable 被当作 function 操作时，调用此方法</span></span><br><span class="line">    <span class="comment">-- 只有 MyTable 设置了元表，并且元表中有 __call 方法，MyTable才能被当作函数调用</span></span><br><span class="line">    <span class="comment">-- 默认会将 MyTable 传入第一个参数</span></span><br><span class="line">    <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, param1)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(param1)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 重载 + 运算符</span></span><br><span class="line">    <span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(table1, table2)</span></span></span><br><span class="line">        <span class="keyword">return</span> table1.age + table2.age</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 当 MyTable 中找不到某个 key 时，就会到元表中__index指定的table中查找</span></span><br><span class="line">    <span class="built_in">__index</span> = &#123;</span><br><span class="line">        sex = <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 当 MyTable 赋值时，如果赋值一个不存在的 key ，那么就会把这个值复制到newindex指定的table中，而不是在MyTable中创建键值对</span></span><br><span class="line">    <span class="built_in">__newindex</span> = &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTable1 =</span><br><span class="line">&#123;</span><br><span class="line">    name = <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTable2 =</span><br><span class="line">&#123;</span><br><span class="line">    name = <span class="string">&quot;小红&quot;</span>,</span><br><span class="line">    age = <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置MyTable的元表为MetaTable</span></span><br><span class="line"><span class="built_in">setmetatable</span>(MyTable1, MetaTable)</span><br><span class="line"><span class="built_in">setmetatable</span>(MyTable2, MetaTable)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取MyTable的元表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(MyTable1).<span class="built_in">__index</span>.sex)    <span class="comment">-- 男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--__tostring</span></span><br><span class="line"><span class="built_in">print</span>(MyTable1)                  <span class="comment">-- 小明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--__call</span></span><br><span class="line">MyTable1(<span class="number">1</span>)                      <span class="comment">-- call 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--__add</span></span><br><span class="line"><span class="built_in">print</span>(MyTable1 + MyTable2)       <span class="comment">-- 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--__index</span></span><br><span class="line"><span class="built_in">print</span>(MyTable1.sex) <span class="comment">-- 男</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(MyTable1, <span class="string">&quot;sex&quot;</span>)) <span class="comment">-- nil(不会触发元方法)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--__newindex</span></span><br><span class="line">MyTable1.home = <span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="built_in">print</span>(MyTable1.home)       <span class="comment">-- nil （受到了__newindex的影响）</span></span><br><span class="line"><span class="built_in">print</span>(MetaTable.<span class="built_in">__newindex</span>.home) <span class="comment">-- 北京 （__newindex新增了键值对）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(MyTable1, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(MyTable1.home) <span class="comment">-- 北京 （因为rawset不会触发元方法，所以不受__newindex的影响）</span></span><br></pre></td></tr></table></figure>

<p>如果要实现<code>__index</code> 指向 <code>MetaTable</code> 自身，是不能在表内实现的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MetaTable =</span><br><span class="line">&#123;</span><br><span class="line">    id = <span class="number">123</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--__index = MetaTable,  --在表内写是不允许的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetaTable.<span class="built_in">__index</span> = MetaTable <span class="comment">--可以在表外写</span></span><br></pre></td></tr></table></figure>
<h2 id="8-thread-线程"><a href="#8-thread-线程" class="headerlink" title="8  thread 线程"></a>8  <code>thread</code> 线程</h2><h2 id="9-协程"><a href="#9-协程" class="headerlink" title="9 协程"></a>9 协程</h2><p>协同程序 <code>coroutine</code> 是一个 <code>thread</code> 类型的对象</p>
<blockquote>
<p>[!quote]<br>coroutine：”co-“ 表示 “共同”（cooperative）或 “协同”（coordinated）的意思。<br>routine 常规、惯例</p>
</blockquote>
<h3 id="协程操作"><a href="#协程操作" class="headerlink" title="协程操作"></a>协程操作</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建（两种方式）</span></span><br><span class="line">Co1 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(Fun) <span class="comment">-- 返回一个thread</span></span><br><span class="line">Co2 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(Fun) <span class="comment">-- 返回一个function， 每次调用该函数都会延续该协程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 恢复协程运行</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co1) <span class="comment">--resume英文意思是（中断后）重新开始/继续/恢复</span></span><br><span class="line">Co2()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 挂起正在运行的协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看协程状态</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">status</span>(Co1)</span><br><span class="line"><span class="comment">-- 执行coroutine.resume(Co1)后，执行coroutine.yield()前：running</span></span><br><span class="line"><span class="comment">-- 执行coroutine.yield()：suspended</span></span><br><span class="line"><span class="comment">-- 执行coroutine.close(Co1)后：dead</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取运行中的线程的线程地址和是否是主线程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">running</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="协程的运行"><a href="#协程的运行" class="headerlink" title="协程的运行"></a>协程的运行</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">-- 挂起正在运行的协程</span></span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式一</span></span><br><span class="line">Co3 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(Func)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)  <span class="comment">--1</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)  <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line">Co4 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(Func)</span><br><span class="line">Co4()  <span class="comment">--1</span></span><br><span class="line">Co4()  <span class="comment">--2</span></span><br><span class="line">Co4()  <span class="comment">--3</span></span><br></pre></td></tr></table></figure>

<h3 id="协程的返回值"><a href="#协程的返回值" class="headerlink" title="协程的返回值"></a>协程的返回值</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 挂起正在运行的协程</span></span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式一</span></span><br><span class="line"><span class="comment">-- 第一个返回值是boolean，表示协同程序成功执行</span></span><br><span class="line"><span class="comment">-- 第二个返回值是coroutine.yield(i)中传的参数</span></span><br><span class="line">Co3 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(Func)</span><br><span class="line">IsSuccess, Value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)</span><br><span class="line"><span class="built_in">print</span>(IsSuccess, Value) <span class="comment">--true    1</span></span><br><span class="line">IsSuccess, Value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)</span><br><span class="line"><span class="built_in">print</span>(IsSuccess, Value) <span class="comment">--true    2</span></span><br><span class="line">IsSuccess, Value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(Co3)</span><br><span class="line"><span class="built_in">print</span>(IsSuccess, Value) <span class="comment">--true    3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="comment">-- 只返回coroutine.yield(i)中传的参数</span></span><br><span class="line">Co4 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(Func)</span><br><span class="line"><span class="built_in">print</span>(Co4()) <span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(Co4()) <span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(Co4()) <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>
<h2 id="9-强制类型转换"><a href="#9-强制类型转换" class="headerlink" title="9 强制类型转换"></a>9 强制类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ol>
<li>Lua会根据代码具体实现在 number 与 string 类型之间的自动转换。在任何需要数值的情况下都会尝试将 string 转换为 number，比如在数值运算时。相反，当Lua语言发现在需要 string 的地方出现了 number 时，它就会把 number 转换为 string：</li>
<li>Lua5.3 提出的 <code>integer</code> 整形没有上述功能，规则是只有在两个操作数都是 integer 值时结果才是整型。因此，由于字符串不是整型值，所以任何有字符串参与的算术运算都会被当作浮点运算处理。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;10&quot;</span> + <span class="number">1</span>  <span class="comment">--结果为11.0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p><code>tonumber</code> ：string 转换为 number</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tonumber</span>(<span class="string">&quot;-3&quot;</span>) <span class="comment">-- 默认为十进制</span></span><br><span class="line"><span class="built_in">tonumber</span>(<span class="string">&quot;100101&quot;</span>, <span class="number">2</span>) <span class="comment">--可以指定二进制到三十六进制之间的任意进制</span></span><br></pre></td></tr></table></figure>

<p><code>tostring</code>：将 number 转换为 string</p>
<h1 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h1><p><strong>算术运算符：</strong></p>
<ul>
<li>支持 <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^ (幂)</code> <code>// (floor向下取整)</code></li>
<li>不支持 <code>++</code> <code>--</code> <code>+=</code> <code>-=</code> <code>/=</code> <code>*=</code> <code>%=</code></li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span> + <span class="number">1</span>) </span><br><span class="line"><span class="comment">-- 输出124，&quot;123&quot;被自动转换为number类型</span></span><br></pre></td></tr></table></figure>

<p><strong>条件运算符</strong>： <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>~=</code> (不等于)</p>
<p><strong>逻辑运算符：</strong></p>
<ul>
<li><code>and</code> （逻辑与，相当于<code>&amp;&amp;</code>）</li>
<li><code>or</code>（逻辑或，相当于<code>||</code>）</li>
<li><code>not</code> ：逻辑非，相当于 <code>!</code>（not 返回值固定位 Boolean）<ul>
<li>lua 和 C++ 的 <code>and</code> 与 <code>or</code> 或都支持“短路求值”，这是一种优化机制，即在表达式的值已经可以确定整个表达式的值时，就停止对表达式的进一步求值。</li>
<li><strong><code>and</code> <code>or</code> 支持连接任何类型的变量</strong></li>
<li><strong>在 lua 中，只有 nil 和 false 被认为是假值</strong><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b = <span class="number">1</span>, <span class="number">2</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> (a+b)) <span class="comment">--返回false</span></span><br><span class="line"><span class="comment">-- false在前，and规定当有一个是false时，结果就是false，所以后面就没必要执行计算了。这样可以减小开销</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">and</span> (a+b)) <span class="comment">--返回3</span></span><br><span class="line"><span class="comment">-- &quot;hello&quot;不是假值，所以会执行(a+b)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> (a+b)) <span class="comment">--返回true</span></span><br><span class="line"><span class="comment">-- or规定有一个是true，结果就是true，这里a+b不会被执行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>惯用写法</strong>：在Lua语言中，形如 <code>x=x or v</code> 的惯用写法非常有用，它等价于： </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span></span><br><span class="line">  x = v</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>即，当 <code>x</code> 未被初始化 （nil 为假）时，将其默认值设为 <code>v</code>（假设<code>x</code>不是Boolean类型的 false ）。</p>
<p><strong>不支持位运算符</strong>：<code>&amp;</code> <code>|</code> </p>
<p><strong>不支持三目运算符，需要自己实现</strong>：<code>? :</code><br><strong>⭐使用短路求值实现三目运算符 <code>and or</code>：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local a, b = <span class="number">1</span>, <span class="number">2</span>  </span><br><span class="line">local res = (a &gt; b) <span class="keyword">and</span> <span class="number">123</span> <span class="keyword">or</span> <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(res) --返回<span class="number">456</span></span><br></pre></td></tr></table></figure>


<h3 id="安全访问操作符"><a href="#安全访问操作符" class="headerlink" title="安全访问操作符"></a>安全访问操作符</h3><p>Lua 没有类似 C# 中的 <code>?</code> 安全访问符，但我们可以使用 lua 语法模拟</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--C#写法：</span></span><br><span class="line"><span class="comment">--如果上述的成员访问过程中出现null，安全访问操作符会正确地处理null并最终返回null</span></span><br><span class="line">Vector3 pos = actor?.Location;</span><br><span class="line"></span><br><span class="line"><span class="comment">--lua模拟写法</span></span><br><span class="line"><span class="comment">--对于表达式a or&#123;&#125;，当a为nil时其结果是一个空表。因此，对于表达式（a or&#123;&#125;）.b，当a为nil时其结果也同样是nil</span></span><br><span class="line">pos = (actor <span class="keyword">or</span> &#123;&#125;).Location;</span><br></pre></td></tr></table></figure>
<h1 id="四、控制流"><a href="#四、控制流" class="headerlink" title="四、控制流"></a>四、控制流</h1><p>lua 不支持<code>switch</code></p>
<h2 id="if-then-end"><a href="#if-then-end" class="headerlink" title="if then end"></a>if then end</h2><p>注意 <code>elseif</code> 连写, <code>end</code> 结尾</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &lt; <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="while-do-end"><a href="#while-do-end" class="headerlink" title="while do end"></a>while do end</h2><p>相当于 while</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="repeat-until"><a href="#repeat-until" class="headerlink" title="repeat until"></a>repeat until</h2><p>重复执行直到条件为真</p>
<p>和 C++中的 do while 不同，do while 中 do 是入口条件。而这里 <strong>until 是出口条件</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> a &gt; <span class="number">10</span>  <span class="comment">-- 满足条件推出循环</span></span><br></pre></td></tr></table></figure>

<h2 id="for-do-end"><a href="#for-do-end" class="headerlink" title="for do end"></a>for do end</h2><h3 id="数值型-for"><a href="#数值型-for" class="headerlink" title="数值型 for"></a>数值型 for</h3><p>注意，在循环开始前，三个表达式（参数）都会运行一次。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 前两个参数表示i从1开始，当 i&gt;10 时结束循环</span></span><br><span class="line"><span class="comment">-- 第三个参数可省略，默认为1，表示每次循环i递增多少</span></span><br><span class="line"><span class="comment">-- 正向打印：1，3，5，7，9</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反向打印：5，4，3，2，1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">5</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>for 循环遍历 table</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>,<span class="built_in">print</span>,<span class="number">12</span>,<span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #t <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, t[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型-for"><a href="#泛型-for" class="headerlink" title="泛型 for"></a>泛型 for</h3><p>与数值型 for 不同，泛型 for 可以使用多个变量，这些变量在每次循环时都会更新。当第一个变量变为nil时，循环终止。</p>
<h2 id="break、return、goto"><a href="#break、return、goto" class="headerlink" title="break、return、goto"></a>break、return、goto</h2><p>break 和 return 语句用于从当前的循环结构中跳出</p>
<p>goto 语句则允许跳转到函数中的几乎任何地方。goto 语句慎用，详情见 8.3 节</p>
<p><strong>所有函数的最后都有一个隐含的return，因此我们不需要在每一个没有返还值的函数最后书写return语句。</strong></p>
<h1 id="五、迭代器"><a href="#五、迭代器" class="headerlink" title="五、迭代器"></a>五、迭代器</h1><p>面试考点：ipairs 和 pairs 的区别</p>
<h2 id="ipairs"><a href="#ipairs" class="headerlink" title="ipairs"></a>ipairs</h2><p>全称：indexed pairs 索引对，ipairs 是<strong>专门用于处理数字索引</strong>的。<br>从第一个非空的数字索引开始，<strong>一直迭代到第一个空值为止</strong>。<strong>通常用于遍历数组，因为它只考虑连续的数字索引。</strong><br>和 pairs 不同，ipairs遍历是按照索引顺序进行的</p>
<p><code>ipairs</code> 遍历也是从下标 1 开始，忽略小于 0 的下标：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = &#123; [<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">-1</span>] = <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印结果</span></span><br><span class="line"><span class="number">1</span>       <span class="number">3</span></span><br><span class="line"><span class="number">2</span>       <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>ipairs</code> <strong>只能遍历连续索引</strong>，如下所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>] = <span class="number">5</span>, <span class="number">6</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印结果，下标为7的不连续项被忽略</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">3</span></span><br><span class="line"><span class="number">4</span>       <span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果将数组改为：</span></span><br><span class="line">A = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">6</span>] = <span class="number">5</span>, <span class="number">6</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以看到元素【6】索引为5，这样索引就连续了，就能打印出全部</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">3</span></span><br><span class="line"><span class="number">4</span>       <span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="number">6</span></span><br><span class="line"><span class="number">6</span>       <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>我们可以只遍历键，或同时遍历键值，但无法单独遍历值。可能会见到这如下写法，看似时只遍历了value：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>实际上在 lua 中 <code>_</code> 也可以作为变量名，上述写法和常规写法实际是相同的，仍是同时遍历键值</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h2><p><code>pairs</code>迭代表的所有键值对。<code>pairs</code> <strong>适用于任何表</strong>，无论其键是数字还是字符串。它迭代表中的所有键值对，不考虑键的类型。</p>
<p>受限于表在Lua语言中的底层实现机制，<strong>遍历过程中元素的出现顺序可能是随机的</strong>，相同的程序在每次运行时也可能产生不同的顺序。唯一可以确定的是，在遍历的过程中每个元素会且只会出现一次。</p>
<p><code>pairs</code> 可以获取所有的键值，不会受不连续的或小于 0 的下标影响</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = &#123; [<span class="number">-1</span>] = <span class="number">1</span>, age = <span class="number">25</span>, [<span class="number">0</span>] = <span class="number">5</span>, city = <span class="string">&quot;New York&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印结果</span></span><br><span class="line"><span class="number">0</span>       <span class="number">5</span></span><br><span class="line">age     <span class="number">25</span></span><br><span class="line">city    New York</span><br><span class="line"><span class="number">-1</span>      <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>nil</code> 会被忽略，但不会截断数组</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(A) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印结果</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">3</span></span><br><span class="line"><span class="number">5</span>       <span class="number">4</span></span><br></pre></td></tr></table></figure>


<h1 id="六、function-函数"><a href="#六、function-函数" class="headerlink" title="六、function 函数"></a>六、<code>function</code> 函数</h1><ul>
<li>在 lua 中 <code>function</code> 是一种类型</li>
<li>Lua 程序既可以调用 Lua 语言编写的函数，也可以调用 C 语言（或者宿主程序使用的其他任意语言）编写的函数。</li>
</ul>
<h2 id="函数是第一类值"><a href="#函数是第一类值" class="headerlink" title="函数是第一类值"></a>函数是第一类值</h2><p><strong>在 Lua 语言中，函数是严格遵循词法定界的第一类值。</strong></p>
<ul>
<li><strong>“第一类值”</strong> 意味着 Lua 语言中的<strong>函数与其他常见类型的值（例如数值和字符串）具有同等权限</strong>：一个程序可以将某个函数保存到变量中（全局变量和局部变量均可）或表中，也可以将某个函数作为参数传递给其他函数，还可以将某个函数作为其他函数的返回值返回。</li>
<li><strong>“词法定界”</strong> 意味着 Lua 语言中的函数可以访问包含其自身的外部函数中的变量（也意味着 Lua 语言完全支持 Lambda 演算）。  ^awkby7</li>
<li>在 Lua 中<strong>所有的函数都是匿名的</strong>。像其他所有的值一样，函数并没有名字。当讨论函数名时，比如 print，实际上指的是保存该函数的变量。</li>
</ul>
<h2 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法一(推荐)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintText</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写法二（=号后面的这个函数很明显是匿名函数，PrintText只是用来保存匿名函数的变量）</span></span><br><span class="line">PrintText = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数调用必须在函数声明后</span></span><br><span class="line">PrintText();</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(PrintText)); <span class="comment">-- 打印结果：function，因为function是一种类型</span></span><br></pre></td></tr></table></figure>

<p>局部函数</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>定义局部递归函数要注意：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当 Lua 语言编译函数体中的 fact（n-1）调用时，局部的 fact 尚未定义。因此，这个表达式会尝试调用全局的 fact 而非局部的 fact。我们可以通过先定义局部变量再定义函数的方式来解决这个问题：这样，函数内的 fact 指向的是局部变量</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line"></span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h2 id="参数与返回值"><a href="#参数与返回值" class="headerlink" title="参数与返回值"></a>参数与返回值</h2><p><strong>有参：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PrintText = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">PrintText(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua支持传参个数不匹配</span></span><br><span class="line"><span class="comment">-- 如果传参少了，自动用 nil 补充</span></span><br><span class="line"><span class="comment">-- 如果传参多了，只取前面有效位数</span></span><br><span class="line">PrintText();</span><br><span class="line">PrintText(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>有返回值：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua函数不需要声明返回值类型</span></span><br><span class="line">GetA = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(GetA(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 支持多个参数或多个返回值</span></span><br><span class="line">GetA = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a, b, <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于该函数有三个返回值，所以需要三个变量来保存结果</span></span><br><span class="line"><span class="comment">-- 允许个数不匹配，lua会自动使用 nil 补充或取有效位数</span></span><br><span class="line">temp1, temp2, temp3 = GetA(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(temp1, temp2, temp3)</span><br></pre></td></tr></table></figure>

<p><strong>变长参数：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintText</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="built_in">arg</span> = &#123; ... &#125; <span class="comment">-- 表达式&#123; ... &#125;是一个包含所有参数的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 遍历参数表</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">arg</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">arg</span>[i])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(PrintText(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--打印：</span></span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<p>当函数只有一个参数且该参数是字符串常量或表构造器时，括号是可选的 (可读性不好)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="参数和返回值数量"><a href="#参数和返回值数量" class="headerlink" title="参数和返回值数量"></a>参数和返回值数量</h3><p><strong>调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致</strong>。Lua 语言会通过抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数</p>
<p><strong>Lua 语言根据函数的被调用情况调整返回值的数量</strong>。</p>
<ul>
<li><p>当函数被作为一条单独语句调用时，其所有返回值都会被丢弃；</p>
</li>
<li><p>当函数被作为表达式（例如，加法的操作数）调用时，将只保留函数的第一个返回值。</p>
</li>
<li><p><strong>只有当函数调用是一系列表达式中的最后一个表达式（或是唯一一个表达式）时，其所有的返回值才能被获取到。否则只返回一个结果</strong></p>
<ul>
<li><strong>什么叫一系列表达式中的最后一个表达式？</strong> 例子如下：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--函数调用</span></span><br><span class="line">x, y, z = func(), <span class="number">2</span>; <span class="comment">-- 此时func()不是最后一个表达式，</span></span><br><span class="line">x, y, z = <span class="number">1</span>, func();  <span class="comment">-- 此时func()就是以后一个表达式</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将函数调用用一对圆括号括起来可以强制其只返回一个结果</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((func()))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="变长参数的遍历"><a href="#变长参数的遍历" class="headerlink" title="变长参数的遍历"></a>变长参数的遍历</h3><p>要遍历可变长参数，函数可以使用表达式 <code>&#123;...&#125;</code> 将可变长参数放在一个表中，就像上文示例中所做的那样。<br>不过，在某些罕见的情况下，如果可变长参数中包含无效的 <code>nil</code>，那么 <code>&#123;...&#125;</code> 获得的表可能不再是一个有效的序列。此时，就没有办法在表中判断原始参数究竟是不是以 <code>nil</code> 结尾的。<br>此时也不能用 <code>#</code> 获取长度，不准确（当序列中存在 nil 值时）???？</p>
<p>对于这种情况，Lua 语言提供了函数 <code>table.pack</code>。该函数像表达式 <code>&#123;...&#125;</code> 一样保存所有的参数，然后将其放在一个表中返回，但是<strong>这个表还有一个保存了参数个数的额外字段 <code>n</code><strong>。例如，</strong>下面的函数使用了函数 <code>table.pack</code> 来检测参数中是否有 <code>nil</code>：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonils</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">arg</span> = <span class="built_in">table</span>.pack(...)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">arg</span>.n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">arg</span>[i] = <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(nonils(<span class="number">2</span>,<span class="number">3</span>,<span class="literal">nil</span>)) <span class="comment">--返回nil</span></span><br></pre></td></tr></table></figure>

<p>另一种遍历函数的可变长参数的方法是使用函数 <code>select</code>。函数 select 总是具有一个固定的参数 <code>selector</code> ，以及数量可变的参数。</p>
<ul>
<li>如果 selector 是数值 n，那么函数 select 则返回第 n 个参数后的所有参数；</li>
<li>否则，selector 应该是字符串”#”，以便函数 select 返回额外参数的总数。</li>
</ul>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054124.png" alt="Pasted image 20240702000024"><br>通常，我们在需要把返回值个数调整为 1 的地方使用函数 select，因此可以把 select（n,…）认为是返回第 n 个额外参数的表达式。</p>
<h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintText</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="comment">-- 定义嵌套函数</span></span><br><span class="line">    SubFunc = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调用嵌套函数</span></span><br><span class="line">    SubFunc()</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 也可以作为返回值返回</span></span><br><span class="line">    <span class="comment">-- return SubFunc</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">PrintText(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者这样写更简洁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintText</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">NewFunc = PrintText(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">NewFunc()</span><br></pre></td></tr></table></figure>

<p>再次强调，在 lua 中 function 只是一种变量类型，所以我们可以将它作为返回值并保存到新变量中。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>![[Lua精粹#^awkby7]]</p>
<p>当编写一个被其他函数 B 包含的函数 A 时，被包含的函数 A 可以访问包含其的函数 B 的所有局部变量，我们将这种特性称为词法定界（ <em>lexical scoping</em> ）</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="comment">--对该匿名函数来说，count既不是全局变量也不是局部变量，而是[非局部变量]，因历史原因又被称为[上值]</span></span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment">--2</span></span><br><span class="line"></span><br><span class="line">c2 = newCounter() <span class="comment">--新的闭包,c1,c2各自拥有局部变量count的独立实例</span></span><br><span class="line"><span class="built_in">print</span>(c2()) <span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(c1()) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(c2()) <span class="comment">-- 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，匿名函数访问了一个非局部变量（count）并将其当作计数器。然而，由于创建变量的函数（newCounter）己经返回，因此当我们调用匿名函数时，变量 count 似乎已经超出了作用范围。<br>但其实不然，由于闭包（<em>closure</em> ）概念的存在，Lua 语言能够正确地应对这种情况。简单地说，<strong>一个闭包就是一个函数外加能够使该函数正确访问非局部变量所需的其他机制</strong>。如果我们再次调用 newCounter，那么一个新的局部变量 count 和一个新的闭包会被创建出来。</p>
<blockquote>
<p>[!summary]<br>从技术上讲，Lua 语言中只有闭包而没有函数。函数本身只是闭包的一种原型。不过尽管如此，只要不会引起混淆，我们就仍将使用术语“函数”来指代闭包。</p>
</blockquote>
<h2 id="和-self"><a href="#和-self" class="headerlink" title=": 和 self"></a><code>:</code> 和 <code>self</code></h2><p>self 类似于 this 指针，大多数面向对象语言都隐藏了这个机制，在编码时不需要显示的声明这个参数，就可以在方法内使用 this（例如 C++和 C#）。<strong>在 lua 中，提供了冒号操作符 <code>:</code> 来隐藏这个参数</strong>。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t:Add</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">self</span>.a + <span class="built_in">self</span>.b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t:Add())</span><br></pre></td></tr></table></figure>

<p>冒号操作符是 Lua 提供的面向对象风格的调用，形如 <code>o:foo()</code> 的表达式意为调用对象 o 的 foo 方法。</p>
<p><strong>冒号的作用有两个</strong>：</p>
<ol>
<li>对于方法定义来说，会增加一个额外的隐藏形参（self）；</li>
<li>对于方法调用来说，会增加一个额外的实参（表自身作为第一个实参）</li>
</ol>
<p>冒号只是一种语法机制，提供的是便利性，并没有引入任何新的东西。使<strong>用冒号完成的事情，都可以使用点语法来完成</strong>。看下面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t:Add</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">self</span>.a + <span class="built_in">self</span>.b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t.Add</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">self</span>.a + <span class="built_in">self</span>.b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- self不是必要的，使用其他符号也可以:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t.Add</span><span class="params">(T)</span></span></span><br><span class="line">    <span class="keyword">return</span> (T.a + T.b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价访问方法</span></span><br><span class="line"><span class="built_in">print</span>(t.Add(t))  <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(t:Add())  <span class="comment">-- -1</span></span><br></pre></td></tr></table></figure>

<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">    x = x+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> g(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当一个函数的最后一个动作是调用<strong>另一个函数</strong>而<strong>没有再进行其他工作时</strong>，就形成了尾调用。<br>当函数 f 调用完函数 g 之后，f 不再需要进行其他的工作。这样，当被调用的函数执行结束后，程序就不再需要返回最初的调用者。因此，在尾调用之后，程序也就不需要在调用栈中保存有关调用函数的任何信息。当 g 返回时，程序的执行路径会直接返回到调用 f 的位置。由于尾调用不会使用栈空间，所以一个程序中能够嵌套的尾调用的数量是无限的</p>
<p>注意，尾调用要求没有进行其他工作</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> g(x)+<span class="number">1</span>  <span class="comment">--调用后又进行了加法，所以不是尾调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x[i].foo(x[j]+a*b, i+j) <span class="comment">--是尾调用，形如return func（ args）的尾调用，其中func和args都可以是复杂的表达式。</span></span><br></pre></td></tr></table></figure>

<h1 id="六、模块和包"><a href="#六、模块和包" class="headerlink" title="六、模块和包"></a>六、模块和包</h1><blockquote>
<p>[!NOTE]<br>包（Package）是包（module）的集合</p>
</blockquote>
<h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>一个模块（ module ）就是一些代码（ Lua 或 C ），这些代码可以通过函数 <code>require</code> 加载，然后创建和返回一个 <code>table</code>。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。</p>
<p><strong>使用表来实现模块的显著优点之一是，让我们可以像操作普通表那样操作模块，并且能利用Lua语言的所有功能实现额外的功能。</strong></p>
<p>例如，所有的标准库都是模块。我们可以按照如下的方法使用数学库：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">sin</span>(<span class="number">3.14</span>))  <span class="comment">--等价print(math.sin(3.14))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--可以为个别函数提供不同名称</span></span><br><span class="line"><span class="keyword">local</span> ADD = m.add</span><br><span class="line">ADD()</span><br><span class="line"></span><br><span class="line"><span class="comment">--还可以只引入特定的函数</span></span><br><span class="line"><span class="keyword">local</span> SUB = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span>.<span class="built_in">sub</span></span><br><span class="line">SUB()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>独立解释器会使用跟如下代码等价的方式提前加载所有标准库，这种提前加载使得我们可以不用费劲地编写代码来加载模块 math 就可以直接使用函数 math.sin。 </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span> = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">string</span> = <span class="built_in">require</span> <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure>


<ol>
<li>require 函数，载入同样的 lua 文件时，只有第一次的时候会去执行，后面的相同的都不执行了。  </li>
<li>如果你要让每一次文件都会执行的话，你可以使用 <code>dofile(&quot;name&quot;)</code> 函数  </li>
<li>如果你要玩载入后不执行，等你需要的时候执行时，你可以使用 loadfile()函数，如下所示：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> hello = <span class="built_in">loadfile</span>(<span class="string">&quot;A&quot;</span>) <span class="comment">--脚本A不会立即执行</span></span><br><span class="line">hello() <span class="comment">-- 调用时，脚本A才执行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>多脚本交互示例：</p>
<figure class="highlight c++"><figcaption><span>title:A.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Var1 = <span class="number">123</span>;</span><br><span class="line">local Var2 = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;脚本A执行&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><figcaption><span>title:B.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ARef = <span class="built_in">require</span>(<span class="string">&quot;A&quot;</span>) <span class="comment">-- 执行脚本A</span></span><br><span class="line"><span class="built_in">print</span>(ARef)</span><br><span class="line"><span class="built_in">print</span>(Var1)</span><br><span class="line"><span class="built_in">print</span>(Var2)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;A&quot;</span>) <span class="comment">-- 已经加载过脚本A, 不会再次执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- require方法首先执行脚本A,如果引用成功则返回true</span></span><br><span class="line"><span class="comment">-- 脚本B可以访问脚本A声明的全局变量，不能访问local变量</span></span><br><span class="line">脚本A执行</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>特别的，我们可以在脚本 A 末尾执行 return 语句，这样 require(“A”)获取返回值。</p>
<figure class="highlight lua"><figcaption><span>title:A.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;脚本A执行&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> a = <span class="number">789</span>  </span><br><span class="line"><span class="keyword">return</span> a </span><br><span class="line"><span class="comment">-- 注意这里我们返回的是局部变量，通过return，我们就可以在脚本B访问脚本A的局部变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><figcaption><span>title:B.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ARef = <span class="built_in">require</span>(<span class="string">&quot;A&quot;</span>) <span class="comment">-- 执行脚本A</span></span><br><span class="line"><span class="built_in">print</span>(ARef) <span class="comment">--打印require返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">脚本A执行</span><br><span class="line"><span class="number">789</span></span><br></pre></td></tr></table></figure>

<p>如果不在同一文件夹之下的脚本，则需要指明文件夹名称，例如脚本 A 要访问 Layer 文件夹下的脚本 C，则脚本名填写成<code>&quot;Layer. C&quot;</code><br><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054125.png" alt="Pasted image 20240117194652"></p>
<h2 id="package-loaded"><a href="#package-loaded" class="headerlink" title="package. loaded"></a>package. loaded</h2><ul>
<li><strong><code>package.loaded</code> 是一个全局 table，用于追踪已经加载的模块</strong>。每当使用 <code>require</code> 加载一个模块时，该模块的信息会被存储在 <code>package.loaded</code> 表格中，以便在后续的 <code>require</code> 调用中避免重复加载相同的模块。</li>
</ul>
<p><strong>加载过程：</strong><br>首先，函数 <code>require</code> 在表 <code>package.loaded</code> 中检査模块是否已被加载。如果模块已经被加载，函数require就返回相应的值。因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。 </p>
<p>如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定）。如果函数require找到了相应的文件，<code>那么就用函数loadfile</code> 将其进行加载，结果是一个我们称之为加载器（ <em>loader</em> ）的函数（加载器就是一个被调用时加载模块的函数）</p>
<p>如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。 （在这种情况下，搜索路径由变量<code> package.cpath</code>指定）如果找到了一个C标准库，则使用底层函数<code>package.loadlib</code>进行加载，这个底层函数会查找名为<code>luaopen_ modname</code> 的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数<code>luaopen_ _modname_</code> 。</p>
<p>不管模块是在Lua文件还是C标准库中找到的，函数require此时都具有了用于加载它的加载函数。为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在文件的名称（大多数模块会忽略这两个参数）。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载同一模块时返回相同的值。如果加载函数没有返回值且表中的<code>package.loaded[@rep&#123;modname&#125;]</code>为空，函数require就假设模块的返回值是 true 。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。</p>
<p>要强制函数require加载同一模块两次，可以先将模块从 <code>package.loaded</code> 中删除（令其为 nil）：下一次再加载这个模块时，函数 <code>require</code> 就会重新加载模块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package.loaded.modname = nil</span><br></pre></td></tr></table></figure>

<h2 id="编写模块的基本方法"><a href="#编写模块的基本方法" class="headerlink" title="编写模块的基本方法"></a>编写模块的基本方法</h2><p><strong>在Lua语言中创建模块的最简单方法是，创建一个表并将所有需要导出的函数放入其中</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125; <span class="comment">--模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个新的复数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r, i)</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;r=r, i=i&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">M.new = new <span class="comment">-- 把new函数加到模块中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接写函数</span></span><br><span class="line">M.i = new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.add</span><span class="params">(c1, c2)</span></span></span><br><span class="line">    <span class="keyword">return</span> new(c1.r + c2.r, c1.i - c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M <span class="comment">--返回</span></span><br></pre></td></tr></table></figure>
<p>有些人不喜欢最后的返回语句。一种将其省略的方式是直接把模块对应的表放到package.loaded中：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125; <span class="comment">--模块</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[...] = M  <span class="comment">--不再需要返回语句</span></span><br></pre></td></tr></table></figure>
<p>在模块的最后加上return语句更清晰。如果我们忘了return语句，那么在测试模块的时候很容易就会发现问题。</p>
<p><strong>另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125; <span class="comment">--模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = new(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1, c2)</span></span></span><br><span class="line">    <span class="keyword">return</span> new(c1.r + c2.r, c1.i - c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;new = new, i=i, add=add&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的优点在于，无须在每一个标识符前增加前缀M.或类似的东西。通过显式的导出表，我们能够以与在模块中相同的方式定义和使用导出和内部函数。这种方式的缺点在于，导出表位于模块最后而不是最前面（把前面的话当作简略文档的话更有用），而且由于必须把每个名字都写两遍，所以导出表有点冗余（这一缺点其实可能会变成优点，因为这允许函数在模块内和模块外具有不同的名称，不过程序很少会用到）。</p>
<h2 id="子模块和包"><a href="#子模块和包" class="headerlink" title="子模块和包"></a>子模块和包</h2><p>Lua支持具有层次结构的模块名，通过点来分隔名称中的层次。例如，一个名为mod.sub的模块是模块mod的一个子模块（ <em>submodule</em> ）。一个包（ <em>package</em> ）是一棵由模块组成的完整的树，它是Lua语言中用于发行程序的单位。</p>
<p>当加载一个名为mod.sub的模块时，函数require依次使用原始的模块名”mod.sub”作为键来查询表package.loaded和表package.preload。这里，模块名中的点像模块名中的其他字符一样，没有特殊含义。</p>
<p>然而，当搜索一个定义子模块的文件时，函数require会将点转换为另一个字符，通常就是操作系统的目录分隔符（例如，POSIX操作系统的斜杠或Windows操作系统的反斜杠）。转换之后，函数require会像搜索其他名称一样搜索这个名称。</p>
<p>这种行为使得一个包中的所有模块能够放到一个目录中。例如，一个具有模块p、p.a和p.b的包对应的文件可以分别是p&#x2F;init.lua、p&#x2F;a.lua和p&#x2F;b.lua，目录p又位于其他合适的目录中。</p>
<h1 id="七、面向对象"><a href="#七、面向对象" class="headerlink" title="七、面向对象"></a>七、面向对象</h1><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054126.png" alt="Pasted image 20240116225101"><br>lua 没有面向对象和类的概念，需要我们自己来模拟。类本质上还是 <code>table</code>，我们是用 <code>table</code> 来模拟一个类。</p>
<blockquote>
<p>[!quote]<br>我们可以参考基于原型的语言（prototype-based language）中的一些做法来在Lua语言中模拟类，例如Self语言（JavaScript采用的也是这种方式）。在这些语言中，对象不属于类。相反，每个对象可以有一个原型（prototype）。<strong>原型也是一种普通的对象，当对象（类的实例）遇到一个未知操作时会首先在原型中查找。要在这种语言中表示一个类，我们只需要创建一个专门被用作其他对象（类的实例）的原型对象即可</strong>。类和原型都是一种组织多个对象间共享行为的方式。</p>
</blockquote>
<p>在 Lua 中，如果 有两个对象A和B，要让B成为A的一个原型，只需要：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(A, &#123;<span class="built_in">__index</span> = B&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="类的成员和调用方法"><a href="#类的成员和调用方法" class="headerlink" title="类的成员和调用方法"></a>类的成员和调用方法</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类名</span></span><br><span class="line">Student =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">-- 成员变量</span></span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    sex = <span class="string">&quot;men&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 成员函数</span></span><br><span class="line">    Learn = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;learning&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在外部声明变量和函数</span></span><br><span class="line">Student.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line"></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;speaking&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Run</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问成员变量和函数</span></span><br><span class="line"><span class="comment">-- Lua中类的实现类似于static变量和static函数</span></span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line">Student.Learn()</span><br><span class="line">Student.Run()</span><br></pre></td></tr></table></figure>

<h4 id="类成员之间的访问"><a href="#类成员之间的访问" class="headerlink" title="类成员之间的访问"></a>类成员之间的访问</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类名</span></span><br><span class="line">Student =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">-- 成员变量</span></span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    sex = <span class="string">&quot;男&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 成员函数</span></span><br><span class="line">    GetAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- 由于本质上是table，不同元素之间是不能访问的，所以该age和类中的成员变量age不是同一个。打印返回nil</span></span><br><span class="line">        <span class="comment">-- print(age)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 正确写法一: 指定类名</span></span><br><span class="line">        <span class="built_in">print</span>(Student.age)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 正确写法二：传入类名</span></span><br><span class="line">    GetSex = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="built_in">print</span>(t.sex)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student.GetAge()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价写法</span></span><br><span class="line">Student.GetSex(Student)</span><br><span class="line">Student:GetSex() <span class="comment">-- 冒号调用，会自动传入类名</span></span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 元类</span></span><br><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基类方法 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(o, side)</span></span></span><br><span class="line">  o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">  <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">  side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">  <span class="built_in">self</span>.area = side*side;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;面积为 &quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">myshape:printArea() <span class="comment">-- 100</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Meta class</span></span><br><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">-- 基类方法 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(o,side)</span></span></span><br><span class="line">  o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">  <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">  side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">  <span class="built_in">self</span>.area = side*side;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;面积为 &quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line">myshape:printArea()  <span class="comment">--100</span></span><br><span class="line"></span><br><span class="line">Square = Shape:new()</span><br><span class="line"><span class="comment">-- 派生类方法 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:new</span> <span class="params">(o,side)</span></span></span><br><span class="line">  o = o <span class="keyword">or</span> Shape:new(o,side)</span><br><span class="line">  <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 派生类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:printArea</span> <span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正方形面积为 &quot;</span>,<span class="built_in">self</span>.area) <span class="comment">--100</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line">mysquare = Square:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line">mysquare:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:new()</span><br><span class="line"><span class="comment">-- 派生类方法 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:new</span> <span class="params">(o,length,breadth)</span></span></span><br><span class="line">  o = o <span class="keyword">or</span> Shape:new(o)</span><br><span class="line">  <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">  <span class="built_in">self</span>.area = length * breadth</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 派生类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:printArea</span> <span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;矩形面积为 &quot;</span>,<span class="built_in">self</span>.area) <span class="comment">--200</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line">myrectangle = Rectangle:new(<span class="literal">nil</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">myrectangle:printArea()</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p> 21.3</p>
<h3 id="私有性"><a href="#私有性" class="headerlink" title="私有性"></a>私有性</h3><p>Lua 本身不提供访问修饰符，可以模拟实现，了解即可<br>21.4<br>21.5<br>21.6</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 派生类方法 printArea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:printArea</span> <span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正方形面积 &quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="八、环境"><a href="#八、环境" class="headerlink" title="八、环境"></a>八、环境</h1><p>在 Lua 语言中，全局变量并不一定是真正全局的，实际上 Lua 并不存在全局变量。而是模拟了全局变量。</p>
<h2 id="G"><a href="#G" class="headerlink" title="_G"></a><code>_G</code></h2><p>Lua 语言把<strong>所有的全局变量</strong>保存<strong>全局环境表</strong>中。</p>
<p><strong>为了方便对全局环境表的操作，Lua 语言将全局环境表保存在全局变量 <code>_G</code> 中（因此，<code>_G._G</code> 与 <code>_G</code> 等价）</strong>。通过 <code>_G.XXX</code> 或 <code>_G[varname]</code>，你可以访问程序中的所有全局变量，而不需要直接引用它们的名称。</p>
<h2 id="非全局环境-ENV"><a href="#非全局环境-ENV" class="headerlink" title="非全局环境  _ENV"></a>非全局环境  <code>_ENV</code></h2><p>一个<strong>自由名称</strong>（ <em>free name</em> ）是指没有关联到显式声明上的名称，即它不出现在对应<strong>局部变量</strong>的范围内。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span> <span class="comment">-- z不是自由名称</span></span><br><span class="line">x = y + z  <span class="comment">-- x,y是自由名称</span></span><br></pre></td></tr></table></figure>

<p>**Lua语言编译器将代码段中的所有自由名称 <code>x</code> 转换为 <code>_ENV.x</code>**。因此，此前的代码段完全等价于：  </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line"><span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y +z</span><br></pre></td></tr></table></figure>

<p>Lua语言把所有的代码段都当作匿名函数。所以，Lua语言编译器实际上将原来的代码段编译为如下形式：也就是说，Lua语言是在一个名为 <code>_ENV</code> 的预定义上值（非局部变量，upvalue）存在的情况下编译所有的代码段的。<br><strong>因此，所有的变量要么是绑定到了一个名称的局部变量，要么是 <code>_ENV</code> 中的一个字段，而 <code>_ENV</code> 本身是一个非局部变量（一个上值）。</strong>   </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = 某些值</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">    <span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>_ENV</code> 的初始值是任意的表，任何一个这样的表都被称为一个<strong>环境</strong>。</li>
<li>通常，当加载一个代码段时，**使用全局环境表初始化代码段的第一个上值 <code>_ENV</code>**。因此，原始的代码段等价于：<blockquote>
<p>由于_ENV只是一个普通的变量，因此可以对其赋值或像访问其他变量一样访问它。赋值语句_ENV&#x3D;nil 会使得后续代码不能直接访问全局变量</p>
</blockquote>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = 全局环境表</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> z = <span class="number">10</span></span><br><span class="line">    <span class="built_in">_ENV</span>.x = <span class="built_in">_ENV</span>.y + z</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>总结： Lua 语言中处理全局变量的方式</strong></p>
<ul>
<li>编译器在编译所有代码段前，在外层创建局部变量_ENV；</li>
<li>编译器将所有自由名称 var 变换为_ENV. var；</li>
<li>函数 load（或函数 loadfile）使用<strong>全局环境表</strong>初始化代码段的第一个上值（即将被代码段的上值 <code>_ENV</code> 初始化为全局环境）</li>
</ul>
<p><strong>作用：</strong><br><code>_ENV</code> 的主要用途是用来改变代码段使用的环境。一旦改变了环境，所有的全局访问就都将使用新表。</p>
<blockquote>
<p>[!NOTE] _G 和_ENV 的关系<br><strong>通常，<code>_G</code> 和 <code>_ENV</code> 指向的是同一个表（即全局环境表）</strong>。但是，尽管如此，它们是很不一样的实体。<code>_ENV</code> 是一个局部变量，所有对“全局变量”的访问实际上访问的都是 <code>_ENV</code>。<code>_G</code> 则是一个在任何情况下都没有任何特殊状态的全局变量。按照定义，<code>_ENV</code> 永远指向的是当前的环境；而假设在可见且无人改变过其值的前提下，<code>_G</code> 通常指向的是全局环境。    </p>
</blockquote>
<h1 id="九、垃圾回收"><a href="#九、垃圾回收" class="headerlink" title="九、垃圾回收"></a>九、垃圾回收</h1><p>垃圾回收（Garbage Collection， GC）</p>
<p>Lua 使用自动内存管理，但有时需要手动控制垃圾回收器。</p>
<p>弱引用表（weak table）、析构器（finalizer）和函数 <code>collectgarbage</code> 是在Lua语言中用来辅助垃圾回收器的主要机制。</p>
<ul>
<li><p>弱引用表允许收集Lua语言中还可以被程序访问的对象；</p>
</li>
<li><p>析构器允许收集不在垃圾回收器直接控制下的外部对象；</p>
</li>
<li><p>函数 <code>collectgarbage</code> 则允许我们控制垃圾回收器的步长。</p>
</li>
<li><p>lua 中想让变量被GC，只需要令其等于 <code>nil</code> 即可</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 垃圾回收通用接口</span></span><br><span class="line"><span class="built_in">collectgarbage</span>(opt)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054127.png" alt="Pasted image 20240118195514"></p>
<h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>一旦一个对象成为了数组的一部分，它就再也无法被回收了！虽然已经没有其他任何地方在引用它，但数组依然在引用它。除非我们告诉Lua语言数组对该对象的引用不应该阻碍对此对象的回收，否则是无法 GC 的。</p>
<p><strong>弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的机制。</strong> 所谓弱引用（ <em>weak reference</em> ）是一种不在垃圾回收器考虑范围内的对象引用。如果对一个对象的所有引用都是弱引用，那么垃圾回收器将会回收这个对象并删除这些弱引用。<br><strong>Lua通过【弱引用表】实现弱引用</strong>，弱引用表就是元素均为弱引用的表，这意味着<strong>如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。</strong></p>
<h2 id="瞬表"><a href="#瞬表" class="headerlink" title="瞬表"></a>瞬表</h2><p><strong>一种棘手的情况是，一个具有弱引用键的表中的值又引用了对应的键</strong>。虽然表中的键是弱引用的，但是表中的值却不是弱引用的。因而对于每一个键来说都存在一个强引用。因此，即使有弱引用的键，这些对象也不会被回收。</p>
<p>Lua语言通过瞬表解决上述问题，在Lua语言中，一个具有弱引用键和强引用值的表是一个瞬表。</p>
<p>在一个瞬表中，一个键的可访问性控制着对应值的可访问性。更确切地说，考虑瞬表中的一个元素 <code>(k,v)</code>，指向的 <em>v</em> 的引用只有当存在某些指向 <em>k</em> 的其他外部引用存在时才是强引用，否则，即使 <em>v</em> （直接或间接地）引用了 <em>k</em> ，垃圾回收器最终会收集 <em>k</em> 并把元素从表中移除。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>一直到Lua 5.0，Lua语言使用的都是一个简单的<strong>标记-清除式</strong>垃圾回收器（Garbage Collector，GC）。这种收集器又被称为“stop-the-world（全局暂停）”式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾回收周期（garbagecollection cycle）。</p>
<p>每一个垃圾回收周期由四个阶段组成：标记、清理、清除和析构。</p>
<ul>
<li><strong>标记阶段</strong>：把根结点集合（ <em>root set</em> ）标记为活跃。保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（当然，在弱引用表中的元素不遵循这个规则）。当所有可达对象都被标记为活跃后，标记阶段完成。<blockquote>
<p>根结点集合由 Lua 语言可以直接访问的对象组成。在 Lua 语言中，这个集合只包括 C 注册表（主线程和全局环境都是在这个注册表中预定义的元素）</p>
</blockquote>
</li>
<li><strong>清理阶段</strong>：在这个阶段中处理析构器和弱引用表。首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有被标记为活跃状态的对象会被标记为活跃（复苏机制），并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。</li>
<li><strong>清除阶段</strong>：遍历所有对象（为了实现这种遍历，Lua语言把所有创建的对象放在一个链表中）。如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。</li>
<li><strong>析构阶段</strong>：Lua 调用清理阶段被分离出的对象的析构器。</li>
</ul>
<p>Lua 5.1使用了<strong>增量式垃圾回收器</strong>。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是<strong>不需要在垃圾收集期间停止主程序的运行。相反，它与解释器一起交替运行</strong>。每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步。</p>
<p>Lua 5.2引入了<strong>紧急垃圾收集</strong>。当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。</p>
<h1 id="十、反射"><a href="#十、反射" class="headerlink" title="十、反射"></a>十、反射</h1><p><strong>反射是程序用来检查和修改其自身某些部分的能力。</strong></p>
<p><strong>Lua这样的动态语言支持几种反射机制：</strong></p>
<ul>
<li>环境允许运行时观察全局变量；</li>
<li>诸如type和pairs这样的函数允许运行时检查和遍历未知数据结构；</li>
<li>诸如load和require这样的函数允许程序在自身中追加代码或更新代码。</li>
<li>不过，还有很多方面仍然是缺失的：程序不能检查局部变量，开发人员不能跟踪代码的执行，函数也不知道是被谁调用的，等等。<strong>调试库（debug library）</strong> 填补了上述的缺失。</li>
</ul>
<p><strong>调试库由两类函数组成：自省函数（ <em>introspective function</em> ）和钩子（ <em>hook</em> ）。</strong> </p>
<ul>
<li>自省函数允许我们检查一个正在运行中的程序的几个方面，例如活动函数的栈、当前正在执行的代码行、局部变量的名称和值。</li>
<li>钩子则允许我们跟踪一个程序的执行。<ul>
<li>调试库中的钩子机制允许用户注册一个钩子函数，这个钩子函数会在程序运行中某个特定事件发生时被调用。有四种事件能够触发一个钩子：<ul>
<li>每当调用一个函数时产生的 <em>call</em> 事件；</li>
<li>每当函数返回时产生的 <em>return</em> 事件；</li>
<li>每当开始执行一行新代码时产生的 <em>line</em> 事件；</li>
<li>执行完指定数量的指令后产生的 <em>count</em> 事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>虽然名字里带有“调试”的字眼，但调试库提供的并不是Lua语言的调试器（debugger）。不过，调试库提供了编写我们自己的调试器所需要的不同层次的所有底层机制。</p>
<p>调试库与其他库不同，必须被慎重地使用。首先，调试库中的某些功能的性能不高。其次，调试库会打破语言的一些固有规则，例如不能从一个局部变量的词法定界范围外访问这个局部变量。虽然调试库作为标准库直接可用，但笔者建议在使用调试库的代码段中显式地加载调试库。</p>
<h1 id="十一、Lua-与-C-的交互机制"><a href="#十一、Lua-与-C-的交互机制" class="headerlink" title="十一、Lua 与 C++的交互机制"></a>十一、Lua 与 C++的交互机制</h1><p>补：27 C 语言 KPI 总览</p>
<h2 id="Lua-虚拟栈"><a href="#Lua-虚拟栈" class="headerlink" title="Lua 虚拟栈"></a>Lua 虚拟栈</h2><p>Lua 和 C&#x2F;C++ 的交互机制的基础在于 Lua 提供了一个<strong>虚拟栈</strong>，C++ 和 Lua 之间的所有类型的数据交换都通过这个栈完成。</p>
<ul>
<li>无论何时 C++ 想从 Lua 中调用一个值，被请求的值将会被压入栈，</li>
<li>无论何时 C++ 想要传递一个值给 Lua，首先将整个值压栈，然后就可以在 Lua 中调用。</li>
</ul>
<p>Lua 中，对虚拟栈提供<strong>正向索引</strong>和<strong>反向索引</strong>两种索引方式，区别是：</p>
<ul>
<li>正数索引 1 永远表示栈底，</li>
<li>负数索引 - 1 永远表示栈顶。</li>
</ul>
<p>假设当前 Lua 的栈中有 5 个元素，如下图所示： </p>
<p><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202408080054120.png"><br>栈上的的每个元素都是一个 Lua 值 （nil，number，string等等）.</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>入栈的数据都由  <code>TValue</code> 这种数据类型来维护。<code>TValue</code> 对应于lua中的所有数据类型, 是一个 <code>&#123;值, 类型&#125;</code> 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*lobject.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefields Value value_; int tt_   <span class="comment">//value是指，tt是类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>

<p><strong>value 数据结构</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*lobject.h*/</span></span><br><span class="line"><span class="comment">/* ** Union of all Lua values */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">Value</span> </span><br><span class="line">&#123;</span><br><span class="line">    GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">    <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">    <span class="type">int</span> b;           <span class="comment">/* booleans */</span></span><br><span class="line">    lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">    lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">    lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br></pre></td></tr></table></figure>
<ul>
<li>gc 存其他诸如table, thread, closure, string需要内存管理垃圾回收的类型。</li>
<li>b 存布尔值</li>
<li>lua的number是分别由i存整型和n存double</li>
<li>light userdata类型代表了一个 C 指针</li>
<li>light C functions的存储</li>
</ul>
<p><strong>tt 可选值：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*lua.h*/</span></span><br><span class="line"><span class="comment">/* ** basic types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE (-1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL 0  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN 1  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA 2  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER 3  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING 4  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE 5  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION 6  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA 7  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD 8  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTAGS 9</span></span><br></pre></td></tr></table></figure>
<h2 id="堆栈的操作"><a href="#堆栈的操作" class="headerlink" title="堆栈的操作"></a>堆栈的操作</h2><p>因为 lua 与 c&#x2F;c++ 是通过栈来通信，lua 提供了 <code>C API</code> 对栈进行操作。</p>
<p>我们先来看一个最简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span>  <span class="comment">//需要配置ide环境，否则报错</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span> </span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span> </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.创建一个state </span></span><br><span class="line">	<span class="comment">// luaL_newstate返回一个指向堆栈的指针</span></span><br><span class="line">	lua_State *L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2.入栈操作 </span></span><br><span class="line">	<span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;I am so cool~&quot;</span>);</span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//3.取值操作 </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">lua_isstring</span>(L, <span class="number">1</span>)) &#123;             <span class="comment">//判断是否可以转为string </span></span><br><span class="line">		cout &lt;&lt; <span class="built_in">lua_tostring</span>(L, <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//转为string并返回 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">lua_isnumber</span>(L, <span class="number">2</span>)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">lua_tonumber</span>(L, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//4.关闭state </span></span><br><span class="line">	<span class="built_in">lua_close</span>(L);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行这个例子之前，我们需要引入 Lua.lib 静态库，也就是上文中 extern “C” 中执行的 include。</p>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>[[1 C++ Primer#extern “C”]]<br>主要作用就是<strong>为了能够正确实现 C++ 代码调用 C 语言代码</strong>。</p>
<h3 id="引入-Lua-静态库"><a href="#引入-Lua-静态库" class="headerlink" title="引入 Lua 静态库"></a>引入 Lua 静态库</h3><ol>
<li>首先，新建一个 Visual C++ 的空项目，右键点击工程属性，选择 VC++ 目录，</li>
<li>把 **<em>lua 工程中的. h 头文件所在的目录</em><strong>加到</strong><em>包含目录</em>**中</li>
<li>把 _<strong>Lua 静态库文件所在的目录</strong>_加到**<em>库目录</em>**中，</li>
<li>最后，点击**<em>链接器 -&gt; 输入 -&gt; 附加依赖项</em>** -&gt; 加上生成的 Lua 静态库，比如 Lua. lib，记得用分号 “;” 与其他库隔开。</li>
<li>OK，大功告成！</li>
</ol>
<h2 id="C-调用-Lua"><a href="#C-调用-Lua" class="headerlink" title="C++ 调用 Lua"></a>C++ 调用 Lua</h2><p>C++ 可以获取 Lua 中的值，可以调用 Lua 函数，还可以修改 Lua 文件</p>
<ol>
<li>首先创建虚拟栈（虚拟机） <code>L</code></li>
<li>加载并运行 Lua 文件</li>
<li>调用 Lua <ul>
<li><strong>C++ 获取 Lua 值</strong>  <ul>
<li>使用 <code>lua_getglocal(L, &quot;varname&quot;)</code> 来获取值，然后将其入栈。由 lua 去寻找全局变量 str 的值，并将 str 的值返回栈顶（替换 str）</li>
<li>使用 <code>lua_toXXX</code> 将栈中元素取出转成相应的 C++ 类型的值  </li>
<li>如果 Lua 值为 table 类型的话，通过<code>lua_getfield</code> 和 <code>lua_setfield</code> 获取和修改表中元素的值</li>
</ul>
</li>
<li><strong>C++ 调用 Lua 函数</strong>  <ul>
<li>使用 <code>lua_getglobal</code> 来获取函数，然后将其压入栈；  </li>
<li>如果这个函数有参数的话，就需要依次将函数的参数也压入栈；  </li>
<li>这些准备工作都准备就绪以后，就调用 <code>lua_pcall</code> 开始调用函数了，调用完成以后，会将返回值压入栈中；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>新建一个简单的 lua 放到工程的同级目录下 <br>例如：hello.lua</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.创建Lua状态，返回一个指向堆栈的指针</span></span><br><span class="line">	lua_State *L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2.加载lua文件</span></span><br><span class="line">	<span class="type">int</span> bRet = <span class="built_in">luaL_loadfile</span>(L, <span class="string">&quot;hello.lua&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;load file error&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//3.运行lua文件</span></span><br><span class="line">	bRet = <span class="built_in">lua_pcall</span>(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pcall error&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//4.读取全局变量，</span></span><br><span class="line">	<span class="comment">// 1.把 str 压栈 2.由lua去寻找全局变量str的值，并将str的值返回栈顶（替换str）</span></span><br><span class="line">	<span class="comment">// 如果存在相同命名的其他变量、table或函数，就会报错（读取位置发生访问冲突）</span></span><br><span class="line">	<span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;str&quot;</span>);</span><br><span class="line">	<span class="comment">// -1取出栈顶元素，转化为string</span></span><br><span class="line">	string str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//5.读取table，把table压栈</span></span><br><span class="line">	<span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;tbl&quot;</span>);</span><br><span class="line">	<span class="comment">//-------------------------------</span></span><br><span class="line">	<span class="comment">// 1.把name压入栈中，2.由lua去寻找table中name键的值，并将键值返回栈顶（替换name）</span></span><br><span class="line">	<span class="comment">// 相当于lua_pushstring(L, &quot;name&quot;) + lua_gettable(L, -2)执行结果是一样的</span></span><br><span class="line">	<span class="built_in">lua_getfield</span>(L, <span class="number">-1</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">	<span class="comment">// 把name压入栈中</span></span><br><span class="line">	<span class="comment">//lua_pushstring(L, &quot;name&quot;);</span></span><br><span class="line">	<span class="comment">// 弹出栈上的name，并从表中找到name的键值，把结果放在栈上相同的位置</span></span><br><span class="line">	<span class="comment">//lua_gettable(L, -2);</span></span><br><span class="line">	<span class="comment">//---------------------------------</span></span><br><span class="line">	str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 因为table在栈顶的下面，所以取-2，把id压栈，由lua找到table中id键的值，并返回栈顶（替换id）</span></span><br><span class="line">	<span class="built_in">lua_getfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">	<span class="comment">// id的值已经在栈顶，取-1</span></span><br><span class="line">	<span class="type">int</span> id = <span class="built_in">lua_tonumber</span>(L, <span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;tbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;tbl:id = &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 读取函数，</span></span><br><span class="line">	<span class="comment">// 1.将函数add放入栈中，2.由lua去寻找函数add，并将函数add返回栈顶（替换add）。</span></span><br><span class="line">	<span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;add&quot;</span>);		<span class="comment">// 获取函数，压入栈中</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, <span class="number">10</span>);			<span class="comment">// 压入第一个参数</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);			<span class="comment">// 压入第二个参数</span></span><br><span class="line">	<span class="comment">// 栈过程：参数出栈-&gt;保存参数-&gt;参数出栈-&gt;保存参数-&gt;函数出栈-&gt;调用函数-&gt;返回结果入栈</span></span><br><span class="line">	<span class="comment">// 调用函数，调用完成以后，会将返回值压入栈中，2表示参数个数，1表示返回结果个数。</span></span><br><span class="line">	<span class="type">int</span> iRet = <span class="built_in">lua_pcall</span>(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (iRet)						</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 调用出错</span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *pErrorMsg = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">		cout &lt;&lt; pErrorMsg &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">lua_close</span>(L);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">lua_isnumber</span>(L, <span class="number">-1</span>))        <span class="comment">//取值输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> fValue = <span class="built_in">lua_tonumber</span>(L, <span class="number">-1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Result is &quot;</span> &lt;&lt; fValue &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 栈的索引方式可以是正数也可以是负数，区别是：1永远表示栈底元素，-1永远表示栈顶元素。</span></span><br><span class="line">	<span class="comment">//至此，栈中的情况是：</span></span><br><span class="line">	<span class="comment">//=================== 栈顶 =================== </span></span><br><span class="line">	<span class="comment">// 索引    类型      值</span></span><br><span class="line">	<span class="comment">// 5或-1   int       30 </span></span><br><span class="line">	<span class="comment">// 4或-2   int       20114442</span></span><br><span class="line">	<span class="comment">// 3或-3   string    shun </span></span><br><span class="line">	<span class="comment">// 2或-4   table	 tbl</span></span><br><span class="line">	<span class="comment">// 1或-5   string	 I am so cool~</span></span><br><span class="line">	<span class="comment">//=================== 栈底 =================== </span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;Master&quot;</span>);</span><br><span class="line">	<span class="comment">// 会将&quot;Master&quot;值出栈，保存值，找到到table的name键，如果键存在，存储到name键中</span></span><br><span class="line">	<span class="built_in">lua_setfield</span>(L, <span class="number">2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="built_in">lua_getfield</span>(L, <span class="number">2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">	str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;tbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建新的table</span></span><br><span class="line">	<span class="built_in">lua_newtable</span>(L);</span><br><span class="line">	<span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;A New Girlfriend&quot;</span>);</span><br><span class="line">	<span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="built_in">lua_getfield</span>(L, <span class="number">-1</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">	str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;newtbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//7.关闭state</span></span><br><span class="line">	<span class="comment">// 销毁指定 Lua 状态机中的所有对象， 并且释放状态机中使用的所有动态内存。</span></span><br><span class="line">	<span class="comment">// （如果有垃圾收集相关的元方法的话，会调用它们）</span></span><br><span class="line">	<span class="built_in">lua_close</span>(L);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们写一个 Lua1. cpp 来访问 lua 中的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;tbl&quot;</span>);</span><br><span class="line"><span class="built_in">lua_getfield</span>(L, <span class="number">-1</span>, <span class="string">&quot;name&quot;</span>);  </span><br></pre></td></tr></table></figure>

<p>代码中，已经有很详细的注释了，这里总结一下：</p>
<p><em><strong>1. 读取 lua 的全局变量：</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;add&quot;</span>);		<span class="comment">// 获取函数，压入栈中</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, <span class="number">10</span>);			<span class="comment">// 压入第一个参数</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);			<span class="comment">// 压入第二个参数</span></span><br><span class="line"><span class="comment">// 栈过程：参数出栈-&gt;保存参数-&gt;参数出栈-&gt;保存参数-&gt;函数出栈-&gt;调用函数-&gt;返回结果入栈</span></span><br><span class="line"><span class="comment">// 调用函数，调用完成以后，会将返回值压入栈中，2表示参数个数，1表示返回结果个数，</span></span><br><span class="line"><span class="comment">// iRet为0表示调用成功</span></span><br><span class="line"><span class="type">int</span> iRet = <span class="built_in">lua_pcall</span>(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>内部实现：<strong>1. 把全局变量 str 里的值压栈 2. 由 lua 去寻找全局变量 str 的值，并将 str 的值返回栈顶（替换 str）</strong><br>注意：<strong>如果存在相同命名的其他变量、table 或函数，就会报错（读取位置发生访问冲突）</strong>      
 </p>
<p><em><strong>2. 读取 table 中的键值：</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lua_getglobal 方法跟上面的实现是一样的。</p>
<p>lua_getfield 方法：</p>
<p>内部实现：<strong>1. 把 name 压入栈中，2. 由 lua 去寻找 table 中 name 键的值，如果键存在，将键值返回栈顶（替换 name）</strong></p>
<p>注意：<strong>这里的参数 - 1，就是表示把 table 中的键值返回到栈顶。</strong></p>
<p><em><strong>3. 调用 lua 中的函数：</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(lua_state *L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">lua_tonumber</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">lua_tonumber</span>(<span class="number">-2</span>);</span><br><span class="line">    <span class="type">int</span> sum = a+b;</span><br><span class="line">    <span class="comment">// 将返回值压入栈中</span></span><br><span class="line">    <span class="built_in">lua_pushnumber</span>(L,sum);</span><br><span class="line">    <span class="comment">// 返回返回值个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lua-调用-C"><a href="#Lua-调用-C" class="headerlink" title="Lua 调用 C++"></a>Lua 调用 C++</h2><p>Lua 可以调用由 C++ 定义、实现具体的函数   </p>
<p>步骤： </p>
<ol>
<li>将 C++ 的函数包装成 Lua 环境认可的 <code>Lua_CFunction</code> 格式</li>
<li>将包装好的函数注册到 Lua 环境中 </li>
<li>像使用普通 Lua 函数那样使用注册函数</li>
</ol>
<p><strong><em>包装 C++ 函数</em></strong></p>
<p>为了从 Lua 脚本中调用 C++ 函数，需要将被调用的 C++ 函数从普通的 C++ 函数包装成 Lua_CFunction 格式，并需要在函数中将返回值压入栈中，并返回返回值个数。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">avg, sum = average(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The average is &quot;</span>, avg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is &quot;</span>, sum)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age&quot;</span>, age)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(newTable) <span class="keyword">do</span> </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;k = &quot;</span>,k,<span class="string">&quot; v = &quot;</span>,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name&quot;</span>, newTable.name)</span><br></pre></td></tr></table></figure>

<p>例如有一个 C++ 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 得到参数个数 */</span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 循环求参数之和 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 求和 */</span></span><br><span class="line">		sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 压入平均值 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line">	<span class="comment">/* 压入和 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line">	<span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 初始化Lua */</span></span><br><span class="line">	<span class="comment">/* 指向Lua解释器的指针 */</span></span><br><span class="line">	lua_State* L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 载入Lua基本库 */</span></span><br><span class="line">	<span class="built_in">luaL_openlibs</span>(L);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注册函数 */</span></span><br><span class="line">	<span class="built_in">lua_register</span>(L, <span class="string">&quot;average&quot;</span>, average);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置lua中的全局变量</span></span><br><span class="line">	<span class="built_in">lua_pushinteger</span>(L, <span class="number">18</span>);   <span class="comment">//入栈</span></span><br><span class="line">	<span class="built_in">lua_setglobal</span>(L, <span class="string">&quot;age&quot;</span>);  <span class="comment">//1.先将18值出栈，保存值，2.在lua中，把值存储到全局变量age中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置lua中table</span></span><br><span class="line">	<span class="built_in">lua_newtable</span>(L); <span class="comment">//创建一张空表，并将其压栈</span></span><br><span class="line">	<span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;lili&quot;</span>);<span class="comment">// 入栈</span></span><br><span class="line">	<span class="comment">// 1.先将&quot;lili&quot;值出栈，保存值，2.找table的name键，如果键存在，存储到name键中</span></span><br><span class="line">	<span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;name&quot;</span>);<span class="comment">//栈顶是lili，新创建的table在lili下，所以是-2</span></span><br><span class="line">	<span class="comment">// 将table赋值到lua中，并弹出table</span></span><br><span class="line">	<span class="built_in">lua_setglobal</span>(L, <span class="string">&quot;newTable&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 运行脚本 */</span></span><br><span class="line">	<span class="built_in">luaL_dofile</span>(L, <span class="string">&quot;avg.lua&quot;</span>);</span><br><span class="line">	<span class="comment">/* 清除Lua */</span></span><br><span class="line">	<span class="built_in">lua_close</span>(L);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 暂停 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Press enter to exit…&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置lua中的全局变量</span></span><br><span class="line"><span class="built_in">lua_pushinteger</span>(L, <span class="number">18</span>);   <span class="comment">//入栈</span></span><br><span class="line"><span class="built_in">lua_setglobal</span>(L, <span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>新建一个简单的 lua 放到工程的同级目录下 <br>avg. lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设置lua中<span class="built_in">table</span></span><br><span class="line">lua_newtable(L); //创建一张空表，并将其压栈</span><br><span class="line">lua_pushstring(L, <span class="string">&quot;lili&quot;</span>);// 入栈</span><br><span class="line">// <span class="number">1.</span>先将<span class="string">&quot;lili&quot;</span>值出栈，保存值，<span class="number">2.</span>找<span class="built_in">table</span>的name键，如果键存在，存储到name键中</span><br><span class="line">lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;name&quot;</span>);//栈顶是lili，新创建的<span class="built_in">table</span>在lili下，所以是<span class="number">-2</span></span><br><span class="line">// 将<span class="built_in">table</span>赋值到lua中，并弹出<span class="built_in">table</span></span><br><span class="line">lua_setglobal(L, <span class="string">&quot;newTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个 Lua2. cpp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 得到参数个数 */</span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 循环求参数之和 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 求和 */</span></span><br><span class="line">		sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 压入平均值 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line">	<span class="comment">/* 压入和 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line">	<span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. 读取 C++ 的变量：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册函数 */</span></span><br><span class="line"><span class="built_in">lua_register</span>(L, <span class="string">&quot;average&quot;</span>, average);</span><br></pre></td></tr></table></figure>

<p>lua_setglobal (L, “age”) 内部实现： <strong>1. 先将值出栈，保存值，2. 在 lua 中，把值存储到全局变量 age 中</strong></p>
<p><strong>2. 调用在 C++ 中创建的新表的元素：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avg, sum = mylib.<span class="built_in">average</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The average is &quot;</span>, avg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is &quot;</span>, sum)</span><br></pre></td></tr></table></figure>

<p>lua_setglobal (L, “newTable”) 内部实现： <strong>1. 先将 table 出栈，保存 table，2. 在 lua 中，存储到 newTable 表中</strong></p>
<p>在 lua 中，print (“name”, newTable. name)，使用 newTable. name 调用在 C++ 中创建的新表的元素。</p>
<p><strong>3. 调用 C++ 中的函数：</strong></p>
<ol>
<li>将 C++ 的函数包装成 Lua 环境认可的 Lua_CFunction 格式</li>
<li>将包装好的函数注册到 Lua 环境中 </li>
<li>像使用普通 Lua 函数那样使用注册函数</li>
</ol>
<p>包装 C++ 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 得到参数个数 */</span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 循环求参数之和 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 求和 */</span></span><br><span class="line">		sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 压入平均值 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line">	<span class="comment">/* 压入和 */</span></span><br><span class="line">	<span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line">	<span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 列出需要封装的C++函数</span></span><br><span class="line"><span class="comment">// luaL_Reg为注册函数的数组类型</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg mylibs_funcs[] = &#123;</span><br><span class="line">	 &#123; <span class="string">&quot;average&quot;</span>, average &#125;,</span><br><span class="line">	 &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 将所有函数放到一个table中，并压入栈中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_openmylib</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个新的表，将所有函数放到一个table中</span></span><br><span class="line">	<span class="comment">//将这个table压到stack里</span></span><br><span class="line">	<span class="built_in">luaL_newlib</span>(L, mylibs_funcs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 将自定义模块加到注册列表里</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg lua_reg_libs[] = &#123;</span><br><span class="line">	 &#123; <span class="string">&quot;base&quot;</span>, luaopen_base &#125;,</span><br><span class="line">	 &#123; <span class="string">&quot;mylib&quot;</span>, lua_openmylib &#125;, <span class="comment">//这里为自定义的模块名字mylib</span></span><br><span class="line">	 &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 初始化Lua */</span></span><br><span class="line">	<span class="comment">/* 指向Lua解释器的指针 */</span></span><br><span class="line">	lua_State* L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 载入Lua基本库 */</span></span><br><span class="line">	<span class="built_in">luaL_openlibs</span>(L);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//4. 注册让lua使用的模块</span></span><br><span class="line">	<span class="type">const</span> luaL_Reg* lua_reg = lua_reg_libs;</span><br><span class="line">	<span class="keyword">for</span> (; lua_reg-&gt;func; ++lua_reg) &#123;</span><br><span class="line">		<span class="comment">// 加载模块</span></span><br><span class="line">		<span class="comment">// 首先查找 package.loaded 表， 检测 modname 是否被加载过。 </span></span><br><span class="line">		<span class="comment">// 如果被加载过，require 返回 package.loaded[modname] 中保存的值。</span></span><br><span class="line">		<span class="comment">// 如果 modname 不在 package.loaded 中， 则调用函数 openf ，并传入字符串 modname。</span></span><br><span class="line">		<span class="comment">// 将其返回值置入 package.loaded[modname]。</span></span><br><span class="line">		<span class="comment">// 如果最后一个参数为真， 同时也将模块设到全局变量 modname 里。在栈上留下该模块的副本。</span></span><br><span class="line">		<span class="built_in">luaL_requiref</span>(L, lua_reg-&gt;name, lua_reg-&gt;func, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 从栈中弹出 1 个元素</span></span><br><span class="line">		<span class="built_in">lua_pop</span>(L, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 运行脚本 */</span></span><br><span class="line">	<span class="built_in">luaL_dofile</span>(L, <span class="string">&quot;avg.lua&quot;</span>);</span><br><span class="line">	<span class="comment">/* 清除Lua */</span></span><br><span class="line">	<span class="built_in">lua_close</span>(L);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 暂停 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Press enter to exit…&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将包装好的函数注册到 Lua 环境中 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">lua_gettop</span> <span class="params">(lua_State *L)</span></span>;	        <span class="comment">//返回栈顶索引（即栈长度）</span></span><br><span class="line"><span class="comment">// lua_settop将栈顶设置为一个指定的位置，即修改栈中元素的数量。</span></span><br><span class="line"><span class="comment">// 如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。</span></span><br><span class="line"><span class="comment">// 所以可以用lua_settop(0)来清空栈。</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_settop</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_pushvalue</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;    <span class="comment">//将idx索引上的值的副本压入栈顶</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_remove</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;	<span class="comment">//移除idx索引上的值</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_insert</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;	<span class="comment">//弹出栈顶元素，并插入索引idx位置</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_replace</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;	<span class="comment">//弹出栈顶元素，并替换索引idx位置的值</span></span><br><span class="line"><span class="comment">// 确保堆栈上至少有 n 个额外空位。 如果不能把堆栈扩展到相应的尺寸，</span></span><br><span class="line"><span class="comment">// 函数返回假。 失败的原因包括将把栈扩展到比固定最大尺寸还大 （至少是几</span></span><br><span class="line"><span class="comment">// 千个元素）或分配内存失败。 这个函数永远不会缩小堆栈； 如果堆栈已经</span></span><br><span class="line"><span class="comment">// 比需要的大了，那么就保持原样</span></span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">lua_checkstack</span> <span class="params">(lua_State *L, <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 lua 中正常调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushnil)</span> <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushnumber)</span> <span class="params">(lua_State *L, lua_Number n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushinteger)</span> <span class="params">(lua_State *L, lua_Integer n)</span></span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushlstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushvfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt,</span><br><span class="line">                                                      va_list argp);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushcclosure)</span> <span class="params">(lua_State *L, lua_CFunction fn, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushlightuserdata)</span> <span class="params">(lua_State *L, <span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>   <span class="params">(lua_pushthread)</span> <span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="把-C-的函数封装成模块"><a href="#把-C-的函数封装成模块" class="headerlink" title="把 C++ 的函数封装成模块"></a>把 C++ 的函数封装成模块</h2><p><em><strong>把 C++ 的函数封装成模块：</strong></em></p>
<p>①将 C++ 的函数包装成 Lua 环境认可的 Lua_CFunction 格式，调用 luaL_newlib，放入到一个 lua 表中压入栈里。</p>
<p>②将自定义模块，注册到 Lua 环境中。</p>
<p>③在 lua 中，加上自定义模块名调用 C++ 函数。</p>
<p>avg. lua，这里的 lua 文件，<strong>在调用 C++ 的函数时，需要加上自定义的模块名。</strong>比如，我们定义模块名为 mylib。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LUA_API int             (lua_isnumber) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isstring) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_iscfunction) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isinteger) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isuserdata) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_type) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<p>Lua1. cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);</span><br><span class="line">LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);</span><br><span class="line">LUA_API int             (lua_toboolean) (lua_State *L, int idx);</span><br><span class="line">LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);</span><br><span class="line">LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);</span><br><span class="line">LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);</span><br><span class="line">LUA_API void           *(lua_touserdata) (lua_State *L, int idx);</span><br><span class="line">LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);</span><br><span class="line">LUA_API const void     *(lua_topointer) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<h2 id="Lua-调用-C-类注册生成的-Lua-模块"><a href="#Lua-调用-C-类注册生成的-Lua-模块" class="headerlink" title="Lua 调用 C++ 类注册生成的 Lua 模块"></a>Lua 调用 C++ 类注册生成的 Lua 模块</h2><p>由于篇幅的限制，请移步：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq826364410/article/details/88652441">https://blog.csdn.net/qq826364410/article/details/88652441</a></p>
<h2 id="在-Lua-中以面向对象的方式使用-C-注册的类"><a href="#在-Lua-中以面向对象的方式使用-C-注册的类" class="headerlink" title="在 Lua 中以面向对象的方式使用 C++ 注册的类"></a>在 Lua 中以面向对象的方式使用 C++ 注册的类</h2><p>由于篇幅的限制，请移步：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq826364410/article/details/88639408">https://blog.csdn.net/qq826364410/article/details/88639408</a></p>
<h2 id="Lua-和-C-交互：全局数组交互"><a href="#Lua-和-C-交互：全局数组交互" class="headerlink" title="Lua 和 C++ 交互：全局数组交互"></a>Lua 和 C++ 交互：全局数组交互</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq826364410/article/details/88713839">https://blog.csdn.net/qq826364410/article/details/88713839</a></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这里补充其他一些栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LUA_API int (lua_getglobal) (lua_State *L, const char *name);</span><br><span class="line">LUA_API int (lua_gettable) (lua_State *L, int idx);</span><br><span class="line">LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);</span><br><span class="line">LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API int (lua_rawget) (lua_State *L, int idx);</span><br><span class="line">LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);</span><br><span class="line"> </span><br><span class="line">LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);</span><br><span class="line">LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);</span><br><span class="line">LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);</span><br><span class="line">LUA_API int  (lua_getuservalue) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<p>下面就分两个主要部分进行介绍（C++ 和栈操作；以及 Lua 和栈操作）</p>
<ol start="2">
<li>C++ 和栈之间操作相关函数</li>
</ol>
<p>①c -&gt; stack 将 C++ 数据压到栈里函数: lua_pushxxx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LUA_API void  (lua_setglobal) (lua_State *L, const char *name);</span><br><span class="line">LUA_API void  (lua_settable) (lua_State *L, int idx);</span><br><span class="line">LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);</span><br><span class="line">LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API void  (lua_rawset) (lua_State *L, int idx);</span><br><span class="line">LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);</span><br><span class="line">LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);</span><br><span class="line">LUA_API void  (lua_setuservalue) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<p>②stack -&gt; c 判断栈里类型相关函数： lua_isxxx (lua_State *L, int idx)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LUA_API int             (lua_isnumber) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isstring) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_iscfunction) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isinteger) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_isuserdata) (lua_State *L, int idx);</span><br><span class="line">LUA_API int             (lua_type) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<p>③stack -&gt; c 获取栈里数据相关函数：lua_toxxx (lua_State *L, int idx)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);</span><br><span class="line">LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);</span><br><span class="line">LUA_API int             (lua_toboolean) (lua_State *L, int idx);</span><br><span class="line">LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);</span><br><span class="line">LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);</span><br><span class="line">LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);</span><br><span class="line">LUA_API void           *(lua_touserdata) (lua_State *L, int idx);</span><br><span class="line">LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);</span><br><span class="line">LUA_API const void     *(lua_topointer) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Lua 和栈之间的操作相关函数</li>
</ol>
<p>①从 Lua 中得到数据放到栈里进行操作：lua_getxxx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LUA_API int (lua_getglobal) (lua_State *L, const char *name);</span><br><span class="line">LUA_API int (lua_gettable) (lua_State *L, int idx);</span><br><span class="line">LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);</span><br><span class="line">LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API int (lua_rawget) (lua_State *L, int idx);</span><br><span class="line">LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);</span><br><span class="line"> </span><br><span class="line">LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);</span><br><span class="line">LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);</span><br><span class="line">LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);</span><br><span class="line">LUA_API int  (lua_getuservalue) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<p>②从栈里将数据写入到 Lua 中: lua_setxxx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LUA_API void  (lua_setglobal) (lua_State *L, const char *name);</span><br><span class="line">LUA_API void  (lua_settable) (lua_State *L, int idx);</span><br><span class="line">LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);</span><br><span class="line">LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API void  (lua_rawset) (lua_State *L, int idx);</span><br><span class="line">LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);</span><br><span class="line">LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);</span><br><span class="line">LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);</span><br><span class="line">LUA_API void  (lua_setuservalue) (lua_State *L, int idx);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>Lua 和 C++ 是通过一个虚拟栈来交互通信的。</p>
</li>
<li><p>C++ 调用 Lua：由 C++ 先把函数名、变量名、table 中键放入栈中，然后把函数名、变量名、table 中键出栈，并返回对应的值到栈顶，再由栈顶返回 C++。</p>
</li>
<li><p>Lua 调 C++：</p>
</li>
</ol>
<p><strong>Lua 调用 C++ 的函数：</strong> 先把普通的 C++ 函数包装成 Lua_CFunction 格式，然后注册函数到 Lua 解释器中，然后由 Lua 去调用这个模块的函数。</p>
<p><strong>Lua 以面向对象的方式调用 C++ 的类：</strong> 新建一个元表 metatable，并设置元表里 key 为 “__index” 的值的为 metatable 本身，然后将成员操作方法添加到元表 metatable 里，在创建对象函数中，把元表赋值给对象指针，这样通过 “: “ 操作符就可以找到对应的方法了。</p>
<h1 id="十二、热更新"><a href="#十二、热更新" class="headerlink" title="十二、热更新"></a>十二、热更新</h1><p>常见的 Lua 热更新都是在客户端下载所有 Lua 代码之后重启游戏，以实现重载所有数据和函数的目的。但在实际开发过程中，如果每次都要改完 Lua 代码重启游戏，正常人都不能接受。</p>
<p>除这种热更方式之外，其实还可以实现运行时热更，或者叫无感知热更。可以做到在玩家运行游戏的时候偷偷更新一部分代码。</p>
<p>很多项目会将只负责处理界面的 View 层 Lua 代码在每次调用时重新读取，以此实现不重启地更新代码。但这样依然有局限性——如果需要在数据层等其他模块修改函数，这些修改都无法生效。因为如果直接<code>require</code>，旧的数据都会丢失。</p>
<p>要实现比较合理的运行时热更新，除了设计热更的逻辑之外，前提是遵循一些约定。在规定热更新约定之前，先了解一下 Lua 热更新涉及的原理。</p>
<h2 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h2><h3 id="require-机制"><a href="#require-机制" class="headerlink" title="require 机制"></a>require 机制</h3><p>从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>
<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。</p>
<p>以下为创建自定义模块 <code>exmaple.lua</code>，文件代码格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exmaple = &#123;&#125;</span><br><span class="line"></span><br><span class="line">exmaple.constant = <span class="string">&quot;constant variable&quot;</span></span><br><span class="line"></span><br><span class="line">function exmaple.<span class="built_in">func1</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;public func&quot;</span>)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function <span class="built_in">func2</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;private func&quot;</span>)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function exmaple.<span class="built_in">func3</span>()</span><br><span class="line">    <span class="built_in">func2</span>()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exmaple</span><br></pre></td></tr></table></figure>

<p>在其他模块中，需要调用<code>exmaple.lua</code>模块的函数，则需要<code>require</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;exmaple&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require <span class="string">&quot;exmaple&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>require</code> 之后，Lua 的 <code>package.loaded</code> 中就会有 <code>exmaple.lua</code> 模块的数据，并且只有第一次 <code>require</code> 会执行 <code>exmaple.lua</code> 中的内容，之后再次 <code>require</code> 就会直接返回 <code>package.loaded[&quot;exmaple&quot;]</code>。 </p>
<p><strong>这样的话，如果想要更新 <code>exmaple.lua</code> 的内容，就需要先清空 <code>package.loaded[&quot;exmaple&quot;]</code> 再 <code>require</code>。</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package.loaded[<span class="string">&quot;example&quot;</span>] = nil</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;example&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>似乎这样就实现了简单的热更，但这远远不够。因为清空<code>package.loaded[&quot;exmaple&quot;]</code>会导致丢失原有的数据，下面是一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local t = &#123;&#125;</span><br><span class="line">t.data = <span class="number">0</span></span><br><span class="line">function t.<span class="built_in">func</span>()</span><br><span class="line">    <span class="built_in">print</span>(t.data)</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> t</span><br></pre></td></tr></table></figure>

<p>如果按照上面的方式热更，每次<code>t.data</code>都会被重置为 0，显然这不是我们想要的。</p>
<p>这种情况下，<code>t.data</code> 作为函数 <code>t.func</code> 的 <code>upvalue</code>（上值）会被重置。 </p>
<h3 id="upvalue"><a href="#upvalue" class="headerlink" title="upvalue"></a>upvalue</h3><p>上面讲到的就是 <code>upvalue</code> 的例子，在游戏运行时，我们不会希望数据被覆盖或清空，应该尽量在保留原有数据的情况下替换函数的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local count = <span class="number">0</span></span><br><span class="line">local function <span class="built_in">func</span>()</span><br><span class="line">	count = count + <span class="number">1</span></span><br><span class="line">	<span class="built_in">print</span>(count)</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，如果使用<code>require</code>机制热更代码，我们需要保存旧函数的<code>count</code>值。Lua 中提供了获取并设置 upvalue 的方法<code>debug.getupvalue</code>和<code>debug.setupvalue</code>。</p>
<p>遍历一个函数的所有 upvalue 并设置 upvalue：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local oldfunc = require <span class="string">&quot;example&quot;</span></span><br><span class="line">package.loaded[<span class="string">&quot;example&quot;</span>] = nil</span><br><span class="line">local newfunc = require <span class="string">&quot;example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, math.huge <span class="keyword">do</span></span><br><span class="line">	local name, value = debug.<span class="built_in">getupvalue</span>(oldfunc, i)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> name then <span class="keyword">break</span> end</span><br><span class="line">	debug.<span class="built_in">setupvalue</span>(newfunc, i, value)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>要注意的是，函数同样可以作为 upvalue，而我们希望使用新的函数、旧的数据。所以在遍历 upvalue 的时候需要判断是否为函数，如果是则要用新的覆盖。</p>
<h3 id="全局语句"><a href="#全局语句" class="headerlink" title="全局语句"></a>全局语句</h3><p>在 <code>require</code> 一个模块时，会重新执行其中的全局语句，这会破坏已有的代码逻辑。解决办法有两种，都比较复杂。</p>
<ul>
<li>一种是语法分析，将全局语句变成 <code>local i = &#123;&#125;</code> 这种，保留住这个变量，然后把旧的数据复制过来；</li>
<li>另一种是使用临时环境表执行新模块，执行完切换成旧模块使用的环境表。</li>
</ul>
<p>这两种方法都比较麻烦，<strong>一般需要热更的主要都是各个系统的数据层，这些数据层基本不会包含全局语句的修改，所以我们可以忽略这种情况，只进行数据层的热更新</strong>。在多数情况下可以满足需求。</p>
<h2 id="热更新的约定"><a href="#热更新的约定" class="headerlink" title="热更新的约定"></a>热更新的约定</h2><p>了解了上面的原理之后，我们要想实现简单的 Lua 运行时热更新，需要满足以下的约定。</p>
<ol>
<li><p>不破坏原有数据<br>游戏运行时许多 Lua 系统中都保存了服务器发来的数据，或者是计算产生的一些数据，我们不希望这些数据被清空或改变。热更新的基础就是更新服务的逻辑，通常只是逻辑发生变化，但原有的值并不能被改变。</p>
</li>
<li><p>不为热更多写代码<br>程序员都比较懒，如果热更需要现在原有的逻辑中加入热更前后进行的操作的话，没人能接受。就像为了热更 C# 而改变原有的代码结构，应该尽量避免额外的负担。</p>
</li>
<li><p>只修改逻辑，而非增加<br>一般来说需要运行时热更的都是改动比较小的更新或者修复一些 bug，这种情况下只要修改函数就可以达到目的，而没有必要新增函数。而且，新增的函数如果使用了 upvalue，新增之后没法给它赋值，因为在旧的模块中不存在这个 upvalue。</p>
</li>
<li><p>可以热更嵌套结构中的函数<br>比如 table 中的函数、table 的 metatable 中的函数等。</p>
</li>
<li><p>不改变所有数据和函数的命名<br>显然，如果改变命名，那谁知道要更新啥呢~</p>
</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>一般来说需要热更的话，是你修改了某个<code>XXXModel.lua</code>文件，这个文件在<code>package.loaded</code>中名为<code>XXXSystem.XXXModel</code>。其中<code>XXXSystem</code>是这个 Lua 模块存放的文件夹名称。</p>
<ol>
<li><strong>热更之前要先保存旧模块的全部数据，然后将 package. loaded 置空：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local oldModule</span><br><span class="line"><span class="keyword">if</span> package.loaded[packageName] then</span><br><span class="line">    oldModule = package.loaded[packageName]</span><br><span class="line">    package.loaded[packageName] = nil</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>之后直接 <code>require</code> 新的模块，然后把新模块记录下来，遍历新模块的所有数据。</strong></li>
</ol>
<ul>
<li>注意：<ol>
<li>总体来说，遍历的过程中，元素如果是 table 就保留旧模块的，如果是 function 就用新模块的。</li>
<li>table 会嵌套 table 和 function，因此这是一个递归的过程。</li>
<li>function 要用新的，但是 function 的的 <code>upvalue</code> 要用旧的。</li>
<li>table 中的 metatable 同样作为 table 处理，使用<code>debug.getmetatable</code>获取一个 table 的 metatable 然后进行与 table 一样的操作。</li>
<li>对于可能出现循环引用的情况，可以在更新表的时候记录已更新的 table，避免重复处理死循环。</li>
</ol>
</li>
</ul>
<h1 id="十、编译、执行和错误（略）"><a href="#十、编译、执行和错误（略）" class="headerlink" title="十、编译、执行和错误（略）"></a>十、编译、执行和错误（略）</h1><blockquote>
<p>[!NOTE] 解释型语言<br>解释型语言：程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次。因此效率比较低</p>
<p>相对于编译型语言存在的，源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。比如Python&#x2F;JavaScript&#x2F; Perl &#x2F;Shell等都是解释型语言。</p>
</blockquote>
<p>虽然我们把Lua语言称为解释型语言（interpreted language），<strong>为了达到较高的执行效率，lua 代码并不是直接被 Lua 解释器解释执行，而是会先编译为字节码，然后再交给 lua 虚拟机去执行</strong>。</p>
<blockquote>
<p>Lua 5.0 开始，Lua 就从基于栈的虚拟机( stack-based VM )<strong>改为了基于寄存器的虚拟机</strong>( register-based VM )。<br>基于栈的虚拟机有JVM，.Net CLR,javascript V8。基于寄存器的虚拟机有Android Dalvik VM.</p>
</blockquote>
<p>编译（compilation）阶段的存在听上去超出了解释型语言的范畴，但<strong>解释型语言的区分并不在于源码是否被编译，而在于是否有能力（且轻易地）执行动态生成的代码（即可以在运行时翻译成机器语言）</strong>。可以认为，正是由于诸如dofile这样函数的存在，才使得Lua语言能够被称为解释型语言。</p>
<h2 id="dofile-loadfile-load"><a href="#dofile-loadfile-load" class="headerlink" title="dofile loadfile load"></a>dofile loadfile load</h2><p><code>dofile</code>，该函数可以立即执行一个指定文件。实际上，函数 <code>dofile</code> 是一个辅助函数，函数 <code>loadfile</code> 才完成了真正的核心工作。与函数 <code>dofile</code> 类似，<strong>函数 <code>loadfile</code> 也是从文件中加载Lua代码段，但它不会运行代码，而只是编译代码，然后将编译后的代码段作为一个函数返回。</strong><br>此外，与函数dofile不同，函数loadfile只返回错误码而不抛出异常。<br>对于简单的需求而言，由于函数dofile在一次调用中就做完了所有工作，所以该函数非常易用。不过，函数loadfile更灵活。在发生错误的情况中，函数loadfile会返回nil及错误信息，以允许我们按自定义的方式来处理错误。此外，如果需要多次运行同一个文件，那么只需调用一次loadfile函数后再多次调用它的返回结果即可。由于只编译一次文件，因此这种方式的开销要比多次调用函数dofile小得多（编译在某种程度上相比其他操作开销更大）。</p>
<p>函数 <code>load</code> 与函数 <code>loadfile</code> 类似，不同之处在于该函数从一个字符串或函数中读取代码段，而不是从文件中读取。尽管函数load的功能很强大，但还是应该谨慎地使用。相对于其他可选的函数而言，该函数的开销较大并且可能会引起诡异的问题。请先确定当下已经找不到更简单的解决方式后再使用该函数。函数load最典型的用法是执行外部代码（即那些来自程序本身之外的代码段）或动态生成的代码。例如，我们可能想运行用户定义的函数，由用户输入函数的代码后调用函数load对其求值。请注意，函数load期望的输入是一段程序，也就是一系列的语句。如果需要对表达式求值，那么可以在表达式前添加 return ，这样才能构成一条返回指定表达式值的语句。例如：</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://liuke101.github.io">灵玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://liuke101.github.io/post/57053.html">http://liuke101.github.io/post/57053.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuke101.github.io" target="_blank">游戏江湖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Lua/">Lua</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏碎银二两</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232247905.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232251074.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/46644.html" title="UE AI系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UE AI系统</div></div></a></div><div class="next-post pull-right"><a href="/post/3834.html" title="Effective Modern C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective Modern C++</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Ny8zNjIzOQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/I168.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵玉</div><div class="author-info__description">游戏开发</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liuke101"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuke101" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/gamerlk@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1. 文章主要迁移自个人的obsidian笔记，存在部分md语法冲突，导致显示异常，暂未完全修复。 2. 文章部分内容参考/引用网络资源，用于个人学习，如有侵权，请联系我删除。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">一、特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5"><span class="toc-text">程序段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">二、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">1 变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">2 全局变量与局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">全局变量的声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-text">3 多变量赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-string-%E6%93%8D%E4%BD%9C"><span class="toc-text">4  string 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-table-%E8%A1%A8"><span class="toc-text">6  table 表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">表索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">表构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">表的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-text">字典</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-metatable-%E5%85%83%E8%A1%A8"><span class="toc-text">7  metatable 元表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-thread-%E7%BA%BF%E7%A8%8B"><span class="toc-text">8  thread 线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8D%8F%E7%A8%8B"><span class="toc-text">9 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">协程操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-text">协程的运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">协程的返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">9 强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">显示类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">安全访问操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">四、控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-then-end"><span class="toc-text">if then end</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-do-end"><span class="toc-text">while do end</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repeat-until"><span class="toc-text">repeat until</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-do-end"><span class="toc-text">for do end</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B-for"><span class="toc-text">数值型 for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-for"><span class="toc-text">泛型 for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E3%80%81return%E3%80%81goto"><span class="toc-text">break、return、goto</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">五、迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ipairs"><span class="toc-text">ipairs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pairs"><span class="toc-text">pairs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81function-%E5%87%BD%E6%95%B0"><span class="toc-text">六、function 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%98%AF%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%80%BC"><span class="toc-text">函数是第一类值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95"><span class="toc-text">函数写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">参数与返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E6%95%B0%E9%87%8F"><span class="toc-text">参数和返回值数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">变长参数的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97"><span class="toc-text">函数嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-self"><span class="toc-text">: 和 self</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8"><span class="toc-text">尾调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="toc-text">六、模块和包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#require"><span class="toc-text">require</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package-loaded"><span class="toc-text">package. loaded</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">编写模块的基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="toc-text">子模块和包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">七、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%92%8C%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">类的成员和调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">类成员之间的访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%80%A7"><span class="toc-text">私有性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">八、环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#G"><span class="toc-text">_G</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83-ENV"><span class="toc-text">非全局环境  _ENV</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">九、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E8%A1%A8"><span class="toc-text">弱引用表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9E%AC%E8%A1%A8"><span class="toc-text">瞬表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">十、反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Lua-%E4%B8%8E-C-%E7%9A%84%E4%BA%A4%E4%BA%92%E6%9C%BA%E5%88%B6"><span class="toc-text">十一、Lua 与 C++的交互机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%99%9A%E6%8B%9F%E6%A0%88"><span class="toc-text">Lua 虚拟栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">堆栈的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-Lua-%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-text">引入 Lua 静态库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-Lua"><span class="toc-text">C++ 调用 Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%B0%83%E7%94%A8-C"><span class="toc-text">Lua 调用 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A-C-%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E6%88%90%E6%A8%A1%E5%9D%97"><span class="toc-text">把 C++ 的函数封装成模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%B0%83%E7%94%A8-C-%E7%B1%BB%E6%B3%A8%E5%86%8C%E7%94%9F%E6%88%90%E7%9A%84-Lua-%E6%A8%A1%E5%9D%97"><span class="toc-text">Lua 调用 C++ 类注册生成的 Lua 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Lua-%E4%B8%AD%E4%BB%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8-C-%E6%B3%A8%E5%86%8C%E7%9A%84%E7%B1%BB"><span class="toc-text">在 Lua 中以面向对象的方式使用 C++ 注册的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E5%92%8C-C-%E4%BA%A4%E4%BA%92%EF%BC%9A%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84%E4%BA%A4%E4%BA%92"><span class="toc-text">Lua 和 C++ 交互：全局数组交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">十二、热更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"><span class="toc-text">热更新原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#require-%E6%9C%BA%E5%88%B6"><span class="toc-text">require 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#upvalue"><span class="toc-text">upvalue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%AF%AD%E5%8F%A5"><span class="toc-text">全局语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="toc-text">热更新的约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">十、编译、执行和错误（略）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dofile-loadfile-load"><span class="toc-text">dofile loadfile load</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3834.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-01-18T04:20:00.000Z" title="发表于 2024-01-18 12:20:00">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/57053.html" title="Lua精粹">Lua精粹</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/46644.html" title="UE AI系统">UE AI系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28207.html" title="UE输入系统">UE输入系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/28208.html" title="UE伤害系统">UE伤害系统</a><time datetime="2023-10-15T16:00:00.000Z" title="发表于 2023-10-16 00:00:00">2023-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdmirror.com/gh/liuke101/PicGo-For-Hexo/image/202404232157234.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灵玉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdmirror.com/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdmirror.com/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-indol.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdmirror.com/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Waline' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://waline-server-indol.vercel.app/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9896988395" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdmirror.com/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdmirror.com/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdmirror.com/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>